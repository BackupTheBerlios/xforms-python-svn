#!/usr/bin/env python
# -*- coding: iso8859-1 -*-

"""
    flbrowser.py - xforms-python's functions to manage browser objects.

    Copyright (C) 2009, 2010  Luca Lazzaroni "LukenShiro"
    e-mail:  <lukenshiro@ngi.it>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, version 2.1 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU LGPL along with this
    program. If not, see <http://www.gnu.org/licenses/>.

    See CREDITS file to read acknowledgements and thanks to XForms,
    ctypes and other developers.
"""


# originally generated by 'h2xml+gccxml' and 'xml2py'
# then heavily reordered and reworked

# ############################################# #
# Interface to XForms shared object libraries   #
# ############################################# #


import ctypes as cty
from xformslib import library as libr
from xformslib import xfdata



#######################
# forms.h (browser.h)
# Object class Browser
#######################

# Routines

# fl_create_browser function placeholder (internal)


def fl_add_browser(browsertype, x, y, w, h, label):
    """Adds a browser object. The label is placed below the box by default.

    --

    :Parameters:
      `browsertype` : int
        type of the browser to be added. Values (from xfdata.py)
        FL_NORMAL_BROWSER, FL_SELECT_BROWSER, FL_HOLD_BROWSER, FL_MULTI_BROWSER
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `label` : str
        text label of browser

    :return: browser object created (pFlObject)
    :rtype: pointer to xfdata.FL_OBJECT

    :note: e.g. brobj = fl_add_browser(FL_SELECT_BROWSER, 200, 250, 200, 200,
        "BrowserList")

    :status: Tested + Doc + Demo = OK

    """
    _fl_add_browser = libr.cfuncproto(
        libr.load_so_libforms(), "fl_add_browser",
        cty.POINTER(xfdata.FL_OBJECT), [cty.c_int, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.STRING],
        """FL_OBJECT * fl_add_browser(int type, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, const char * label)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(browsertype,
        xfdata.BROWSERTYPE_list)
    ibrowsertype = libr.convert_to_int(browsertype)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    slabel = libr.convert_to_string(label)
    libr.keep_elem_refs(browsertype, x, y, w, h, label, ibrowsertype, ix, \
                        iy, iw, ih, slabel)
    retval = _fl_add_browser(ibrowsertype, ix, iy, iw, ih, slabel)
    return retval


def fl_clear_browser(pFlObject):
    """Clears contents of a browser object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object

    :note: e.g. fl_clear_browser(brobj)

    :status: Tested + Doc + Demo = OK

    """
    _fl_clear_browser = libr.cfuncproto(
        libr.load_so_libforms(), "fl_clear_browser",
        None, [cty.POINTER(xfdata.FL_OBJECT)],
        """void fl_clear_browser(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    _fl_clear_browser(pFlObject)


def fl_add_browser_line(pFlObject, newtext):
    """Add a line to a browser object. The line may contain embedded newline
    characters: these will result in the text being split up into several
    lines, separated at the newline characters. It is possible to change the
    appearance of individual lines in the browser. Whenever a line starts
    with the symbol '@' the next letter indicates the special characteristics
    associated with this line. The following possibilities exist at the moment:
    f (Fixed width font), n (Normal, Helvetica font), t (Times-Roman like
    font), b (Boldface modifier), i (Italics modifier), l (Large, new size is
    xfdata.FL_LARGE_SIZE), m (Medium, new size is xfdata.FL_MEDIUM_SIZE),
    s (Small, new size is xfdata.FL_SMALL_SIZE), L (Large, new size = current
    size + 6), M (Medium, new size = current size + 4), S (Small, new size =
    current size - 2), c (Centered), r (Right aligned), _ (Draw underlined
    text, - (An engraved separator. Text following '-' is ignored), C (The
    next number indicates the color index for this line).,N (Non-selectable
    line, in selectable browsers), @@, double @ (Regular '@' character). The
    modifiers (bold and italic) work by adding xfdata.FL_BOLD_STYLE and
    xfdata.FL_ITALIC_STYLE to the current active font index to look up the
    font in the font table (you can modify the table using fl_set_font_name()).
    More than one option can be used by putting them next to each other. For
    example, "@C1@l@f@b@cTitle" will give you the red, large, bold fixed font,
    centered word "Title". As you can see the font change requests accumulate
    and the order is important, i.e., "@f@b@i" gives you a fixed bold italic
    font while "@b@i@f" gives you a (plain) fixed font. Depending on the font
    size and style lines may have different heights.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `newtext` : str
        line of text to be added

    :note: e.g. fl_add_browser_line(brobj, "My new line text")

    :status: Tested + Doc + Demo = OK

    """
    _fl_add_browser_line = libr.cfuncproto(
        libr.load_so_libforms(), "fl_add_browser_line",
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.STRING],
        """void fl_add_browser_line(FL_OBJECT * ob, const char * newtext)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    snewtext = libr.convert_to_string(newtext)
    libr.keep_elem_refs(pFlObject, newtext, snewtext)
    _fl_add_browser_line(pFlObject, snewtext)


def fl_addto_browser(pFlObject, newtext):
    """Adds text to browser. The browser will be shifted such that the newly
    appended line is visible. This is useful when e.g. using the browser to
    display messages. The text may contain embedded newline characters. See
    fl_add_browser_line() for appearance change.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `newtext` : str
        text to be added

    :note: e.g. fl_addto_browser(brobj, "blablablablablublublu")

    :status: Tested + Doc + Demo = OK

    """
    _fl_addto_browser = libr.cfuncproto(
        libr.load_so_libforms(), "fl_addto_browser",
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.STRING],
        """void fl_addto_browser(FL_OBJECT * ob, const char * newtext)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    snewtext = libr.convert_to_string(newtext)
    libr.keep_elem_refs(pFlObject, newtext, snewtext)
    _fl_addto_browser(pFlObject, snewtext)


def fl_addto_browser_chars(pFlObject, addedtext):
    """Appends text to the last line in the browser without advancing the
    line counter. The text may contain embedded newline characters. In that
    case, the text before the first embedded newline is appended to the last
    line, and everything aferwards is put onto new lines. As in the case of
    fl_addto_browser() the last added line will be visible in the browser.
    See fl_add_browser_line() for appearance change.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `addedtext` : str
        text to be added

    :note: e.g. fl_addto_browser_chars(brobj, "some chars")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_addto_browser_chars = libr.cfuncproto(
        libr.load_so_libforms(), "fl_addto_browser_chars",
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.STRING],
        """void fl_addto_browser_chars(FL_OBJECT * ob, const char * str)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    saddedtext = libr.convert_to_string(addedtext)
    libr.keep_elem_refs(pFlObject, addedtext, saddedtext)
    _fl_addto_browser_chars(pFlObject, saddedtext)


fl_append_browser = fl_addto_browser_chars


def fl_insert_browser_line(pFlObject, linenum, newtext):
    """Inserts a line in front of a given line in browser. All lines after it
    will be shifted. Embedded newline characters don't result in the line
    being split up as it's done in the previous functions. Instead they will
    rather likely appear as strange looking characters in the text shown. The
    only exception is when inserting into an empty browser or after the last
    line, then this function works exactly as if you had called
    fl_add_browser_line(). See fl_add_browser_line() for appearance change.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `linenum` : int
        line number after which insert it (top line is numbered 1, not 0)
      `newtext` : str
        text to be inserted

    :note: e.g. fl_insert_browser_line(brobj, 1, "blblabla")

    :status: Tested + Doc + Demo = OK

    """
    _fl_insert_browser_line = libr.cfuncproto(
        libr.load_so_libforms(), "fl_insert_browser_line",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int, xfdata.STRING],
        """void fl_insert_browser_line(FL_OBJECT * ob, int linenumb,
           const char * newtext)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ilinenum = libr.convert_to_int(linenum)
    snewtext = libr.convert_to_string(newtext)
    libr.keep_elem_refs(pFlObject, linenum, newtext, ilinenum, snewtext)
    _fl_insert_browser_line(pFlObject, ilinenum, snewtext)


def fl_delete_browser_line(pFlObject, linenum):
    """Deletes a line (shifting the following lines)

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `linenum` : int
        line number to delete

    :note: e.g. fl_delete_browser_line(brobj, 3)

    :status: Tested + Doc + Demo = OK

    """
    _fl_delete_browser_line = libr.cfuncproto(
        libr.load_so_libforms(), "fl_delete_browser_line",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_delete_browser_line(FL_OBJECT * ob, int linenumb)""")
    libr.verify_flobjectptr_type(pFlObject)
    ilinenum = libr.convert_to_int(linenum)
    libr.keep_elem_refs(pFlObject, linenum, ilinenum)
    _fl_delete_browser_line(pFlObject, ilinenum)


def fl_replace_browser_line(pFlObject, linenum, newtext):
    """Replaces a line in the browser. As in the case of
    fl_insert_browser_line() newline characters embedded into the replacement
    text don't have any special meaning, i.e. they don't result in replacement
    of more than a single line. See fl_add_browser_line() for appearance
    change.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `linenum` : int
        line number to replace
      `newtext` : str
        text line used as replacement

    :note: e.g. fl_replace_browser_line(brobj, 5, "newblabla")

    :status: Tested + Doc + Demo = OK

    """
    _fl_replace_browser_line = libr.cfuncproto(
        libr.load_so_libforms(), "fl_replace_browser_line",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int, xfdata.STRING],
        """void fl_replace_browser_line(FL_OBJECT * ob, int linenumb,
           const char * newtext)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ilinenum = libr.convert_to_int(linenum)
    snewtext = libr.convert_to_string(newtext)
    libr.keep_elem_refs(pFlObject, linenum, newtext, ilinenum, snewtext)
    _fl_replace_browser_line(pFlObject, ilinenum, snewtext)


def fl_get_browser_line(pFlObject, linenum):
    """Obtains the contents of a particular line in the browser.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `linenum` : int
        line number to return

    :return: line text
    :rtype: str

    :note: e.g. txt4thline = fl_get_browser_line(brobj, 4)

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_browser_line = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_browser_line",
        xfdata.STRING, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """const char * fl_get_browser_line(FL_OBJECT * ob, int linenumb)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ilinenum = libr.convert_to_int(linenum)
    libr.keep_elem_refs(pFlObject, linenum, ilinenum)
    retval = _fl_get_browser_line(pFlObject, ilinenum)
    return retval


def fl_load_browser(pFlObject, filename):
    """Loads an entire file into a browser. An empty string (or the file
    couldn't be opened for reading) the browser is just cleared. This
    routine is particularly useful when using the browser for a help
    facility. You can create different help files and load the needed one
    depending on context.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `filename` : str
        name of the file

    :return: 1 (if file is successfully loaded), otherwise 0
    :rtype: int

    :note: e.g. ival = fl_load_browser(brobj, "somefile.txt")

    :status: Tested + Doc + Demo = OK

    """
    _fl_load_browser = libr.cfuncproto(
        libr.load_so_libforms(), "fl_load_browser",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT), xfdata.STRING],
        """int fl_load_browser(FL_OBJECT * ob, const char * filename)""")
    libr.verify_flobjectptr_type(pFlObject)
    sfilename = libr.convert_to_string(filename)
    libr.keep_elem_refs(pFlObject, filename, sfilename)
    retval = _fl_load_browser(pFlObject, sfilename)
    return retval


def fl_select_browser_line(pFlObject, linenum):
    """Selects a line in the browser.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `linenum` : int
        line number to select

    :note: e.g. fl_select_browser_line(brobj, 4)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_select_browser_line = libr.cfuncproto(
        libr.load_so_libforms(), "fl_select_browser_line",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_select_browser_line(FL_OBJECT * ob, int line)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ilinenum = libr.convert_to_int(linenum)
    libr.keep_elem_refs(pFlObject, linenum, ilinenum)
    _fl_select_browser_line(pFlObject, ilinenum)


def fl_deselect_browser_line(pFlObject, linenum):
    """Deselects a line in the browser.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `linenum` : int
        line id to deselect

    :note: e.g. fl_deselect_browser_line(brobj, 4)

    :status: Tested + Doc + Demo = OK

    """
    _fl_deselect_browser_line = libr.cfuncproto(
        libr.load_so_libforms(), "fl_deselect_browser_line",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_deselect_browser_line(FL_OBJECT * ob, int line)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ilinenum = libr.convert_to_int(linenum)
    libr.keep_elem_refs(pFlObject, linenum, ilinenum)
    _fl_deselect_browser_line(pFlObject, ilinenum)


def fl_deselect_browser(pFlObject):
    """Deselects all lines in the browser.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object

    :note: e.g. fl_deselect_browser(brobj)

    :status: Tested + Doc + Demo = OK

    """
    _fl_deselect_browser = libr.cfuncproto(
        libr.load_so_libforms(), "fl_deselect_browser",
        None, [cty.POINTER(xfdata.FL_OBJECT)],
        """void fl_deselect_browser(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    _fl_deselect_browser(pFlObject)


def fl_isselected_browser_line(pFlObject, linenum):
    """Checks whether a line is selected or not.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `linenum` : int
        line id to evaluate

    :return: num.
    :rtype: int

    :note: e.g. if fl_isselected_browser_line(brobj, 2): ...

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_isselected_browser_line = libr.cfuncproto(
        libr.load_so_libforms(), "fl_isselected_browser_line",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """int fl_isselected_browser_line(FL_OBJECT * ob, int line)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ilinenum = libr.convert_to_int(linenum)
    libr.keep_elem_refs(pFlObject, linenum, ilinenum)
    retval = _fl_isselected_browser_line(pFlObject, ilinenum)
    return retval


def fl_get_browser_topline(pFlObject):
    """Finds out the (un-obscured) line that is currently shown at the top
    of the browser. The index of the top line is 1, not 0.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object

    :return: line id number
    :rtype: int

    :note: e.g. topl = fl_get_browser_topline(brobj)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_browser_topline = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_browser_topline",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],
        """int fl_get_browser_topline(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_browser_topline(pFlObject)
    return retval


def fl_get_browser(pFlObject):
    """Obtains the last selection made by the user, e.g. when the browser is
    returned.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object

    :return: line num. of the last selection, or 0 (if no selection was made).
        For FL_MULTI_BROWSER only: the negative of deselected line num. (when
        the last action was a deselection)
    :rtype: int

    :note: e.g. lastsel = fl_get_browser(pFlObject)

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_browser = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_browser",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],
        """int fl_get_browser(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_browser(pFlObject)
    return retval


def fl_get_browser_maxline(pFlObject):
    """Returns the number of lines in the browser.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object

    :return: number of lines
    :rtype: int

    :note: e.g. maxlin = fl_get_browser_maxline(brobj)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_browser_maxline = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_browser_maxline",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],
        """int fl_get_browser_maxline(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_browser_maxline(pFlObject)
    return retval


def fl_get_browser_screenlines(pFlObject):
    """Returns an approximation of the number of lines shown in the browser.
    This count only includes lines that are shown completely in the browser,
    partially obscured ones aren't counted in.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object

    :return: number of lines
    :rtype: int

    :note: e.g. visiblines = fl_get_browser_screenlines(brobj)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_browser_screenlines = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_browser_screenlines",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],
        """int fl_get_browser_screenlines(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_browser_screenlines(pFlObject)
    return retval


def fl_set_browser_topline(pFlObject, linenum):
    """Moves a text line to the top of the browser. Line numbers start with 1.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `linenum` : int
        line id to be moved to top

    :note: e.g. fl_set_browser_topline(brobj, 5)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_browser_topline = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_browser_topline",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_set_browser_topline(FL_OBJECT * ob, int line)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ilinenum = libr.convert_to_int(linenum)
    libr.keep_elem_refs(pFlObject, linenum, ilinenum)
    _fl_set_browser_topline(pFlObject, ilinenum)


def fl_set_browser_bottomline(pFlObject, linenum):
    """Moves a text line to the bottom of the browser. Line numbers start with
    1.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `linenum` : int
        line id to be moved to bottom

    :note: e.g. fl_set_browser_bottomline(brobj, 2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_browser_bottomline = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_browser_bottomline",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_set_browser_bottomline(FL_OBJECT * ob, int line)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ilinenum = libr.convert_to_int(linenum)
    libr.keep_elem_refs(pFlObject, linenum, ilinenum)
    _fl_set_browser_bottomline(pFlObject, ilinenum)


def fl_set_browser_fontsize(pFlObject, size):
    """Sets the font size used inside the browser.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `size` : int
        font size to be set. Values (from xfdata.py) FL_TINY_SIZE,
        FL_SMALL_SIZE, FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE,
        FL_HUGE_SIZE, FL_DEFAULT_SIZE

    :note: e.g. fl_set_browser_fontsize(brobj, xfdata.FL_NORMAL_SIZE)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_browser_fontsize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_browser_fontsize",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_set_browser_fontsize(FL_OBJECT * ob, int size)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    isize = libr.convert_to_int(size)
    libr.keep_elem_refs(pFlObject, size, isize)
    _fl_set_browser_fontsize(pFlObject, isize)


def fl_set_browser_fontstyle(pFlObject, style):
    """Sets the font style of a browser object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `style` : int
        font style to be set. Values (from xfdata.py) FL_NORMAL_STYLE,
        FL_BOLD_STYLE, FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE

    :note: e.g. fl_set_browser_fontstyle(brobj, xfdata.FL_EMBOSSED_STYLE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_browser_fontstyle = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_browser_fontstyle",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_set_browser_fontstyle(FL_OBJECT * ob, int style)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    istyle = libr.convert_to_int(style)
    libr.keep_elem_refs(pFlObject, style, istyle)
    _fl_set_browser_fontstyle(pFlObject, istyle)


def fl_set_browser_specialkey(pFlObject, specialkey):
    """Changes the special character (used to change appearance, see
    fl_add_browser_line()) to something other than '@'. In some cases the
    character '@' might need to be placed at the beginning of the lines
    without introducing the special meaning mentioned above. In this case you
    can use "@@".

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `specialkey` : int or char
        escape key to be set

    :note: e.g. fl_set_browser_specialkey(brobj, "|")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_browser_specialkey = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_browser_specialkey",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_set_browser_specialkey(FL_OBJECT * ob, int specialkey)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    if isinstance(specialkey, str):
        # workaround to let a character as int argument
        ordspkey = ord(specialkey)
    else:
        ordspkey = specialkey
    ispecialkey = libr.convert_to_int(ordspkey)
    libr.keep_elem_refs(pFlObject, specialkey, ordspkey, ispecialkey)
    _fl_set_browser_specialkey(pFlObject, ispecialkey)


def fl_set_browser_vscrollbar(pFlObject, how):
    """Turns the vertical scrollbar on or off. When you switch the scrollbars
    off the text can't be scrolled by the user anymore at all (i.e. also not
    using methods that don't use scrollbars, e.g. using the cursor keys).

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `how` : int
        how bar is turned. Values (from xfdata.py) FL_ON, FL_OFF, FL_AUTO
        (default)

    :note: fl_set_browser_vscrollbar(brobj, xfdata.FL_OFF)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_browser_vscrollbar = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_browser_vscrollbar",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_set_browser_vscrollbar(FL_OBJECT * ob, int on)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.check_admitted_value_in_list(how, xfdata.SCROLLBARVAL_list)
    ihow = libr.convert_to_int(how)
    libr.keep_elem_refs(pFlObject, how, ihow)
    _fl_set_browser_vscrollbar(pFlObject, ihow)


def fl_set_browser_hscrollbar(pFlObject, how):
    """Turns the horizontal scrollbar on or off. When you switch the
    scrollbars off the text can't be scrolled by the user anymore at all (i.e.
    also not using methods that don't use scrollbars, e.g. using the cursor
    keys).

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `how` : int
        how bar is turned. Values (from xfdata.py) FL_ON, FL_OFF, FL_AUTO
        (default)

    :note: fl_set_browser_hscrollbar(brobj, xfdata.FL_OFF)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_browser_hscrollbar = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_browser_hscrollbar",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_set_browser_hscrollbar(FL_OBJECT * ob, int on)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.check_admitted_value_in_list(how, xfdata.SCROLLBARVAL_list)
    ihow = libr.convert_to_int(how)
    libr.keep_elem_refs(pFlObject, how, ihow)
    _fl_set_browser_hscrollbar(pFlObject, ihow)


def fl_set_browser_line_selectable(pFlObject, linenum, yesno):
    """Sets if a line of browser object is selectable or not.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `linenum` : int
        line id to set
      `yesno` : int
        selectable state. Values 1 (selectable) or 0 (not selectable)

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_browser_line_selectable = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_browser_line_selectable",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int, cty.c_int],
        """void fl_set_browser_line_selectable(FL_OBJECT * ob, int line,
           int flag)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ilinenum = libr.convert_to_int(linenum)
    iyesno = libr.convert_to_int(yesno)
    libr.keep_elem_refs(pFlObject, linenum, yesno, ilinenum, iyesno)
    _fl_set_browser_line_selectable(pFlObject, ilinenum, iyesno)


def fl_get_browser_dimension(pFlObject):
    """Obtains the browser size in pixels for the text area.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object

    :return: horizontal (x) and vertical position (y), width (w), height (h)
    :rtype: int, int, int, int

    :note: e.g. x, y, wid, hei = fl_get_browser_dimension(brobj)

    :attention: API change from XForms - upstream was
        fl_get_browser_dimension(pFlObject, x, y, w, h)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_browser_dimension = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_browser_dimension",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord), cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord)],
        """void fl_get_browser_dimension(FL_OBJECT * ob, FL_Coord * x,
           FL_Coord * y, FL_Coord * w, FL_Coord * h)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    x, px = libr.make_FL_Coord_and_pointer()
    y, py = libr.make_FL_Coord_and_pointer()
    w, pw = libr.make_FL_Coord_and_pointer()
    h, ph = libr.make_FL_Coord_and_pointer()
    libr.keep_elem_refs(pFlObject, x, y, w, h, px, py, pw, ph)
    _fl_get_browser_dimension(pFlObject, px, py, pw, ph)
    return x.value, y.value, w.value, h.value


def fl_set_browser_dblclick_callback(pFlObject, py_CallbackPtr, data):
    """Registers a callback function that gets called when a line is
    double-clicked on. Double-click callbacks make most sense for
    xfdata.FL_HOLD_BROWSERs.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `py_CallbackPtr` : python function callback, no return
        name referring to function(pObject, longdata)
      `data` : long
        user data to be passed to function

    :note: e.g. def browsercb(pobj, data): > ...
    :note: e.g. fl_set_browser_dblclick_callback(brobj, browsercb, data)

    :status: Tested + Doc + NoDemo = OK

    """
    #FL_CALLBACKPTR = cty.CFUNCTYPE(None, cty.POINTER(xfdata.FL_OBJECT), \
    #                               cty.c_long)
    _fl_set_browser_dblclick_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_browser_dblclick_callback",
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_CALLBACKPTR, \
        cty.c_long],
        """void fl_set_browser_dblclick_callback(FL_OBJECT * ob,
           FL_CALLBACKPTR cb, long int a)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ldata = libr.convert_to_long(data)
    c_CallbackPtr = xfdata.FL_CALLBACKPTR(py_CallbackPtr)
    libr.keep_cfunc_refs(c_CallbackPtr, py_CallbackPtr)
    libr.keep_elem_refs(pFlObject, data, ldata)
    _fl_set_browser_dblclick_callback(pFlObject, c_CallbackPtr, ldata)


def fl_get_browser_xoffset(pFlObject):
    """Obtains the amount of text that is scrolled in horizontal direction.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object

    :return: coord num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _fl_get_browser_xoffset = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_browser_xoffset",
        xfdata.FL_Coord, [cty.POINTER(xfdata.FL_OBJECT)],
        """FL_Coord fl_get_browser_xoffset(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_browser_xoffset(pFlObject)
    return retval


def fl_get_browser_rel_xoffset(pFlObject):
    """Obtains the relative amount of text that is scrolled in horizontal
    direction.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object

    :return: relative offset
    :rtype: float

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _fl_get_browser_rel_xoffset = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_browser_rel_xoffset",
        cty.c_double, [cty.POINTER(xfdata.FL_OBJECT)],
        """double fl_get_browser_rel_xoffset(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_browser_rel_xoffset(pFlObject)
    return retval


def fl_set_browser_xoffset(pFlObject, npixels):
    """Sets the amount of text that is scrolled in horizontal direction.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `npixels` : int
        amount of text to be scrolled

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _fl_set_browser_xoffset = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_browser_xoffset",
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_Coord],
        """void fl_set_browser_xoffset(FL_OBJECT * ob, FL_Coord npixels)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    inpixels = libr.convert_to_FL_Coord(npixels)
    libr.keep_elem_refs(pFlObject, npixels, inpixels)
    _fl_set_browser_xoffset(pFlObject, inpixels)


def fl_set_browser_rel_xoffset(pFlObject, val):
    """Sets the relative amount of text that is scrolled in horizontal
    direction.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `val` : float
        relative amount to be scrolled

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_browser_rel_xoffset = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_browser_rel_xoffset",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_double],
        """void fl_set_browser_rel_xoffset(FL_OBJECT * ob, double val)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    fval = libr.convert_to_double(val)
    libr.keep_elem_refs(pFlObject, val, fval)
    _fl_set_browser_rel_xoffset(pFlObject, fval)


def fl_get_browser_yoffset(pFlObject):
    """Obtains the amount of text that is scrolled in horizontal direction.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object

    :return: coord. num.
    :rtype: int

    :note: e.g. *todo*

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_browser_yoffset = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_browser_yoffset",
        xfdata.FL_Coord, [cty.POINTER(xfdata.FL_OBJECT)],
        """FL_Coord fl_get_browser_yoffset(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_browser_yoffset(pFlObject)
    return retval


def fl_get_browser_rel_yoffset(pFlObject):
    """Obtains the relative amount of text that is scrolled in horizontal
    direction.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object

    :return: relative offset
    :rtype: float

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _fl_get_browser_rel_yoffset = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_browser_rel_yoffset",
        cty.c_double, [cty.POINTER(xfdata.FL_OBJECT)],
        """double fl_get_browser_rel_yoffset(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_browser_rel_yoffset(pFlObject)
    return retval


def fl_set_browser_yoffset(pFlObject, npixels):
    """Sets the amount of text that is scrolled in horizontal direction.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `npixels` : int
        amount of text to be scrolled

    :note: e.g. *todo*

    :status: Tested + NoDoc + Demo = OK

    """
    _fl_set_browser_yoffset = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_browser_yoffset",
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_Coord],
        """void fl_set_browser_yoffset(FL_OBJECT * ob, FL_Coord npixels)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    inpixels = libr.convert_to_FL_Coord(npixels)
    libr.keep_elem_refs(pFlObject, npixels, inpixels)
    _fl_set_browser_yoffset(pFlObject, inpixels)


def fl_set_browser_rel_yoffset(pFlObject, val):
    """Sets the relative amount of text that is scrolled in horizontal
    direction.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `val` : float
        relative amount of text to be scrolled

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _fl_set_browser_rel_yoffset = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_browser_rel_yoffset",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_double],
        """void fl_set_browser_rel_yoffset(FL_OBJECT * ob, double val)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    fval = libr.convert_to_double(val)
    libr.keep_elem_refs(pFlObject, val, fval)
    _fl_set_browser_rel_yoffset(pFlObject, fval)


def fl_set_browser_scrollbarsize(pFlObject, hh, vw):
    """Sets the scrollbar size of the browser. By default, the scrollbar size
    is based on the relation between the size of the browser and the size of
    the text.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `hh` : int
        horizontal scrollbar height (0 for the default)
      `vw` : int
        vertical scrollbar width (0 for the default)

    :note: e.g. fl_set_browser_scrollbarsize(brobj, 10, 10)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_browser_scrollbarsize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_browser_scrollbarsize",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int, cty.c_int],
        """void fl_set_browser_scrollbarsize(FL_OBJECT * ob,
           int hh, int vw)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ihh = libr.convert_to_int(hh)
    ivw = libr.convert_to_int(vw)
    libr.keep_elem_refs(pFlObject, hh, vw, ihh, ivw)
    _fl_set_browser_scrollbarsize(pFlObject, ihh, ivw)


def fl_show_browser_line(pFlObject, line):
    """Brings a browser line into view.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `line` : int
        line number to show

    :note: e.g. fl_show_browser_line(brobj, 12)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_show_browser_line = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_browser_line",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_show_browser_line(FL_OBJECT * ob, int j)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    iline = libr.convert_to_int(line)
    libr.keep_elem_refs(pFlObject, line, iline)
    _fl_show_browser_line(pFlObject, iline)


# fl_set_default_browser_maxlinelength function placeholder (deprecated)


def fl_set_browser_hscroll_callback(pFlObject, py_BrowserScrollCallback,
                                    vdata):
    """Sets the callback function to be invoked whenever the horizontal
    scrollbar changes position.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `py_BrowserScrollCallback` : python function callback, no return
        name referring to function(pFlObject, num, vdata)
      `vdata` : pointer to void
        user data to be passed to function

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    #FL_BROWSER_SCROLL_CALLBACK = cty.CFUNCTYPE(None,
    #            cty.POINTER(xfdata.FL_OBJECT), cty.c_int, cty.c_void_p)
    _fl_set_browser_hscroll_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_browser_hscroll_callback",
        None, [cty.POINTER(xfdata.FL_OBJECT), \
        xfdata.FL_BROWSER_SCROLL_CALLBACK, cty.c_void_p],
        """void fl_set_browser_hscroll_callback(FL_OBJECT * ob,
           FL_BROWSER_SCROLL_CALLBACK cb, void * data)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    c_BrowserScrollCallback = xfdata.FL_BROWSER_SCROLL_CALLBACK( \
                                py_BrowserScrollCallback)
    pvdata = cty.cast(vdata, cty.c_void_p)
    libr.keep_cfunc_refs(c_BrowserScrollCallback, py_BrowserScrollCallback)
    libr.keep_elem_refs(pFlObject, vdata, pvdata)
    _fl_set_browser_hscroll_callback(pFlObject, c_BrowserScrollCallback,
                                     pvdata)


def fl_set_browser_vscroll_callback(pFlObject, py_BrowserScrollCallback,
                                    vdata):
    """Sets the callback function to be invoked whenever the vertical
    scrollbar changes position.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `py_BrowserScrollCallback` : python function callback, no return
        name referring to function(pFlObject, num, vdata)
      `vdata` : pointer to void
        user data to be passed to function

    :note: e.g. *todo*

    :status: Tested + NoDoc + Demo = OK

    """
    _fl_set_browser_vscroll_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_browser_vscroll_callback",
        None, [cty.POINTER(xfdata.FL_OBJECT),
        xfdata.FL_BROWSER_SCROLL_CALLBACK, cty.c_void_p],
        """void fl_set_browser_vscroll_callback(FL_OBJECT * ob,
           FL_BROWSER_SCROLL_CALLBACK cb, void * data)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    c_BrowserScrollCallback = xfdata.FL_BROWSER_SCROLL_CALLBACK( \
                                py_BrowserScrollCallback)
    pvdata = cty.cast(vdata, cty.c_void_p)
    libr.keep_cfunc_refs(c_BrowserScrollCallback, py_BrowserScrollCallback)
    libr.keep_elem_refs(pFlObject, vdata, pvdata)
    _fl_set_browser_vscroll_callback(pFlObject, c_BrowserScrollCallback,
                                    pvdata)


def fl_get_browser_line_yoffset(pFlObject, line):
    """Returns the y-offset for a line.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object
      `line` : int
        line number

    :return: offset of the line, or -1 (if the line does not exist)
    :rtype: int

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _fl_get_browser_line_yoffset = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_browser_line_yoffset",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """int fl_get_browser_line_yoffset(FL_OBJECT * obj, int line)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    iline = libr.convert_to_int(line)
    libr.keep_elem_refs(pFlObject, line, iline)
    retval = _fl_get_browser_line_yoffset(pFlObject, iline)
    return retval


def fl_get_browser_hscroll_callback(pFlObject):
    """Obtains the callback function created for horizontal scrollbar position
    change.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object

    :return: xfdata.FL_BROWSER_SCROLL_CALLBACK function

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _fl_get_browser_hscroll_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_browser_hscroll_callback",
        xfdata.FL_BROWSER_SCROLL_CALLBACK, [cty.POINTER(xfdata.FL_OBJECT)],
        """FL_BROWSER_SCROLL_CALLBACK fl_get_browser_hscroll_callback(
           FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_browser_hscroll_callback(pFlObject)
    return retval


def fl_get_browser_vscroll_callback(pFlObject):
    """Obtains the callback function created for horizontal scrollbar position
    change.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        browser object

    :return: xfdata.FL_BROWSER_SCROLL_CALLBACK function

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _fl_get_browser_vscroll_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_browser_vscroll_callback",
        xfdata.FL_BROWSER_SCROLL_CALLBACK, [cty.POINTER(xfdata.FL_OBJECT)],
        """FL_BROWSER_SCROLL_CALLBACK fl_get_browser_vscroll_callback(
           FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_browser_vscroll_callback(pFlObject)
    return retval

