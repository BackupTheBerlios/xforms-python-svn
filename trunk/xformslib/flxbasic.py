#!/usr/bin/env python
# -*- coding: iso8859-1 -*-

"""
    xforms-python - Python wrapper for XForms (X11) GUI C toolkit library
    using ctypes

    Copyright (C) 2009, 2010  Luca Lazzaroni "LukenShiro"
    e-mail: <lukenshiro@ngi.it>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, version 2.1 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU LGPL along with this
    program. If not, see <http://www.gnu.org/licenses/>.

    See CREDITS file to read acknowledgements and thanks to XForms,
    ctypes and other developers.
"""


# originally generated by 'h2xml+gccxml' and 'xml2py'
# then heavily reordered and reworked

# ############################################# #
# Interface to XForms shared object libraries   #
# ############################################# #


import ctypes as cty
from xformslib import library
from xformslib import xfdata
from xformslib import flbasic
from xformslib import flcanvas




fl_current_form = (cty.POINTER(xfdata.FL_FORM)).in_dll(library.load_so_libforms(), \
                   'fl_current_form')
fl_display = (cty.POINTER(xfdata.Display)).in_dll(library.load_so_libforms(), 'fl_display')
fl_screen = (cty.c_int).in_dll(library.load_so_libforms(), 'fl_screen')
# root window
fl_root = (xfdata.Window).in_dll(library.load_so_libforms(), 'fl_root')
# virtual root window
fl_vroot = (xfdata.Window).in_dll(library.load_so_libforms(), 'fl_vroot')
# screen dimension in pixels
fl_scrh = (cty.c_int).in_dll(library.load_so_libforms(), 'fl_scrh')
fl_scrw = (cty.c_int).in_dll(library.load_so_libforms(), 'fl_scrw')
fl_vmode = (cty.c_int).in_dll(library.load_so_libforms(), 'fl_vmode')
fl_state = (cty.POINTER(xfdata.FL_State)).in_dll(library.load_so_libforms(), 'fl_state')
fl_ul_magic_char = (xfdata.STRING).in_dll(library.load_so_libforms(), 'fl_state')



###########################
# forms.h (XBasic.h)
# X Window dependent stuff
###########################

def FL_is_gray(v):
    if (v == xfdata.GrayScale) or (v == xfdata.StaticGray):
        return True
    else:
        return False


def FL_is_rgb(v):
    if (v == xfdata.TrueColor) or (v == xfdata.DirectColor):
        return True
    else:
        return False


# Current version only runs in single visual mode
def fl_get_vclass():
    return fl_vmode


def fl_get_form_vclass(a):
    return fl_vmode


def fl_get_gc():
    return fl_state[fl_vmode].gc[0]


def fl_mode_capable(mode, warn):
    """Return if the system is capable of displaying in the specified visual
    class, or not.

    @param mode: visual mode. Values (from xfdata module) GrayScale,
        StaticGray, PseudoColor, StaticColor, DirectColor and TrueColor
    @type mode: int
    @param warn: if set a warning is printed out in case the capability asked
        for isn't available. Values 0 (don't print warning) or 1 (print warning)
    @type warn: int

    :return: flag 1 (if capable) or 0 otherwise
    :rtype: int

    :note: e.g. capable = fl_mode_capable(xfdata.GrayScale, 1)

    :status: Tested + Doc + NoDemo = OK
    """
    _fl_mode_capable = library.cfuncproto(
        library.load_so_libforms(), "fl_mode_capable",\
        cty.c_int, [cty.c_int, cty.c_int],\
        """int fl_mode_capable(int mode, int warn)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(mode, xfdata.VISUALMODE_list)
    imode = library.convert_to_int(mode)
    iwarn = library.convert_to_int(warn)
    library.keep_elem_refs(mode, warn, imode, iwarn)
    retval = _fl_mode_capable(imode, iwarn)
    return retval


def fl_default_win():
    return fl_state[fl_vmode].trailblazer


def fl_default_window():
    return fl_state[fl_vmode].trailblazer


# Some basic drawing routines

# Rectangles

def fl_rectangle(fill, x, y, w, h, colr):
    """Draws a rectangle.

    @param fill: flag if the rectangle has to be filled or just the outline is
        needed. Values 0 (the outline only) or 1 (filled)
    @type fill: int
    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_rectangle(1, 100, 200, 300, 200, xfdata.FL_BEIGE)

    :status: Tested + Doc + Demo = OK

    """
    _fl_rectangle = library.cfuncproto(
        library.load_so_libforms(), "fl_rectangle",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR], \
        """void fl_rectangle(int fill, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR col)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(colr, xfdata.COLOR_list)
    ifill = library.convert_to_int(fill)
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    ulcolr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(fill, x, y, w, h, colr, ifill, ix, iy, iw, ih,
                   ulcolr)
    _fl_rectangle(ifill, ix, iy, iw, ih, ulcolr)


def fl_rectbound(x, y, w, h, colr):
    """Draws a filled rectangle with a black border.

    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_rectbound(100, 200, 300, 200, xfdata.FL_PINK)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_rectbound = library.cfuncproto(
        library.load_so_libforms(), "fl_rectbound",\
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_COLOR],\
        """void fl_rectbound(FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, FL_COLOR col)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(colr, xfdata.COLOR_list)
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    ulcolr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(x, y, w, h, colr, ix, iy, iw, ih, ulcolr)
    _fl_rectbound(ix, iy, iw, ih, ulcolr)


def fl_rectf(x, y, w, h, colr):
    """Draws a filled rectangle on the screen.

    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_rectf(150, 220, 300, 200, xfdata.FL_TOMATO)

    :status: Tested + Doc + Demo = OK

    """
    fl_rectangle(1, x, y, w, h, colr)


def fl_rect(x, y, w, h, colr):
    """Draws a rectangle's outline on the screen.

    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int
    @param colr: color value
    @type colr: int

    :note: e.g. fl_rect(100, 200, 300, 200, xfdata.FL_SLATEBLUE)

    :status: Tested + Doc + Demo = OK

    """
    fl_rectangle(0, x, y, w, h, colr)


# Rectangle with rounded-corners

def fl_roundrectangle(fill, x, y, w, h, colr):
    """Draws a rectangle with rounded corners (filled or just the outline).

    @param fill: flag if the rectangle has to be filled or just the outline is
        needed. Values 0 (the outline only) or 1 (filled)
    @type fill: int
    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_roundrectangle(1, 100, 200, 300, 200, xfdata.FL_MAGENTA)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_roundrectangle = library.cfuncproto(
        library.load_so_libforms(), "fl_roundrectangle",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR],\
        """void fl_roundrectangle(int fill, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR col)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(colr, xfdata.COLOR_list)
    ifill = library.convert_to_int(fill)
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    ulcolr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(fill, x, y, w, h, colr, ifill, ix, iy, iw, ih,
                   ulcolr)
    _fl_roundrectangle(ifill, ix, iy, iw, ih, ulcolr)


def fl_roundrectf(x, y, w, h, colr):
    """Draws a filled rectangle with rounded corners.

    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_roundrectf(100, 200, 300, 200, xfdata.FL_CYAN)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_roundrectangle(1, x, y, w, h, colr)


def fl_roundrect(x, y, w, h, colr):
    """Draws a rectangle's outline with rounded corners.

    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_roundrect(100, 200, 300, 200, xfdata.Fl_INDIANRED)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_roundrectangle(0, x, y, w, h, colr)


# General polygon and polylines

def fl_polygon(fill, Point, numpt, colr):
    """Draws a generic polygon on the screen (filled or just an outline).

    @param fill: if polygon has to be filled or just an outline is needed.
        Values 1 (if filled) or 0 (an outline only)
    @type fill: int
    @param Point: an array of FL_POINT class instance
    @type Point: array of class instances
    @param numpt: number of points
    @type numpt: int
    @param colr: value of color to be set
    @type colr: long_pos

    :note: e.g. pointmap = (FL_POINT * 4)()
    :note: e.g. pointmap[0].x = 12 ; pointmap[0].y = 32
    :note: e.g. pointmap[1].x = 24 ; pointmap[1].y = 100
    :note: e.g. pointmap[2].x = 87 ; pointmap[0].y = 132
    :note: e.g. fl_polygon(1, pointmap, 3, xfdata.FL_PALEGREEN)

    :status: Tested + Doc + Demo = OK

    """
    _fl_polygon = library.cfuncproto(
        library.load_so_libforms(), "fl_polygon",\
        None, [cty.c_int, cty.POINTER(xfdata.FL_POINT), cty.c_int,
        xfdata.FL_COLOR],
        """void fl_polygon(int fill, FL_POINT * xp, int n, FL_COLOR col)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(colr, xfdata.COLOR_list)
    ifill = library.convert_to_int(fill)
    pPoint = cty.cast(Point, cty.POINTER(xfdata.FL_POINT))
    inumpt = library.convert_to_int(numpt)
    ulcolr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(fill, Point, numpt, colr, ifill, pPoint, inumpt, ulcolr)
    _fl_polygon(ifill, pPoint, inumpt, ulcolr)


def fl_polyf(Point, numpt, colr):
    """Draws a generic filled polygon on the screen.

    @param Point: an array of FL_POINT class instance
    @type Point: array of class instances
    @param numpt: number of points
    @type numpt: int
    @param colr: value of color to be set
    @type colr: long_pos

    :note: e.g. pointmap = (FL_POINT * 4)() ;
    :note: e.g. pointmap[0].x = 12 ; pointmap[0].y = 32 ;
    :note: e.g. pointmap[1].x = 24 ; pointmap[1].y = 100 ;
    :note: e.g. pointmap[2].x = 87 ; pointmap[0].y = 132 ;
    :note: e.g. fl_polyf(pointmap, 3, xfdata.FL_PALEGREEN)

    :status: Tested + Doc + Demo = OK

    """
    fl_polygon(1, Point, numpt, colr)


def fl_polyl(Point, numpt, colr):
    """Draws a generic polygon's outline on the screen.

    @param Point: an array of FL_POINT class instance
    @type Point: array of class instances
    @param numpt: number of points
    @type numpt: int
    @param colr: value of color to be set
    @type colr: long_pos

    :note: e.g. pointmap = (FL_POINT * 4)() ;
    :note: e.g. pointmap[0].x = 12 ; pointmap[0].y = 32 ;
    :note: e.g. pointmap[1].x = 24 ; pointmap[1].y = 100 ;
    :note: e.g. pointmap[2].x = 87 ; pointmap[0].y = 132 ;
    :note: e.g. fl_polyl(pointmap, 3, xfdata.FL_ORCHID)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_polygon(0, Point, numpt, colr)


def fl_polybound(Point, numpt, colr):
    """Draws a generic filled polygon with a black border in the screen.

    @param Point: an array of FL_POINT class instance
    @type Point: array of class instances
    @param numpt: number of points
    @type numpt: int
    @param colr: value of color to be set
    @type colr: long_pos

    :note: e.g. pointmap = (FL_POINT * 4)() ;
    :note: e.g. pointmap[0].x = 12 ; pointmap[0].y = 32 ;
    :note: e.g. pointmap[1].x = 24 ; pointmap[1].y = 100 ;
    :note: e.g. pointmap[2].x = 87 ; pointmap[0].y = 132 ;
    :note: e.g. fl_polybound(pointmap, 3, xfdata.FL_DARKGOLD)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_polygon(1, Point, numpt, colr)
    fl_polygon(0, Point, numpt, xfdata.FL_BLACK)


def fl_lines(Point, numpt, colr):
    """Draws connected line segments between a number of points

    @param Point: an array of FL_POINT class instance
    @type Point: array of class instances
    @param numpt: number of points
    @type numpt: int
    @param colr: value of color to be set
    @type colr: long_pos

    :note: e.g. pointmap = (FL_POINT * 4)() ;
    :note: e.g. pointmap[0].x = 23 ; pointmap[0].y = 12 ;
    :note: e.g. pointmap[1].x = 56 ; pointmap[1].y = 34 ;
    :note: e.g. pointmap[2].x = 102 ; pointmap[0].y = 250 ;
    :note: e.g. fl_lines(pointmap, 3, xfdata.FL_DODGERBLUE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_lines = library.cfuncproto(
        library.load_so_libforms(), "fl_lines",\
        None, [cty.POINTER(xfdata.FL_POINT), cty.c_int, xfdata.FL_COLOR],\
        """void fl_lines(FL_POINT * xp, int n, FL_COLOR col)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(colr, xfdata.COLOR_list)
    pPoint = cty.cast(Point, cty.POINTER(xfdata.FL_POINT))
    inumpt = library.convert_to_int(numpt)
    ulcolr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(Point, numpt, colr, inumpt, ulcolr)
    _fl_lines(pPoint, inumpt, ulcolr)


def fl_line(xi, yi, xf, yf, colr):
    """Connects two points with a straight line.

    @param xi: initial horizontal position (upper-left corner)
    @type xi: int
    @param yi: initial vertical position (upper-left corner)
    @type yi: int
    @param xf: final horizontal position (upper-left corner)
    @type xf: int
    @param yf: final vertical position (upper-left corner)
    @type yf: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_line(100, 100, 200, 200, xfdata.FL_ANTIQUEWHITE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_line = library.cfuncproto(
        library.load_so_libforms(), "fl_line",\
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_COLOR],\
        """void fl_line(FL_Coord xi, FL_Coord yi, FL_Coord xf,
           FL_Coord yf, FL_COLOR c)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(colr, xfdata.COLOR_list)
    ixi = library.convert_to_int(xi)
    iyi = library.convert_to_int(yi)
    ixf = library.convert_to_int(xf)
    iyf = library.convert_to_int(yf)
    ulcolr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(xi, yi, xf, yf, colr, ixi, iyi, ixf, iyf, ulcolr)
    _fl_line(ixi, iyi, ixf, iyf, ulcolr)


fl_simple_line = fl_line


def fl_point(x, y, colr):
    """Draws one point on the screen.

    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_point(75, 452, xfdata.FL_CHARTREUSE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_point = library.cfuncproto(
        library.load_so_libforms(), "fl_point",\
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_COLOR],\
        """void fl_point(FL_Coord x, FL_Coord y, FL_COLOR c)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(colr, xfdata.COLOR_list)
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    ulcolr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(x, y, colr, ix, iy, ulcolr)
    _fl_point(ix, iy, ulcolr)


def fl_points(Point, numpt, colr):
    """Draws more than one points.

    @param Point: an array of FL_POINT class instance
    @type Point: array of class instances
    @param numpt: number of points
    @type numpt: int
    @param colr: value of color to be set
    @type colr: long_pos

    :note: e.g. pointmap = (FL_POINT * 3)() ;
    :note: e.g. pointmap[0].x = 23 ; pointmap[0].y = 12 ;
    :note: e.g. pointmap[1].x = 56 ; pointmap[1].y = 34 ;
    :note: e.g. pointmap[2].x = 102 ; pointmap[0].y = 250 ;
    :note: e.g. fl_points(pointmap, 3, xfdata.FL_AZURE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_points = library.cfuncproto(
        library.load_so_libforms(), "fl_points",\
        None, [cty.POINTER(xfdata.FL_POINT), cty.c_int, xfdata.FL_COLOR],
        """void fl_points(FL_POINT * p, int np, FL_COLOR c)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(colr, xfdata.COLOR_list)
    pPoint = cty.cast(Point, cty.POINTER(xfdata.FL_POINT))
    inumpt = library.convert_to_int(numpt)
    ulcolr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(Point, numpt, colr, pPoint, inumpt, ulcolr)
    _fl_points(pPoint, inumpt, ulcolr)


def fl_dashedlinestyle(dash, ndash):
    """Changes the dash pattern for xfdata.FL_USERDASH and
    xfdata.FL USERDOUBLEDASH. Each element of the array dash is the length of
    a segment of the pattern in pixels. Dashed lines are drawn as alternating
    segments, each with the length of an element in dash. Thus the overall
    length of the dash pattern, in pixels, is the sum of all elements of dash.
    When the pattern is used up but the line to draw is longer it used from the
    start again. You have to call this one whenever xfdata.FL_USERDASH is used
    to set the dash pattern, otherwise whatever the last pattern was, it will
    be used. After the sequence, the pattern repeats.

    @param dash: sequence list of dashes to use. Use None as default dash
        pattern
    @type dash: list_of_int
    @param ndash: length of dashes list
    @type ndash: int

    :note: e.g. dashlist = [9, 3, 2, 3]
    :note: e.g. fl_dashedlinestyle(dashlist, 4)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_dashedlinestyle = library.cfuncproto(
        library.load_so_libforms(), "fl_dashedlinestyle",\
        None, [xfdata.STRING, cty.c_int],\
        """void fl_dashedlinestyle(const char * dash, int ndash)""")
    library.check_if_initialized()
    sdash = library.convert_to_string(dash)
    indash = library.convert_to_int(ndash)
    library.keep_elem_refs(dash, ndash, sdash, indash)
    _fl_dashedlinestyle(sdash, indash)


def fl_update_display(block):
    """Flushes properly the output buffer. It resolves the problem of the form
    being only partially redrawn, due to the two way buffering mechanism of
    Xlib, if fl_show_form() is followed by something that blocks (e.g.,
    waiting for a device other than X devices to come online). For typical
    programs that use fl_do_forms() or fl_check_forms() after fl_show_form(),
    flushing is not necessary as the output buffer is flushed automatically.
    Excessive call to fl_update_display() degrades performance.

    @param block: mode of X buffer flushing. Values 0 (it's flushed so the
        drawing requests are on their way to the server) or 1 (it's flushed and
        waits until all the events are received and processed by the server)
    @type block: int

    :note: e.g. fl_update_display()

    @postcondition: to be used after fl_show_form()
    :status: Tested + Doc + NoDemo = OK

    """
    _fl_update_display = library.cfuncproto(
        library.load_so_libforms(), "fl_update_display",\
        None, [cty.c_int],\
        """void fl_update_display(int block)""")
    library.check_if_initialized()
    iblock = library.convert_to_int(block)
    library.keep_elem_refs(block, iblock)
    _fl_update_display(iblock)


def fl_diagline(x, y, w, h, colr):
    """Draws a line along the diagonal of a box (to draw a horizontal line
    set h to 1, not to 0).

    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_diagline(180, 90, 5, 2, xfdata.FL_BISQUE)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_line(x, y, (x) + (w) - 1, (y) + (h) - 1, colr)


# Line attributes

def fl_linewidth(lw):
    """Changes the line width.

    @param lw: width of line in coord units. 0 to reset to the server's default
    @type lw: int

    :note: e.g. fl_linewidth(2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_linewidth = library.cfuncproto(
        library.load_so_libforms(), "fl_linewidth",\
        None, [cty.c_int],\
        """void fl_linewidth(int n)""")
    library.check_if_initialized()
    ilw = library.convert_to_int(lw)
    library.keep_elem_refs(lw, ilw)
    _fl_linewidth(ilw)


fl_set_linewidth = fl_linewidth


def fl_linestyle(linestyle):
    """Changes the line style.

    @param linestyle: style of the line to draw. Values (from xfdata module)
        FL_SOLID, FL_USERDASH, FL_USERDOUBLEDASH, FL_DOT, FL_DOTDASH, FL_DASH,
        FL_LONGDASH
    @type linestyle: int

    :note: e.g. fl_linestyle(xfdata.FL_DOT)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_linestyle = library.cfuncproto(
        library.load_so_libforms(), "fl_linestyle",\
        None, [cty.c_int],\
        """void fl_linestyle(int n)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(linestyle, xfdata.LINESTYLE_list)
    ilinestyle = library.convert_to_int(linestyle)
    library.keep_elem_refs(linestyle, ilinestyle)
    _fl_linestyle(ilinestyle)


fl_set_linestyle = fl_linestyle


def fl_drawmode(mode):
    """Changes the drawing mode so the destination pixel values play a role
    in the final pixel value. By default, all lines are drawn so they
    overwrite the destination pixel values.

    @param mode: requested mode setting. Values (from xfdata module) FL_XOR,
        FL_COPY, FL_AND
    @type mode: int

    :note: e.g. fl_drawmode(xfdata.FL_AND)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_drawmode = library.cfuncproto(
        library.load_so_libforms(), "fl_drawmode",\
        None, [cty.c_int],\
        """void fl_drawmode(int request)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(mode, xfdata.DRAWMODE_list)
    imode = library.convert_to_int(mode)
    library.keep_elem_refs(mode, imode)
    _fl_drawmode(imode)


def fl_get_linewidth():
    """Returns the width of line.

    :return: line width (lw)
    :rtype: int

    :note: e.g. wid = fl_get_linewidth()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_linewidth = library.cfuncproto(
        library.load_so_libforms(), "fl_get_linewidth", \
        cty.c_int, [], \
        """int fl_get_linewidth()""")
    library.check_if_initialized()
    retval = _fl_get_linewidth()
    return retval


def fl_get_linestyle():
    """Returns the style of line (from xfdata, e.g. FL_SOLID, FL_DOT, etc..).

    :return: line style
    :rtype: int

    :note: e.g. currstl = fl_get_linestyle()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_linestyle = library.cfuncproto(
        library.load_so_libforms(), "fl_get_linestyle", \
        cty.c_int, [], \
        """int fl_get_linestyle()""")
    library.check_if_initialized()
    retval = _fl_get_linestyle()
    return retval


def fl_get_drawmode():
    """Returns the drawing mode of lines (from xfdata, e.g. FL_AND, FL_XOR
    etc..).

    :return: drawing mode
    :rtype: int

    :note: e.g. currdrw = fl_get_draw_mode()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_drawmode = library.cfuncproto(
        library.load_so_libforms(), "fl_get_drawmode",\
        cty.c_int, [],\
        """int fl_get_drawmode()""")
    library.check_if_initialized()
    retval = _fl_get_drawmode()
    return retval


fl_set_drawmode = fl_drawmode


# Ellipses

def fl_oval(fill, x, y, w, h, colr):
    """Draws an ellipse, either filled or open. Use w equal to h to get a
    circle.

    @param fill: flag if filled or open ellipse. Values 1 (if filled ellipse)
        or 0 (if open)
    @type fill: int
    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_oval(1, 125, 256, 145, 320, xfdata.FL_BURLYWOOD)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_oval = library.cfuncproto(
        library.load_so_libforms(), "fl_oval",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR], \
        """void fl_oval(int fill, FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, FL_COLOR col)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(colr, xfdata.COLOR_list)
    ifill = library.convert_to_int(fill)
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    ulcolr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(fill, x, y, w, h, colr, ifill, ix, iy, iw, ih, ulcolr)
    _fl_oval(ifill, ix, iy, iw, ih, ulcolr)


def fl_ovalbound(x, y, w, h, colr):
    """Draws a filled ellipse with a black outline. Use w equal to h to get a
    circle.

    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_ovalbound(1, 125, 256, 145, 320, xfdata.FL_BLANCHEDALMOND)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_ovalbound = library.cfuncproto(
        library.load_so_libforms(), "fl_ovalbound",\
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_COLOR],\
        """void fl_ovalbound(FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, FL_COLOR col)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(colr, xfdata.COLOR_list)
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    ulcolr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(x, y, w, h, colr, ix, iy, iw, ih, ulcolr)
    _fl_ovalbound(ix, iy, iw, ih, ulcolr)


def fl_ovalarc(fill, x, y, w, h, stheta, dtheta, colr):
    """Draws an elliptical arc, either filled or open.

    @param fill: flag if filled or open. Values 1 (if filled) or 0 (if open)
    @type fill: int
    @param x: horizontal position (upper-left corner) (<int>)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int
    @param stheta: starting angle, measured in tenth of a degree and with
        0 at 3 o'clock position
    @type stheta: int
    @param dtheta: the directione and the extent of the arc. If positive the
        arc is drawn in counter-clockwise direction from the starting point,
        otherwise in clockwise direction. If it is larger than 3600 it is
        truncated to 3600.
    @type dtheta: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_ovalarc(1, 275, 256, 145, 320, 200, 900, xfdata.FL_DARKSALMON)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_ovalarc = library.cfuncproto(
        library.load_so_libforms(), "fl_ovalarc",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, cty.c_int, cty.c_int, xfdata.FL_COLOR],
        """void fl_ovalarc(int fill, FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, int t0, int dt, FL_COLOR col)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(colr, xfdata.COLOR_list)
    ifill = library.convert_to_int(fill)
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    istheta = library.convert_to_int(stheta)
    idtheta = library.convert_to_int(dtheta)
    ulcolr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(fill, x, y, w, h, stheta, dtheta, colr, ifill, ix, iy, iw,
                   ih, istheta, idtheta, ulcolr)
    _fl_ovalarc(ifill, ix, iy, iw, ih, istheta, idtheta, ulcolr)


def fl_ovalf(x, y, w, h, colr):
    """Draws a filled ellipse. Use w equal to h to get a circle.

    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_ovalf(125, 256, 145, 320, xfdata.FL_CORNFLOWERBLUE)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_oval(1, x, y, w, h, colr)


def fl_ovall(x, y, w, h, colr):
    """Draws an open ellipse. Use w equal to h to get a circle.

    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_ovall(125, 256, 145, 320, xfdata.FL_DARKERED)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_oval(0, x, y, w, h, colr)


fl_oval_bound = fl_ovalbound


def fl_circf(x, y, r, colr):
    """Draws a filled circle.

    @param x: horizontal position of the center of the arc
    @type x: int
    @param y: vertical position of the center of the arc
    @type y: int
    @param r: radius of the arc
    @type r: int

    :note: e.g. fl_circf(200, 250, 69, xfdata.FL_FUCHSIA)

    :status: Tested + NoDoc + Demo = OK
    """
    fl_oval(1, (x) - (r), (y) - (r), 2 * (r), 2 * (r), colr)


def fl_circ(x, y, r, colr):
    """Draws an open circle.

    @param x: horizontal position of the center of the arc
    @type x: int
    @param y: vertical position of the center of the arc
    @type y: int
    @param r: radius of the arc
    @type r: int

    :note: e.g. fl_circ(200, 250, 69, xfdata.FL_GAINSBORO)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_oval(0, (x) - (r), (y) - (r), 2 * (r), 2 * (r), colr)


# Arcs

def fl_pieslice(fill, x, y, w, h, stheta, etheta, colr):
    """Draws an elliptical arc, either filled or open.

    @param fill: if the arc is filled or open. Values 1 (if filled) or 0
        (if open)
    @type fill: int
    @param x: horizontal position of the bounding box
    @type x: int
    @param y: vertical position of the bounding box
    @type y: int
    @param h: horizontal axe of the ellipse
    @type h: int
    @param w: vertical axe of the ellipse
    @type w: int
    @param stheta: starting angle of the arc in units of tenths of a degree
        (where 0 stands for a direction of 3 o'clock, i.e. the right-most point
        of a circle)
    @type stheta: int
    @param etheta: ending angle of the arc in units of tenths of a degree
        (where 0 stands for a direction of 3 o'clock, i.e. the right-most point
        of a circle)
    @type etheta: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_pieslice(1, 120, 253, 400, 100, 60, 70, xfdata.FL_GOLD)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_pieslice = library.cfuncproto(
        library.load_so_libforms(), "fl_pieslice",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, cty.c_int, cty.c_int, xfdata.FL_COLOR],
        """void fl_pieslice(int fill, FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, int a1, int a2, FL_COLOR col)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(colr, xfdata.COLOR_list)
    ifill = library.convert_to_int(fill)
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    istheta = library.convert_to_int(stheta)
    ietheta = library.convert_to_int(etheta)
    ulcolr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(fill, x, y, w, h, stheta, etheta, colr, ifill, ix, iy, iw,
                   ih, istheta, ietheta, ulcolr)
    _fl_pieslice(ifill, ix, iy, iw, ih, istheta, ietheta, ulcolr)


def fl_arcf(x, y, r, stheta, etheta, colr):
    """Draws a filled circular arc. If the difference between theta end and
    theta start is larger than 3600 (360 degrees), drawing is truncated to
    360 degrees.

    @param x: horizontal position of the center of the arc
    @type x: int
    @param y: vertical position of the center of the arc
    @type y: int
    @param r: radius of the arc
    @type r: int
    @param stheta: starting angle of the arc in units of tenths of a degree
        (where 0 stands for a direction of 3 o'clock, i.e. the right-most
        point of a circle)
    @type stheta: int
    @param etheta: ending angle of the arc in units of tenths of a degree
        (where 0 stands for a direction of 3 o'clock, i.e. the right-most
        point of a circle)
    @type etheta: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_arcf(120, 253, 40, 10, 60, xfdata.FL_FIREBRICK)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_pieslice(1, (x - r), (y - r), (2 * r), (2 * r), stheta, etheta, colr)


def fl_arc(x, y, r, stheta, etheta, colr):
    """Draws an open circular arc. If the difference between theta end and
    theta start is larger than 3600 (360 degrees), drawing is truncated to
    360 degrees.

    @param x: horizontal position of the center of the arc
    @type x: int
    @param y: vertical position of the center of the arc
    @type y: int
    @param r: radius of the arc
    @type r: int
    @param stheta: starting angle of the arc in units of tenths of a degree
        (where 0 stands for a direction of 3 o'clock, i.e. the right-most
        point of a circle)
    @type stheta: int
    @param etheta: ending angle of the arc in units of tenths of a degree
        (where 0 stands for a direction of 3 o'clock, i.e. the right-most
        point of a circle)
    @type etheta: int
    @param colr: color value
    @type colr: long_pos

    :note: e.g. fl_arc(120, 253, 40, 10, 60, xfdata.FL_FORESTGREEN)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_pieslice(0, (x - r), (y - r), (2 * r), (2 * r), stheta, etheta, colr)


# High level drawing routines

def fl_drw_frame(boxtype, x, y, w, h, colr, bw):
    """Draws a frame outside of the bounding box specified.

    @param boxtype: type of frame box. Values (from xfdata module) FL_NO_BOX,
        FL_UP_BOX, FL_DOWN_BOX, FL_BORDER_BOX, FL_SHADOW_BOX, FL_FRAME_BOX,
        FL_ROUNDED_BOX, FL_EMBOSSED_BOX, FL_FLAT_BOX, FL_RFLAT_BOX,
        FL_RSHADOW_BOX, FL_OVAL_BOX, FL_ROUNDED3D_UPBOX, FL_ROUNDED3D_DOWNBOX,
        FL_OVAL3D_UPBOX, FL_OVAL3D_DOWNBOX, FL_OVAL3D_FRAMEBOX,
        FL_OVAL3D_EMBOSSEDBOX
    @type boxtype: int
    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int
    @param colr: color value
    @type colr: long_pos
    @param bw: width of boundary
    @type bw: int

    :note: e.g. fl_drw_frame(xfdata.FL_UP_BOX, 470, 560, 170, 280,
        xfdata.FL_DIMGRAY, 2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_drw_frame = library.cfuncproto(
        library.load_so_libforms(), "fl_drw_frame",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_COLOR, cty.c_int],
        """void fl_drw_frame(int style, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR c, int bw)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(boxtype, xfdata.BOXTYPE_list)
    library.check_admitted_listvalues(colr, xfdata.COLOR_list)
    iboxtype = library.convert_to_int(boxtype)
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    ulcolr = library.convert_to_FL_COLOR(colr)
    ibw = library.convert_to_int(bw)
    library.keep_elem_refs(boxtype, x, y, w, h, colr, bw, iboxtype, ix, iy, iw,
                   ih, ulcolr, ibw)
    _fl_drw_frame(iboxtype, ix, iy, iw, ih, ulcolr, ibw)


def fl_drw_checkbox(boxtype, x, y, w, h, colr, bw):
    """Draws a box retated 45 degrees.

    @param boxtype: type of checkbox to draw. Values (from xfdata module)
        FL_NO_BOX, FL_UP_BOX, FL_DOWN_BOX, FL_BORDER_BOX, FL_SHADOW_BOX,
        FL_FRAME_BOX, FL_ROUNDED_BOX, FL_EMBOSSED_BOX, FL_FLAT_BOX,
        FL_RFLAT_BOX, FL_RSHADOW_BOX, FL_OVAL_BOX, FL_ROUNDED3D_UPBOX,
        FL_ROUNDED3D_DOWNBOX, FL_OVAL3D_UPBOX, FL_OVAL3D_DOWNBOX,
        FL_OVAL3D_FRAMEBOX, FL_OVAL3D_EMBOSSEDBOX
    @type boxtype: int
    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int
    @param colr: color value
    @type colr: long_pos
    @param bw: width of boundary
    @type bw: int

    :note: e.g. fl_drw_checkbox(xfdata.FL_ROUNDED3D_UPBOX, 470, 560, 170,
        280, xfdata.FL_LEMONCHIFFON, -2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_drw_checkbox = library.cfuncproto(
        library.load_so_libforms(), "fl_drw_checkbox",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_COLOR, cty.c_int],
        """void fl_drw_checkbox(int type, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR col, int bw)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(boxtype, xfdata.BOXTYPE_list)
    library.check_admitted_listvalues(colr, xfdata.COLOR_list)
    iboxtype = library.convert_to_int(boxtype)
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    ulcolr = library.convert_to_FL_COLOR(colr)
    ibw = library.convert_to_int(bw)
    library.keep_elem_refs(boxtype, x, y, w, h, colr, bw, iboxtype, ix, iy, iw,
                   ih, ulcolr, ibw)
    _fl_drw_checkbox(iboxtype, ix, iy, iw, ih, ulcolr, ibw)


# Interfaces

def fl_get_fontstruct(style, size):
    """Returns the X font structure for a particular size and style as used
    in XForms Library.

    @param style: font style. Values (from xfdata module) FL_NORMAL_STYLE,
        FL_BOLD_STYLE, FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
    @type style: int
    @param size: font size. Values (from xfdata module) FL_TINY_SIZE,
        FL_SMALL_SIZE, FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE,
        FL_HUGE_SIZE, FL_DEFAULT_SIZE
    @type size: int

    :return: XFontStruct class instance
    :rtype: pointer to xfdata.XFontStruct

    :note: e.g. pfstruc = gl_get_fontstruc(FL_ITALIC_STYLE, FL_NORMAL_STYLE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_fontstruct = library.cfuncproto(
        library.load_so_libforms(), "fl_get_fontstruct",\
        cty.POINTER(xfdata.XFontStruct), [cty.c_int, cty.c_int],\
        """XFontStruct * fl_get_fontstruct(int style, int size)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(style, xfdata.TEXTSTYLE_list)
    library.check_admitted_listvalues(size, xfdata.FONTSIZE_list)
    istyle = library.convert_to_int(style)
    isize = library.convert_to_int(size)
    library.keep_elem_refs(style, size, istyle, isize)
    retval = _fl_get_fontstruct(istyle, isize)
    return retval


fl_get_font_struct = fl_get_fontstruct
fl_get_fntstruct = fl_get_font_struct


def fl_get_mouse():
    """Obtains the current mouse position relative to the root window, and
    the current state of the modifier keys and pointer buttons.

    :return: window the mouse is in (win), horizontal (x) and vertical
        position (y), keymask
    :rtype: long_pos, int, int, int_pos

    :note: e.g. win, x, y, kmsk = fl_get_mouse()

    :attention: API change from XForms - upstream was
        fl_get_mouse(x, y, keymask)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_mouse = library.cfuncproto(
        library.load_so_libforms(), "fl_get_mouse",\
        xfdata.Window, [cty.POINTER(xfdata.FL_Coord), cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(cty.c_uint)],\
        """Window fl_get_mouse(FL_Coord * x, FL_Coord * y,
          unsigned int * keymask)""")
    library.check_if_initialized()
    x, px = library.make_FL_Coord_and_pointer()
    y, py = library.make_FL_Coord_and_pointer()
    keymask, pkeymask = library.make_uint_and_pointer()
    library.keep_elem_refs(x, y, keymask, px, py, pkeymask)
    retval = _fl_get_mouse(px, py, pkeymask)
    return retval, x.value, y.value, keymask.value


def fl_set_mouse(x, y):
    """Moves the mouse to a specific location relative to the root window.
    Use this function sparingly, it can be extremely annoying for the user if
    the mouse position is changed by a program.

    @param x: horizontal position
    @type x: int
    @param y: vertical position
    @type y: int

    :note: e.g. fl_set_mouse(200, 120)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_mouse = library.cfuncproto(
        library.load_so_libforms(), "fl_set_mouse",\
        None, [xfdata.FL_Coord, xfdata.FL_Coord],\
        """void fl_set_mouse(FL_Coord mx, FL_Coord my)""")
    library.check_if_initialized()
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    library.keep_elem_refs(x, y, ix, iy)
    _fl_set_mouse(ix, iy)


def fl_get_win_mouse(win):
    """Obtains the position of the mouse relative to a certain window, and
    the current state of the modifier keys and pointer buttons.

    @param win: window id
    @type win: long_pos

    :return: window the mouse is in (win), horizontal (x) and vertical
        position (y), keymask
    :rtype: long_pos, int, int, int_pos

    :note: e.g. win, x, y, keym = fl_get_win_mouse()

    :attention: API change from XForms - upstream was
        fl_get_win_mouse(win, x, y, keymask)

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_win_mouse = library.cfuncproto(
        library.load_so_libforms(), "fl_get_win_mouse",\
        xfdata.Window, [xfdata.Window, cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord), cty.POINTER(cty.c_uint)],\
        """Window fl_get_win_mouse(Window win, FL_Coord * x, FL_Coord * y,
        unsigned int * keymask)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    x, px = library.make_FL_Coord_and_pointer()
    y, py = library.make_FL_Coord_and_pointer()
    keymask, pkeymask = library.make_uint_and_pointer()
    library.keep_elem_refs(win, x, y, keymask, ulwin, px, py, pkeymask)
    retval = _fl_get_win_mouse(ulwin, px, py, pkeymask)
    return retval, x.value, y.value, keymask.value


def fl_get_form_mouse(pFlForm):
    """Obtains the position of the mouse relative to a certain form, and
    the current state of the modifier keys and pointer buttons.

    @param pFlForm: form
    @type pFlForm: pointer to xfdata.FL_FORM

    :return: window the mouse is in (win), horizontal (x) and vertical
        position (y), keymask
    :rtype: long_pos, int, int, int_pos

    :note: e.g. win, x, y, keym = fl_get_form_mouse()

    :attention: API change from XForms - upstream was
        fl_get_form_mouse(fm, x, y, keymask)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_form_mouse = library.cfuncproto(
        library.load_so_libforms(), "fl_get_form_mouse",\
        xfdata.Window, [cty.POINTER(xfdata.FL_FORM), cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord), cty.POINTER(cty.c_uint)],\
        """Window fl_get_form_mouse(FL_FORM * fm, FL_Coord * x,
           FL_Coord * y, unsigned int * keymask)""")
    library.check_if_initialized()
    library.check_if_FL_FORM_ptr(pFlForm)
    x, px = library.make_FL_Coord_and_pointer()
    y, py = library.make_FL_Coord_and_pointer()
    keymask, pkeymask = library.make_uint_and_pointer()
    library.keep_elem_refs(pFlForm, x, y, keymask)
    retval = _fl_get_form_mouse(pFlForm, px, py, pkeymask)
    return retval, x.value, y.value, keymask.value


def fl_win_to_form(win):
    """Returns the form the specified window belongs to.

    @param win : window id
    @type win: long_pos

    :return: form (pFlForm) or None (on failure)
    :rtype: pointer to xfdata.FL_FORM

    :note: e.g. pform2 = fl_win_to_form(win1)

    :status: Tested + Doc + NoDemo = OK
    """
    _fl_win_to_form = library.cfuncproto(
        library.load_so_libforms(), "fl_win_to_form",
        cty.POINTER(xfdata.FL_FORM), [xfdata.Window],\
        """FL_FORM * fl_win_to_form(Window win)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    library.keep_elem_refs(win, ulwin)
    retval = _fl_win_to_form(ulwin)
    return retval


def fl_set_form_icon(pFlForm, icon, mask):
    """Sets or changes the icon shown when a form is iconified.

    @param pFlForm: form (pFlForm)
    @type pFlForm: pointer to xfdata.FL_FORM
    @param icon: icon pixmap id
    @type icon: long_pos
    @param mask: mask pixmap id
    @type mask: long_pos

    :note: e.g. ?

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_form_icon = library.cfuncproto(
        library.load_so_libforms(), "fl_set_form_icon",\
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.Pixmap, xfdata.Pixmap],\
        """void fl_set_form_icon(FL_FORM * form, Pixmap p, Pixmap m)""")
    library.check_if_initialized()
    library.check_if_FL_FORM_ptr(pFlForm)
    ulicon = library.convert_to_Pixmap(icon)
    ulmask = library.convert_to_Pixmap(mask)
    library.keep_elem_refs(pFlForm, icon, mask, ulicon, ulmask)
    _fl_set_form_icon(pFlForm, ulicon, ulmask)


def fl_get_decoration_sizes(pFlForm):
    """Returns the sizes of the "decorations" the window manager puts around
    a form's window. Returns 0 on success and 1 if the form isn't visible or
    it's a form embedded into another form.

    @param pFlForm: form
    @type pFlForm: pointer to xfdata.FL_FORM

    :return: num. (0 or 1), top size, right size, bottom size, left size
    :rtype: int, int, int, int

    :note: e.g. dsize = fl_get_decoration_sizes(pform)

    :attention: API change from XForms - upstream was
        fl_get_decoration_sizes(pFlForm, top, right, bottom, left)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_decoration_sizes = library.cfuncproto(
        library.load_so_libforms(), "fl_get_decoration_sizes",
        cty.c_int, [cty.POINTER(xfdata.FL_FORM), cty.POINTER(cty.c_int),\
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int)],\
        """int fl_get_decoration_sizes(FL_FORM * form, int * top,
           int * right, int * bottom, int * left)""")
    library.check_if_initialized()
    library.check_if_FL_FORM_ptr(pFlForm)
    top, ptop = library.make_int_and_pointer()
    right, pright = library.make_int_and_pointer()
    bottom, pbottom = library.make_int_and_pointer()
    left, pleft = library.make_int_and_pointer()
    library.keep_elem_refs(pFlForm, top, right, bottom, left, ptop, pright, pbottom,
                   pleft)
    retval = _fl_get_decoration_sizes(pFlForm, ptop, pright, pbottom, pleft)
    return retval, top.value, right.value, bottom.value, left.value


def fl_raise_form(pFlForm):
    """Raises a form to the top of the screen so no other forms obscure it.

    @param pFlForm: form to be raised
    @type pFlForm: pointer to xfdata.FL_FORM

    :note: e.g. fl_raise_form(pform2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_raise_form = library.cfuncproto(
        library.load_so_libforms(), "fl_raise_form",\
        None, [cty.POINTER(xfdata.FL_FORM)],\
        """void fl_raise_form(FL_FORM * p1)""")
    library.check_if_initialized()
    library.check_if_FL_FORM_ptr(pFlForm)
    library.keep_elem_refs(pFlForm)
    _fl_raise_form(pFlForm)


def fl_lower_form(pFlForm):
    """Lowers a form to the bottom of the stack.

    @param pFlForm: form to be lowered
    @type pFlForm: pointer to xfdata.FL_FORM

    :note: e.g. fl_lower_form(pform2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_lower_form = library.cfuncproto(
        library.load_so_libforms(), "fl_lower_form",\
        None, [cty.POINTER(xfdata.FL_FORM)],\
        """void fl_lower_form(FL_FORM * p1)""")
    library.check_if_initialized()
    library.check_if_FL_FORM_ptr(pFlForm)
    library.keep_elem_refs(pFlForm)
    _fl_lower_form(pFlForm)


def fl_set_foreground(gc, colr):
    """Sets foreground color in Graphics Contexts (GCs) other than the XForms
    library's default.

    @param gc: Graphics context number
    @type gc: ?
    @param colr: color value to be set as foreground
    @type colr: long_pos

    :note: e.g. gc = fl_state[fl_get_vclass()].gc[0] ??
        fl_set_foreground(gc, xfdata.FL_LAWNGREEN)

    :status: Untested + NoDoc + NoDemo = NOT OK (NULL pointer access)

    """
    _fl_set_foreground = library.cfuncproto(
        library.load_so_libforms(), "fl_set_foreground",\
        None, [xfdata.GC, xfdata.FL_COLOR],\
        """void fl_set_foreground(GC gc, FL_COLOR col)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(colr, xfdata.COLOR_list)
    ulcolr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(gc, colr, ulcolr)
    _fl_set_foreground(gc, ulcolr)


def fl_set_background(gc, colr):
    """Sets background color in Graphics contexts (GCs) other than the XForms
    library's default.

    @param gc: Graphics context number
    @type gc: ?
    @param colr: color value to be set as background
    @type colr: long_pos

    :note: e.g. gc = fl_state[fl_get_vclass()].gc[0] ??
        fl_set_foreground(gc, xfdata.FL_HONEYDEW)

    :status: Untested + NoDoc + NoDemo = NOT OK (NULL pointer access)

    """
    _fl_set_background = library.cfuncproto(
        library.load_so_libforms(), "fl_set_background",\
        None, [xfdata.GC, xfdata.FL_COLOR],\
        """void fl_set_background(GC gc, FL_COLOR col)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(colr, xfdata.COLOR_list)
    ulcolr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(gc, colr, ulcolr)
    _fl_set_background(gc, ulcolr)


# General windowing support

def fl_wincreate(title):
    """Creates a window with a specified title.

    @param title: title of the window
    @type title: str

    :return: created window id (win)
    :rtype: long_pos

    :note: e.g. win2 = fl_wincreate("My long title")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_wincreate = library.cfuncproto(
        library.load_so_libforms(), "fl_wincreate",\
        xfdata.Window, [xfdata.STRING],\
        """Window fl_wincreate(const char * label)""")
    library.check_if_initialized()
    stitle = library.convert_to_string(title)
    library.keep_elem_refs(title, stitle)
    retval = _fl_wincreate(stitle)
    return retval


def fl_winshow(win):
    """Shows the window (created with fl_wincreate).

    @param win: window id to show
    @type win: long_pos

    :return: window id shown (win)
    :rtype: long_pos

    :note: e.g. winw = fl_winshow(win2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winshow = library.cfuncproto(
        library.load_so_libforms(), "fl_winshow",\
        xfdata.Window, [xfdata.Window],\
        """Window fl_winshow(Window win)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    library.keep_elem_refs(win, ulwin)
    retval = _fl_winshow(ulwin)
    return retval


def fl_winopen(title):
    """Opens (creates and shows) a toplevel window with the specified title.

    @param title: title of the window
    @type title: str

    :return: created window id (win)
    :rtype: long_pos

    :note: e.g. win2 = fl_winopen("My long title")

    :status: Tested + Doc + Demo = OK

    """
    _fl_winopen = library.cfuncproto(
        library.load_so_libforms(), "fl_winopen", \
        xfdata.Window, [xfdata.STRING], \
        """Window fl_winopen(const char * label)""")
    library.check_if_initialized()
    stitle = library.convert_to_string(title)
    library.keep_elem_refs(title, stitle)
    retval = _fl_winopen(stitle)
    return retval


def fl_winhide(win):
    """Hides a shown window.

    @param win: window id to hide (win)

    :note: e.g. fl_winhide(win2)

    :status: Tested + Doc + Demo = OK

    """
    _fl_winhide = library.cfuncproto(
        library.load_so_libforms(), "fl_winhide", \
        None, [xfdata.Window], \
        """void fl_winhide(Window win)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    library.keep_elem_refs(win, ulwin)
    _fl_winhide(ulwin)


def fl_winclose(win):
    """Closes (hides and destroys) the specified window.

    @param win: window id to close
    @type win: long_pos

    :note: e.g. fl_winclose(win2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winclose = library.cfuncproto(
        library.load_so_libforms(), "fl_winclose", \
        None, [xfdata.Window], \
        """void fl_winclose(Window win)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    library.keep_elem_refs(win, ulwin)
    _fl_winclose(win, ulwin)


def fl_winset(win):
    """Sets the "current window", defined as the window the object that uses
    the drawing routine belongs to.

    @param win: window id to set as current
    @type win: long_pos

    :note: e.g. fl_winset(win3)

    :status: Tested + Doc + Demo = OK

    """
    _fl_winset = library.cfuncproto(
        library.load_so_libforms(), "fl_winset", \
        None, [xfdata.Window], \
        """void fl_winset(Window win)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    library.keep_elem_refs(win, ulwin)
    _fl_winset(ulwin)


def fl_winreparent(win, winnewparent):
    """Makes a toplevel window a subwindow of another (new parent) window;
    both the window and the parent window must be valid ones.

    @param win: window id to be made a subwindow
    @type win: long_pos
    @param winnewparent: window id to become its new parent window
    @type winnewparent: long_pos

    :return: num., or -1 (on failure)
    :rtype: int

    :note: e.g. exitval = fl_winreparent(win1, win3)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winreparent = library.cfuncproto(
        library.load_so_libforms(), "fl_winreparent", \
        cty.c_int, [xfdata.Window, xfdata.Window], \
        """int fl_winreparent(Window win, Window new_parent)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    ulwinnewparent = library.convert_to_Window(winnewparent)
    library.keep_elem_refs(win, winnewparent, ulwin, ulwinnewparent)
    retval = _fl_winreparent(ulwin, ulwinnewparent)
    return retval


def fl_winfocus(win):
    """Keyboard input is directed to the specified window, overriding the
    keyboard focus assignment.

    @param win: window id
    @type win: long_pos

    :note: e.g. fl_winfocus(win3)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winfocus = library.cfuncproto(
        library.load_so_libforms(), "fl_winfocus", \
        None, [xfdata.Window], \
        """void fl_winfocus(Window win)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    library.keep_elem_refs(win, ulwin)
    _fl_winfocus(ulwin)


def fl_winget():
    """Queries the current window. One caveat about fl_winget() is that it
    can return None if called outside of an object's event handler, depending
    on where the mouse is. Thus, the return value of this function should be
    checked when called outside of an object handler.

    :return: window id (win)
    :rtype: long_pos

    :note: e.g. currwin = fl_winget()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winget = library.cfuncproto(
        library.load_so_libforms(), "fl_winget", \
        xfdata.Window, [], \
        """Window fl_winget()""")
    library.check_if_initialized()
    retval = _fl_winget()
    return retval


def fl_iconify(win):
    """Iconifies the specified window.

    @param win: window id
    @type win: long_pos

    :return: num.
    :rtype: int

    :note: e.g. fl_iconify(win2)

    :status: Tested + Doc + NoDemo = OK


    """
    _fl_iconify = library.cfuncproto(
        library.load_so_libforms(), "fl_iconify", \
        cty.c_int, [xfdata.Window], \
        """int fl_iconify(Window win)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    library.keep_elem_refs(win, ulwin)
    retval = _fl_iconify(ulwin)
    return retval


def fl_winresize(win, w, h):
    """Resizes a window.

    @param win: window id to resize
    @type win: long_pos
    @param w: new width in coord units
    @type w: int
    @param h: new height in coord units
    @type h: int

    :note: e.g. fl_winresize(win6, 547, 624)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winresize = library.cfuncproto(
        library.load_so_libforms(), "fl_winresize", \
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord], \
        """void fl_winresize(Window win, FL_Coord neww, FL_Coord newh)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    iw = library.convert_to_int(w)
    ih = library.convert_to_int(h)
    library.keep_elem_refs(win, w, h, ulwin, iw, ih)
    _fl_winresize(ulwin, iw, ih)


def fl_winmove(win, x, y):
    """Moves the specified window to a new position.

    @param win: window id to move to a new position
    @type win: long_pos
    @param x: new horizontal position (upper-left corner)
    @type x: int
    @param y: new vertical position (upper-left corner)
    @type y: int

    :note: e.g. fl_winmove(win5, 116, 331)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winmove = library.cfuncproto(
        library.load_so_libforms(), "fl_winmove", \
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord], \
        """void fl_winmove(Window win, FL_Coord dx, FL_Coord dy)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    ix = library.convert_to_int(x)
    iy = library.convert_to_int(y)
    library.keep_elem_refs(win, x, y, ulwin, ix, iy)
    _fl_winmove(ulwin, ix, iy)


def fl_winreshape(win, x, y, w, h):
    """Reshapes (resizes and moves) a window.

    @param win: window id to reshape
    @type win: long_pos
    @param x: new horizontal position (upper-left corner)
    @type x: int
    @param y: new vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int

    :note: e.g. fl_winreshape(win5, 116, 331, 144, 182)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winreshape = library.cfuncproto(
        library.load_so_libforms(), "fl_winreshape", \
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord], \
        """void fl_winreshape(Window win, FL_Coord dx, FL_Coord dy,
           FL_Coord w, FL_Coord h)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    ix = library.convert_to_int(x)
    iy = library.convert_to_int(y)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    library.keep_elem_refs(win, x, y, w, h, ulwin, ix, iy, iw, ih)
    _fl_winreshape(ulwin, ix, iy, iw, ih)


def fl_winicon(win, icon, mask):
    """Installs an icon for the window.

    @param win: window id
    @type win: long_pos
    @param icon: pixmap icon id to be installed in window
    @type icon: long_pos
    @param mask: pixmap mask id
    @type mask: long_pos

    :note: e.g. fl_winicon(win0, ...) ?

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_winicon = library.cfuncproto(
        library.load_so_libforms(), "fl_winicon", \
        None, [xfdata.Window, xfdata.Pixmap, xfdata.Pixmap], \
        """void fl_winicon(Window win, Pixmap p, Pixmap m)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    ulicon = library.convert_to_Pixmap(icon)
    ulmask = library.convert_to_Pixmap(mask)
    library.keep_elem_refs(win, icon, mask, ulwin, ulicon, ulmask)
    _fl_winicon(ulwin, ulicon, ulmask)


def fl_winbackground(win, bkcolr):
    """Sets the background of window to a certain color.

    @param win: window id
    @type win: long_pos
    @param bkcolr: background color to be set
    @type bkcolr: long_pos

    :note: e.g. fl_winbackground(win1, xfdata.FL_GHOSTWHITE)

    :status: Tested + NoDoc + Demo = OK

    """
    _fl_winbackground = library.cfuncproto(
        library.load_so_libforms(), "fl_winbackground", \
        None, [xfdata.Window, xfdata.FL_COLOR], \
        """void fl_winbackground(Window win, FL_COLOR bk)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(bkcolr, xfdata.COLOR_list)
    ulwin = library.convert_to_Window(win)
    ulbkcolr = library.convert_to_FL_COLOR(bkcolr)
    library.keep_elem_refs(win, bkcolr, ulwin, ulbkcolr)
    _fl_winbackground(ulwin, ulbkcolr)


fl_win_background = fl_winbackground


# STOPPED HERE

def fl_winstepsize(win, xunit, yunit):
    """Sets the steps by which the size of a window can be changed. Changes
    to the window size will be multiples of specified units after this
    call. Note that this only applies to interactive resizing.

    @param xunit: number of pixels of changes per unit in horizontal
        direction
    @type xunit: int
    @param yunit: number of pixels of changes per unit in vertical
        direction
    @type yunit: int

    :note: e.g. fl_winstepsize(win0, 10, 10)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winstepsize = library.cfuncproto(
        library.load_so_libforms(), "fl_winstepsize", \
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord], \
        """void fl_winstepsize(Window win, FL_Coord dx, FL_Coord dy)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    ixunit = library.convert_to_int(xunit)
    iyunit = library.convert_to_int(yunit)
    library.keep_elem_refs(win, xunit, yunit, ulwin, ixunit, iyunit)
    _fl_winstepsize(ulwin, ixunit, iyunit)


fl_winstepunit = fl_winstepsize
fl_set_winstepunit = fl_winstepsize
fl_set_winstepunit = fl_winstepunit


def fl_winisvalid(win):
    """Checks if a window id is valid or not. Note that excessive use of
    this function may negatively impact performance.

    @param win: window to evaluate
    @type win: long_pos

    :return: num.
    :rtype: int

    :note: e.g. if fl_winisvalid(win3): ...

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winisvalid = library.cfuncproto(
        library.load_so_libforms(), "fl_winisvalid", \
        cty.c_int, [xfdata.Window], \
        """int fl_winisvalid(Window win)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    library.keep_elem_refs(win, ulwin)
    retval = _fl_winisvalid(ulwin)
    return retval


def fl_wintitle(win, title):
    """Changes the window title (and its associated icon title).

    @param win: window id
    @type win: long_pos
    @param title: window title to be set
    @type title: str

    :note: e.g. fl_wintitle("My brand new title")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_wintitle = library.cfuncproto(
        library.load_so_libforms(), "fl_wintitle", \
        None, [xfdata.Window, xfdata.STRING], \
        """void fl_wintitle(Window win, const char * title)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    stitle = library.convert_to_string(title)
    library.keep_elem_refs(win, title, ulwin, stitle)
    _fl_wintitle(ulwin, stitle)


def fl_winicontitle(win, title):
    """Changes only the icon title for the window.

    @param win: window id
    @type win: long_pos
    @param title: icon title to be set
    @type title: str

    :note: e.g. fl_winicontitle("My icon label")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winicontitle = library.cfuncproto(
        library.load_so_libforms(), "fl_winicontitle", \
        None, [xfdata.Window, xfdata.STRING], \
        """void fl_winicontitle(Window win, const char * title)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    stitle = library.convert_to_string(title)
    library.keep_elem_refs(win, title, ulwin, stitle)
    _fl_winicontitle(ulwin, stitle)


def fl_winposition(x, y):
    """Sets the position of a window to be opened.

    @param x: horizontal position of window (upper-left corner)
    @type x: int
    @param y: vertical position of window (upper-left corner)
    @type y: int

    :note: e.g. fl_winposition(140, 123)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winposition = library.cfuncproto(
        library.load_so_libforms(), "fl_winposition",
        None, [xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_winposition(FL_Coord x, FL_Coord y)""")
    library.check_if_initialized()
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    library.keep_elem_refs(x, y, ix, iy)
    _fl_winposition(ix, iy)


fl_pref_winposition = fl_winposition


def fl_winminsize(win, w, h):
    """Sets a constraint for a resizable window whose size will be within a
    range not less than minumum (to be used before calling fl_winopen).

    @param win: window id to be set
    @type win: long_pos
    @param w: minimum width of window in coord units
    @type w: int
    @param h: minimum height of window in coord units
    @type h: int

    :note: e.g. fl_winminsize(win1, 500, 500)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winminsize = library.cfuncproto(
        library.load_so_libforms(), "fl_winminsize",
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_winminsize(Window win, FL_Coord w, FL_Coord h)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    library.keep_elem_refs(win, w, h, ulwin, iw, ih)
    _fl_winminsize(ulwin, iw, ih)


def fl_winmaxsize(win, w, h):
    """Sets a constraint for a resizable window whose size will be within a
    range not bigger than maximum (before calling fl_winopen).

    @param win: window id to be set (<long_pos>)
    @type win: long_pos
    @param w: maximum width of window in coord units
    @type w: int
    @param h: maximum height of window in coord units
    @type h: int

    :note: e.g. fl_winmaxsize(win1, 500, 500)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winmaxsize = library.cfuncproto(
        library.load_so_libforms(), "fl_winmaxsize",
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_winmaxsize(Window win, FL_Coord w, FL_Coord h)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    library.keep_elem_refs(win, w, h, ulwin, iw, ih)
    _fl_winmaxsize(ulwin, iw, ih)


def fl_winaspect(win, x, y):
    """Sets the aspect ratio of the window for later interactive resizing.

    @param win: window id to be set
    @type win: long_pos
    @param x: horizontal aspect ratio in coord units
    @type x: int
    @param y: vertical aspect ratio in coord units
    @type y: int

    :note: e.g. fl_winaspect(win0, 2, 4)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winaspect = library.cfuncproto(
        library.load_so_libforms(), "fl_winaspect",
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_winaspect(Window win, FL_Coord x, FL_Coord y)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    library.keep_elem_refs(win, x, y, ulwin, ix, iy)
    _fl_winaspect(ulwin, ix, iy)


def fl_reset_winconstraints(win):
    """Changes constraints (size and aspect ratio) on an active window.

    @param win: window to be reset
    @type win: long_pos

    :note: e.g. fl_reset_constraints(win0)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_reset_winconstraints = library.cfuncproto(
        library.load_so_libforms(), "fl_reset_winconstraints",
        None, [xfdata.Window],
        """void fl_reset_winconstraints(Window win)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    library.keep_elem_refs(win)
    _fl_reset_winconstraints(ulwin)


def fl_winsize(w, h):
    """Sets the preferred window size (before calling fl_winopen), and
    makes the window non-resizeable.

    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int

    :note: e.g. fl_winsize(700, 600)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winsize = library.cfuncproto(
        library.load_so_libforms(), "fl_winsize",
        None, [xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_winsize(FL_Coord w, FL_Coord h)""")
    library.check_if_initialized()
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    library.keep_elem_refs(w, h, iw, ih)
    _fl_winsize(iw, ih)


fl_pref_winsize = fl_winsize


def fl_initial_winsize(w, h):
    """Sets the preferred window size (before calling fl_winopen).

    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int

    :note: e.g. fl_initial_winsize(700, 600)

    :status: Tested + Doc + Demo = OK

    """
    _fl_initial_winsize = library.cfuncproto(
        library.load_so_libforms(), "fl_initial_winsize",
        None, [xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_initial_winsize(FL_Coord w, FL_Coord h)""")
    library.check_if_initialized()
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    library.keep_elem_refs(w, h, iw, ih)
    _fl_initial_winsize(iw, ih)


# TODO: verify if it's supposed to be used in python
def fl_initial_winstate(state):
    """Sets initial state, normal or iconic, of the window.

    @param state: window state to be set. Values (from xfdata module)
        NormalState, IconicState
    @type state: int

    :note: e.g. fl_initial_winstate(xfdata.IconicState)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_initial_winstate = library.cfuncproto(
        library.load_so_libforms(), "fl_initial_winstate",
        None, [cty.c_int],
        """void fl_initial_winstate(int state)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(state, xfdata.WINSTATE_list)
    istate = library.convert_to_int(state)
    library.keep_elem_refs(state, istate)
    _fl_initial_winstate(istate)


def fl_create_colormap(pXVisualInfo, nfill):
    """Creates a colormap appropriate for a given visual to be used with
    a canvas.

    @param pXVisualInfo: XVisualInfo class instance
    @type  pXVisualInfo: pointer to xfdata.XVisualInfo
    @param nfill: how many colors in the newly created colormap should
        be filled with XForms' default colors (to avoid flashing effects)
    @type nfill: int

    :return: created colormap
    :rtype: long_pos

    :note: e.g. ??

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _fl_create_colormap = library.cfuncproto(
        library.load_so_libforms(), "fl_create_colormap",
        xfdata.Colormap, [cty.POINTER(xfdata.XVisualInfo), cty.c_int],
        """Colormap fl_create_colormap(XVisualInfo * xv, int nfill)""")
    library.check_if_initialized()
    infill = library.convert_to_int(nfill)
    library.keep_elem_refs(pXVisualInfo, nfill, infill)
    retval = _fl_create_colormap(pXVisualInfo, infill)
    return retval


def fl_wingeometry(x, y, w, h):
    """Sets the initial geometry (position and size) of the window to be
    opened; the window will not be resizable.

    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int

    :note: e.g. fl_wingeometry(192, 231, 450, 550)

    :status: Tested + Doc + Demo = OK

    """
    _fl_wingeometry = library.cfuncproto(
        library.load_so_libforms(), "fl_wingeometry",
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord],
        """void fl_wingeometry(FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h)""")
    library.check_if_initialized()
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    library.keep_elem_refs(x, y, w, h, ix, iy, iw, ih)
    _fl_wingeometry(ix, iy, iw, ih)


fl_pref_wingeometry = fl_wingeometry


def fl_initial_wingeometry(x, y, w, h):
    """Sets the initial geometry (position and size) of the window to be
    opened.

    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int

    :note: e.g. fl_initial_wingeometry(192, 231, 450, 550)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_initial_wingeometry = library.cfuncproto(
        library.load_so_libforms(), "fl_initial_wingeometry",
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord],
        """void fl_initial_wingeometry(FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h)""")
    library.check_if_initialized()
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    library.keep_elem_refs(x, y, w, h, ix, iy, iw, ih)
    _fl_initial_wingeometry(ix, iy, iw, ih)


def fl_noborder():
    """Suppresses the window manager's decoration (before creating the
    window).

    :note: e.g. fl_noborder()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_noborder = library.cfuncproto(
        library.load_so_libforms(), "fl_noborder",
        None, [],
        """void fl_noborder()""")
    library.check_if_initialized()
    _fl_noborder()


def fl_transient():
    """Makes a window a transient one (before creating the window).

    :note: e.g. fl_transient()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_transient = library.cfuncproto(
        library.load_so_libforms(), "fl_transient",
        None, [], \
        """void fl_transient()""")
    library.check_if_initialized()
    _fl_transient()


def fl_get_winsize(win):
    """Returns the size of the specified window.

    @param win: window id to evaluate
    @type win: long_pos

    :return: width (w) and height (h) of window
    :rtype: int, int

    :note: e.g. wid, hei = fl_get_winsize(win0)

    :attention: API change from XForms - upstream was
        fl_get_winsize(win, w, h)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_winsize = library.cfuncproto(
        library.load_so_libforms(), "fl_get_winsize",
        None, [xfdata.Window, cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord)],
        """void fl_get_winsize(Window win, FL_Coord * w, FL_Coord * h)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    w, pw = library.make_int_and_pointer()
    h, ph = library.make_int_and_pointer()
    library.keep_elem_refs(win, ulwin, w, h, pw, ph)
    _fl_get_winsize(ulwin, pw, ph)
    return w.value, h.value


def fl_get_winorigin(win):
    """Returns the origin (position) of the specified window.

    @param win: window id to evaluate
    @type win: long_pos

    :return: horizontal (x) and vertical position (y) of window
    :rtype: int, int

    :note: e.g. xpos, ypos = fl_get_winorigin(win0)

    :attention: API change from XForms - upstream was
        fl_get_winorigin(win, x, y)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_winorigin = library.cfuncproto(
        library.load_so_libforms(), "fl_get_winorigin",
        None, [xfdata.Window, cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord)],
        """void fl_get_winorigin(Window win, FL_Coord * x, FL_Coord * y)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    x, px = library.make_FL_Coord_and_pointer()
    y, py = library.make_FL_Coord_and_pointer()
    library.keep_elem_refs(win, ulwin, x, y, px, py)
    _fl_get_winorigin(win, px, py)
    return x.value, y.value


def fl_get_wingeometry(win):
    """Returns geometry (position and size) of a window.

    @param win: window id to evaluate
    @type win: long_pos

    :return: horizontal (x) and vertical position (y), width (w) and
        height (h) of window
    :rtype: int, int, int, int

    :note: e.g. xpos, ypos, wid, hei = fl_get_wingeometry(win0)

    :attention: API change from XForms - upstream was
        fl_get_wingeometry(win, x, y, w, h)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_wingeometry = library.cfuncproto(
        library.load_so_libforms(), "fl_get_wingeometry",
        None, [xfdata.Window, cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord), cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord)],
        """void fl_get_wingeometry(Window win, FL_Coord * x,
           FL_Coord * y, FL_Coord * w, FL_Coord * h)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    x, px = library.make_FL_Coord_and_pointer()
    y, py = library.make_FL_Coord_and_pointer()
    w, pw = library.make_FL_Coord_and_pointer()
    h, ph = library.make_FL_Coord_and_pointer()
    library.keep_elem_refs(win, x, y, w, h, ulwin, px, py, pw, ph)
    _fl_get_wingeometry(ulwin, px, py, pw, ph)
    return x.value, y.value, w.value, h.value


# fl_get_win_size placeholder (backwards)
# fl_get_win_origin (backwards)
# fl_get_win_geometry (backwards)
# fl_initial_winposition (backwards)


def fl_get_display():
    library.check_if_initialized()
    return fl_display


def FL_FormDisplay(pFlForm):
    library.check_if_initialized()
    library.check_if_FL_FORM_ptr(pFlForm)
    return fl_display


# undocumented data maybe dismissed --LK
def FL_ObjectDisplay(pFlObject):
    library.check_if_initialized()
    library.check_if_FL_OBJECT_ptr(pFlObject)
    return fl_display


def FL_IS_CANVAS(pFlObject):
    if (flbasic.fl_get_object_objclass(pFlObject) == xfdata.FL_CANVAS) or \
        (flbasic.fl_get_object_objclass(pFlObject) == xfdata.FL_GLCANVAS):
        return True
    else:
        return False


# The window an object belongs to - for drawing
def FL_ObjWin(pFlObject):
    """Obtains the window id an object belongs to (for general use).

    @param pFlObject: object
    @type pFlObject: pointer to xfdata.FL_OBJECT

    :return: window id (win)
    :rtype: long_pos

    :note: e.g. wind = FL_ObjWin(pobj)

    :status: Tested + Doc + Demo = OK

    """
    library.check_if_initialized()
    library.check_if_FL_OBJECT_ptr(pFlObject)
    if FL_IS_CANVAS(pFlObject):
        return flcanvas.fl_get_canvas_id(pFlObject)
    else:
        return pFlObject.contents.form.contents.window


def fl_get_real_object_window(pFlObject):
    """ Obtains the real window id an object belongs to (to be used for
    cursor or pointer routines).

    @param pFlObject: object
    @type pFlObject: pointer to xfdata.FL_OBJECT

    :return: window id (win)
    :rtype: long_pos

    :note: e.g. wind = fl_get_real_object_window(pobj)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_real_object_window = library.cfuncproto(
        library.load_so_libforms(), "fl_get_real_object_window",
        xfdata.Window, [cty.POINTER(xfdata.FL_OBJECT)],
        """Window fl_get_real_object_window(FL_OBJECT * ob)""")
    library.check_if_initialized()
    library.check_if_FL_OBJECT_ptr(pFlObject)
    library.keep_elem_refs(pFlObject)
    retval = _fl_get_real_object_window(pFlObject)
    return retval


FL_OBJECT_WID = FL_ObjWin


# Replacements for X functions that access the event queue

def fl_XNextEvent(pXEvent):
    """

    @param pXEvent: XEvent class instance
    @type pXEvent: pointer to XEvent

    :return: event num.
    :rtype: int

    :note: e.g. ??

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_XNextEvent = library.cfuncproto(
        library.load_so_libforms(), "fl_XNextEvent",
        cty.c_int, [cty.POINTER(xfdata.XEvent)],
        """int fl_XNextEvent(XEvent * xev)""")
    library.check_if_initialized()
    library.keep_elem_refs(pXEvent)
    retval = _fl_XNextEvent(pXEvent)
    return retval


def fl_XPeekEvent(pXEvent):
    """

    @param pXEvent: XEvent class instance
    @type pXEvent: pointer to XEvent

    :return: event num.
    :rtype: int

    :note: e.g. ??

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_XPeekEvent = library.cfuncproto(
        library.load_so_libforms(), "fl_XPeekEvent",
        cty.c_int, [cty.POINTER(xfdata.XEvent)],
        """int fl_XPeekEvent(XEvent * xev)""")
    library.check_if_initialized()
    library.keep_elem_refs(pXEvent)
    retval = _fl_XPeekEvent(pXEvent)
    return retval


def fl_XEventsQueued(mode):
    """

    @param mode: mode
    @type mode: int

    :return: event num.
    :rtype: int

    :note: e.g. ??

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_XEventsQueued = library.cfuncproto(
        library.load_so_libforms(), "fl_XEventsQueued",
        cty.c_int, [cty.c_int],
        """int fl_XEventsQueued(int mode)""")
    library.check_if_initialized()
    imode = library.convert_to_int(mode)
    library.keep_elem_refs(mode, imode)
    retval = _fl_XEventsQueued(imode)
    return retval


def fl_XPutBackEvent(pXEvent):
    """ fl_XPutBackEvent(pXEvent)

    @param pXEvent: XEvent class instance
    @type pXEvent: pointer to XEvent

    :note: e.g. ??

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_XPutBackEvent = library.cfuncproto(
        library.load_so_libforms(), "fl_XPutBackEvent",
        None, [cty.POINTER(xfdata.XEvent)],
        """void fl_XPutBackEvent(XEvent * xev)""")
    library.check_if_initialized()
    library.keep_elem_refs(pXEvent)
    _fl_XPutBackEvent(pXEvent)


def fl_last_event():
    """

    :return: XEvent class instance (pXEvent)
    :rtype: pointer to xfdata.XEvent

    :note: e.g. ??

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_last_event = library.cfuncproto(
        library.load_so_libforms(), "fl_last_event",
        cty.POINTER(xfdata.XEvent), [],
        """const char * fl_last_event()""")
    library.check_if_initialized()
    retval = _fl_last_event()
    return retval


def fl_set_event_callback(py_AppEventCb, vdata):
    """Setups an event callback routine. Whenever an event happens, the
    callback function is invoked with the event as the first argument.
    This assumes the application program solicits the events and further,
    the callback routine should be prepared to handle all XEvent for all
    non-form windows. The callback function normally should return 0
    unless the event isn't for one of the applcation-managed windows.
    This routine will be called whenever an XEvent is pending for the
    application's own window.

    @param py_AppEventCb: python function callback, returning value
    @type py_AppEventCb: __ funcname (pXEvent, ptr_void) -> num. __
    @param vdata: user data to be passed to function
    @type vdata: pointer to void

    :return: old event callback
    :rtype: pointer to xfdata.FL_APPEVENT_CB

    :note: e.g. def eventcb(pxev, vdata):
    :note: e.g. |->| ...
    :note: e.g. |->| return 0
    :note: e.g. fl_set_event_callback(eventcb, None)

    :status: Tested + Doc + Demo = OK

    """
    #FL_APPEVENT_CB = cty.CFUNCTYPE(cty.c_int, cty.POINTER(XEvent),
    #                               cty.c_void_p)
    _fl_set_event_callback = library.cfuncproto(
        library.load_so_libforms(), "fl_set_event_callback",
        xfdata.FL_APPEVENT_CB, [xfdata.FL_APPEVENT_CB, cty.c_void_p],
        """FL_APPEVENT_CB fl_set_event_callback(FL_APPEVENT_CB callback,
           void * user_data)""")
    library.check_if_initialized()
    c_AppEventCb = xfdata.FL_APPEVENT_CB(py_AppEventCb)
    pvdata = cty.cast(vdata, cty.c_void_p)
    library.keep_cfunc_refs(c_AppEventCb, py_AppEventCb)
    library.keep_elem_refs(vdata, pvdata)
    retval = _fl_set_event_callback(c_AppEventCb, pvdata)
    return retval


def fl_set_idle_callback(py_AppEventCb, vdata):
    """Registers an idle callback. Interaction with it  can used for periodic
    tasks, e.g. rotating an image, checking the status of some external
    device or application state etc. An idle callback is an application
    function that is registered with the system and is called whenever there
    are no events pending for forms (or application windows). If called with
    a function as callback who does nothing, it removes idle callback.
    The time interval between invocations of the idle callback can vary
    considerably depending on interface activity and other factors. A
    range between 50 and 300 msec should be expected.

    @param py_AppEventCb: python function callback, returning unused value
    @type py_AppEventCb: __ funcname (pXEvent, ptr_void) -> num __
    @param vdata: user data to be passed to function
    @type vdata: None or long or pointer to xfdata.FL_OBJECT

    :return: old event callback function
    :rtype: pointer to xfdata.FL_APPEVENT_CB

    :note: e.g. def idlecb(xev, userdata):
    :note: e.g. |->| ...
    :note: e.g. |->| return 0
    :note: e.g. appevtcb = fl_set_idle_callback(idlecb, None)
    :note: e.g. def donothing_idlecb(xev, userdata):
    :note: e.g. |->| pass
    :note: e.g. removedcb = fl_set_idle_callback(donothing_idlecb, None)

    :status: Tested + Doc + NoDemo = OK
    """
    #FL_APPEVENT_CB = cty.CFUNCTYPE(cty.c_int, cty.POINTER(XEvent),
    #                               cty.c_void_p)
    _fl_set_idle_callback = library.cfuncproto(
        library.load_so_libforms(), "fl_set_idle_callback",
        xfdata.FL_APPEVENT_CB, [xfdata.FL_APPEVENT_CB, cty.c_void_p],
        """FL_APPEVENT_CB fl_set_idle_callback(FL_APPEVENT_CB callback,
           void * user_data)""")
    library.check_if_initialized()
    c_AppEventCb = xfdata.FL_APPEVENT_CB(py_AppEventCb)
    if vdata is None:
        pvdata = cty.cast(vdata, cty.c_void_p)
    elif isinstance(vdata, long):
        ldata = library.convert_to_long(vdata)
        pvdata = cty.cast(ldata, cty.POINTER(cty.c_long))
    else:
        pvdata = vdata          # it is pFlObject
    library.keep_cfunc_refs(c_AppEventCb, py_AppEventCb)
    library.keep_elem_refs(vdata, pvdata)
    retval = _fl_set_idle_callback(c_AppEventCb, pvdata)
    return retval


def fl_addto_selected_xevent(win, mask):
    """Adds solicited event masks on the fly without altering other masks
    already selected.

    @param win: window id
    @type win: long_pos
    @param mask : event mask
    @type mask: long

    :return: num.
    :rtype: long_pos

    :note: e.g. lnum = fl_addto_selected_xevent(win7, xfdata.ButtonMotionMask)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_addto_selected_xevent = library.cfuncproto(
        library.load_so_libforms(), "fl_addto_selected_xevent",
        cty.c_long, [xfdata.Window, cty.c_long],
        """long int fl_addto_selected_xevent(Window win, long int mask)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    lmask = library.convert_to_long(mask)
    library.keep_elem_refs(win, mask, ulwin, lmask)
    retval = _fl_addto_selected_xevent(ulwin, lmask)
    return retval


def fl_remove_selected_xevent(win, mask):
    """ Removes solicited event masks on the fly without altering other masks
    already selected.

    @param win: window id
    @type win: long_pos
    @param mask : event mask
    @type mask: long

    :return: num.
    :rtype: long_pos

    :note: e.g. lnum = fl_remove_selected_xevent(win7, xfdata.ButtonMotionMask)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_remove_selected_xevent = library.cfuncproto(
        library.load_so_libforms(), "fl_remove_selected_xevent",
        cty.c_long, [xfdata.Window, cty.c_long],
        """long int fl_remove_selected_xevent(Window win, long int mask)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    lmask = library.convert_to_long(mask)
    library.keep_elem_refs(win, mask, ulwin, lmask)
    retval = _fl_remove_selected_xevent(ulwin, lmask)
    return retval


fl_add_selected_xevent = fl_addto_selected_xevent


def fl_set_idle_delta(msec):
    """ Changes what the library considers to be "idle". Be aware that under
    some conditions ad idle callback can be called sooner than the minimum
    interval; if the timing of the idle callback is of concerned, timeouts
    should be used.

    @param msec: minimum time interval of inactivity, after which the main
        loop is considered to be in idle state
    @type msec: long

    :note: e.g. fl_set_idle_delta(800)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_idle_delta = library.cfuncproto(
        library.load_so_libforms(), "fl_set_idle_delta",
        None, [cty.c_long],
        """void fl_set_idle_delta(long int delta)""")
    library.check_if_initialized()
    lmsec = library.convert_to_long(msec)
    library.keep_elem_refs(msec, lmsec)
    _fl_set_idle_delta(lmsec)


def fl_add_event_callback(win, evttype, py_AppEventCb, vdata):
    """Adds an event handler for a window. Manipulates the event callback
    functions for the window specified, which will be called when an
    event of specified type is pending for the window. It does not
    solicit any event for the caller, i.e. the XForms library assumes
    the caller opens the window and solicits all events before calling
    these routines.

    @param win: window id to add event handler to
    @type win: long_pos
    @param evttype: event type number. 0 signifies that a callback for
        all event for window
    @type evttype: int
    @param py_AppEventCb: python function callback, returning value
    @type py_AppEventCb: __ funcname (pXEvent, ptr_void) -> num. __
    @param vdata: user data to be passed to function
    @type vdata: None or long or pointer to xfdata.FL_OBJECT

    :return: event callback
    :rtype: pointer to xfdata.FL_APPEVENT_CB

    :note: e.g. def eventcb(pxev, vdata):
    :note: e.g. |->|  ...
    :note: e.g. |->| return 0
    :note: e.g. fl_add_event_callback(win2, 0, eventcb, None)

    :status: Tested + Doc + NoDemo = OK

    """
    #FL_APPEVENT_CB = cty.CFUNCTYPE(cty.c_int, cty.POINTER(XEvent),
    #                               cty.c_void_p)
    _fl_add_event_callback = library.cfuncproto(
        library.load_so_libforms(), "fl_add_event_callback",
        xfdata.FL_APPEVENT_CB, [xfdata.Window, cty.c_int,
        xfdata.FL_APPEVENT_CB, cty.c_void_p],
        """FL_APPEVENT_CB fl_add_event_callback(Window win, int ev,
           FL_APPEVENT_CB wincb, void * user_data)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    ievttype = library.convert_to_int(evttype)
    c_AppEventCb = xfdata.FL_APPEVENT_CB(py_AppEventCb)
    if vdata is None:
        pvdata = cty.cast(vdata, cty.c_void_p)
    elif isinstance(vdata, long):
        ldata = library.convert_to_long(vdata)
        pvdata = cty.cast(ldata, cty.POINTER(cty.c_long))
    else:
        pvdata = vdata          # it is pFlObject
    library.keep_cfunc_refs(c_AppEventCb, py_AppEventCb)
    library.keep_elem_refs(win, evttype, vdata, ulwin, ievttype, pvdata)
    retval = _fl_add_event_callback(ulwin, ievttype, c_AppEventCb, pvdata)
    return retval


def fl_remove_event_callback(win, evttype):
    """ Removes one or all event callbacks for a window and for an event of
    specified type. May be called with for a window for which no event
    callbacks have been set.

    @param win: window id
    @type win: long_pos
    @param evttype: event type number
    @type evttype: int

    :note: e.g. fl_remove_event_callback(win2, 0)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_remove_event_callback = library.cfuncproto(
        library.load_so_libforms(), "fl_remove_event_callback",
        None, [xfdata.Window, cty.c_int],
        """void fl_remove_event_callback(Window win, int ev)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    ievttype = library.convert_to_int(evttype)
    library.keep_elem_refs(win, evttype, ulwin, ievttype)
    _fl_remove_event_callback(ulwin, ievttype)


def fl_activate_event_callbacks(win):
    """Handles event solicitation. Activates the default mapping of events
    to event masks built-in in the XForms Library, and causes the system
    to solicit the events for you. Note however, the mapping of events
    to masks are not unique and depending on applications, the default
    mapping may or may not be the one you want.

    @param win: window whose events are referred to
    @type win: long_pos

    :note: e.g. fl_activate_event_callback(win3)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_activate_event_callbacks = library.cfuncproto(
        library.load_so_libforms(), "fl_activate_event_callbacks",
        None, [xfdata.Window],
        """void fl_activate_event_callbacks(Window win)""")
    library.check_if_initialized()
    ulwin = library.convert_to_Window(win)
    library.keep_elem_refs(win, ulwin)
    _fl_activate_event_callbacks(ulwin)


def fl_print_xevent_name(where, pXEvent):
    """Print the name of an XEvent and some other infos.

    @param where: can indicate where this function is called
    @type where: str
    @param pXEvent: event
    @type pXEvent: pointer to xfdata.XEvent

    :return: event (pXEvent)
    :rtype: pointer to xfdata.XEvent

    :note: e.g. pxev = fl_print_xevent_name("from whatever.py", pxev)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_print_xevent_name = library.cfuncproto(
        library.load_so_libforms(), "fl_print_xevent_name",
        cty.POINTER(xfdata.XEvent), [xfdata.STRING,
        cty.POINTER(xfdata.XEvent)],
        """XEvent * fl_print_xevent_name(const char * where,
           const Xevent * xev)""")
    library.check_if_initialized()
    swhere = library.convert_to_string(where)
    library.keep_elem_refs(where, pXEvent, swhere)
    retval = _fl_print_xevent_name(swhere, pXEvent)
    return retval


def fl_XFlush():
    """Flushes the output buffer. Convenience replacement for X11 XFlush()

    :note: e.g. fl_XFlush()

    :status: Tested + Doc + Demo = OK

    """
    _fl_XFlush = library.cfuncproto(
        library.load_so_libforms(), "fl_XFlush",
        None, [],
        """void fl_XFlush(void)""")
    _fl_XFlush()


def metakey_down(mask):
    return (mask & xfdata.Mod1Mask)


def shiftkey_down(mask):
    return (mask & xfdata.ShiftMask)


def controlkey_down(mask):
    return (mask & xfdata.ControlMask)


def button_down(mask):
    if (mask & xfdata.Button1Mask) or (mask & xfdata.Button2Mask) or \
     (mask & xfdata.Button3Mask) or (mask & xfdata.Button4Mask) or \
     (mask & xfdata.Button5Mask):
        return True
    else:
        return False


# Resources

def fl_initialize(numargs, argslist, appname, appoptions, nappopts):
    """Initializes XForms library. It should always be called before any
    other calls to the XForms Library (except fl_set_defaults() and a few
    other functions that alter some of the defaults of the library.
    Command line arguments are NOT supported here, but you can always set
    most of parameters with relative functions.

    @param numargs: number of arguments passed to command line, unused
                        in python
    @type numargs: int
    @param argslist: arguments passed to command line, unused in python
    @type argslist: list of str
    @param appname: application class name
    @type appname: str
    @param appoptions: options passed
    @type appoptions: instance of xfdata.FL_CMD_OPT
    @param nappopts: number of options
    @type nappopts: int

    :return: display (pDisplay) or None (on failure, if a connection
        couldn't be made)
    :rtype: pointer to xfdata.Display

    :note: e.g. from xformslib import sys
    :note: e.g. fl_initialize(len(sys.argv), sys.argv, "MyFormDemo", 0, 0)

    :status: HalfTested + Doc + Demo = HALF OK (not for command line args)

    """
    _fl_initialize = library.cfuncproto(
        library.load_so_libforms(), "fl_initialize",
        cty.POINTER(xfdata.Display), [cty.POINTER(cty.c_int),
        cty.POINTER(xfdata.STRING), xfdata.STRING,
        cty.POINTER(xfdata.FL_CMD_OPT), cty.c_int],
        """Display * fl_initialize(int * na, char * * arg,
            const char * appclass, FL_CMD_OPT * appopt, int nappopt)""")
    # verify if installed XForms is compatible with this one
    library.verify_version_compatibility()
    library.set_initialized()
    numargs = 1
    inumargs = library.convert_to_int(numargs)
    argslist = " "          # discard any script arguments
    sargslist = library.convert_to_string(argslist)
    sappname = library.convert_to_string(appname)
    pappoptions = cty.cast(appoptions, cty.POINTER(xfdata.FL_CMD_OPT))
    inappopts = library.convert_to_int(nappopts)
    library.keep_elem_refs(numargs, inumargs, argslist, sargslist, appname,
                   sappname, appoptions, pappoptions, nappopts, inappopts)
    retval = _fl_initialize(inumargs, sargslist, sappname, pappoptions,
                            inappopts)
    return retval


def fl_finish():
    """It is a final cleanup routine, restores all X server defaults, shuts
    down the connection and frees dynamically allocated memory.

    :note: e.g. fl_finish()

    :status: Tested + Doc + Demo = OK

    """
    _fl_finish = library.cfuncproto(
        library.load_so_libforms(), "fl_finish",
        None, [],
        """void fl_finish()""")
    library.check_if_initialized()
    _fl_finish()


def fl_get_resource(rname, cname, dtype, defval, val, size):
    """

    @param rname: complete resource name specification (minus the
        application name) and should not contain wildcards of any kind
    @type rname: str
    @param cname: complete resource class specification (minus the
        application name) and should not contain wildcards of any kind
    @type cname: str
    @param dtype: type of resource. Values (from xfdata module) FL_NONE,
        FL_SHORT, FL_BOOL, FL_INT, FL_LONG, FL_FLOAT, FL_STRING
    @type dtype: int
    @param defval: default value
    @type defval: str
    @param val: ??
    @type val: pointer to void
    @param size: number of bytes, used only if dtype is FL_STRING
    @type size: int

    :return: text representation of the resource value
    :rtype: str

    :note: e.g. ??

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_get_resource = library.cfuncproto(
        library.load_so_libforms(), "fl_get_resource",
        xfdata.STRING, [xfdata.STRING, xfdata.STRING,
        xfdata.FL_RTYPE, xfdata.STRING, cty.c_void_p, cty.c_int],
        """const char * fl_get_resource(const char * rname,
           const char * cname, FL_RTYPE dtype, const char * defval,
           void * val, int size)""")
    library.check_admitted_listvalues(dtype, xfdata.RTYPE_list)
    srname = library.convert_to_string(rname)
    scname = library.convert_to_string(cname)
    idtype = library.convert_to_int(dtype)
    sdefval = library.convert_to_string(defval)
    pval = cty.cast(val, cty.c_void_p)
    isize = library.convert_to_int(size)
    library.keep_elem_refs(rname, cname, dtype, defval, val, size, srname, scname,
                   idtype, sdefval, pval, isize)
    retval = _fl_get_resource(srname, scname, idtype, sdefval, pval, isize)
    return retval


def fl_set_resource(resstr, txtval):
    """Changes some of the built-in button labels with proper resource names.

    @param resstr: resource name
    @type resstr: str
    @param txtval: new string value for resource
    @type txtval: str

    :note: e.g. ??

    :status: Tested + NoDoc + Demo = OK

    """
    _fl_set_resource = library.cfuncproto(
        library.load_so_libforms(), "fl_set_resource",
        None, [xfdata.STRING, xfdata.STRING],
        """void fl_set_resource(const char * str, const char * val)""")
    sresstr = library.convert_to_string(resstr)
    stxtval = library.convert_to_string(txtval)
    library.keep_elem_refs(resstr, txtval, sresstr, stxtval)
    _fl_set_resource(sresstr, stxtval)


def fl_get_app_resources(pResource, n):
    """ fl_get_app_resources(pResource, n)

    @param pResource: resource
    @type pResource: pointer to xfdata.FL_RESOURCE

    :note: e.g. ??

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_get_app_resources = library.cfuncproto(
        library.load_so_libforms(), "fl_get_app_resources",
        None, [cty.POINTER(xfdata.FL_RESOURCE), cty.c_int],
        """void fl_get_app_resources(FL_RESOURCE * appresource, int n)""")
    inum = library.convert_to_int(n)
    library.keep_elem_refs(pResource, n, inum)
    _fl_get_app_resources(pResource, inum)


def fl_set_graphics_mode(mode, doublebuf):
    """ fl_set_graphics_mode(mode, doublebuf)

    @param mode: graphics mode to be set
    @type mode: int
    @param doublebuf: ?
    @type doublebuf: int

    :note: e.g. ??

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_graphics_mode = library.cfuncproto(
        library.load_so_libforms(), "fl_set_graphics_mode",
        None, [cty.c_int, cty.c_int],
        """void fl_set_graphics_mode(int mode, int doublebuf)""")
    library.check_if_initialized()
    imode = library.convert_to_int(mode)
    idoublebuf = library.convert_to_int(doublebuf)
    library.keep_elem_refs(mode, doublebuf, imode, idoublebuf)
    _fl_set_graphics_mode(imode, idoublebuf)


def fl_set_visualID(idnum):
    """ fl_set_visualID(idnum)

    @param idnum: ?
    @type idnum: int

    :note: e.g. ?

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_visualID = library.cfuncproto(
        library.load_so_libforms(), "fl_set_visualID",
        None, [cty.c_long],
        """void fl_set_visualID(long int id)""")
    lidnum = library.convert_to_long(idnum)
    library.keep_elem_refs(idnum, lidnum)
    _fl_set_visualID(lidnum)


def fl_keysym_pressed(keysym):
    """ fl_keysym_pressed(keysym) -> num.

        :status: Untested + NoDoc + NoDemo = NOT OK
    """
    _fl_keysym_pressed = library.cfuncproto(
        library.load_so_libforms(), "fl_keysym_pressed",
        cty.c_int, [xfdata.KeySym],
        """int fl_keysym_pressed(KeySym k)""")
    library.check_if_initialized()
    ulkeysym = library.convert_to_ulong(keysym)
    library.keep_elem_refs(keysym, ulkeysym)
    retval = _fl_keysym_pressed(ulkeysym)
    return retval


fl_keypressed = fl_keysym_pressed


# Program default masks

def fl_set_defaults(mask, pIopt):
    """ fl_set_defaults(mask, pIopt)

    @param mask: ?
    @type mask: long_pos
    @param pIopt: program defaults class instance
    @type pIopt: pointer to xfdata.FL_IOPT

    :note: e.g. ??

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_defaults = library.cfuncproto(
        library.load_so_libforms(), "fl_set_defaults",
        None, [cty.c_ulong, cty.POINTER(xfdata.FL_IOPT)],
        """void fl_set_defaults(long unsigned int mask, FL_IOPT * cntl):""")
    ulmask = library.convert_to_ulong(mask)
    library.keep_elem_refs(mask, pIopt, ulmask)
    _fl_set_defaults(ulmask, pIopt)


def fl_set_tabstop(tabtext):
    """Adjusts the distance by setting the tab stops. For proportional font,
    substituting tabs with spaces is not always appropriate because this
    most likely will fail to align text properly. Instead, a tab is
    treated as an absolute measure of distance, in pixels, and a tab
    stop will always end at multiples of this distance. The default is
    "aaaaaaaa", i.e. eight 'a's.

    @param tabtext: text string whose width in pixel is to be used as the
        tab length. The font used to calculate the width is the same font
        that is used to render the string in which the tab is embedded
    @type tabtext: str

    :note: e.g. fl_set_tabstop("aaaa")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_tabstop = library.cfuncproto(
        library.load_so_libforms(), "fl_set_tabstop",
        None, [xfdata.STRING],
        """void fl_set_tabstop(const char * s)""")
    library.check_if_initialized()
    stabtext = library.convert_to_string(tabtext)
    library.keep_elem_refs(tabtext, stabtext)
    _fl_set_tabstop(stabtext)


def fl_get_defaults():
    """Return program defaults from the resource database.

    :return: program defaults class instance
    :rtype: instance of xfdata.FL_IOPT

    :note: e.g. defprgres = fl_get_defaults()

    :attention: API change from XForms - upstream was fl_get_defaults(pIopt)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_defaults = library.cfuncproto(
        library.load_so_libforms(), "fl_get_defaults",
        None, [cty.POINTER(xfdata.FL_IOPT)],
        """void fl_get_defaults(FL_IOPT * cntl)""")
    Iopt = xfdata.FL_IOPT()
    pIopt = cty.byref(Iopt)
    library.keep_elem_refs(pIopt, Iopt)
    _fl_get_defaults(pIopt)
    return Iopt


def fl_get_visual_depth():
    """Returns the visual depth.

    :return: visual depth for current mode
    :rtype: int

    :note: e.g. curdepth = fl_get_visual_depth()

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_visual_depth = library.cfuncproto(
        library.load_so_libforms(), "fl_get_visual_depth",
        cty.c_int, [],
        """int fl_get_visual_depth()""")
    library.check_if_initialized()
    retval = _fl_get_visual_depth()
    return retval


def fl_vclass_name(n):
    """

    @param n: ?
    @type n: int

    :return: vclass name
    :rtype: str

    :note: e.g. ??

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_vclass_name = library.cfuncproto(
        library.load_so_libforms(), "fl_vclass_name",
        xfdata.STRING, [cty.c_int],
        """const char * fl_vclass_name(int n)""")
    library.check_if_initialized()
    inum = library.convert_to_int(n)
    library.keep_elem_refs(n, inum)
    _fl_vclass_name(inum)


def fl_vclass_val(val):
    """

    @param val: ?
    @type val: str

    :return: vclass num.
    :rtype: int

    :note: e.g. ??

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_vclass_val = library.cfuncproto(
        library.load_so_libforms(), "fl_vclass_val",
        cty.c_int, [xfdata.STRING],
        """int fl_vclass_val(const char * v)""")
    library.check_if_initialized()
    sval = library.convert_to_string(val)
    library.keep_elem_refs(val, sval)
    retval = _fl_vclass_val(sval)
    return retval


def fl_set_ul_property(prop, thickness):
    """ fl_set_ul_property(prop, thickness)

    @param prop: ?
    @type prop: int
    @param thickness: ?
    @type thickness: int

    :note: e.g. ??

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_ul_property = library.cfuncproto(
        library.load_so_libforms(), "fl_set_ul_property",
        None, [cty.c_int, cty.c_int],
        """void fl_set_ul_property(int prop, int thickness)""")
    iprop = library.convert_to_int(prop)
    ithickness = library.convert_to_int(thickness)
    library.keep_elem_refs(prop, thickness, iprop, ithickness)
    _fl_set_ul_property(iprop, ithickness)


def fl_set_clipping(x, y, w, h):
    """Sets a clipping region in the Forms Library's default GC (gc[0]).
    This defines the area (delimited by arguments passed) drawing is to
    restrict to and are relative to the window/form that will be drawn to.
    In this way you can prevent drawing over other object and outside the
    box.

    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int

    :note: e.g. fl_set_clipping(250, 200, 100, 80)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_clipping = library.cfuncproto(
        library.load_so_libforms(), "fl_set_clipping",
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_set_clipping(FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h)""")
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    library.keep_elem_refs(x, y, w, h, ix, iy, iw, ih)
    _fl_set_clipping(ix, iy, iw, ih)


# commented as it gives a NULL pointer access. Maybe GCs other than 
# default are not viable in python.
#def fl_set_gc_clipping(gc, x, y, w, h):
#    """Sets a clipping region in the specified graphics context (GC).
#    This defines the area (delimited by arguments passed) drawing is to
#    restrict to and are relative to the window/form that will be drawn to.
#    In this way you can prevent drawing over other object and outside the
#    box.
#
#    @param gc: Graphics Context number
#    @type gc: ?
#    @param x: horizontal position (upper-left corner)
#    @type x: int
#    @param y: vertical position (upper-left corner)
#    @type y: int
#    @param w: width in coord units
#    @type w: int
#    @param h: height in coord units
#    @type h: int
#
#    :note: e.g. ??
#
#    :status: Untested + NoDoc + NoDemo = NOT OK
#
#    """
#    _fl_set_gc_clipping = library.cfuncproto(
#        library.load_so_libforms(), "fl_set_gc_clipping",
#        None, [xfdata.GC, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
#        xfdata.FL_Coord],
#        """void fl_set_gc_clipping(GC gc, FL_Coord x, FL_Coord y,
#           FL_Coord w, FL_Coord h)""")
#    ix = library.convert_to_FL_Coord(x)
#    iy = library.convert_to_FL_Coord(y)
#    iw = library.convert_to_FL_Coord(w)
#    ih = library.convert_to_FL_Coord(h)
#    library.keep_elem_refs(gc, x, y, w, h, ix, iy, iw, ih)
#    _fl_set_gc_clipping(gc, ix, iy, iw, ih)


# commented as it gives a NULL pointer access. Maybe GCs other than 
# default are not viable in python.
#def fl_unset_gc_clipping(gc):
#    """ fl_unset_gc_clipping(gc)
#
#    @param gc: Graphics Context numebr
#    @type gc: ?
#
#    :status: Untested + NoDoc + NoDemo = NOT OK
#
#    """
#    _fl_unset_gc_clipping = library.cfuncproto(
#        library.load_so_libforms(), "fl_unset_gc_clipping",
#        None, [xfdata.GC],
#        """void fl_unset_gc_clipping(GC gc)""")
#    library.keep_elem_refs(gc)
#    _fl_unset_gc_clipping(gc)


def fl_set_clippings(pRect, n):
    """ fl_set_clippings(pRect, n)

    @param pRect: rectangle class instance
    @type pRect: pointer to xfdata.FL_RECT
    @param n: ?
    @type n: int

    :note: e.g. ??

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_clippings = library.cfuncproto(
        library.load_so_libforms(), "fl_set_clippings",
        None, [cty.POINTER(xfdata.FL_RECT), cty.c_int],
        """void fl_set_clippings(FL_RECT * xrect, int n)""")
    inum = library.convert_to_int(n)
    library.keep_elem_refs(pRect, n, inum)
    _fl_set_clippings(pRect, inum)


def fl_unset_clipping():
    """Stops clipping and removes clipping area defined with
    fl_set_clipping()

    :note: e.g. fl_unset_clipping()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_unset_clipping = library.cfuncproto(
        library.load_so_libforms(), "fl_unset_clipping",
        None, [],
        """void fl_unset_clipping()""")
    _fl_unset_clipping()


def fl_set_text_clipping(x, y, w, h):
    """Sets a clipping region for text in the Forms Library's default GC
    (gc[0]). This defines the area (delimited by arguments passed) drawing
    is to restrict to and are relative to the window/form that will be
    drawn to. In this way you can prevent drawing over other object and
    outside the box.

    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int

    :note: e.g. fl_set_text_clipping(200, 200, 300, 50)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_text_clipping = library.cfuncproto(
        library.load_so_libforms(), "fl_set_text_clipping",
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord],
        """void fl_set_text_clipping(FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h)""")
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    library.keep_elem_refs(x, y, w, h, ix, iy, iw, ih)
    _fl_set_text_clipping(ix, iy, iw, ih)


def fl_unset_text_clipping():
    """Stops clipping for text and removes clipping area defined with
    fl_set_text_clipping()

    :note: e.g. fl_unset_text_clipping()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_unset_text_clipping = library.cfuncproto(
        library.load_so_libforms(), "fl_unset_text_clipping",
        None, [],
        """void fl_unset_text_clipping()""")
    _fl_unset_text_clipping()


# How we pack and unpack colors

def FL_PCCLAMP(a):
    if (a > xfdata.FL_PCMAX):
        return xfdata.FL_PCMAX
    elif (a < 0):
        return 0
    else:
        return a


# If PCBITS is not 8, we need to apply the RGBmask

def FL_GETR(packed):
    return ((packed >> xfdata.FL_RSHIFT) & xfdata.FL_RMASK)

# maybe unused in python?
def FL_GETG(packed):
    return ((packed) >> xfdata.FL_GSHIFT) & xfdata.FL_PCMAX

# maybe unused in python?
def FL_GETB(packed):
    return ((packed) >> xfdata.FL_BSHIFT) & xfdata.FL_PCMAX

# maybe unused in python?
def FL_GETA(packed):
    return ((packed) >> xfdata.FL_ASHIFT) & xfdata.FL_PCMAX

# maybe unused in python?
def FL_PACK3(r, g, b ):
    return (r << xfdata.FL_RSHIFT) | (g << xfdata.FL_GSHIFT) | \
        (b << xfdata.FL_BSHIFT)

# maybe unused in python?
FL_PACK = FL_PACK3

# maybe unused in python?
def FL_PACK4(r, g, b, a):
    return (FL_PACK3(r, g, b) | (a << xfdata.FL_ASHIFT))

# maybe unused in python?
def FL_UNPACK(p, r, g, b):
    r = FL_GETR(p)
    g = FL_GETG(p)
    b = FL_GETB(p)
    return r, g, b

# maybe unused in python?
FL_UNPACK3 = FL_UNPACK

# maybe unused in python?
def FL_UNPACK4(p, r, g, b, a):
    r, g, b = FL_UNPACK3(p, r, g, b)
    a = FL_GETA(p)
    return r, g, b, a

