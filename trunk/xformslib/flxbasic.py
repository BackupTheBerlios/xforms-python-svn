#!/usr/bin/env python
# -*- coding: iso8859-1 -*-

""" xforms-python's functions to handle X Window basic and drawing stuff.
"""

#    Copyright (C) 2009, 2010, 2011  Luca Lazzaroni "LukenShiro"
#    e-mail: <lukenshiro@ngi.it>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Lesser General Public License as
#    published by the Free Software Foundation, version 2.1 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU Lesser General Public License for more details.
#
#    You should have received a copy of the GNU LGPL along with this
#    program. If not, see <http://www.gnu.org/licenses/>.
#
#    See CREDITS file to read acknowledgements and thanks to XForms,
#    ctypes and other developers.

# originally generated by 'h2xml+gccxml' and 'xml2py'
# then heavily reordered and reworked

# ############################################# #
# Interface to XForms shared flobject libraries #
# ############################################# #


import ctypes as cty
from xformslib import library
from xformslib import xfdata
from xformslib import flbasic
from xformslib import flcanvas


# these variable are not meant to be moved in xfdata.py!
fl_current_form = (cty.POINTER(xfdata.FL_FORM)).in_dll( \
        library.load_so_libforms(), 'fl_current_form')
fl_display = (cty.POINTER(xfdata.Display)).in_dll(library.load_so_libforms(),
        'fl_display')
fl_screen = (cty.c_int).in_dll(library.load_so_libforms(), 'fl_screen')
# root window
fl_root = (xfdata.Window).in_dll(library.load_so_libforms(), 'fl_root')
# virtual root window
fl_vroot = (xfdata.Window).in_dll(library.load_so_libforms(), 'fl_vroot')
# screen dimension in pixels
fl_scrh = (cty.c_int).in_dll(library.load_so_libforms(), 'fl_scrh')
fl_scrw = (cty.c_int).in_dll(library.load_so_libforms(), 'fl_scrw')

fl_vmode = (cty.c_int).in_dll(library.load_so_libforms(), 'fl_vmode')
#fl_state = (cty.POINTER(xfdata.FL_State)).in_dll(library.load_so_libforms(),
#            'fl_state')
fl_state = (xfdata.FL_State * 6)()  # fl_state is an array of 6 FL_State



###########################
# forms.h (XBasic.h)
# X Window dependent stuff
###########################

def FL_is_gray(visual):
    if (visual == xfdata.GrayScale) or (visual == xfdata.StaticGray):
        return True
    else:
        return False


def FL_is_rgb(visual):
    if (visual == xfdata.TrueColor) or (visual == xfdata.DirectColor):
        return True
    else:
        return False


# Current version only runs in single visual mode
def fl_get_vclass():
    return fl_vmode.value


def fl_get_form_vclass(a):
    return fl_vmode.value


def fl_get_gc():
    return fl_state[fl_get_vclass()].gc[0]
    #return xfdata.fl_state[xfdata.fl_vmode().value].gc[0]
    #return xfdata.fl_state[xfdata.fl_vmode].gc[0]


def fl_mode_capable(mode, warn):
    """fl_mode_capable(mode, warn) -> yesno

    Tells if the system is capable of displaying in the specified visual class,
    or not.

    Parameters
    ----------
        mode : int
            visual mode. Values (from xfdata module) GrayScale, StaticGray,
            PseudoColor, StaticColor, DirectColor, TrueColor, DefaultVisual
        warn : int
            if set a warning is printed out in case the capability asked for is
            not available. Values 0 (do not print warning) or 1 (print warning)

    Returns
    -------
        yesno : int
            flag for capability. Values 1 (if capable) or 0 otherwise

    Examples
    --------
        >>> capable = fl_mode_capable(xfdata.GrayScale, 1)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_mode_capable = library.cfuncproto(
        library.load_so_libforms(), "fl_mode_capable",\
        cty.c_int, [cty.c_int, cty.c_int],\
        """int fl_mode_capable(int mode, int warn)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(mode, xfdata.VISUALMODE_list)
    i_mode = library.convert_to_intc(mode)
    i_warn = library.convert_to_intc(warn)
    library.keep_elem_refs(mode, warn, i_mode, i_warn)
    retval = _fl_mode_capable(i_mode, i_warn)
    return retval


def fl_default_win():
    return fl_state[fl_get_vclass()].trailblazer
    #return fl_state[fl_vmode().value].trailblazer
    #return fl_state[fl_vmode].trailblazer


def fl_default_window():
    return fl_state[fl_get_vclass()].trailblazer
    #return xfdata.fl_state[xfdata.fl_vmode().value].trailblazer
    #return xfdata.fl_state[xfdata.fl_vmode].trailblazer


# Some basic drawing routines

# Rectangles

def fl_rectangle(fill, xpos, ypos, width, height, colr):
    """fl_rectangle(fill, xpos, ypos, width, height, colr)

    Draws a rectangle.

    Parameters
    ----------
        fill : int
            flag if the rectangle has to be filled or just the outline is
            needed. Values 0 (the outline only) or 1 (filled).
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_rectangle(1, 100, 200, 300, 200, xfdata.FL_BEIGE)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_rectangle = library.cfuncproto(
        library.load_so_libforms(), "fl_rectangle",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, \
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_COLOR], \
        """void fl_rectangle(int fill, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR col)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    i_fill = library.convert_to_intc(fill)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(fill, xpos, ypos, width, height, colr, \
            i_fill, i_xpos, i_ypos, i_width, i_height, ul_colr)
    _fl_rectangle(i_fill, i_xpos, i_ypos, i_width, i_height, ul_colr)


def fl_rectbound(xpos, ypos, width, height, colr):
    """fl_rectbound(xpos, ypos, width, height, colr)

    Draws a filled rectangle with a black border.

    Parameters
    ----------
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_rectbound(100, 200, 300, 200, xfdata.FL_PINK)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_rectbound = library.cfuncproto(
        library.load_so_libforms(), "fl_rectbound", \
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR],\
        """void fl_rectbound(FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, FL_COLOR col)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(xpos, ypos, width, height, colr, i_xpos, \
            i_ypos, i_width, i_height, ul_colr)
    _fl_rectbound(i_xpos, i_ypos, i_width, i_height, ul_colr)


def fl_rectf(xpos, ypos, width, height, colr):
    """fl_rectf(xpos, ypos, width, height, colr)

    Draws a filled rectangle on the screen.

    Parameters
    ----------
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_rectf(150, 220, 300, 200, xfdata.FL_TOMATO)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    fl_rectangle(1, xpos, ypos, width, height, colr)


def fl_rect(xpos, ypos, width, height, colr):
    """fl_rect(xpos, ypos, width, height, colr)

    Draws a rectangle's outline on the screen.

    Parameters
    ----------
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_rect(100, 200, 300, 200, xfdata.FL_SLATEBLUE)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    fl_rectangle(0, xpos, ypos, width, height, colr)


# Rectangle with rounded-corners

def fl_roundrectangle(fill, xpos, ypos, width, height, colr):
    """fl_roundrectangle(fill, xpos, ypos, width, height, colr)

    Draws a rectangle with rounded corners (filled or just the outline).

    Parameters
    ----------
        fill : int
            flag if the rectangle has to be filled or just the outline is
            needed. Values 0 (the outline only) or 1 (filled)
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_roundrectangle(1, 100, 200, 300, 200, xfdata.FL_MAGENTA)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_roundrectangle = library.cfuncproto(
        library.load_so_libforms(), "fl_roundrectangle",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR],\
        """void fl_roundrectangle(int fill, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR col)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    i_fill = library.convert_to_intc(fill)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(fill, xpos, ypos, width, height, colr, \
            i_fill, i_xpos, i_ypos, i_width, i_height, ul_colr)
    _fl_roundrectangle(i_fill, i_xpos, i_ypos, i_width, i_height, ul_colr)


def fl_roundrectf(xpos, ypos, width, height, colr):
    """fl_roundrectf(xpos, ypos, width, height, colr)

    Draws a filled rectangle with rounded corners.

    Parameters
    ----------
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_roundrectf(100, 200, 300, 200, xfdata.FL_CYAN)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    fl_roundrectangle(1, xpos, ypos, width, height, colr)


def fl_roundrect(xpos, ypos, width, height, colr):
    """fl_roundrect(xpos, ypos, width, height, colr)

    Draws a rectangle's outline with rounded corners.

    Parameters
    ----------
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_roundrect(100, 200, 300, 200, xfdata.FL_INDIANRED)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    fl_roundrectangle(0, xpos, ypos, width, height, colr)


# General polygon and polylines

def fl_polygon(fill, ptr_flpoint, numpoints, colr):
    """fl_polygon(fill, ptr_flpoint, numpoints, colr)

    Draws a generic polygon on the screen (filled or just an outline).

    Parameters
    ----------
        fill : int
            if polygon has to be filled or just an outline is needed.
            Values 1 (if filled) or 0 (an outline only)
        ptr_flpoint : pointer to xfdata.FL_POINT
            an array of point class instances. You can prepare it passing a
            dict or a list of dicts (whose key are corresponding to
            xfdata.FL_POINT's members) to xfstruct.fls_make_ptr_flpoint() function
        numpoints : int
            number of points
        colr : long_pos
            XForms colormap index as color to be set

    Examples
    --------
        >>> ppointmap = xfstruct.fls_make_ptr_flpoint([{'x' : 12, 'y' : 32},
        >>>         {'x' : 24, 'y' : 100}, {'x' : 87, 'y' : 132}])
        >>> fl_polygon(1, ppointmap, 3, xfdata.FL_PALEGREEN)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_polygon = library.cfuncproto(
        library.load_so_libforms(), "fl_polygon",\
        None, [cty.c_int, cty.POINTER(xfdata.FL_POINT), cty.c_int,
        xfdata.FL_COLOR],
        """void fl_polygon(int fill, FL_POINT * xp, int n, FL_COLOR col)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    i_fill = library.convert_to_intc(fill)
    library.verify_otherclassptr_type(ptr_flpoint, \
            cty.POINTER(xfdata.FL_POINT))
    i_numpoints = library.convert_to_intc(numpoints)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(fill, ptr_flpoint, numpoints, colr, i_fill, \
            i_numpoints, ul_colr)
    _fl_polygon(i_fill, ptr_flpoint, i_numpoints, ul_colr)


def fl_polyf(ptr_flpoint, numpoints, colr):
    """fl_polyf(ptr_flpoint, numpoints, colr)

    Draws a generic filled polygon on the screen.

    Parameters
    ----------
        ptr_flpoint : pointer to xfdata.FL_POINT
            an array of point class instances. You can prepare it passing a
            dict or a list of dicts (whose key are corresponding to
            xfdata.FL_POINT's members) to xfstruct.fls_make_ptr_flpoint() function
        numpoints : int
            number of points
        colr : long_pos
            XForms colormap index as color to be set

    Examples
    --------
        >>> ppointmap = xfstruct.fls_make_ptr_flpoint([{'x' : 12, 'y' : 32},
        >>>         {'x' : 24, 'y' : 100}, {'x' : 87, 'y' : 132}])
        >>> fl_polyf(ppointmap, 3, xfdata.FL_PALEGREEN)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    fl_polygon(1, ptr_flpoint, numpoints, colr)


def fl_polyl(ptr_flpoint, numpoints, colr):
    """fl_polyl(ptr_flpoint, numpoints, colr)

    Draws a generic polygon's outline on the screen.

    Parameters
    ----------
        ptr_flpoint : pointer to xfdata.FL_POINT
            an array of point class instances. You can prepare it passing a
            dict or a list of dicts (whose key are corresponding to
            xfdata.FL_POINT's members) to xfstruct.fls_make_ptr_flpoint() function
        numpoints : int
            number of points
        colr : long_pos
            XForms colormap index as color to be set

    Examples
    --------
        >>> ppointmap = xfstruct.fls_make_ptr_flpoint([{'x' : 12, 'y' = 32},
        >>>         {'x' : 24, 'y' : 100}, {'x' : 87, 'y' : 132}])
        >>> fl_polyl(ppointmap, 3, xfdata.FL_ORCHID)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    fl_polygon(0, ptr_flpoint, numpoints, colr)


def fl_polybound(ptr_flpoint, numpoints, colr):
    """fl_polybound(ptr_flpoint, numpoints, colr)

    Draws a generic filled polygon with a black border in the screen.

    Parameters
    ----------
        ptr_flpoint : pointer to xfdata.FL_POINT
            an array of point class instances. You can prepare it passing a
            dict or a list of dicts (whose key are corresponding to
            xfdata.FL_POINT's members) to xfstruct.fls_make_ptr_flpoint() function
        numpoints : int
            number of points
        colr : long_pos
            XForms colormap index as color to be set

    Examples
    --------
        >>> ppointmap = xfstruct.fls_make_ptr_flpoint([{'x' : 12, 'y' : 32},
        >>>         {'x' : 24, 'y' : 100}, {'x' : 87, 'y' : 132}])
        >>> fl_polybound(ppointmap, 3, xfdata.FL_DARKGOLD)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    fl_polygon(1, ptr_flpoint, numpoints, colr)
    fl_polygon(0, ptr_flpoint, numpoints, xfdata.FL_BLACK)


def fl_lines(ptr_flpoint, numpoints, colr):
    """fl_lines(ptr_flpoint, numpoints, colr)

    Draws connected line segments between a number of points.

    Parameters
    ----------
        ptr_flpoint : pointer to xfdata.FL_POINT
            an array of point class instances. You can prepare it passing a
            dict or a list of dicts (whose key are corresponding to
            xfdata.FL_POINT's members) to xfstruct.fls_make_ptr_flpoint() function
        numpoints : int
            number of points
        colr : long_pos
            XForms colormap index as color to be set

    Examples
    --------
        >>> ppointmap = xfstruct.fls_make_ptr_flpoint([{'x' : 12, 'y' : 32},
        >>>         {'x' : 24, 'y' : 100}, {'x' : 87, 'y' : 132}])
        >>> fl_lines(ppointmap, 3, xfdata.FL_DODGERBLUE)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_lines = library.cfuncproto(
        library.load_so_libforms(), "fl_lines", \
        None, [cty.POINTER(xfdata.FL_POINT), cty.c_int, xfdata.FL_COLOR], \
        """void fl_lines(FL_POINT * xp, int n, FL_COLOR col)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ptr_flpoint = cty.cast(ptr_flpoint, cty.POINTER(xfdata.FL_POINT))
    i_numpoints = library.convert_to_intc(numpoints)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(ptr_flpoint, numpoints, colr, ptr_flpoint, \
            i_numpoints, ul_colr)
    _fl_lines(ptr_flpoint, i_numpoints, ul_colr)


def fl_line(startxpos, startypos, endxpos, endypos, colr):
    """fl_line(startxpos, startypos, endxpos, endypos, colr)

    Connects two points with a straight line.

    Parameters
    ----------
        startxpos : int
            initial horizontal position (upper-left corner)
        startypos : int
            initial vertical position (upper-left corner)
        endxpos : int
            final horizontal position (upper-left corner)
        endypos : int
            final vertical position (upper-left corner)
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_line(100, 100, 200, 200, xfdata.FL_ANTIQUEWHITE)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_line = library.cfuncproto(
        library.load_so_libforms(), "fl_line",\
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR],\
        """void fl_line(FL_Coord xi, FL_Coord yi, FL_Coord xf,
           FL_Coord yf, FL_COLOR c)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    i_startxpos = library.convert_to_intc(startxpos)
    i_startypos = library.convert_to_intc(startypos)
    i_endxpos = library.convert_to_intc(endxpos)
    i_endypos = library.convert_to_intc(endypos)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(startxpos, startypos, endxpos, endypos, colr,
            i_startxpos, i_startypos, i_endxpos, i_endypos, ul_colr)
    _fl_line(i_startxpos, i_startypos, i_endxpos, i_endypos, ul_colr)


fl_simple_line = fl_line


def fl_point(xpos, ypos, colr):
    """fl_point(xpos, ypos, colr)

    Draws one point on the screen.

    Parameters
    ----------
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_point(75, 452, xfdata.FL_CHARTREUSE)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_point = library.cfuncproto(
        library.load_so_libforms(), "fl_point",\
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_COLOR],\
        """void fl_point(FL_Coord x, FL_Coord y, FL_COLOR c)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(xpos, ypos, colr, i_xpos, i_ypos, ul_colr)
    _fl_point(i_xpos, i_ypos, ul_colr)


def fl_points(ptr_flpoint, numpoints, colr):
    """fl_points(ptr_flpoint, numpoints, colr)

    Draws more than one points.

    Parameters
    ----------
        ptr_flpoint : pointer to xfdata.FL_POINT
            an array of point class instances. You can prepare it passing a
            dict or a list of dicts (whose key are corresponding to
            xfdata.FL_POINT's members) to xfstruct.fls_make_ptr_flpoint() function
        numpoints : int
            number of points
        colr : long_pos
            XForms colormap index as color to be set

    Examples
    --------
        >>> ppointmap = xfstruct.fls_make_ptr_flpoint([{'x' : 12, 'y' : 32},
        >>>         {'x' : 24, 'y' : 100}, {'x' : 87, 'y' : 132}])
        >>> fl_points(ppointmap, 3, xfdata.FL_AZURE)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_points = library.cfuncproto(
        library.load_so_libforms(), "fl_points",\
        None, [cty.POINTER(xfdata.FL_POINT), cty.c_int, xfdata.FL_COLOR],
        """void fl_points(FL_POINT * p, int np, FL_COLOR c)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ptr_flpoint = cty.cast(ptr_flpoint, cty.POINTER(xfdata.FL_POINT))
    i_numpoints = library.convert_to_intc(numpoints)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(ptr_flpoint, numpoints, colr, ptr_flpoint, \
            i_numpoints, ul_colr)
    _fl_points(ptr_flpoint, i_numpoints, ul_colr)


def fl_dashedlinestyle(dash, numdash):
    """fl_dashedlinestyle(dash, numdash)

    Changes the dash pattern for xfdata.FL_USERDASH and
    xfdata.FL USERDOUBLEDASH. Each element of the array dash is the length of
    a segment of the pattern in pixels. Dashed lines are drawn as alternating
    segments, each with the length of an element in dash. Thus the overall
    length of the dash pattern, in pixels, is the sum of all elements of dash.
    When the pattern is used up but the line to draw is longer it used from
    the start again. You have to call this one whenever xfdata.FL_USERDASH is
    used to set the dash pattern, otherwise whatever the last pattern was, it
    will be used. After the sequence, the pattern repeats.

    Parameters
    ----------
        dash : str
            text sequence of dashes to use. If it is empty (""), use default
            dash pattern
        numdash : int
            length of dashes list. If it is 0, use the default dash pattern

    Examples
        >>> dashlist = "\x09\x03\x02\x03"
        >>> fl_dashedlinestyle(dashlist, 4)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_dashedlinestyle = library.cfuncproto(
        library.load_so_libforms(), "fl_dashedlinestyle", \
        None, [xfdata.STRING, cty.c_int], \
        """void fl_dashedlinestyle(const char * dash, int ndash)""")
    library.check_if_flinitialized()
    #if not dash:                # it is None
    #    #library.verify_tuplelist_type(dash)
    #    s_dash = cty.cast(dash, cty.c_void_p)
    #else:
    s_dash = library.convert_to_stringc(dash)
    i_numdash = library.convert_to_intc(numdash)
    library.keep_elem_refs(dash, numdash, s_dash, i_numdash)
    _fl_dashedlinestyle(s_dash, i_numdash)


def fl_update_display(block):
    """fl_update_display(block)

    Flushes properly the output buffer. It resolves the problem of the form
    being only partially redrawn, due to the two way buffering mechanism of
    Xlib, if fl_show_form() is followed by something that blocks (e.g., waiting
    for a device other than X devices to come online). For typical programs
    that use fl_do_forms() or fl_check_forms() after fl_show_form(), flushing
    is not necessary as the output buffer is flushed automatically. Excessive
    calls to fl_update_display() degrade performance.

    Parameters
    ----------
        block : int
            mode of X buffer flushing. Values 0 (it is flushed so the drawing
            requests are on their way to the server) or 1 (it is flushed and
            waits until all the events are received and processed by server)

    Examples
    --------
        >>> fl_update_display()

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe
        Postcondition: to be used after fl_show_form()

    """
    _fl_update_display = library.cfuncproto(
        library.load_so_libforms(), "fl_update_display",\
        None, [cty.c_int],\
        """void fl_update_display(int block)""")
    library.check_if_flinitialized()
    i_block = library.convert_to_intc(block)
    library.keep_elem_refs(block, i_block)
    _fl_update_display(i_block)


def fl_diagline(xpos, ypos, width, height, colr):
    """fl_diagline(xpos, ypos, width, height, colr)

    Draws a line along the diagonal of a box. To draw a horizontal line set
    height to 1, not to 0.

    Parameters
    ----------
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_diagline(180, 90, 5, 2, xfdata.FL_BISQUE)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    fl_line(xpos, ypos, (xpos + width - 1), (ypos + height - 1), colr)


# Line attributes

def fl_linewidth(lnwidth):
    """fl_linewidth(lnwidth)

    Changes the line width.

    Parameters
    ----------
        lnwidth : int
            width of line in coord units. If it is 0, reset to server default.

    Examples
    --------
        >>> fl_linewidth(2)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_linewidth = library.cfuncproto(
        library.load_so_libforms(), "fl_linewidth", \
        None, [cty.c_int], \
        """void fl_linewidth(int n)""")
    library.check_if_flinitialized()
    i_lnwidth = library.convert_to_intc(lnwidth)
    library.keep_elem_refs(lnwidth, i_lnwidth)
    _fl_linewidth(i_lnwidth)


fl_set_linewidth = fl_linewidth


def fl_linestyle(lnstyle):
    """fl_linestyle(lnstyle)

    Changes the line style.

    Parameters
    ----------
        lnstyle : int
            style of the line to draw. Values (from xfdata.py)
            - FL_SOLID (Solid line. Default and most efficient),
            - FL_USERDASH (Dashed line, but the dash pattern is definable by
              user via fl_dashedlinestyle(). Only the odd numbered segments
              are drawn with the foreground color),
            - FL_USERDOUBLEDASH (Similar to FL_LINE_USERDASH but both even and
              odd numbered segments are drawn, with the even numbered segments
              drawn in the background color, as set by flbasic.fl_bk_color()),
            - FL_DOT (Dotted line [....]),
            - FL_DOTDASH (Dash-dot-dash line [-.-.]),
            - FL_DASH (Dashed line [----]),
            - FL_LONGDASH (Long dashed line [_ _ _]).

    Examples
    --------
        >>> fl_linestyle(xfdata.FL_DOT)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_linestyle = library.cfuncproto(
        library.load_so_libforms(), "fl_linestyle",\
        None, [cty.c_int],\
        """void fl_linestyle(int n)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(lnstyle, xfdata.LINESTYLE_list)
    i_lnstyle = library.convert_to_intc(lnstyle)
    library.keep_elem_refs(lnstyle, i_lnstyle)
    _fl_linestyle(i_lnstyle)


fl_set_linestyle = fl_linestyle


def fl_drawmode(dmode):
    """fl_drawmode(dmode)

    Changes the drawing mode so the destination pixel values play a role in
    the final pixel value. By default, all lines are drawn so they overwrite
    the destination pixel values.

    Parameters
    ----------
      dmode : int
        requested mode setting. Values (from xfdata.py)
        - FL_XOR (Bitwise XOR, exclusive-or, of the pixel value to be drawn
          with the pixel value already on the screen. Useful for
          rubber-banding),
        - FL_COPY (Default overwrite mode, final pixel value is the same as
          source),
        - FL_AND (Bitwise AND of the pixel value to be drawn with the pixel
          value already on the screen).

    Examples
    --------
        >>> fl_drawmode(xfdata.FL_AND)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_drawmode = library.cfuncproto(
        library.load_so_libforms(), "fl_drawmode",\
        None, [cty.c_int],\
        """void fl_drawmode(int request)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(dmode, xfdata.DRAWMODE_list)
    i_dmode = library.convert_to_intc(dmode)
    library.keep_elem_refs(dmode, i_dmode)
    _fl_drawmode(i_dmode)


def fl_get_linewidth():
    """fl_get_linewidth() -> lnwidth

    Finds out the width of line.

    Returns
    -------
        lnwidth : int
            line width

    Examples
    --------
        >>> wid = fl_get_linewidth()

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_linewidth = library.cfuncproto(
        library.load_so_libforms(), "fl_get_linewidth", \
        cty.c_int, [], \
        """int fl_get_linewidth()""")
    library.check_if_flinitialized()
    retval = _fl_get_linewidth()
    return retval


def fl_get_linestyle():
    """fl_get_linestyle() -> linestyle

    Finds out the style of line.

    Returns
    -------
        linestyle: int
            line style (from xfdata.py, e.g. FL_SOLID, FL_DOT, etc..)

    Examples
    --------
        >>> currstl = fl_get_linestyle()

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_linestyle = library.cfuncproto(
        library.load_so_libforms(), "fl_get_linestyle", \
        cty.c_int, [], \
        """int fl_get_linestyle()""")
    library.check_if_flinitialized()
    retval = _fl_get_linestyle()
    return retval


def fl_get_drawmode():
    """fl_get_drawmode() -> dmode

    Finds out the drawing mode of lines.

    Returns
    -------
        dmode : int
            drawing mode.
            Values (from xfdata.py) FL_XOR (Bitwise XOR, exclusive-or, of the
            pixel value to be drawn with the pixel value already on the screen.
            Useful for rubber-banding), FL_COPY (Default overwrite mode, final
            pixel value is the same as source), FL_AND (Bitwise AND of the
            pixel value to be drawn with the pixel value already on the screen)

    Examples
    --------
        >>> currdrw = fl_get_draw_mode()

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_drawmode = library.cfuncproto(
        library.load_so_libforms(), "fl_get_drawmode",\
        cty.c_int, [],\
        """int fl_get_drawmode()""")
    library.check_if_flinitialized()
    retval = _fl_get_drawmode()
    return retval


fl_set_drawmode = fl_drawmode


# Ellipses

def fl_oval(fill, xpos, ypos, width, height, colr):
    """fl_oval(fill, xpos, ypos, width, height, colr)

    Draws an ellipse, either filled or open. Use width equal to height to get
    a circle.

    Parameters
    ----------
        fill : int
            flag if filled or open ellipse. Values 1 (if filled ellipse) or 0
            (if open)
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_oval(1, 125, 256, 145, 320, xfdata.FL_BURLYWOOD)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_oval = library.cfuncproto(
        library.load_so_libforms(), "fl_oval",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR], \
        """void fl_oval(int fill, FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, FL_COLOR col)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    i_fill = library.convert_to_intc(fill)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(fill, xpos, ypos, width, height, colr, i_fill, \
            i_xpos, i_ypos, i_width, i_height, ul_colr)
    _fl_oval(i_fill, i_xpos, i_ypos, i_width, i_height, ul_colr)


def fl_ovalbound(xpos, ypos, width, height, colr):
    """fl_ovalbound(xpos, ypos, width, height, colr)

    Draws a filled ellipse with a black outline. Use width equal to height to
    get a circle.

    Parameters
    ----------
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_ovalbound(1, 125, 256, 145, 320, xfdata.FL_BLANCHEDALMOND)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_ovalbound = library.cfuncproto(
        library.load_so_libforms(), "fl_ovalbound",\
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR],
        """void fl_ovalbound(FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, FL_COLOR col)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(xpos, ypos, width, height, colr, i_xpos, \
            i_ypos, i_width, i_height, ul_colr)
    _fl_ovalbound(i_xpos, i_ypos, i_width, i_height, ul_colr)


def fl_ovalarc(fill, xpos, ypos, width, height, stheta, dtheta, colr):
    """fl_ovalarc(fill, xpos, ypos, width, height, stheta, dtheta, colr)

    Draws an elliptical arc, either filled or open.

    Parameters
    ----------
        fill : int
            flag if filled or open. Values 1 (if filled) or 0 (if open)
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        stheta : int
            starting angle, measured in tenth of a degree and with 0 at 3
            o'clock position
        dtheta : int
            the direction and the extent of the arc. If positive the arc is
            drawn in counter-clockwise direction from the starting point,
            otherwise in clockwise direction. If it is larger than 3600 it is
            truncated to 3600.
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_ovalarc(1, 275, 256, 145, 320, 200, 900,
                xfdata.FL_DARKSALMON)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_ovalarc = library.cfuncproto(
        library.load_so_libforms(), "fl_ovalarc",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, cty.c_int, cty.c_int,
        xfdata.FL_COLOR],
        """void fl_ovalarc(int fill, FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, int t0, int dt, FL_COLOR col)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    i_fill = library.convert_to_intc(fill)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    i_stheta = library.convert_to_intc(stheta)
    i_dtheta = library.convert_to_intc(dtheta)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(fill, xpos, ypos, width, height, stheta, dtheta, \
            colr, i_fill, i_xpos, i_ypos, i_width, i_height, i_stheta, \
            i_dtheta, ul_colr)
    _fl_ovalarc(i_fill, i_xpos, i_ypos, i_width, i_height, i_stheta, \
            i_dtheta, ul_colr)


def fl_ovalf(xpos, ypos, width, height, colr):
    """fl_ovalf(xpos, ypos, width, height, colr)

    Draws a filled ellipse. Use width equal to height to get a circle.

    Parameters
    ----------
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_ovalf(125, 256, 145, 320, xfdata.FL_CORNFLOWERBLUE)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    fl_oval(1, xpos, ypos, width, height, colr)


def fl_ovall(xpos, ypos, width, height, colr):
    """fl_ovall(xpos, ypos, width, height, colr)

    Draws an open ellipse. Use width equal to height to get a circle.

    Parameters
    ----------
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_ovall(125, 256, 145, 320, xfdata.FL_DARKERED)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    fl_oval(0, xpos, ypos, width, height, colr)


fl_oval_bound = fl_ovalbound


def fl_circf(xpos, ypos, radius, colr):
    """fl_circf(xpos, ypos, radius, colr)

    Draws a filled circle.

    Parameters
    ----------
        xpos : int
            horizontal position of the center of the arc
        ypos : int
            vertical position of the center of the arc
        radius : int
            radius of the arc
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_circf(200, 250, 69, xfdata.FL_FUCHSIA)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    fl_oval(1, (xpos - radius), (ypos - radius), 2 * radius, 2 * radius, colr)


def fl_circ(xpos, ypos, radius, colr):
    """fl_circ(xpos, ypos, radius, colr)

    Draws an open circle.

    Parameters
    ----------
        xpos : int
            horizontal position of the center of the arc
        ypos : int
            vertical position of the center of the arc
        radius : int
            radius of the arc
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_circ(200, 250, 69, xfdata.FL_GAINSBORO)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    fl_oval(0, (xpos - radius), (ypos - radius), 2 * radius, 2 * radius, colr)


# Arcs

def fl_pieslice(fill, xpos, ypos, width, height, stheta, etheta, colr):
    """fl_pieslice(fill, xpos, ypos, width, height, stheta, etheta, colr)

    Draws an elliptical arc, either filled or open.

    Parameters
    ----------
        fill : int
            if the arc is filled or open. Values 1 (if filled) or 0 (if open)
        xpos : int
            horizontal position of the bounding box
        ypos : int
            vertical position of the bounding box
        width : int
            horizontal axe of the ellipse
        height : int
            vertical axe of the ellipse
        stheta : int
            starting angle of the arc in units of tenths of a degree (where 0
            stands for a direction of 3 o'clock, i.e. the right-most point of
            a circle)
        etheta : int
            ending angle of the arc in units of tenths of a degree (where 0
            stands for a direction of 3 o'clock, i.e. the right-most point of
            a circle)
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_pieslice(1, 120, 253, 400, 100, 60, 70, xfdata.FL_GOLD)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_pieslice = library.cfuncproto(
        library.load_so_libforms(), "fl_pieslice",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, cty.c_int, cty.c_int,
        xfdata.FL_COLOR],
        """void fl_pieslice(int fill, FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, int a1, int a2, FL_COLOR col)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    i_fill = library.convert_to_intc(fill)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    i_stheta = library.convert_to_intc(stheta)
    i_etheta = library.convert_to_intc(etheta)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(fill, xpos, ypos, width, height, stheta, etheta, \
            colr, i_fill, i_xpos, i_ypos, i_width, i_height, i_stheta, \
            i_etheta, ul_colr)
    _fl_pieslice(i_fill, i_xpos, i_ypos, i_width, i_height, i_stheta, \
            i_etheta, ul_colr)


def fl_arcf(xpos, ypos, radius, stheta, etheta, colr):
    """fl_arcf(xpos, ypos, radius, stheta, etheta, colr)

    Draws a filled circular arc. If the difference between theta end and
    theta start is larger than 3600 (360 degrees), drawing is truncated to
    360 degrees.

    Parameters
    ----------
        xpos : int
            horizontal position of the center of the arc
        ypos : int
            vertical position of the center of the arc
        radius : int
            radius of the arc
        stheta : int
            starting angle of the arc in units of tenths of a degree (where 0
            stands for a direction of 3 o'clock, i.e. the right-most point of
            a circle)
        etheta : int
            ending angle of the arc in units of tenths of a degree (where 0
            stands for a direction of 3 o'clock, i.e. the right-most point of
            a circle)
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_arcf(120, 253, 40, 10, 60, xfdata.FL_FIREBRICK)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    fl_pieslice(1, (xpos - radius), (ypos - radius), (2 * radius), \
            (2 * radius), stheta, etheta, colr)


def fl_arc(xpos, ypos, radius, stheta, etheta, colr):
    """fl_arc(xpos, ypos, radius, stheta, etheta, colr)

    Draws an open circular arc. If the difference between theta end and
    theta start is larger than 3600 (360 degrees), drawing is truncated to
    360 degrees.

    Parameters
    ----------
        xpos : int
            horizontal position of the center of the arc
        ypos : int
            vertical position of the center of the arc
        radius : int
            radius of the arc
        stheta : int
            starting angle of the arc in units of tenths of a degree (where 0
            stands for a direction of 3 o'clock, i.e. the right-most point of
            a circle)
        etheta : int
            ending angle of the arc in units of tenths of a degree (where 0
            stands for a direction of 3 o'clock, i.e. the right-most point of
            a circle)
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_arc(120, 253, 40, 10, 60, xfdata.FL_FORESTGREEN)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    fl_pieslice(0, (xpos - radius), (ypos - radius), (2 * radius), \
            (2 * radius), stheta, etheta, colr)


# High level drawing routines

def fl_drw_frame(boxtype, xpos, ypos, width, height, colr, bndrwidth):
    """fl_drw_frame(boxtype, xpos, ypos, width, height, colr, bndrwidth)

    Draws a frame outside of the bounding box specified.

    Parameters
    ----------
        boxtype : int
            type of frame box. Values (from xfdata.py)
            - FL_NO_BOX (No box at all, it is transparent, just a label),
            - FL_UP_BOX (A box that comes out of the screen),
            - FL_DOWN_BOX (A box that goes down into the screen),
            - FL_BORDER_BOX (A flat box with a border),
            - FL_SHADOW_BOX (A flat box with a shadow),
            - FL_FRAME_BOX (A flat box with an engraved frame),
            - FL_ROUNDED_BOX (A rounded box),
            - FL_EMBOSSED_BOX (A flat box with an embossed frame),
            - FL_FLAT_BOX (A flat box without a border, normally invisible
              unless given a different color than the surroundings),
            - FL_RFLAT_BOX (A rounded box without a border, normally invisible
              unless given a different color than the surroundings),
            - FL_RSHADOW_BOX (A rounded box with a shadow),
            - FL_OVAL_BOX (A box shaped like an ellipse),
            - FL_ROUNDED3D_UPBOX (A rounded box coming out of the screen),
            - FL_ROUNDED3D_DOWNBOX (A rounded box going into the screen),
            - FL_OVAL3D_UPBOX (An oval box coming out of the screen),
            - FL_OVAL3D_DOWNBOX (An oval box going into the screen),
            - FL_OVAL3D_FRAMEBOX (An oval box with an engraved frame),
            - FL_OVAL3D_EMBOSSEDBOX (An oval box with an embossed frame)
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color
        bndrwidth : int
            width of boundary

    Examples
    --------
        >>> fl_drw_frame(xfdata.FL_UP_BOX, 470, 560, 170, 280,
                xfdata.FL_DIMGRAY, 2)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_drw_frame = library.cfuncproto(
        library.load_so_libforms(), "fl_drw_frame",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_COLOR, cty.c_int],
        """void fl_drw_frame(int style, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR c, int bw)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(boxtype, xfdata.BOXTYPE_list)
    i_boxtype = library.convert_to_intc(boxtype)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    i_bndrwidth = library.convert_to_intc(bndrwidth)
    library.keep_elem_refs(boxtype, xpos, ypos, width, height, colr, \
            bndrwidth, i_boxtype, i_xpos, i_ypos, i_width, i_height, \
            ul_colr, i_bndrwidth)
    _fl_drw_frame(i_boxtype, i_xpos, i_ypos, i_width, i_height, ul_colr, \
            i_bndrwidth)


def fl_drw_checkbox(boxtype, xpos, ypos, width, height, colr, bndrwidth):
    """fl_drw_checkbox(boxtype, xpos, ypos, width, height, colr, bndrwidth)

    Draws a box rotated 45 degrees.

    Parameters
    ----------
        boxtype : int
            type of checkbox to draw. Values (from xfdata.py)
            - FL_NO_BOX (No box at all, it is transparent, just a label),
            - FL_UP_BOX (A box that comes out of the screen),
            - FL_DOWN_BOX (A box that goes down into the screen),
            - FL_BORDER_BOX (A flat box with a border),
            - FL_SHADOW_BOX (A flat box with a shadow),
            - FL_FRAME_BOX (A flat box with an engraved frame),
            - FL_ROUNDED_BOX (A rounded box),
            - FL_EMBOSSED_BOX (A flat box with an embossed frame),
            - FL_FLAT_BOX (A flat box without a border, normally invisible
              unless given a different color than the surroundings),
            - FL_RFLAT_BOX (A rounded box without a border, normally invisible
              unless given a different color than the surroundings),
            - FL_RSHADOW_BOX (A rounded box with a shadow),
            - FL_OVAL_BOX (A box shaped like an ellipse),
            - FL_ROUNDED3D_UPBOX (A rounded box coming out of the screen),
            - FL_ROUNDED3D_DOWNBOX (A rounded box going into the screen),
            - FL_OVAL3D_UPBOX (An oval box coming out of the screen),
            - FL_OVAL3D_DOWNBOX (An oval box going into the screen),
            - FL_OVAL3D_FRAMEBOX (An oval box with an engraved frame),
            - FL_OVAL3D_EMBOSSEDBOX (An oval box with an embossed frame)
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color
        bndrwidth : int
            width of boundary

    Examples
    --------
        >>> fl_drw_checkbox(xfdata.FL_ROUNDED3D_UPBOX, 470, 560, 170, 280,
                xfdata.FL_LEMONCHIFFON, -2)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_drw_checkbox = library.cfuncproto(
        library.load_so_libforms(), "fl_drw_checkbox",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_COLOR, cty.c_int],
        """void fl_drw_checkbox(int type, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR col, int bw)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(boxtype, xfdata.BOXTYPE_list)
    i_boxtype = library.convert_to_intc(boxtype)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    i_bndrwidth = library.convert_to_intc(bndrwidth)
    library.keep_elem_refs(boxtype, xpos, ypos, width, height, colr, \
            bndrwidth, i_boxtype, i_xpos, i_ypos, i_width, i_height, \
            ul_colr, i_bndrwidth)
    _fl_drw_checkbox(i_boxtype, i_xpos, i_ypos, i_width, i_height, \
            ul_colr, i_bndrwidth)


# Interfaces

def fl_get_fontstruct(style, size):
    """fl_get_fontstruct(style, size) -> ptr_xfontstruct

    Finds out the X font structure for a particular size and style as used in
    XForms.

    Parameters
    ----------
        style : int
            font style for text. Values (from xfdata.py)
            - FL_NORMAL_STYLE (Helvetica normal text),
            - FL_BOLD_STYLE (Helvetica boldface text),
            - FL_ITALIC_STYLE (Helvetica italic text),
            - FL_BOLDITALIC_STYLE (Helvetica boldface and italic text),
            - FL_FIXED_STYLE (Courier fixed width, good for tables),
            - FL_FIXEDBOLD_STYLE (Courier bold fixed text),
            - FL_FIXEDITALIC_STYLE (Courier italic fixed text),
            - FL_FIXEDBOLDITALIC_STYLE (Courier boldface and italic fixed),
            - FL_TIMES_STYLE (Times-Roman like normal font),
            - FL_TIMESBOLD_STYLE (Times-Roman like boldface text),
            - FL_TIMESITALIC_STYLE (Times-Roman like italic text),
            - FL_TIMESBOLDITALIC_STYLE (Times-Roman like boldface and italic),
            - FL_MISC_STYLE (Charter normal text),
            - FL_MISCBOLD_STYLE (Charter boldface text),
            - FL_MISCITALIC_STYLE (Charter italic text),
            - FL_SYMBOL_STYLE (Symbol text),
            - FL_SHADOW_STYLE (Text casting a shadow, modifier mask),
            - FL_ENGRAVED_STYLE (Text engraved into the form, modifier mask),
            - FL_EMBOSSED_STYLE (Text standing out, modifier mask).
            Bitwise OR with any of modifiers is allowed.
        size : int
            font size for text. Values (from xfdata.py)
            - FL_TINY_SIZE (8 points font),
            - FL_SMALL_SIZE or FL_DEFAULT_SIZE (10 points font, default),
            - FL_NORMAL_SIZE (12 points font),
            - FL_MEDIUM_SIZE (14 points font),
            - FL_LARGE_SIZE (18 points font),
            - FL_HUGE_SIZE (24 points font),
            - or other numeric odd or even value

    Returns
    -------
        ptr_xfontstruct : pointer to xfdata.XFontStruct
            XFontStruct class instance

    Examples
    --------
        >>> pfstruc = fl_get_fontstruct(xfdata.FL_ITALIC_STYLE,
                xfdata.FL_NORMAL_STYLE)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_fontstruct = library.cfuncproto(
        library.load_so_libforms(), "fl_get_fontstruct",\
        cty.POINTER(xfdata.XFontStruct), [cty.c_int, cty.c_int],\
        """XFontStruct * fl_get_fontstruct(int style, int size)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(style, xfdata.TEXTSTYLE_list)
    i_style = library.convert_to_intc(style)
    i_size = library.convert_to_intc(size)
    library.keep_elem_refs(style, size, i_style, i_size)
    retval = _fl_get_fontstruct(i_style, i_size)
    return retval


fl_get_font_struct = fl_get_fontstruct
fl_get_fntstruct = fl_get_font_struct


def fl_get_mouse():
    """fl_get_mouse() -> win, xpos, ypos, keymask

    Finds out the current mouse position relative to the root window, and the
    current state of the modifier keys and pointer buttons.

    Returns
    -------
        win : long_pos
            window the mouse is in
        xpos : int
            horizontal position of mouse
        ypos : int
            vertical position of mouse
        keymask : int_pos
            bitwise inclusive OR of one or more of the button or modifier key
            bitmasks to match the current state of the mouse buttons and the
            modifier keys.

    Examples
    --------
        >>> win, xpos, ypos, kmsk = fl_get_mouse()

    API_diversion
    -------------
        API changed from XForms, upstream is fl_get_mouse(xpos, ypos, keymask)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_mouse = library.cfuncproto(
        library.load_so_libforms(), "fl_get_mouse",\
        xfdata.Window, [cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord), cty.POINTER(cty.c_uint)],\
        """Window fl_get_mouse(FL_Coord * x, FL_Coord * y,
          unsigned int * keymask)""")
    library.check_if_flinitialized()
    i_xpos, ptr_xpos = library.make_FL_Coord_and_pointer()
    i_ypos, ptr_ypos = library.make_FL_Coord_and_pointer()
    ui_keymask, ptr_keymask = library.make_uintc_and_pointer()
    library.keep_elem_refs(i_xpos, i_ypos, ui_keymask, ptr_xpos, ptr_ypos, \
            ptr_keymask)
    retval = _fl_get_mouse(ptr_xpos, ptr_ypos, ptr_keymask)
    return retval, i_xpos.value, i_ypos.value, ui_keymask.value


def fl_set_mouse(xpos, ypos):
    """fl_set_mouse(xpos, ypos)

    Moves the mouse to a specific location relative to the root window. Use
    this function sparingly, it can be extremely annoying for the user if the
    mouse position is changed by a program.

    Parameters
    ----------
        xpos : int
            horizontal position
        ypos : int
            vertical position

    Examples
    --------
        >>> fl_set_mouse(200, 120)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_mouse = library.cfuncproto(
        library.load_so_libforms(), "fl_set_mouse",\
        None, [xfdata.FL_Coord, xfdata.FL_Coord],\
        """void fl_set_mouse(FL_Coord mx, FL_Coord my)""")
    library.check_if_flinitialized()
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    library.keep_elem_refs(xpos, ypos, i_xpos, i_ypos)
    _fl_set_mouse(i_xpos, i_ypos)


def fl_get_win_mouse(win):
    """fl_get_win_mouse(win) -> win, xpos, ypos, keymask

    Finds out the position of the mouse relative to a certain window, and the
    current state of the modifier keys and pointer buttons.

    Parameters
    ----------
        win : long_pos
            window id

    Returns
    -------
        win : long_pos
            window id the mouse is in
        xpos : int
            horizontal position of mouse
        ypos : int
            vertical position of mouse
        keymask : int_pos
            bitwise inclusive OR of one or more of the button or modifier key
            bitmasks to match the current state of the mouse buttons and the
            modifier keys.

    Examples
    --------
        >>> win, xpos, ypos, keym = fl_get_win_mouse()

    API_diversion
    -------------
        API changed from XForms, upstream is
        fl_get_win_mouse(win, xpos, ypos, keymask)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_get_win_mouse = library.cfuncproto(
        library.load_so_libforms(), "fl_get_win_mouse",\
        xfdata.Window, [xfdata.Window, cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord), cty.POINTER(cty.c_uint)],\
        """Window fl_get_win_mouse(Window win, FL_Coord * x, FL_Coord * y,
        unsigned int * keymask)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    i_xpos, ptr_xpos = library.make_FL_Coord_and_pointer()
    i_ypos, ptr_ypos = library.make_FL_Coord_and_pointer()
    ui_keymask, ptr_keymask = library.make_uintc_and_pointer()
    library.keep_elem_refs(win, i_xpos, i_ypos, ui_keymask, ul_win, \
            ptr_xpos, ptr_ypos, ptr_keymask)
    retval = _fl_get_win_mouse(ul_win, ptr_xpos, ptr_ypos, ptr_keymask)
    return retval, i_xpos.value, i_ypos.value, ui_keymask.value


def fl_get_form_mouse(ptr_flform):
    """fl_get_form_mouse(ptr_flform) -> win, xpos, ypos, keymask

    Finds out the position of the mouse relative to a certain form, and the
    current state of the modifier keys and pointer buttons.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form

    Returns
    -------
        win : long_pos
            window the mouse is in
        xpos : int
            horizontal position of mouse
        ypos : int
            vertical position of mouse
        keymask : int_pos
            bitwise inclusive OR of one or more of the button or modifier key
            bitmasks to match the current state of the mouse buttons and the
            modifier keys.

    Examples
    --------
        >>> win, xpos, ypos, keym = fl_get_form_mouse()

    API_diversion
    -------------
        API changed from XForms, upstream is
        fl_get_form_mouse(fm, xpos, ypos, keymask)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_form_mouse = library.cfuncproto(
        library.load_so_libforms(), "fl_get_form_mouse",\
        xfdata.Window, [cty.POINTER(xfdata.FL_FORM),
        cty.POINTER(xfdata.FL_Coord), cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(cty.c_uint)],\
        """Window fl_get_form_mouse(FL_FORM * fm, FL_Coord * x,
           FL_Coord * y, unsigned int * keymask)""")
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    i_xpos, ptr_xpos = library.make_FL_Coord_and_pointer()
    i_ypos, ptr_ypos = library.make_FL_Coord_and_pointer()
    ui_keymask, ptr_keymask = library.make_uintc_and_pointer()
    library.keep_elem_refs(ptr_flform, i_xpos, i_ypos, ui_keymask)
    retval = _fl_get_form_mouse(ptr_flform, ptr_xpos, ptr_ypos, ptr_keymask)
    return retval, i_xpos.value, i_ypos.value, ui_keymask.value


def fl_win_to_form(win):
    """fl_win_to_form(win) -> ptr_flform

    Finds out the form the specified window belongs to.

    Parameters
    ----------
      win : long_pos
        window id

    Returns
    -------
        ptr_flform : pointer to xfdata.FL_FORM
            form, or None (on failure)

    Examples
    --------
        >>> pform2 = fl_win_to_form(win1)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_win_to_form = library.cfuncproto(
        library.load_so_libforms(), "fl_win_to_form",
        cty.POINTER(xfdata.FL_FORM), [xfdata.Window],\
        """FL_FORM * fl_win_to_form(Window win)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    library.keep_elem_refs(win, ul_win)
    retval = _fl_win_to_form(ul_win)
    return retval


def fl_set_form_icon(ptr_flform, icon, mask):
    """fl_set_form_icon(ptr_flform, icon, mask)

    Defines or changes the icon shown when a form is iconified.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form
        icon : long_pos
            icon pixmap resource id
        mask : long_pos
            mask pixmap resource id

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_form_icon = library.cfuncproto(
        library.load_so_libforms(), "fl_set_form_icon",\
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.Pixmap, xfdata.Pixmap],\
        """void fl_set_form_icon(FL_FORM * form, Pixmap p, Pixmap m)""")
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    ul_icon = library.convert_to_Pixmap(icon)
    ul_mask = library.convert_to_Pixmap(mask)
    library.keep_elem_refs(ptr_flform, icon, mask, ul_icon, ul_mask)
    _fl_set_form_icon(ptr_flform, ul_icon, ul_mask)


def fl_get_decoration_sizes(ptr_flform):
    """fl_get_decoration_sizes(ptr_flform)
    -> result, topsz, rightsz, bottomsz, leftsz

    Finds out the sizes of the "decorations" the window manager puts around a
    form's window.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form

    Returns
    -------
        result : int
            0 (on success), or -1 (if the form is not visible or it is a form
            embedded into another form)
        topsz : int
            top size
        rightsz : int
            right size
        bottomsz : int
            bottom size
        leftsz : int
            left size

    Examples
    --------
        >>> resl, top, right, bottom, left = fl_get_decoration_sizes(pform)

    API_diversion
    -------------
        API changed from XForms, upstream is
        fl_get_decoration_sizes(ptr_flform, top, right, bottom, left)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_decoration_sizes = library.cfuncproto(
        library.load_so_libforms(), "fl_get_decoration_sizes",
        cty.c_int, [cty.POINTER(xfdata.FL_FORM), cty.POINTER(cty.c_int),\
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int)],\
        """int fl_get_decoration_sizes(FL_FORM * form, int * top,
           int * right, int * bottom, int * left)""")
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    i_topsz, ptr_topsz = library.make_intc_and_pointer()
    i_rightsz, ptr_rightsz = library.make_intc_and_pointer()
    i_bottomsz, ptr_bottomsz = library.make_intc_and_pointer()
    i_leftsz, ptr_leftsz = library.make_intc_and_pointer()
    library.keep_elem_refs(ptr_flform, i_topsz, i_rightsz, i_bottomsz, \
            i_leftsz, ptr_topsz, ptr_rightsz, ptr_bottomsz, ptr_leftsz)
    retval = _fl_get_decoration_sizes(ptr_flform, ptr_topsz, ptr_rightsz, \
            ptr_bottomsz, ptr_leftsz)
    return retval, i_topsz.value, i_rightsz.value, i_bottomsz.value, \
           i_leftsz.value


def fl_raise_form(ptr_flform):
    """fl_raise_form(ptr_flform)

    Raises a form to the top of the screen so no other forms obscure it.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to be raised

    Examples
    --------
        >>> fl_raise_form(pform2)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_raise_form = library.cfuncproto(
        library.load_so_libforms(), "fl_raise_form",\
        None, [cty.POINTER(xfdata.FL_FORM)],\
        """void fl_raise_form(FL_FORM * p1)""")
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    _fl_raise_form(ptr_flform)


def fl_lower_form(ptr_flform):
    """fl_lower_form(ptr_flform)

    Lowers a form to the bottom of the stack.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to be lowered

    Examples
    --------
        >>> fl_lower_form(pform2)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_lower_form = library.cfuncproto(
        library.load_so_libforms(), "fl_lower_form",\
        None, [cty.POINTER(xfdata.FL_FORM)],\
        """void fl_lower_form(FL_FORM * p1)""")
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    _fl_lower_form(ptr_flform)


def fl_set_foreground(gctx, colr):
    """fl_set_foreground(gctx, colr)

    Defines foreground color in Graphics Contexts (GCs) other than the XForms
    default (gc[0]).

    Parameters
    ----------
        gctx : xfdata.GC
            Graphics context class instance. You can use fl_gc()?
        colr : long_pos
            XForms colormap index as color to be set as foreground

    Examples
    --------
        >>> graco = fl_gc()
        >>> fl_set_foreground(graco, xfdata.FL_LAWNGREEN)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_foreground = library.cfuncproto(
        library.load_so_libforms(), "fl_set_foreground",\
        None, [xfdata.GC, xfdata.FL_COLOR],\
        """void fl_set_foreground(GC  gctx, FL_COLOR col)""")
    library.check_if_flinitialized()
    library.verify_otherclassptr_type(gctx, xfdata.GC)
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(gctx, colr, ul_colr)
    _fl_set_foreground(gctx, ul_colr)


def fl_set_background(gctx, colr):
    """fl_set_background(gctx, colr)

    Defines background color in Graphics contexts (GCs) other than the XForms
    default (gc[0]).

    Parameters
    ----------
        gctx : xfdata.GC
            Graphics context class instance. You can use fl_gc()?
        colr : long_pos
            XForms colormap index as color to be set as background

    Examples
    --------
        >>> graco = fl_gc()
        >>> fl_set_foreground(graco, xfdata.FL_HONEYDEW)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_background = library.cfuncproto(
        library.load_so_libforms(), "fl_set_background",\
        None, [xfdata.GC, xfdata.FL_COLOR],\
        """void fl_set_background(GC  gctx, FL_COLOR col)""")
    library.check_if_flinitialized()
    library.verify_otherclassptr_type(gctx, xfdata.GC)
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(gctx, colr, ul_colr)
    _fl_set_background(gctx, ul_colr)


# General windowing support

def fl_wincreate(title):
    """fl_wincreate(title) -> win

    Creates a window with a specified title.

    Parameters
    ----------
        title : str
            title of the window

    Returns
    -------
        win : long_pos
            created window id

    Examples
    --------
        >>> win2 = fl_wincreate("My long title")

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_wincreate = library.cfuncproto(
        library.load_so_libforms(), "fl_wincreate",\
        xfdata.Window, [xfdata.STRING],\
        """Window fl_wincreate(const char * label)""")
    library.check_if_flinitialized()
    s_title = library.convert_to_stringc(title)
    library.keep_elem_refs(title, s_title)
    retval = _fl_wincreate(s_title)
    return retval


def fl_winshow(win):
    """fl_winshow(win) -> win

    Shows the window created with fl_wincreate().

    Parameters
    ----------
        win : long_pos
            window id to show

    Returns
    -------
        win : long_pos
            window id shown

    Examples
    --------
        >>> winw = fl_winshow(win2)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winshow = library.cfuncproto(
        library.load_so_libforms(), "fl_winshow",\
        xfdata.Window, [xfdata.Window],\
        """Window fl_winshow(Window win)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    library.keep_elem_refs(win, ul_win)
    retval = _fl_winshow(ul_win)
    return retval


def fl_winopen(title):
    """fl_winopen(title) -> win

    Opens (creates and shows) a toplevel window with the specified title.

    Parameters
    ----------
        title : str
            title of the window

    Returns
    -------
        win : long_pos
            created window id

    Examples
    --------
        >>> win2 = fl_winopen("My long title")

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_winopen = library.cfuncproto(
        library.load_so_libforms(), "fl_winopen", \
        xfdata.Window, [xfdata.STRING], \
        """Window fl_winopen(const char * label)""")
    library.check_if_flinitialized()
    s_title = library.convert_to_stringc(title)
    library.keep_elem_refs(title, s_title)
    retval = _fl_winopen(s_title)
    return retval


def fl_winhide(win):
    """fl_winhide(win)

    Hides a shown window.

    Parameters
    ----------
        win : long_pos
            window id to hide

    Examples
    --------
        >>> fl_winhide(win2)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winhide = library.cfuncproto(
        library.load_so_libforms(), "fl_winhide", \
        None, [xfdata.Window], \
        """void fl_winhide(Window win)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    library.keep_elem_refs(win, ul_win)
    _fl_winhide(ul_win)


def fl_winclose(win):
    """fl_winclose(win)

    Closes (hides and destroys) the specified window.

    Parameters
    ----------
        win : long_pos
            window id to close

    Examples
    --------
        >>> fl_winclose(win2)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winclose = library.cfuncproto(
        library.load_so_libforms(), "fl_winclose", \
        None, [xfdata.Window], \
        """void fl_winclose(Window win)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    library.keep_elem_refs(win, ul_win)
    _fl_winclose(win, ul_win)


def fl_winset(win):
    """fl_winset(win)

    Defines the "current window", defined as the window the flobject that uses
    the drawing routine belongs to.

    Parameters
    ----------
        win : long_pos
            window id to be set

    Examples
    --------
        >>> fl_winset(win3)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_winset = library.cfuncproto(
        library.load_so_libforms(), "fl_winset", \
        None, [xfdata.Window], \
        """void fl_winset(Window win)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    library.keep_elem_refs(win, ul_win)
    _fl_winset(ul_win)


def fl_winreparent(win, winnewparent):
    """fl_winreparent(win, winnewparent) -> result

    Makes a toplevel window a subwindow of another (new parent) window; both
    the window and the parent window must be valid ones.

    Parameters
    ----------
        win : long_pos
            window id to be made a subwindow
        winnewparent : long_pos
            window id to become its new parent window

    Returns
    -------
        result : int
            None, or -1 (on failure)

    Examples
    --------
        >>> exitval = fl_winreparent(win1, win3)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winreparent = library.cfuncproto(
        library.load_so_libforms(), "fl_winreparent", \
        cty.c_int, [xfdata.Window, xfdata.Window], \
        """int fl_winreparent(Window win, Window new_parent)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    ul_winnewparent = library.convert_to_Window(winnewparent)
    library.keep_elem_refs(win, winnewparent, ul_win, ul_winnewparent)
    retval = _fl_winreparent(ul_win, ul_winnewparent)
    return retval


def fl_winfocus(win):
    """fl_winfocus(win)

    Keyboard input is directed to the specified window, overriding the
    keyboard focus assignment.

    Parameters
    ----------
        win : long_pos
            window id

    Examples
    --------
        >>> fl_winfocus(win3)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winfocus = library.cfuncproto(
        library.load_so_libforms(), "fl_winfocus", \
        None, [xfdata.Window], \
        """void fl_winfocus(Window win)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    library.keep_elem_refs(win, ul_win)
    _fl_winfocus(ul_win)


def fl_winget():
    """fl_winget() -> win

    Queries the current window. One caveat about fl_winget() is that it can
    return None if called outside of a flobject's event handler, depending on
    where the mouse is. Thus, the return value of this function should be
    checked when called outside of a flobject handler.

    Returns
    -------
        win : long_pos
            window id

    Examples
    --------
        >>> currwin = fl_winget()

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winget = library.cfuncproto(
        library.load_so_libforms(), "fl_winget", \
        xfdata.Window, [], \
        """Window fl_winget()""")
    library.check_if_flinitialized()
    retval = _fl_winget()
    return retval


def fl_iconify(win):
    """fl_iconify(win) -> result

    Iconifies the specified window.

    Parameters
    ----------
        win : long_pos
            window id

    Returns
    -------
        result : int
            non-zero, or 0 (on failure)

    Examples
    --------
        >>> fl_iconify(win2)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_iconify = library.cfuncproto(
        library.load_so_libforms(), "fl_iconify", \
        cty.c_int, [xfdata.Window], \
        """int fl_iconify(Window win)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    library.keep_elem_refs(win, ul_win)
    retval = _fl_iconify(ul_win)
    return retval


def fl_winresize(win, width, height):
    """fl_winresize(win, width, height)

    Resizes a window.

    Parameters
    ----------
        win : long_pos
            window id to resize
        width : int
            new width in coord units
        height : int
            new height in coord units

    Examples
    --------
        >>> fl_winresize(win6, 547, 624)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winresize = library.cfuncproto(
        library.load_so_libforms(), "fl_winresize", \
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord], \
        """void fl_winresize(Window win, FL_Coord neww, FL_Coord newh)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    i_width = library.convert_to_intc(width)
    i_height = library.convert_to_intc(height)
    library.keep_elem_refs(win, width, height, ul_win, i_width, i_height)
    _fl_winresize(ul_win, i_width, i_height)


def fl_winmove(win, xpos, ypos):
    """fl_winmove(win, xpos, ypos)

    Moves the specified window to a new position.

    Parameters
    ----------
        win : long_pos
            window id to move to a new position
        xpos : int
            new horizontal position (upper-left corner)
        ypos : int
            new vertical position (upper-left corner)

    Examples
    --------
        >>> fl_winmove(win5, 116, 331)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winmove = library.cfuncproto(
        library.load_so_libforms(), "fl_winmove", \
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord], \
        """void fl_winmove(Window win, FL_Coord dx, FL_Coord dy)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    i_xpos = library.convert_to_intc(xpos)
    i_ypos = library.convert_to_intc(ypos)
    library.keep_elem_refs(win, xpos, ypos, ul_win, i_xpos, i_ypos)
    _fl_winmove(ul_win, i_xpos, i_ypos)


def fl_winreshape(win, xpos, ypos, width, height):
    """fl_winreshape(win, xpos, ypos, width, height)

    Reshapes (resizes and moves) a window.

    Parameters
    ----------
        win : long_pos
            window id to reshape
        xpos : int
            new horizontal position (upper-left corner)
        ypos : int
            new vertical position (upper-left corner)
        width : int
            new width in coord units
        height : int
            new height in coord units

    Examples
    --------
        >>> fl_winreshape(win5, 116, 331, 144, 182)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winreshape = library.cfuncproto(
        library.load_so_libforms(), "fl_winreshape", \
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord], \
        """void fl_winreshape(Window win, FL_Coord dx, FL_Coord dy,
           FL_Coord w, FL_Coord h)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    i_xpos = library.convert_to_intc(xpos)
    i_ypos = library.convert_to_intc(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(win, xpos, ypos, width, height, ul_win, \
            i_xpos, i_ypos, i_width, i_height)
    _fl_winreshape(ul_win, i_xpos, i_ypos, i_width, i_height)


def fl_winicon(win, icon, mask):
    """fl_winicon(win, icon, mask)

    Installs an icon for the window.

    Parameters
    ----------
        win : long_pos
            window id
        icon : long_pos
            pixmap icon resource id to be installed in window
        mask : long_pos
            pixmap mask resource id

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winicon = library.cfuncproto(
        library.load_so_libforms(), "fl_winicon", \
        None, [xfdata.Window, xfdata.Pixmap, xfdata.Pixmap], \
        """void fl_winicon(Window win, Pixmap p, Pixmap m)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    ul_icon = library.convert_to_Pixmap(icon)
    ul_mask = library.convert_to_Pixmap(mask)
    library.keep_elem_refs(win, icon, mask, ul_win, ul_icon, ul_mask)
    _fl_winicon(ul_win, ul_icon, ul_mask)


def fl_winbackground(win, pixelval):
    """fl_winbackground(win, pixelval)

    Defines the background of window to the color a certain pixel has.

    Parameters
    ----------
        win : long_pos
            window id
        pixelval : long_pos
            pixel value X understands, to be used as background color

    Examples
    --------
        >>> fl_winbackground(win1, xfl.fl_get_pixel(xfdata.FL_GHOSTWHITE))

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_winbackground = library.cfuncproto(
        library.load_so_libforms(), "fl_winbackground", \
        None, [xfdata.Window, cty.c_ulong], \
        """void fl_winbackground(Window win, unsigned long bk)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    ul_pixelval = library.convert_to_FL_COLOR(pixelval)
    library.keep_elem_refs(win, pixelval, ul_win, ul_pixelval)
    _fl_winbackground(ul_win, ul_pixelval)


fl_win_background = fl_winbackground


def fl_winstepsize(win, xunit, yunit):
    """fl_winstepsize(win, xunit, yunit)

    Defines the steps by which the size of a window can be changed. Changes to
    the window size will be multiples of specified units after this call. Note
    that this only applies to interactive resizing.

    Parameters
    ----------
        win : long_pos
            window id
        xunit : int
            number of pixels of changes per unit in horizontal direction
        yunit : int
            number of pixels of changes per unit in vertical direction

    Examples
    --------
        >>> fl_winstepsize(win0, 10, 10)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winstepsize = library.cfuncproto(
        library.load_so_libforms(), "fl_winstepsize", \
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord], \
        """void fl_winstepsize(Window win, FL_Coord dx, FL_Coord dy)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    i_xunit = library.convert_to_intc(xunit)
    i_yunit = library.convert_to_intc(yunit)
    library.keep_elem_refs(win, xunit, yunit, ul_win, i_xunit, i_yunit)
    _fl_winstepsize(ul_win, i_xunit, i_yunit)


fl_winstepunit = fl_winstepsize
fl_set_winstepunit = fl_winstepsize
fl_set_winstepunit = fl_winstepunit


def fl_winisvalid(win):
    """fl_winisvalid(win) -> result

    Checks if a window id is valid or not. Note that excessive use of this
    function may negatively impact performance.

    Parameters
    ----------
        win : long_pos
            window id to evaluate

    Returns
    -------
        result : int
            not 0 (on success)

    Examples
    --------
        >>> if fl_winisvalid(win3):
        >>> ... <something>

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winisvalid = library.cfuncproto(
        library.load_so_libforms(), "fl_winisvalid", \
        cty.c_int, [xfdata.Window], \
        """int fl_winisvalid(Window win)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    library.keep_elem_refs(win, ul_win)
    retval = _fl_winisvalid(ul_win)
    return retval


def fl_wintitle(win, title):
    """fl_wintitle(win, title)

    Changes the window title (and its associated icon title).

    Parameters
    ----------
        win : long_pos
            window id
        title : str
            window title to be set

    Examples
    --------
        >>> win0 = fl_winget()
        >>> fl_wintitle(win0, "My brand new title")

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_wintitle = library.cfuncproto(
        library.load_so_libforms(), "fl_wintitle", \
        None, [xfdata.Window, xfdata.STRING], \
        """void fl_wintitle(Window win, const char * title)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    s_title = library.convert_to_stringc(title)
    library.keep_elem_refs(win, title, ul_win, s_title)
    _fl_wintitle(ul_win, s_title)


def fl_winicontitle(win, title):
    """fl_winicontitle(win, title)

    Changes only the icon title for the window.

    Parameters
    ----------
        win : long_pos
            window id
        title : str
            icon title to be set

    Examples
    --------
        >>> fl_winicontitle(win0, "My icon label")

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winicontitle = library.cfuncproto(
        library.load_so_libforms(), "fl_winicontitle", \
        None, [xfdata.Window, xfdata.STRING], \
        """void fl_winicontitle(Window win, const char * title)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    s_title = library.convert_to_stringc(title)
    library.keep_elem_refs(win, title, ul_win, s_title)
    _fl_winicontitle(ul_win, s_title)


def fl_winposition(xpos, ypos):
    """fl_winposition(xpos, ypos)

    Defines the position of a window to be opened.

    Parameters
    ----------
        xpos : int
            horizontal position of window (upper-left corner)
        ypos : int
            vertical position of window (upper-left corner)

    Examples
    --------
        >>> fl_winposition(140, 123)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winposition = library.cfuncproto(
        library.load_so_libforms(), "fl_winposition",
        None, [xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_winposition(FL_Coord x, FL_Coord y)""")
    library.check_if_flinitialized()
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    library.keep_elem_refs(xpos, ypos, i_xpos, i_ypos)
    _fl_winposition(i_xpos, i_ypos)


fl_pref_winposition = fl_winposition


def fl_winminsize(win, width, height):
    """fl_winminsize(win, width, height)

    Defines a constraint for a resizable window whose size will be within a
    range not less than minimum. To be used before calling fl_winopen().

    Parameters
    ----------
        win : long_pos
            window id to be set
        width : int
            minimum width of window in coord units
        height : int
            minimum height of window in coord units

    Examples
    --------
        >>> fl_winminsize(win1, 500, 500)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winminsize = library.cfuncproto(
        library.load_so_libforms(), "fl_winminsize",
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_winminsize(Window win, FL_Coord w, FL_Coord h)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(win, width, height, ul_win, i_width, i_height)
    _fl_winminsize(ul_win, i_width, i_height)


def fl_winmaxsize(win, width, height):
    """fl_winmaxsize(win, width, height)

    Defines a constraint for a resizable window whose size will be within a
    range not bigger than maximum. To be used before calling fl_winopen().

    Parameters
    ----------
        win : long_pos
            window id to be set
        width : int
            maximum width of window in coord units
        height : int
            maximum height of window in coord units

    Examples
    --------
        >>> fl_winmaxsize(win1, 500, 500)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winmaxsize = library.cfuncproto(
        library.load_so_libforms(), "fl_winmaxsize",
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_winmaxsize(Window win, FL_Coord w, FL_Coord h)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(win, width, height, ul_win, i_width, i_height)
    _fl_winmaxsize(ul_win, i_width, i_height)


def fl_winaspect(win, xratio, yratio):
    """fl_winaspect(win, xratio, yratio)

    Defines the aspect ratio of the window for later interactive resizing.

    Parameters
    ----------
        win : long_pos
            window id to be set
        xratio : int
            horizontal aspect ratio
        yratio : int
            vertical aspect ratio

    Examples
    --------
        >>> fl_winaspect(win0, 2, 4)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_winaspect = library.cfuncproto(
        library.load_so_libforms(), "fl_winaspect",
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_winaspect(Window win, FL_Coord x, FL_Coord y)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    i_xratio = library.convert_to_FL_Coord(xratio)
    i_yratio = library.convert_to_FL_Coord(yratio)
    library.keep_elem_refs(win, xratio, yratio, ul_win, i_xratio, i_yratio)
    _fl_winaspect(ul_win, i_xratio, i_yratio)


def fl_reset_winconstraints(win):
    """fl_reset_winconstraints(win)

    Changes constraints (size and aspect ratio) to default ones on an active
    window.

    Parameters
    ----------
        win : long_pos
            window id to be reset

    Examples
    --------
        >>> fl_reset_constraints(win0)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_reset_winconstraints = library.cfuncproto(
        library.load_so_libforms(), "fl_reset_winconstraints",
        None, [xfdata.Window],
        """void fl_reset_winconstraints(Window win)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    library.keep_elem_refs(win)
    _fl_reset_winconstraints(ul_win)


def fl_winsize(width, height):
    """fl_winsize(width, height)

    Defines the preferred window size and makes the window non-resizeable. To
    be used before calling fl_winopen().

    Parameters
    ----------
        width : int
            width in coord units
        height : int
            height in coord units

    Examples
    --------
        >>> fl_winsize(700, 600)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_winsize = library.cfuncproto(
        library.load_so_libforms(), "fl_winsize",
        None, [xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_winsize(FL_Coord w, FL_Coord h)""")
    library.check_if_flinitialized()
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(width, height, i_width, i_height)
    _fl_winsize(i_width, i_height)


fl_pref_winsize = fl_winsize


def fl_initial_winsize(width, height):
    """fl_initial_winsize(width, height)

    Defines the preferred window size. To be used before calling fl_winopen().

    Parameters
    ----------
        width : int
            width in coord units
        height : int
            height in coord units

    Examples
    --------
        >>> fl_initial_winsize(700, 600)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_initial_winsize = library.cfuncproto(
        library.load_so_libforms(), "fl_initial_winsize",
        None, [xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_initial_winsize(FL_Coord w, FL_Coord h)""")
    library.check_if_flinitialized()
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(width, height, i_width, i_height)
    _fl_initial_winsize(i_width, i_height)


# TODO: verify if it is supposed to be used in python
def fl_initial_winstate(state):
    """fl_initial_winstate(state)

    Defines initial state, normal or iconic, of the window.

    Parameters
    ----------
        state : int
            window state to be set. Values (from xfdata.py)
            - NormalState (most applications want to start this way),
            - IconicState (application wants to start as an icon).

    Examples
    --------
        >>> fl_initial_winstate(xfdata.IconicState)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_initial_winstate = library.cfuncproto(
        library.load_so_libforms(), "fl_initial_winstate",
        None, [cty.c_int],
        """void fl_initial_winstate(int state)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(state, xfdata.WINSTATE_list)
    i_state = library.convert_to_intc(state)
    library.keep_elem_refs(state, i_state)
    _fl_initial_winstate(i_state)


def fl_create_colormap(ptr_xvisualinfo, numfilledcolrs):
    """fl_create_colormap(ptr_xvisualinfo, numfilledcolrs) -> colormap

    Creates a colormap appropriate for a given visual to be used with
    a canvas.

    Parameters
    ----------
        ptr_xvisualinfo : pointer to xfdata.XVisualInfo
            XVisualInfo class instance
        numfilledcolrs : int
            how many colors in the newly created colormap should be filled
            with XForms' default colors (to avoid flashing effects)

    Returns
    -------
        colormap : long_pos
            created colormap

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_create_colormap = library.cfuncproto(
        library.load_so_libforms(), "fl_create_colormap",
        xfdata.Colormap, [cty.POINTER(xfdata.XVisualInfo), cty.c_int],
        """Colormap fl_create_colormap(XVisualInfo * xv, int nfill)""")
    library.check_if_flinitialized()
    i_numfilledcolrs = library.convert_to_intc(numfilledcolrs)
    library.keep_elem_refs(ptr_xvisualinfo, numfilledcolrs, \
            i_numfilledcolrs)
    retval = _fl_create_colormap(ptr_xvisualinfo, i_numfilledcolrs)
    return retval


def fl_wingeometry(xpos, ypos, width, height):
    """fl_wingeometry(xpos, ypos, width, height)

    Defines the initial geometry (position and size) of the window to be
    opened; the window will not be resizable.

    Parameters
    ----------
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units

    Examples
    --------
        >>> fl_wingeometry(192, 231, 450, 550)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_wingeometry = library.cfuncproto(
        library.load_so_libforms(), "fl_wingeometry",
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord],
        """void fl_wingeometry(FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h)""")
    library.check_if_flinitialized()
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(xpos, ypos, width, height, i_xpos, i_ypos, \
            i_width, i_height)
    _fl_wingeometry(i_xpos, i_ypos, i_width, i_height)


fl_pref_wingeometry = fl_wingeometry


def fl_initial_wingeometry(xpos, ypos, width, height):
    """fl_initial_wingeometry(xpos, ypos, width, height)

    Defines the initial geometry (position and size) of the window to be
    opened.

    Parameters
    ----------
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units

    Examples
    --------
        >>> fl_initial_wingeometry(192, 231, 450, 550)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_initial_wingeometry = library.cfuncproto(
        library.load_so_libforms(), "fl_initial_wingeometry",
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord],
        """void fl_initial_wingeometry(FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h)""")
    library.check_if_flinitialized()
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(xpos, ypos, width, height, i_xpos, i_ypos, \
            i_width, i_height)
    _fl_initial_wingeometry(i_xpos, i_ypos, i_width, i_height)


def fl_noborder():
    """fl_noborder()

    Suppresses the window manager's decoration (before creating the window).

    Examples
    --------
        >>> fl_noborder()

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_noborder = library.cfuncproto(
        library.load_so_libforms(), "fl_noborder",
        None, [],
        """void fl_noborder()""")
    library.check_if_flinitialized()
    _fl_noborder()


def fl_transient():
    """fl_transient()

    Makes a window a transient one (before creating the window).

    Examples
    --------
        >>> fl_transient()

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_transient = library.cfuncproto(
        library.load_so_libforms(), "fl_transient",
        None, [], \
        """void fl_transient()""")
    library.check_if_flinitialized()
    _fl_transient()


def fl_get_winsize(win):
    """fl_get_winsize(win) -> width, height

    Finds out the size of the specified window.

    Parameters
    ----------
        win : long_pos
            window id to evaluate

    Returns
    -------
        width : int
            width of window
        height : int
            height of window

    Examples
    --------
        >>> wid, hei = fl_get_winsize(win0)

    API_diversion
    -------------
        API changed from XForms, upstream is
        fl_get_winsize(win, width, height)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_winsize = library.cfuncproto(
        library.load_so_libforms(), "fl_get_winsize",
        None, [xfdata.Window, cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord)],
        """void fl_get_winsize(Window win, FL_Coord * w, FL_Coord * h)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    i_width, ptr_width = library.make_intc_and_pointer()
    i_height, ptr_height = library.make_intc_and_pointer()
    library.keep_elem_refs(win, ul_win, i_width, i_height, ptr_width, \
            ptr_height)
    _fl_get_winsize(ul_win, ptr_width, ptr_height)
    return i_width.value, i_height.value


def fl_get_winorigin(win):
    """fl_get_winorigin(win) -> xpos, ypos

    Finds out the origin (position) of the specified window.

    Parameters
    ----------
        win : long_pos
            window id to evaluate

    Returns
    -------
        xpos : int
            horizontal position of window
        ypos : int
            vertical position of window

    Examples
    --------
        >>> xpos, ypos = fl_get_winorigin(win0)

    API_diversion
    -------------
        API changed from XForms, upstream is
        fl_get_winorigin(win, xpos, ypos)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_winorigin = library.cfuncproto(
        library.load_so_libforms(), "fl_get_winorigin",
        None, [xfdata.Window, cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord)],
        """void fl_get_winorigin(Window win, FL_Coord * x, FL_Coord * y)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    i_xpos, ptr_xpos = library.make_FL_Coord_and_pointer()
    i_ypos, ptr_ypos = library.make_FL_Coord_and_pointer()
    library.keep_elem_refs(win, ul_win, i_xpos, i_ypos, ptr_xpos, ptr_ypos)
    _fl_get_winorigin(win, ptr_xpos, ptr_ypos)
    return i_xpos.value, i_ypos.value


def fl_get_wingeometry(win):
    """fl_get_wingeometry(win) -> xpos, ypos, width, height

    Finds out geometry (position and size) of a window.

    Parameters
    ----------
        win : long_pos
            window id to evaluate

    Returns
    -------
        xpos : int
            horizontal position of window
        ypos : int
            vertical position of window
        width : int
            width of window
        height : int
            height of window

    Examples
    --------
        >>> xpos, ypos, wid, hei = fl_get_wingeometry(win0)

    API_diversion
    -------------
        API changed from XForms, upstream is
        fl_get_wingeometry(win, xpos, ypos, width, height)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_wingeometry = library.cfuncproto(
        library.load_so_libforms(), "fl_get_wingeometry",
        None, [xfdata.Window, cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord), cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord)],
        """void fl_get_wingeometry(Window win, FL_Coord * x,
           FL_Coord * y, FL_Coord * w, FL_Coord * h)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    i_xpos, ptr_xpos = library.make_FL_Coord_and_pointer()
    i_ypos, ptr_ypos = library.make_FL_Coord_and_pointer()
    i_width, ptr_width = library.make_FL_Coord_and_pointer()
    i_height, ptr_height = library.make_FL_Coord_and_pointer()
    library.keep_elem_refs(win, i_xpos, i_ypos, i_width, i_height, ul_win, \
            ptr_xpos, ptr_ypos, ptr_width, ptr_height)
    _fl_get_wingeometry(ul_win, ptr_xpos, ptr_ypos, ptr_width, ptr_height)
    return i_xpos.value, i_ypos.value, i_width.value, i_height.value


# fl_get_win_size() function placeholder (backwards)
# fl_get_win_origin() function placeholder (backwards)
# fl_get_win_geometry() function placeholder (backwards)
# fl_initial_winposition() function placeholder (backwards)


def fl_get_display():
    library.check_if_flinitialized()
    return xfdata.fl_display


def FL_FormDisplay(ptr_flform):
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    return xfdata.fl_display


# undocumented data, maybe dismissed? --LK
def FL_ObjectDisplay(ptr_flobject):
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    return xfdata.fl_display


def FL_IS_CANVAS(ptr_flobject):
    if (flbasic.fl_get_object_objclass(ptr_flobject) == \
            xfdata.FL_CANVAS) or \
            (flbasic.fl_get_object_objclass(ptr_flobject) == \
            xfdata.FL_GLCANVAS):
        return True
    else:
        return False


# The window a flobject belongs to - for drawing

def FL_ObjWin(ptr_flobject):
    """FL_ObjWin(ptr_flobject) -> win

    Finds out the window id a flobject belongs to (for general use).

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject

    Returns
    -------
        win : long_pos
            window id

    Examples
    --------
        >>> wind = FL_ObjWin(pobj)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    if FL_IS_CANVAS(ptr_flobject):
        return flcanvas.fl_get_canvas_id(ptr_flobject)
    else:
        return ptr_flobject.contents.form.contents.window       #.value


def fl_get_real_object_window(ptr_flobject):
    """fl_get_real_object_window(ptr_flobject) -> win

    Finds out the real window id a flobject belongs to (to be used for cursor
    or pointer routines).

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            object

    Returns
    -------
        win : long_pos
            window id

    Examples
    --------
        >>> wind = fl_get_real_object_window(pobj)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_real_object_window = library.cfuncproto(
        library.load_so_libforms(), "fl_get_real_object_window",
        xfdata.Window, [cty.POINTER(xfdata.FL_OBJECT)],
        """Window fl_get_real_object_window(FL_OBJECT * ob)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_get_real_object_window(ptr_flobject)
    return retval


FL_OBJECT_WID = FL_ObjWin


# TODO: verify if fl_XNextEvent(), fl_XPeekEvent(), fl_XEventsQueued() and
# fl_XPutbackEvent() functions are of any use in python.

# Replacements for X functions that access the event queue

def fl_XNextEvent(ptr_xevent):
    """fl_XNextEvent(ptr_xevent) -> result, ptr_xevent

    X11 XNextEvent equivalent function.

    Parameters
    ----------
        ptr_xevent : pointer to xfdata.XEvent
            XEvent class instance

    Returns
    -------
        result : int
            always 1
        ptr_xevent : pointer to xfdata.XEvent
            same XEvent passed as arg, and modified by this function

    Examples
    --------
        >>> *todo*

    API_diversion
    -------------
        API changed from XForms, upstream is fl_XNextEvent(ptr_xevent)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_XNextEvent = library.cfuncproto(
        library.load_so_libforms(), "fl_XNextEvent",
        cty.c_int, [cty.POINTER(xfdata.XEvent)],
        """int fl_XNextEvent(XEvent * xev)""")
    library.check_if_flinitialized()
    library.verify_otherclassptr_type(ptr_xevent, \
            cty.POINTER(xfdata.XEvent))
    library.keep_elem_refs(ptr_xevent)
    retval = _fl_XNextEvent(ptr_xevent)
    return retval, ptr_xevent


def fl_XPeekEvent(ptr_xevent):
    """fl_XPeekEvent(ptr_xevent) -> result, ptr_xevent

    X11 XPeekEvent equivalent function. Blocks if there is no event until a
    new one has arrived.

    Parameters
    ----------
        ptr_xevent : pointer to xfdata.XEvent
            XEvent class instance

    Returns
    -------
        result : int
            always 1
        ptr_xevent : pointer to xfdata.XEvent
            same XEvent passed as arg, and modified by this function

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_XPeekEvent = library.cfuncproto(
        library.load_so_libforms(), "fl_XPeekEvent",
        cty.c_int, [cty.POINTER(xfdata.XEvent)],
        """int fl_XPeekEvent(XEvent * xev)""")
    library.check_if_flinitialized()
    library.verify_otherclassptr_type(ptr_xevent, \
            cty.POINTER(xfdata.XEvent))
    library.keep_elem_refs(ptr_xevent)
    retval = _fl_XPeekEvent(ptr_xevent)
    return retval, ptr_xevent


def fl_XEventsQueued(mode):
    """fl_XEventsQueued(mode) -> yesno

    X11 XEventsQueued equivalent function, finds out if there are any events
    in the event queue.

    Parameters
    ----------
        mode : int
            mode (currently not used)

    Returns
    -------
        yesno : int
            True (if there are events), ot False (if there are not)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_XEventsQueued = library.cfuncproto(
        library.load_so_libforms(), "fl_XEventsQueued",
        cty.c_int, [cty.c_int],
        """int fl_XEventsQueued(int mode)""")
    library.check_if_flinitialized()
    i_mode = library.convert_to_intc(mode)
    library.keep_elem_refs(mode, i_mode)
    retval = _fl_XEventsQueued(i_mode)
    return retval


def fl_XPutBackEvent(ptr_xevent):
    """fl_XPutBackEvent(ptr_xevent)

    X11 XPutBackEvent equivalent function, allows to push back an event onto
    the queue.

    Parameters
    ----------
        ptr_xevent : pointer to xfdata.XEvent
            XEvent class instance

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_XPutBackEvent = library.cfuncproto(
        library.load_so_libforms(), "fl_XPutBackEvent",
        None, [cty.POINTER(xfdata.XEvent)],
        """void fl_XPutBackEvent(XEvent * xev)""")
    library.check_if_flinitialized()
    library.verify_otherclassptr_type(ptr_xevent, \
            cty.POINTER(xfdata.XEvent))
    library.keep_elem_refs(ptr_xevent)
    _fl_XPutBackEvent(ptr_xevent)


def fl_last_event():
    """fl_last_event() -> ptr_xevent

    Finds out the last X event. If this routine is used outside of a
    callback function, the value returned may not be the real "last
    event" if the program was idling and, in this case, it returns a
    synthetic xfdata.MotionNotify event.

    Returns
    -------
        ptr_xevent : pointer to xfdata.XEvent
            XEvent class instance

    Examples
    --------
        >>> pxev = fl_last_event()

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_last_event = library.cfuncproto(
        library.load_so_libforms(), "fl_last_event",
        cty.POINTER(xfdata.XEvent), [],
        """const char * fl_last_event()""")
    library.check_if_flinitialized()
    retval = _fl_last_event()
    return retval


def fl_set_event_callback(pyfn_AppEventCb, userdata):
    """fl_set_event_callback(pyfn_AppEventCb, userdata) -> AppEventCb

    Defines up an event callback routine. Whenever an event happens, the
    callback function is invoked with the event as the first argument. This
    assumes the application program solicits the events and further, the
    callback routine should be prepared to handle all X events for all
    non-form windows. This routine will be called whenever an X Event is
    pending for the application's own window.

    Parameters
    ----------
        pyfn_AppEventCb : python function callback, returned value
            name referring to function(ptr_xevent, [pointer to void]pvdata)
            -> [int]num.
            The callback function normally should return 0, unless the
            event is not for one of the application-managed windows.
        userdata : any type (e.g. None, int, str, etc..)
            user data to be passed to function; invoked callback has to take
            care of type check and re-cast from ptr_void to chosen type using
            appropriate xfstruct.fls_convert_ptrvoid_to_*() function

    Returns
    -------
        AppEventCb : xfdata.FL_APPEVENT_CB
            old event callback

    Examples
    --------
        >>> def eventcb(pxev, pvdata):
        >>> ... <something>
        >>> ... return 0
        >>> fl_set_event_callback(eventcb, None)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    #FL_APPEVENT_CB = cty.CFUNCTYPE(cty.c_int, cty.POINTER(XEvent),
    #       cty.c_void_p)
    _fl_set_event_callback = library.cfuncproto(
        library.load_so_libforms(), "fl_set_event_callback",
        xfdata.FL_APPEVENT_CB, [xfdata.FL_APPEVENT_CB, cty.c_void_p],
        """FL_APPEVENT_CB fl_set_event_callback(FL_APPEVENT_CB callback,
           void * user_data)""")        # cty.c_void_p]
    library.check_if_flinitialized()
    library.verify_function_type(pyfn_AppEventCb)
    cfn_AppEventCb = xfdata.FL_APPEVENT_CB(pyfn_AppEventCb)
    ptr_vdata = library.convert_userdata_to_ptrvoid(userdata)
    library.keep_cfunc_refs(cfn_AppEventCb, pyfn_AppEventCb)
    library.keep_elem_refs(userdata, ptr_vdata)
    retval = _fl_set_event_callback(cfn_AppEventCb, ptr_vdata)
    return retval


def fl_set_idle_callback(pyfn_AppEventCb, userdata):
    """fl_set_idle_callback(pyfn_AppEventCb, userdata) -> AppEventCb

    Registers an idle callback. Interaction with it  can used for periodic
    tasks, e.g. rotating an image, checking the status of some external device
    or application state etc. An idle callback is an application function that
    is registered with the system and is called whenever there are no events
    pending for forms (or application windows). If called with a function as
    callback who does nothing, it removes idle callback. The time interval
    between invocations of the idle callback can vary considerably depending
    on interface activity and other factors. A range between 50 and 300 msec
    should be expected.

    Parameters
    ----------
        pyfn_AppEventCb : python function callback, returning unused value
            name referring to function(ptr_xevent, [pointer to void]pvdata)
            -> [int]num.
        userdata : any type (e.g. None, int, str, etc..)
            user data to be passed to function; invoked callback has to take
            care of type check and re-cast from ptr_void to chosen type using
            appropriate xfstruct.fls_convert_ptrvoid_to_*() function

    Returns
    -------
        AppEventCb : xfdata.FL_APPEVENT_CB
            old event callback function

    Examples
    --------
        >>> def idlecb(xev, pvdata):
        >>> ... <something>
        >>> ... return 0
        >>> appevtcb = fl_set_idle_callback(idlecb, None)
        >>> def donothing_idlecb(xev, pvdata):
        >>> ... pass
        >>> ... return 0
        >>> removedcb = fl_set_idle_callback(donothing_idlecb, None)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    #FL_APPEVENT_CB = cty.CFUNCTYPE(cty.c_int, cty.POINTER(XEvent),
    #                               cty.c_void_p)
    _fl_set_idle_callback = library.cfuncproto(
        library.load_so_libforms(), "fl_set_idle_callback",
        xfdata.FL_APPEVENT_CB, [xfdata.FL_APPEVENT_CB, cty.c_void_p],
        """FL_APPEVENT_CB fl_set_idle_callback(FL_APPEVENT_CB callback,
           void * user_data)""")
    library.check_if_flinitialized()
    library.verify_function_type(pyfn_AppEventCb)
    cfn_AppEventCb = xfdata.FL_APPEVENT_CB(pyfn_AppEventCb)
    ptr_vdata = library.convert_userdata_to_ptrvoid(userdata)
    library.keep_cfunc_refs(cfn_AppEventCb, pyfn_AppEventCb)
    library.keep_elem_refs(userdata, ptr_vdata)
    retval = _fl_set_idle_callback(cfn_AppEventCb, ptr_vdata)
    return retval


def fl_addto_selected_xevent(win, evtmask):
    """fl_addto_selected_xevent(win, evtmask) -> evtmask

    Adds solicited event masks on the fly without altering other
    masks already selected.

    Parameters
    ----------
        win : long_pos
            window id
        evtmask : long
            event mask to add. Values (from xfdata.py) NoEventMask,
            KeyPressMask, KeyReleaseMask, ButtonPressMask,
            ButtonReleaseMask, EnterWindowMask, LeaveWindowMask,
            PointerMotionMask, PointerMotionHintMask, Button1MotionMask,
            Button2MotionMask, Button3MotionMask, Button4MotionMask,
            Button5MotionMask, ButtonMotionMask, KeymapStateMask,
            ExposureMask, VisibilityChangeMask, StructureNotifyMask,
            ResizeRedirectMask, SubstructureNotifyMask,
            SubstructureRedirectMask, FocusChangeMask, ColormapChangeMask,
            OwnerGrabButtonMask *todo* verify if other masks can be added

    Returns
    -------
        evtmask : long
            resulting event mask, after the addition

    Examples
    --------
        >>> lnum = fl_addto_selected_xevent(win7, xfdata.ButtonMotionMask)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_addto_selected_xevent = library.cfuncproto(
        library.load_so_libforms(), "fl_addto_selected_xevent",
        cty.c_long, [xfdata.Window, cty.c_long],
        """long int fl_addto_selected_xevent(Window win, long int mask)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    library.checkfatal_allowed_value_in_list(evtmask, \
            xfdata.INPUTEVENTMASK_list)
    l_evtmask = library.convert_to_longc(evtmask)
    library.keep_elem_refs(win, evtmask, ul_win, l_evtmask)
    retval = _fl_addto_selected_xevent(ul_win, l_evtmask)
    return retval


def fl_remove_selected_xevent(win, evtmask):
    """fl_remove_selected_xevent(win, evtmask) -> evtmask

    Removes solicited event masks on the fly without altering other masks
    already selected.

    Parameters
    ----------
        win : long_pos
            window id
        evtmask : long
            event mask to remove. Values (from xfdata.py) NoEventMask,
            KeyPressMask, KeyReleaseMask, ButtonPressMask,
            ButtonReleaseMask, EnterWindowMask, LeaveWindowMask,
            PointerMotionMask, PointerMotionHintMask, Button1MotionMask,
            Button2MotionMask, Button3MotionMask, Button4MotionMask,
            Button5MotionMask, ButtonMotionMask, KeymapStateMask,
            ExposureMask, VisibilityChangeMask, StructureNotifyMask,
            ResizeRedirectMask, SubstructureNotifyMask,
            SubstructureRedirectMask, FocusChangeMask, ColormapChangeMask,
            OwnerGrabButtonMask *todo* verify if other masks can be added

    Returns
    -------
        evtmask : long
            resulting event mask, after the removal

    Examples
    --------
        >>> lnum = fl_remove_selected_xevent(win7, xfdata.ButtonMotionMask)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_remove_selected_xevent = library.cfuncproto(
        library.load_so_libforms(), "fl_remove_selected_xevent",
        cty.c_long, [xfdata.Window, cty.c_long],
        """long int fl_remove_selected_xevent(Window win, long int mask)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    library.checkfatal_allowed_value_in_list(evtmask, \
            xfdata.INPUTEVENTMASK_list)
    l_evtmask = library.convert_to_longc(evtmask)
    library.keep_elem_refs(win, evtmask, ul_win, l_evtmask)
    retval = _fl_remove_selected_xevent(ul_win, l_evtmask)
    return retval


fl_add_selected_xevent = fl_addto_selected_xevent


def fl_set_idle_delta(msec):
    """fl_set_idle_delta(msec)

    Changes what the library considers to be "idle". Be aware that under some
    conditions an idle callback can be called sooner than the minimum interval;
    if the timing of idle callback is of concerned, timeouts should be used.

    Parameters
    ----------
        msec : long
            minimum time interval of inactivity in milliseconds, after which
            the main loop is considered to be in idle state

    Examples
    --------
        >>> fl_set_idle_delta(800)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_idle_delta = library.cfuncproto(
        library.load_so_libforms(), "fl_set_idle_delta",
        None, [cty.c_long],
        """void fl_set_idle_delta(long int delta)""")
    library.check_if_flinitialized()
    l_msec = library.convert_to_longc(msec)
    library.keep_elem_refs(msec, l_msec)
    _fl_set_idle_delta(l_msec)


def fl_add_event_callback(win, evtnum, pyfn_AppEventCb, userdata):
    """fl_add_event_callback(win, evtnum, pyfn_AppEventCb, userdata)
    -> AppEventCb

    Adds an event handler for a window. Manipulates the event callback
    functions for the window specified, which will be called when an event of
    specified type is pending for the window. It does not solicit any event for
    the caller, i.e. XForms assumes the caller opens the window and solicits
    all events before calling these routines.

    Parameters
    ----------
        win : long_pos
            window id to add event handler to
        evtnum : int
            X event type names. Values (from xfdata.py) KeyPress,
            KeyRelease, ButtonPress, ButtonRelease, MotionNotify,
            EnterNotify, LeaveNotify, FocusIn, FocusOut, KeymapNotify,
            Expose, GraphicsExpose, NoExpose, VisibilityNotify,
            CreateNotify, DestroyNotify, UnmapNotify, MapNotify,
            MapRequest, ReparentNotify, ConfigureNotify, ConfigureRequest,
            GravityNotify, ResizeRequest, CirculateNotify, CirculateRequest,
            PropertyNotify, SelectionClear, SelectionRequest, SelectionNotify
            If it is 0, the callback is for all events for the window
        pyfn_AppEventCb : python function callback, returned value
            name referring to function(ptr_xevent, [pointer to void]pvdata)
            -> [int]num.
        userdata : any type (e.g. None, int, str, etc..)
            user data to be passed to function; invoked callback has to take
            care of type check and re-cast from ptr_void to chosen type using
            appropriate xfstruct.fls_convert_ptrvoid_to_*() function

    Returns
    -------
        AppEventCb : pointer to xfdata.FL_APPEVENT_CB
            old event callback, or None (on failure)

    Examples
    --------
        >>> def eventcb(pxev, pvdata):
        >>> ... <something>
        >>> ... return 0
        >>> fl_add_event_callback(win2, 0, eventcb, None)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    #FL_APPEVENT_CB = cty.CFUNCTYPE(cty.c_int, cty.POINTER(XEvent),
    #                               cty.c_void_p)
    _fl_add_event_callback = library.cfuncproto(
        library.load_so_libforms(), "fl_add_event_callback",
        xfdata.FL_APPEVENT_CB, [xfdata.Window, cty.c_int,
        xfdata.FL_APPEVENT_CB, cty.c_void_p],
        """FL_APPEVENT_CB fl_add_event_callback(Window win, int ev,
           FL_APPEVENT_CB wincb, void * user_data)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    library.checkfatal_allowed_value_in_list(evtnum, xfdata.XEVENTNAME_list)
    i_evtnum = library.convert_to_intc(evtnum)
    library.verify_function_type(pyfn_AppEventCb)
    cfn_AppEventCb = xfdata.FL_APPEVENT_CB(pyfn_AppEventCb)
    ptr_vdata = library.convert_userdata_to_ptrvoid(userdata)
    library.keep_cfunc_refs(cfn_AppEventCb, pyfn_AppEventCb)
    library.keep_elem_refs(win, evtnum, userdata, ul_win, i_evtnum, ptr_vdata)
    retval = _fl_add_event_callback(ul_win, i_evtnum, cfn_AppEventCb, \
            ptr_vdata)
    return retval


def fl_remove_event_callback(win, evtnum):
    """fl_remove_event_callback(win, evtnum)

    Removes one or all event callbacks for a window and for an event of
    specified type. May be called with for a window for which no event
    callbacks have been set.

    Parameters
    ----------
        win : long_pos
            window id
        evttype : int
            X event type names. Values (from xfdata.py) KeyPress,
            KeyRelease, ButtonPress, ButtonRelease, MotionNotify,
            EnterNotify, LeaveNotify, FocusIn, FocusOut, KeymapNotify,
            Expose, GraphicsExpose, NoExpose, VisibilityNotify,
            CreateNotify, DestroyNotify, UnmapNotify, MapNotify,
            MapRequest, ReparentNotify, ConfigureNotify, ConfigureRequest,
            GravityNotify, ResizeRequest, CirculateNotify, CirculateRequest,
            PropertyNotify, SelectionClear, SelectionRequest, SelectionNotify
            If it is 0, the callback is for all events for the window

    Examples
    --------
        >>> fl_remove_event_callback(win2, 0)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_remove_event_callback = library.cfuncproto(
        library.load_so_libforms(), "fl_remove_event_callback",
        None, [xfdata.Window, cty.c_int],
        """void fl_remove_event_callback(Window win, int ev)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    library.checkfatal_allowed_value_in_list(evtnum, xfdata.XEVENTNAME_list)
    i_evtnum = library.convert_to_intc(evtnum)
    library.keep_elem_refs(win, evtnum, ul_win, i_evtnum)
    _fl_remove_event_callback(ul_win, i_evtnum)


def fl_activate_event_callbacks(win):
    """fl_activate_event_callbacks(win)

    Handles event solicitation. Activates the default mapping of events to
    event masks built-in in XForms, and causes the system to solicit the
    events for you. Note, however, the mapping of events to masks are not
    unique and depending on applications, the default mapping may or may not
    be the one you want.

    Parameters
    ----------
        win : long_pos
            window whose events are referred to

    Examples
    --------
        >>> fl_activate_event_callback(win3)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_activate_event_callbacks = library.cfuncproto(
        library.load_so_libforms(), "fl_activate_event_callbacks",
        None, [xfdata.Window],
        """void fl_activate_event_callbacks(Window win)""")
    library.check_if_flinitialized()
    ul_win = library.convert_to_Window(win)
    library.keep_elem_refs(win, ul_win)
    _fl_activate_event_callbacks(ul_win)


def fl_print_xevent_name(wheretxt, ptr_xevent):
    """fl_print_xevent_name(wheretxt, ptr_xevent) -> ptr_xevent

    Prints the name of an XEvent and some other infos.

    Parameters
    ----------
        wheretxt : str
            text for X event. It can indicate where this function
            is called.
        ptr_xevent : pointer to xfdata.XEvent
            XEvent class instance

    Returns
    -------
        ptr_xevent : pointer to xfdata.XEvent
            X event

    Examples
    --------
        >>> pxev = fl_print_xevent_name("from whatever.py", pxev)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_print_xevent_name = library.cfuncproto(
        library.load_so_libforms(), "fl_print_xevent_name",
        cty.POINTER(xfdata.XEvent), [xfdata.STRING, \
        cty.POINTER(xfdata.XEvent)],
        """XEvent * fl_print_xevent_name(const char * where,
           const Xevent * xev)""")
    library.check_if_flinitialized()
    s_wheretxt = library.convert_to_stringc(wheretxt)
    library.keep_elem_refs(wheretxt, ptr_xevent, s_wheretxt)
    retval = _fl_print_xevent_name(s_wheretxt, ptr_xevent)
    return retval


def fl_XFlush():
    """fl_XFlush()

    Flushes the X output buffer. Convenience replacement for X11 XFlush()
    function.

    Examples
    --------
        >>> fl_XFlush()

    Notes
    -----
        Status: NN-UTest + Doc + Demo = OK

    """
    _fl_XFlush = library.cfuncproto(
        library.load_so_libforms(), "fl_XFlush",
        None, [],
        """void fl_XFlush(void)""")
    _fl_XFlush()


def metakey_down(mask):
    return (mask & xfdata.Mod1Mask)


def shiftkey_down(mask):
    return (mask & xfdata.ShiftMask)


def controlkey_down(mask):
    return (mask & xfdata.ControlMask)


def button_down(mask):
    if (mask & xfdata.Button1Mask) or (mask & xfdata.Button2Mask) or \
            (mask & xfdata.Button3Mask) or (mask & xfdata.Button4Mask) or \
            (mask & xfdata.Button5Mask):
        return True
    else:
        return False


# Resources
def fl_initialize(numargs, argslist, appname, ptr_appoptions, numappopts):
    """fl_initialize(numargs, argslist, appname, ptr_appoptions, numappopts)
    -> ptr_display

    Initializes XForms. It should always be called before any other calls to
    the XForms, except fl_set_defaults() and a few other functions that alter
    some of the defaults of the library. Command line arguments are supported.

    Parameters
    ----------
        numargs : int
            number of arguments passed to command line
        argslist : list_of_str
            arguments passed to command line
        appname : str
            application class name
        ptr_appoptions : pointer to xfdata.FL_CMD_OPT
            possible options passed as a flcmdopt class instance. You can
            prepare it passing a dict (with keys corresponding to
            xfdata.FL_CMD_OPT attributes) to xfstruct.fls_make_ptr_flcmdopt()
            function. If it is None, user application has no options
        numappopts : int
            number of options passed in appoptions. If it is 0, user
            application has no options

    Returns
    -------
        ptr_display : pointer to xfdata.Display
            display, or None (on failure, if a connection could not be made)

    Examples
    --------
        >>> import sys
        >>> fl_initialize(len(sys.argv), sys.argv, "MyFormDemo", None, 0)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_initialize = library.cfuncproto(
        library.load_so_libforms(), "fl_initialize",
        cty.POINTER(xfdata.Display), [cty.POINTER(cty.c_int),
        cty.POINTER(xfdata.STRING), xfdata.STRING,
        cty.POINTER(xfdata.FL_CMD_OPT), cty.c_int],
        """Display * fl_initialize(int * na, char * * arg,
            const char * appclass, FL_CMD_OPT * appopt, int nappopt)""")
    # ok if installed XForms shared library is compatible with this one
    library.verify_version_compatibility()
    library.set_flinitialized()
    #numargs = 1
    i_numargs = library.convert_to_intc(numargs)
    ptr_numargs = cty.pointer(i_numargs)
    ptr_argslist = library.convert_to_ptr_stringc(argslist)
    s_appname = library.convert_to_stringc(appname)
    if not ptr_appoptions:      # if it is None
        ptr_appoptions = cty.cast(None, cty.POINTER(xfdata.FL_CMD_OPT))
    else:                       # if it is a real FL_CMD_OPT
        library.verify_otherclassptr_type(ptr_appoptions, \
                cty.POINTER(xfdata.FL_CMD_OPT))
    i_numappopts = library.convert_to_intc(numappopts)
    library.keep_elem_refs(numargs, ptr_numargs, argslist, ptr_argslist, \
            appname, s_appname, ptr_appoptions, numappopts, i_numappopts)
    retval = _fl_initialize(ptr_numargs, ptr_argslist, s_appname, \
            ptr_appoptions, i_numappopts)
    return retval


def fl_finish():
    """fl_finish()

    It is a final cleanup routine, restores all X server defaults, shuts down
    the connection and frees dynamically allocated memory. To be used as the
    last function.

    Examples
    --------
        >>> fl_finish()

    Notes
    -----
        Status: NN-UTest + Doc + Demo = OK

    """
    _fl_finish = library.cfuncproto(
        library.load_so_libforms(), "fl_finish",
        None, [],
        """void fl_finish()""")
    library.check_if_flinitialized()
    _fl_finish()


def fl_get_resource(resname, resclass, dtype, defval, size):
    """fl_get_resource(resname, resclass, dtype, defval, size)
    -> restext, varvalue

    Finds out resource data at the lowest level. It may be useful to e.g.
    retrieve arbitrary strings and values and to pass data around.

    Parameters
    ----------
        resname : str
            complete resource name specification (minus the application name)
            and should not contain wildcards of any kind. Alternative to
            resource class
        resclass : str
            complete resource class specification (minus the application name)
            and should not contain wildcards of any kind. Alternative to
            resource name
        dtype : int
            type of resource. Values (from xfdata.py)
            - FL_NONE (type for variables not to be used, or not available),
            - FL_SHORT (type for short variable),
            - FL_BOOL (type for boolean variable, int),
            - FL_INT (type for int variable),
            - FL_LONG (type for long variable),
            - FL_FLOAT (type for float variable),
            - FL_STRING (type for c_char_p/string variable)
        defval : str
            default value for resource data
        size : int
            number of bytes+1, used only if dtype is xfdata.FL_STRING

    Returns
    -------
        restext : str
            text representation of the resource value, or None (on failure)
        varvalue : any type
            variable value. You will need to use the appropriate
            xfstruct.fls_convert_ptrvoid_to_*() function to retrieve correct value

    Examples
    --------
        >>> text, myvalue = fl_get_resource("myresource", "", xfl.FL_STRING,
                "normal", 7)

    API_diversion
    -------------
        API changed from XForms, upstream is
        fl_get_resource(resname, resclass, dtype, defval, val, size)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_resource = library.cfuncproto(
        library.load_so_libforms(), "fl_get_resource",
        xfdata.STRING, [xfdata.STRING, xfdata.STRING, xfdata.FL_RTYPE, \
        xfdata.STRING, cty.c_void_p, cty.c_int],
        """const char * fl_get_resource(const char * rname,
        const char * cname, FL_RTYPE dtype, const char * defval, void * val,
        int size)""")
    library.checkfatal_allowed_value_in_list(dtype, xfdata.RTYPE_list)
    s_resname = library.convert_to_stringc(resname)
    s_resclass = library.convert_to_stringc(resclass)
    i_dtype = library.convert_to_intc(dtype)
    s_defval = library.convert_to_stringc(defval)
    # handling any type who will hold the value
    if dtype == xfdata.FL_INT or dtype == xfdata.FL_BOOL:
        varvalue, ptr_varvalue = library.make_intc_and_pointer()
    elif dtype == xfdata.FL_FLOAT:
        varvalue, ptr_varvalue = library.make_floatc_and_pointer()
    elif dtype == xfdata.FL_STRING:
        varvalue, ptr_varvalue = library.make_stringc_and_pointer()
    else:       # if xfdata.FL_NONE
        varvalue, ptr_varvalue = cty.c_void_p(), cty.c_void_p()
    ptr_varvalue2 = cty.cast(ptr_varvalue, cty.c_void_p)
    i_size = library.convert_to_intc(size)
    library.keep_elem_refs(resname, resclass, dtype, defval, size, s_resname, \
            s_resclass, i_dtype, s_defval, varvalue, ptr_varvalue, \
            ptr_varvalue2, i_size)
    retval = _fl_get_resource(s_resname, s_resclass, i_dtype, s_defval, \
            ptr_varvalue2, i_size)
    if dtype == xfdata.FL_INT or dtype == xfdata.FL_BOOL:
        ptr_varvalue3 = cty.cast(ptr_varvalue2, cty.POINTER(cty.c_int))
        varvalue3 = ptr_varvalue3.contents.value
    elif dtype == xfdata.FL_FLOAT:
        ptr_varvalue3 = cty.cast(ptr_varvalue2, cty.POINTER(cty.c_float))
        varvalue3 = ptr_varvalue3.contents.value
    elif dtype == xfdata.FL_STRING:
        ptr_varvalue3 = cty.cast(ptr_varvalue2, cty.c_char_p)
        varvalue3 = ptr_varvalue3.value
    else:       # if xfdata.FL_NONE
        ptr_varvalue3 = varvalue3 = ptr_varvalue2
    return retval, varvalue3


def fl_set_resource(resnamecls, txtval):
    """fl_set_resource(resnamecls, txtval)

    Defines a resource, associating a value to it. It may be useful to e.g.
    change a built-in button labels with proper resource names, or to store
    arbitrary strings and values and to pass data around.

    Parameters
    ----------
        resnamecls : str
            a fully qualified resource name (minus the application name) or
            a resource class
        txtval : str
            new text value for resource

    Examples
    --------
        >>> fl_set_resource("myresource", "anyval")

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_resource = library.cfuncproto(
        library.load_so_libforms(), "fl_set_resource",
        None, [xfdata.STRING, xfdata.STRING],
        """void fl_set_resource(const char * str, const char * val)""")
    s_resnamecls = library.convert_to_stringc(resnamecls)
    s_txtval = library.convert_to_stringc(txtval)
    library.keep_elem_refs(resnamecls, txtval, s_resnamecls, s_txtval)
    _fl_set_resource(s_resnamecls, s_txtval)


def fl_get_app_resources(ptr_flresource, numresources):
    """fl_get_app_resources(ptr_flresource, numresources)

    Reads user application specific options.

    Parameters
    ----------
        ptr_flresource : pointer to xfdata.FL_RESOURCE
            an array of resource class instances. You can pass a dict or a
            list of dicts (whose keys corresponding to xfdata.FL_RESOURCE
            attributes) to xfstruct.fls_make_ptr_flresource() function
        numresources : int
            number of resources (starting from 1) passed with ptr_flresource

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_app_resources = library.cfuncproto(
        library.load_so_libforms(), "fl_get_app_resources",
        None, [cty.POINTER(xfdata.FL_RESOURCE), cty.c_int],
        """void fl_get_app_resources(FL_RESOURCE * appresource, int n)""")
    library.check_if_flinitialized()
    library.verify_otherclassptr_type(ptr_flresource, \
            cty.POINTER(xfdata.FL_RESOURCE))
    i_numresources = library.convert_to_intc(numresources)
    library.keep_elem_refs(ptr_flresource, numresources, i_numresources)
    _fl_get_app_resources(ptr_flresource, i_numresources)


def fl_set_graphics_mode(vmode, doublebuf):
    """fl_set_graphics_mode(vmode, doublebuf)

    Defines graphics mode and doublebuffer state.

    Parameters
    ----------
        vmode : int
            visual mode. Values (from xfdata module) GrayScale, StaticGray,
            PseudoColor, StaticColor, DirectColor or TrueColor
        doublebuf : int
            flag to enable/disable doublebuffer. Value 0 (to disable) or 1 (to
            enable)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_graphics_mode = library.cfuncproto(
        library.load_so_libforms(), "fl_set_graphics_mode",
        None, [cty.c_int, cty.c_int],
        """void fl_set_graphics_mode(int mode, int doublebuf)""")
    library.check_if_flinitialized()
    i_vmode = library.convert_to_intc(vmode)
    i_doublebuf = library.convert_to_intc(doublebuf)
    library.keep_elem_refs(vmode, doublebuf, i_vmode, i_doublebuf)
    _fl_set_graphics_mode(i_vmode, i_doublebuf)


def fl_set_visualID(vmode):
    """fl_set_visualID(vmode)

    Defines visual mode and depth. By default, X Server's visual and depth
    values are used.

    Parameters
    ----------
        vmode : long
            visual mode. Values (from xfdata.py) StaticGray, GrayScale,
            StaticColor, PseudoColor, TrueColor, DirectColor, DefaultVisual,
            GreyScale, StaticGrey

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe
        Precondition: to be called before fl_initialize()

    """
    _fl_set_visualID = library.cfuncproto(
        library.load_so_libforms(), "fl_set_visualID",
        None, [cty.c_long],
        """void fl_set_visualID(long int id)""")
    library.checkfatal_allowed_value_in_list(vmode, xfdata.VISUALMODE_list)
    l_vmode = library.convert_to_longc(vmode)
    library.keep_elem_refs(vmode, l_vmode)
    _fl_set_visualID(l_vmode)


def fl_keysym_pressed(keysym):
    """fl_keysym_pressed(keysym) -> result

    Finds out if a keyboard symbol has been pressed, or not.

    Parameters
    ----------
        keysym : long_pos
            Symbol of key to evaluate. Values (from xfdata.py) e.g. XK_Home,
            XK_Left, XK_BackSpace, etc...

    Returns
    -------
        result : int
            1 (if pressed), or 0 (if not pressed or on failure)

    Examples
    --------
        >>> if fl_keysym_pressed(xfdata.XK_End):
        >>> ... <something>

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_keysym_pressed = library.cfuncproto(
        library.load_so_libforms(), "fl_keysym_pressed",
        cty.c_int, [xfdata.KeySym],
        """int fl_keysym_pressed(KeySym k)""")
    library.check_if_flinitialized()
    ul_keysym = library.convert_to_ulongc(keysym)
    library.keep_elem_refs(keysym, ul_keysym)
    retval = _fl_keysym_pressed(ul_keysym)
    return retval


fl_keypressed = fl_keysym_pressed


# Program default masks

def fl_set_defaults(pdmask, ptr_fliopt):
    """fl_set_defaults(pdmask, ptr_fliopt)

    Defines program default option masks.

    Parameters
    ----------
        pdmask : long_pos
            Mask of program defaults. Values (from xfdata.py)
            - FL_PDDepth (Preferred visual depth, "depth"),
            - FL_PDClass (class of flobject? *todo*),
            - FL_PDDouble (Simulates double buffering, "doubleBuffer"),
            - FL_PDSync (*todo*),
            - FL_PDPrivateMap (Selects private colormap if appropriate,
              "privateColormap"),
            - FL_PDScrollbarType (Scrollbar type to use for browser and input,
              "scrollbarType"),
            - FL_PDPupFontSize (Font size for pop-ups, "PupFontSize"),
            - FL_PDButtonFontSize (Default button label font size,
              "buttonFontSize"),
            - FL_PDInputFontSize (Input label and text font size,
              "menuFontSize"),
            - FL_PDSliderFontSize (Slider label and text font size),
            - FL_PDVisual (Preferred visual mode, e.g. TrueColor .., "vclass"),
            - FL_PDULThickness (Underline thickness, "ulThickness"),
            - FL_PDULPropWidth (Underline width, 0 for constant width fonts,
              "ulPropWidth"),
            - FL_PDBS (Turn BackingStore on or off, "backingStore"),
            - FL_PDCoordUnit (Unit of measure for screen coordinates, e.g.
              pixel, mm, point, etc.., "coordUnit"),
            - FL_PDDebug (Debug level, 0-5, "debug"),
            - FL_PDSharedMap (Forces use of shared colormap, "sharedColormap"),
            - FL_PDStandardMap (Forces use of standard colormap,
              "standardColormap"),
            - FL_PDBorderWidth (Default border width, "borderWidth"),
            - FL_PDSafe (*todo*),
            - FL_PDMenuFontSize (Menu label font size, "menuFontSize"),
            - FL_PDBrowserFontSize (Browser label and text font size,
              "browserFontSize"),
            - FL_PDChoiceFontSize (Choice label and choice text font size,
              "choiceFontSize"),
            - FL_PDLabelFontSize (Label font size for all other flobjects,
              e.g. box, pixmap etc.., "labelFontSize"),
            - FL_PDButtonLabelSize or FL_PDButtonLabel or FL_PDButtonFontSize
              (Default button label font size, "buttonFontSize"),
            - FL_PDSliderLabelSize or FL_PDSliderFontSize (Default slider
              label font size),
            - FL_PDInputLabelSize or FL_PDInputFontSize (Input label and text
              font size, "menuFontSize").
        ptr_fliopt : pointer to xfdata.FL_IOPT array
            program defaults class instance. You can use pass a dict or a list
            of dicts (whose keys correspond to xfdata.FL_IOPT's attributes) to
            xfstruct.fls_make_ptr_fliopt() function.

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe
        Precondition: to be called before fl_initialize()

    """
    _fl_set_defaults = library.cfuncproto(
        library.load_so_libforms(), "fl_set_defaults",
        None, [cty.c_ulong, cty.POINTER(xfdata.FL_IOPT)],
        """void fl_set_defaults(long unsigned int mask, FL_IOPT * cntl)""")
    library.checkfatal_allowed_value_in_list(pdmask, \
            xfdata.PRGDEFAULTS_list)
    ul_pdmask = library.convert_to_ulongc(pdmask)
    library.keep_elem_refs(pdmask, ptr_fliopt, ul_pdmask)
    _fl_set_defaults(ul_pdmask, ptr_fliopt)


def fl_set_tabstop(tabtext):
    """fl_set_tabstop(tabtext)

    Adjusts the distance by setting the tab stops. For proportional font,
    substituting tabs with spaces is not always appropriate because this most
    likely will fail to align text properly. Instead, a tab is treated as an
    absolute measure of distance, in pixels, and a tab stop will always end at
    multiples of this distance. The default is "aaaaaaaa" (i.e. eight 'a's).

    Parameters
    ----------
        tabtext : str
            text string whose width in pixel is to be used as the tab length.
            The font used to calculate the width is the same font that is used
            to render the string in which the tab is embedded.

    Examples
    --------
        >>> fl_set_tabstop("aaaa")

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_tabstop = library.cfuncproto(
        library.load_so_libforms(), "fl_set_tabstop",
        None, [xfdata.STRING],
        """void fl_set_tabstop(const char * s)""")
    library.check_if_flinitialized()
    s_tabtext = library.convert_to_stringc(tabtext)
    library.keep_elem_refs(tabtext, s_tabtext)
    _fl_set_tabstop(s_tabtext)


def fl_get_defaults():
    """fl_get_defaults() -> ptr_fliopt

    Finds out program defaults from the resource database.

    Returns
    -------
        ptr_fliopt : pointer to xfdata.FL_IOPT
            program defaults class instance

    Examples
    --------
        >>> pdefprgres = fl_get_defaults()

    API_diversion
    -------------
        API changed from XForms, upstream is fl_get_defaults(pIopt)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_defaults = library.cfuncproto(
        library.load_so_libforms(), "fl_get_defaults",
        None, [cty.POINTER(xfdata.FL_IOPT)],
        """void fl_get_defaults(FL_IOPT * cntl)""")
    library.check_if_flinitialized()
    iopt = xfdata.FL_IOPT()
    ptr_fliopt = cty.pointer(iopt)
    library.keep_elem_refs(iopt, ptr_fliopt)
    _fl_get_defaults(ptr_fliopt)
    return ptr_fliopt


def fl_get_visual_depth():
    """fl_get_visual_depth() -> depth

    Finds out the visual depth.

    Returns
    -------
        depth : int
            visual depth for current mode (e.g. 1, 4, 8, 16, 24?, 32 ..)

    Examples
    --------
        >>> curdepth = fl_get_visual_depth()

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_get_visual_depth = library.cfuncproto(
        library.load_so_libforms(), "fl_get_visual_depth",
        cty.c_int, [],
        """int fl_get_visual_depth()""")
    library.check_if_flinitialized()
    retval = _fl_get_visual_depth()
    return retval


def fl_vclass_name(vmode):
    """fl_vclass_name(vmode) -> vname

    Finds out name corresponding to a visual mode.

    Parameters
    ----------
        vmode : int
            visual mode. Values (from xfdata.py) StaticGray or StaticGrey,
            GrayScale or GreyScale, StaticColor, PseudoColor, TrueColor,
            DirectColor, DefaultVisual

    Returns
    -------
        vname : str
            name corresponding to visual mode

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_vclass_name = library.cfuncproto(
        library.load_so_libforms(), "fl_vclass_name",
        xfdata.STRING, [cty.c_int],
        """const char * fl_vclass_name(int n)""")
    library.check_if_flinitialized()
    i_vmode = library.convert_to_intc(vmode)
    library.keep_elem_refs(vmode, i_vmode)
    retval = _fl_vclass_name(i_vmode)
    return retval


def fl_vclass_val(vname):
    """fl_vclass_val(vname) -> vmode

    Finds out value of visual mode.

    Parameters
    ----------
        vname : str
            textual name of visual mode. Values "StaticGray",
            "GrayScale", "StaticColor", "PseudoColor", "TrueColor",
            "DirectColor", or "DefaultVisual"

    Returns
    -------
        vmode : int
            visual mode corresponding to name (e.g. xfdata.TrueColor,
            xfdata.DirectColor, etc..)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_vclass_val = library.cfuncproto(
        library.load_so_libforms(), "fl_vclass_val",
        cty.c_int, [xfdata.STRING],
        """int fl_vclass_val(const char * v)""")
    library.check_if_flinitialized()
    s_vname = library.convert_to_stringc(vname)
    library.keep_elem_refs(vname, s_vname)
    retval = _fl_vclass_val(s_vname)
    return retval


def fl_set_ul_property(proportional, thickness):
    """fl_set_ul_property(proportional, thickness)

    Defines property of an underlined text.

    Parameters
    ----------
        proportional : int
            if width is proportional or not. Values 0 (if fixed) or 1 (if
            proportional)
        thickness : int
            thickness of underline.

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_ul_property = library.cfuncproto(
        library.load_so_libforms(), "fl_set_ul_property",
        None, [cty.c_int, cty.c_int],
        """void fl_set_ul_property(int prop, int thickness)""")
    i_proportional = library.convert_to_intc(proportional)
    i_thickness = library.convert_to_intc(thickness)
    library.keep_elem_refs(proportional, thickness, i_proportional, \
            i_thickness)
    _fl_set_ul_property(i_proportional, i_thickness)


def fl_set_clipping(xpos, ypos, width, height):
    """fl_set_clipping(xpos, ypos, width, height)

    Defines a clipping region in the XForms default graphics context (gc[0]).
    This defines the area (delimited by arguments passed) drawing is to
    restrict to and are relative to the window/form that will be drawn to. In
    this way you can prevent drawing over other flobject and outside the box.

    Parameters
    ----------
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units

    Examples
    --------
        >>> fl_set_clipping(250, 200, 100, 80)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_clipping = library.cfuncproto(
        library.load_so_libforms(), "fl_set_clipping",
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord],
        """void fl_set_clipping(FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h)""")
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(xpos, ypos, width, height, i_xpos, i_ypos, \
            i_width, i_height)
    _fl_set_clipping(i_xpos, i_ypos, i_width, i_height)


def fl_set_gc_clipping(gctx, xpos, ypos, width, height):
    """fl_set_gc_clipping(gctx, xpos, ypos, width, height)

    Defines a clipping region in the specified graphics context. This defines
    the area (delimited by arguments passed) drawing is to restrict to and are
    relative to the window/form that will be drawn to. In this way you can
    prevent drawing over other flobject and outside the box.

    Parameters
    ----------
       gctx : xfdata.GC
            Graphics Context class instance. You can use fl_gc()?
       xpos : int
            horizontal position (upper-left corner)
       ypos : int
            vertical position (upper-left corner)
       width : int
            width in coord units
       height : int
            height in coord units

    Examples
    --------
        >>> graco = xfl.fl_gc()
        >>> fl_set_gc_clipping(graco, 250, 200, 100, 80)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_gc_clipping = library.cfuncproto(
        library.load_so_libforms(), "fl_set_gc_clipping",
        None, [xfdata.GC, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord],
        """void fl_set_gc_clipping(GC  gctx, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h)""")
    library.check_if_flinitialized()
    library.verify_otherclassptr_type(gctx, xfdata.GC)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(gctx, xpos, ypos, width, height, i_xpos, i_ypos, \
            i_width, i_height)
    _fl_set_gc_clipping(gctx, i_xpos, i_ypos, i_width, i_height)


def fl_unset_gc_clipping(gctx):
    """ fl_unset_gc_clipping(gctx)

    Removes clipping region in the specified graphics context (GC).

    Parameters
    ----------
       gctx : xfdata.GC
            Graphics Context class instance. You can use fl_gc()?

    Examples
    --------
        >>> graco = xfl.fl_gc()
        >>> fl_unset_gc_clipping(graco)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_unset_gc_clipping = library.cfuncproto(
        library.load_so_libforms(), "fl_unset_gc_clipping",
        None, [xfdata.GC],
        """void fl_unset_gc_clipping(GC gc)""")
    library.check_if_flinitialized()
    library.verify_otherclassptr_type(gctx, xfdata.GC)
    library.keep_elem_refs(gctx)
    _fl_unset_gc_clipping(gctx)


def fl_set_clippings(ptr_rect, numrects):
    """fl_set_clippings(ptr_rect, numrects)

    Changes the clip-mask in the specified GC to the specified list of
    rectangles and sets the clip origin. The output is clipped to remain
    contained within the rectangles. The clip-origin is interpreted relative
    to the origin of whatever destination drawable is specified in a graphics
    request. The rectangle coordinates are interpreted relative to the
    clip-origin. The rectangles should be nonintersecting, or the graphics
    results will be undefined.

    Parameters
    ----------
        ptr_rect : pointer to xfdata.FL_RECT
            rectangle class instance
        numrects : int
            number of rectangles

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_clippings = library.cfuncproto(
        library.load_so_libforms(), "fl_set_clippings",
        None, [cty.POINTER(xfdata.FL_RECT), cty.c_int],
        """void fl_set_clippings(FL_RECT * xrect, int n)""")
    library.check_if_flinitialized()
    library.verify_otherclassptr_type(ptr_rect, cty.POINTER(xfdata.FL_RECT))
    i_numrects = library.convert_to_intc(numrects)
    library.keep_elem_refs(ptr_rect, numrects, i_numrects)
    _fl_set_clippings(ptr_rect, i_numrects)


def fl_unset_clipping():
    """fl_unset_clipping()

    Stops clipping and removes clipping area defined with fl_set_clipping().

    Examples
    --------
        >>> fl_unset_clipping()

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_unset_clipping = library.cfuncproto(
        library.load_so_libforms(), "fl_unset_clipping",
        None, [],
        """void fl_unset_clipping()""")
    library.check_if_flinitialized()
    _fl_unset_clipping()


def fl_set_text_clipping(xpos, ypos, width, height):
    """fl_set_text_clipping(xpos, ypos, width, height)

    Defines a clipping region for text in the XForms default graphics context
    (gc[0]). This defines the area (delimited by arguments passed) drawing is
    to restrict to and are relative to the window/form that will be drawn to.
    In this way you can prevent drawing over other flobjects and outside the
    box.

    Parameters
    ----------
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units

    Examples
    --------
        >>> fl_set_text_clipping(200, 200, 300, 50)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_text_clipping = library.cfuncproto(
        library.load_so_libforms(), "fl_set_text_clipping",
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord],
        """void fl_set_text_clipping(FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h)""")
    library.check_if_flinitialized()
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(xpos, ypos, width, height, i_xpos, i_ypos, \
            i_width, i_height)
    _fl_set_text_clipping(i_xpos, i_ypos, i_width, i_height)


def fl_unset_text_clipping():
    """fl_unset_text_clipping()

    Stops clipping for text and removes clipping area defined with
    fl_set_text_clipping().

    Examples
    --------
        >>> fl_unset_text_clipping()

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_unset_text_clipping = library.cfuncproto(
        library.load_so_libforms(), "fl_unset_text_clipping",
        None, [],
        """void fl_unset_text_clipping()""")
    library.check_if_flinitialized()
    _fl_unset_text_clipping()


# How we pack and unpack colors

def FL_PCCLAMP(a):
    if (a > xfdata.FL_PCMAX):
        return xfdata.FL_PCMAX
    elif (a < 0):
        return 0
    else:
        return a


# If PCBITS is not 8, we need to apply the RGBmask

def FL_GETR(packed):
    """FL_GETR(packed) -> red

    Retrieve red value from a packed color value.

    Parameters
    ----------
        packed : int?
            packed value of color

    Returns
    -------
        red : int?
            value for red

    """
    return (packed >> xfdata.FL_RSHIFT) & xfdata.FL_RMASK


def FL_GETG(packed):
    """FL_GETG(packed) -> green

    Retrieve green value from a packed color value.

    Parameters
    ----------
        packed : int?
            packed value of color

    Returns
    -------
        green : int?
            value for green

    """
    return (packed >> xfdata.FL_GSHIFT) & xfdata.FL_PCMAX


def FL_GETB(packed):
    """FL_GETB(packed) -> blue

    Retrieve blue value from a packed color value.

    Parameters
    ----------
        packed : int?
            packed value of color

    Returns
    -------
        blue : int?
            value for blue

    """
    return (packed >> xfdata.FL_BSHIFT) & xfdata.FL_PCMAX


def FL_GETA(packed):
    """FL_GETA(packed) -> alpha

    Retrieve alpha level from a packed color value.

    Parameters
    ----------
        packed : int?
            packed value of color

    Returns
    -------
        alpha : int?
            alpha level

    """
    return (packed >> xfdata.FL_ASHIFT) & xfdata.FL_PCMAX


def FL_PACK3(red, green, blue):
    """FL_PACK4(red, green, blue) - > packed

    Packs red, green and blue values into a packed color value.

    Parameters
    ----------
        red : int?
            value for red
        green : int?
            value for green
        blue : int?
            value for blue

    Returns
    -------
        packed : int?
            packed value of color

    """
    return (red << xfdata.FL_RSHIFT) | (green << xfdata.FL_GSHIFT) | \
            (blue << xfdata.FL_BSHIFT)

FL_PACK = FL_PACK3


def FL_PACK4(red, green, blue, alphalvl):
    """FL_PACK4(red, green, blue, alpha) - > packed

    Packs red, green, blue and alpha? values into a packed color value.

    Parameters
    ----------
        red : int?
            value for red
        green : int?
            value for green
        blue : int?
            value for blue
        alphalvl : int?
            alpha level

    Returns
    -------
        packed : int?
            packed value of color

    """
    return (FL_PACK3(red, green, blue) | (alphalvl << xfdata.FL_ASHIFT))


def FL_UNPACK(packed):
    """FL_UNPACK(packed) -> red, green, blue

    Unpacks a packed color value into red, green and blue values.

    Parameters
    ----------
        packed : int?
            packed value of color

    Returns
    -------
        red : int?
            value for red
        green : int?
            value for green
        blue : int?
            value for blue

    API_diversion
    -------------
        API changed from upstream, XForms is FL_UNPACK4(p, r, g, b)

    """
    red = FL_GETR(packed)
    green = FL_GETG(packed)
    blue = FL_GETB(packed)
    return red, green, blue

FL_UNPACK3 = FL_UNPACK


def FL_UNPACK4(packed):
    """FL_UNPACK4(packed) -> red, green, blue, alphalvl

    Unpacks a packed color value into red, green, blue and alpha values.

    Parameters
    ----------
        packed : int?
            packed value of color

    Returns
    -------
        red : int?
            value for red
        green : int?
            value for green
        blue : int?
            value for blue
        alphalvl : int?
            alpha level

    API_diversion
    -------------
        API changed from upstream, XForms is FL_UNPACK4(p, r, g, b, a)

    """
    red, green, blue = FL_UNPACK3(packed)
    alphalvl = FL_GETA(packed)
    return red, green, blue, alphalvl

