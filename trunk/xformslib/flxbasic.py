#!/usr/bin/env python
# -*- coding: iso8859-1 -*-

""" xforms-python's functions to handle X Window basic and drawing stuff.

    Copyright (C) 2009, 2010  Luca Lazzaroni "LukenShiro"
    e-mail: <lukenshiro@ngi.it>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, version 2.1 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU LGPL along with this
    program. If not, see <http://www.gnu.org/licenses/>.

    See CREDITS file to read acknowledgements and thanks to XForms,
    ctypes and other developers.
"""


# originally generated by 'h2xml+gccxml' and 'xml2py'
# then heavily reordered and reworked

# ############################################# #
# Interface to XForms shared object libraries   #
# ############################################# #


import ctypes as cty
from xformslib import library as libr
from xformslib import xfdata
from xformslib import flbasic
from xformslib import flcanvas



fl_current_form = (cty.POINTER(xfdata.FL_FORM)).in_dll( \
                   libr.load_so_libforms(), 'fl_current_form')
fl_display = (cty.POINTER(xfdata.Display)).in_dll(libr.load_so_libforms(),
              'fl_display')
fl_screen = (cty.c_int).in_dll(libr.load_so_libforms(), 'fl_screen')
# root window
fl_root = (xfdata.Window).in_dll(libr.load_so_libforms(), 'fl_root')
# virtual root window
fl_vroot = (xfdata.Window).in_dll(libr.load_so_libforms(), 'fl_vroot')
# screen dimension in pixels
fl_scrh = (cty.c_int).in_dll(libr.load_so_libforms(), 'fl_scrh')
fl_scrw = (cty.c_int).in_dll(libr.load_so_libforms(), 'fl_scrw')
fl_vmode = (cty.c_int).in_dll(libr.load_so_libforms(), 'fl_vmode')
fl_state = (cty.POINTER(xfdata.FL_State)).in_dll(libr.load_so_libforms(),
            'fl_state')
fl_ul_magic_char = (xfdata.STRING).in_dll(libr.load_so_libforms(),
                    'fl_state')



###########################
# forms.h (XBasic.h)
# X Window dependent stuff
###########################

def FL_is_gray(v):
    if (v == xfdata.GrayScale) or (v == xfdata.StaticGray):
        return True
    else:
        return False


def FL_is_rgb(v):
    if (v == xfdata.TrueColor) or (v == xfdata.DirectColor):
        return True
    else:
        return False


# Current version only runs in single visual mode
def fl_get_vclass():
    return fl_vmode


def fl_get_form_vclass(a):
    return fl_vmode


def fl_get_gc():
    return fl_state[fl_vmode].gc[0]


def fl_mode_capable(mode, warn):
    """Returns if the system is capable of displaying in the specified visual
    class, or not.

    --

    :Parameters:
      `mode` : int
        visual mode. Values (from xfdata module) GrayScale, StaticGray,
        PseudoColor, StaticColor, DirectColor or TrueColor
      `warn` : int
        if set a warning is printed out in case the capability asked for
        isn't available. Values 0 (don't print warning) or 1 (print warning)

    :return: flag 1 (if capable) or 0 otherwise
    :rtype: int

    :note: e.g. capable = fl_mode_capable(xfdata.GrayScale, 1)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_mode_capable = libr.cfuncproto(
        libr.load_so_libforms(), "fl_mode_capable",\
        cty.c_int, [cty.c_int, cty.c_int],\
        """int fl_mode_capable(int mode, int warn)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(mode, xfdata.VISUALMODE_list)
    imode = libr.convert_to_int(mode)
    iwarn = libr.convert_to_int(warn)
    libr.keep_elem_refs(mode, warn, imode, iwarn)
    retval = _fl_mode_capable(imode, iwarn)
    return retval


def fl_default_win():
    return fl_state[fl_vmode].trailblazer


def fl_default_window():
    return fl_state[fl_vmode].trailblazer


# Some basic drawing routines

# Rectangles

def fl_rectangle(fill, x, y, w, h, colr):
    """Draws a rectangle.

    --

    :Parameters:
      `fill` : int
        flag if the rectangle has to be filled or just the outline is needed.
        Values 0 (the outline only) or 1 (filled).
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value

    :note: e.g. fl_rectangle(1, 100, 200, 300, 200, xfdata.FL_BEIGE)

    :status: Tested + Doc + Demo = OK

    """
    _fl_rectangle = libr.cfuncproto(
        libr.load_so_libforms(), "fl_rectangle",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR], \
        """void fl_rectangle(int fill, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR col)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ifill = libr.convert_to_int(fill)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(fill, x, y, w, h, colr, ifill, ix, iy, iw, ih,
                        ulcolr)
    _fl_rectangle(ifill, ix, iy, iw, ih, ulcolr)


def fl_rectbound(x, y, w, h, colr):
    """Draws a filled rectangle with a black border.

    --

    :Parameters:
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value

    :note: e.g. fl_rectbound(100, 200, 300, 200, xfdata.FL_PINK)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_rectbound = libr.cfuncproto(
        libr.load_so_libforms(), "fl_rectbound",\
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR],\
        """void fl_rectbound(FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, FL_COLOR col)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(x, y, w, h, colr, ix, iy, iw, ih, ulcolr)
    _fl_rectbound(ix, iy, iw, ih, ulcolr)


def fl_rectf(x, y, w, h, colr):
    """Draws a filled rectangle on the screen.

    --

    :Parameters:
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value

    :note: e.g. fl_rectf(150, 220, 300, 200, xfdata.FL_TOMATO)

    :status: Tested + Doc + Demo = OK

    """
    fl_rectangle(1, x, y, w, h, colr)


def fl_rect(x, y, w, h, colr):
    """Draws a rectangle's outline on the screen.

    --

    :Parameters:
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value

    :note: e.g. fl_rect(100, 200, 300, 200, xfdata.FL_SLATEBLUE)

    :status: Tested + Doc + Demo = OK

    """
    fl_rectangle(0, x, y, w, h, colr)


# Rectangle with rounded-corners

def fl_roundrectangle(fill, x, y, w, h, colr):
    """Draws a rectangle with rounded corners (filled or just the outline).

    --

    :Parameters:
      `fill` : int
        flag if the rectangle has to be filled or just the outline is
        needed. Values 0 (the outline only) or 1 (filled)
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value

    :note: e.g. fl_roundrectangle(1, 100, 200, 300, 200, xfdata.FL_MAGENTA)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_roundrectangle = libr.cfuncproto(
        libr.load_so_libforms(), "fl_roundrectangle",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR],\
        """void fl_roundrectangle(int fill, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR col)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ifill = libr.convert_to_int(fill)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(fill, x, y, w, h, colr, ifill, ix, iy, iw, ih,
                   ulcolr)
    _fl_roundrectangle(ifill, ix, iy, iw, ih, ulcolr)


def fl_roundrectf(x, y, w, h, colr):
    """Draws a filled rectangle with rounded corners.

    --

    :Parameters:
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value

    :note: e.g. fl_roundrectf(100, 200, 300, 200, xfdata.FL_CYAN)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_roundrectangle(1, x, y, w, h, colr)


def fl_roundrect(x, y, w, h, colr):
    """Draws a rectangle's outline with rounded corners.

    --

    :Parameters:
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value

    :note: e.g. fl_roundrect(100, 200, 300, 200, xfdata.Fl_INDIANRED)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_roundrectangle(0, x, y, w, h, colr)


# General polygon and polylines

def fl_polygon(fill, Point, numpt, colr):
    """Draws a generic polygon on the screen (filled or just an outline).

    --

    :Parameters:
      `fill` : int
        if polygon has to be filled or just an outline is needed. Values 1
        (if filled) or 0 (an outline only)
      `Point` : array of xfdata.FL_POINT
        an array of point class instances
      `numpt` : int
        number of points
      `colr` : long_pos
        value of color to be set

    :note: e.g. pointmap = (FL_POINT * 4)()
    :note: e.g. pointmap[0].x = 12 ; pointmap[0].y = 32
    :note: e.g. pointmap[1].x = 24 ; pointmap[1].y = 100
    :note: e.g. pointmap[2].x = 87 ; pointmap[0].y = 132
    :note: e.g. fl_polygon(1, pointmap, 3, xfdata.FL_PALEGREEN)

    :status: Tested + Doc + Demo = OK

    """
    _fl_polygon = libr.cfuncproto(
        libr.load_so_libforms(), "fl_polygon",\
        None, [cty.c_int, cty.POINTER(xfdata.FL_POINT), cty.c_int,
        xfdata.FL_COLOR],
        """void fl_polygon(int fill, FL_POINT * xp, int n, FL_COLOR col)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ifill = libr.convert_to_int(fill)
    pPoint = cty.cast(Point, cty.POINTER(xfdata.FL_POINT))
    inumpt = libr.convert_to_int(numpt)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(fill, Point, numpt, colr, ifill, pPoint, inumpt,
                        ulcolr)
    _fl_polygon(ifill, pPoint, inumpt, ulcolr)


def fl_polyf(Point, numpt, colr):
    """Draws a generic filled polygon on the screen.

    --

    :Parameters:
      `Point` : array of xfdata.FL_POINT
        an array of point class instances
      `numpt` : int
        number of points
      `colr` : long_pos
        value of color to be set

    :note: e.g. pointmap = (FL_POINT * 4)() ;
    :note: e.g. pointmap[0].x = 12 ; pointmap[0].y = 32 ;
    :note: e.g. pointmap[1].x = 24 ; pointmap[1].y = 100 ;
    :note: e.g. pointmap[2].x = 87 ; pointmap[0].y = 132 ;
    :note: e.g. fl_polyf(pointmap, 3, xfdata.FL_PALEGREEN)

    :status: Tested + Doc + Demo = OK

    """
    fl_polygon(1, Point, numpt, colr)


def fl_polyl(Point, numpt, colr):
    """Draws a generic polygon's outline on the screen.

    --

    :Parameters:
      `Point` : array of xfdata.FL_POINT
        an array of point class instances
      `numpt` : int
        number of points
      `colr` : long_pos
        value of color to be set

    :note: e.g. pointmap = (FL_POINT * 4)() ;
    :note: e.g. pointmap[0].x = 12 ; pointmap[0].y = 32 ;
    :note: e.g. pointmap[1].x = 24 ; pointmap[1].y = 100 ;
    :note: e.g. pointmap[2].x = 87 ; pointmap[0].y = 132 ;
    :note: e.g. fl_polyl(pointmap, 3, xfdata.FL_ORCHID)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_polygon(0, Point, numpt, colr)


def fl_polybound(Point, numpt, colr):
    """Draws a generic filled polygon with a black border in the screen.

    --

    :Parameters:
      `Point` : array of xfdata.FL_POINT
        an array of point class instances
      `numpt` : int
        number of points
      `colr` : long_pos
        value of color to be set

    :note: e.g. pointmap = (FL_POINT * 4)() ;
    :note: e.g. pointmap[0].x = 12 ; pointmap[0].y = 32 ;
    :note: e.g. pointmap[1].x = 24 ; pointmap[1].y = 100 ;
    :note: e.g. pointmap[2].x = 87 ; pointmap[0].y = 132 ;
    :note: e.g. fl_polybound(pointmap, 3, xfdata.FL_DARKGOLD)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_polygon(1, Point, numpt, colr)
    fl_polygon(0, Point, numpt, xfdata.FL_BLACK)


def fl_lines(Point, numpt, colr):
    """Draws connected line segments between a number of points.

    --

    :Parameters:
      `Point` : array of xfdata.FL_POINT
        an array of point class instances
      `numpt` : int
        number of points
      `colr` : long_pos
        value of color to be set

    :note: e.g. pointmap = (FL_POINT * 4)() ;
    :note: e.g. pointmap[0].x = 23 ; pointmap[0].y = 12 ;
    :note: e.g. pointmap[1].x = 56 ; pointmap[1].y = 34 ;
    :note: e.g. pointmap[2].x = 102 ; pointmap[2].y = 250 ;
    :note: e.g. fl_lines(pointmap, 3, xfdata.FL_DODGERBLUE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_lines = libr.cfuncproto(
        libr.load_so_libforms(), "fl_lines",\
        None, [cty.POINTER(xfdata.FL_POINT), cty.c_int, xfdata.FL_COLOR],\
        """void fl_lines(FL_POINT * xp, int n, FL_COLOR col)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    pPoint = cty.cast(Point, cty.POINTER(xfdata.FL_POINT))
    inumpt = libr.convert_to_int(numpt)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(Point, numpt, colr, pPoint, inumpt, ulcolr)
    _fl_lines(pPoint, inumpt, ulcolr)


def fl_line(xi, yi, xf, yf, colr):
    """Connects two points with a straight line.

    --

    :Parameters:
      `xi` : int
        initial horizontal position (upper-left corner)
      `yi` : int
        initial vertical position (upper-left corner)
      `xf` : int
        final horizontal position (upper-left corner)
      `yf` : int
        final vertical position (upper-left corner)
      `colr` : long_pos
        color value

    :note: e.g. fl_line(100, 100, 200, 200, xfdata.FL_ANTIQUEWHITE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_line = libr.cfuncproto(
        libr.load_so_libforms(), "fl_line",\
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_COLOR],\
        """void fl_line(FL_Coord xi, FL_Coord yi, FL_Coord xf,
           FL_Coord yf, FL_COLOR c)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ixi = libr.convert_to_int(xi)
    iyi = libr.convert_to_int(yi)
    ixf = libr.convert_to_int(xf)
    iyf = libr.convert_to_int(yf)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(xi, yi, xf, yf, colr, ixi, iyi, ixf, iyf, ulcolr)
    _fl_line(ixi, iyi, ixf, iyf, ulcolr)


fl_simple_line = fl_line


def fl_point(x, y, colr):
    """Draws one point on the screen.

    --

    :Parameters:
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `colr` : long_pos
        color value

    :note: e.g. fl_point(75, 452, xfdata.FL_CHARTREUSE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_point = libr.cfuncproto(
        libr.load_so_libforms(), "fl_point",\
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_COLOR],\
        """void fl_point(FL_Coord x, FL_Coord y, FL_COLOR c)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(x, y, colr, ix, iy, ulcolr)
    _fl_point(ix, iy, ulcolr)


def fl_points(Point, numpt, colr):
    """Draws more than one points.

    --

    :Parameters:
      `Point` : array of xfdata.FL_POINT
        an array of point class instances
      `numpt` : int
        number of points
      `colr` : long_pos
        value of color to be set

    :note: e.g. pointmap = (FL_POINT * 3)() ;
    :note: e.g. pointmap[0].x = 23 ; pointmap[0].y = 12 ;
    :note: e.g. pointmap[1].x = 56 ; pointmap[1].y = 34 ;
    :note: e.g. pointmap[2].x = 102 ; pointmap[2].y = 250 ;
    :note: e.g. fl_points(pointmap, 3, xfdata.FL_AZURE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_points = libr.cfuncproto(
        libr.load_so_libforms(), "fl_points",\
        None, [cty.POINTER(xfdata.FL_POINT), cty.c_int, xfdata.FL_COLOR],
        """void fl_points(FL_POINT * p, int np, FL_COLOR c)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    pPoint = cty.cast(Point, cty.POINTER(xfdata.FL_POINT))
    inumpt = libr.convert_to_int(numpt)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(Point, numpt, colr, pPoint, inumpt, ulcolr)
    _fl_points(pPoint, inumpt, ulcolr)


def fl_dashedlinestyle(dash, ndash):
    """Changes the dash pattern for xfdata.FL_USERDASH and
    xfdata.FL USERDOUBLEDASH. Each element of the array dash is the length of
    a segment of the pattern in pixels. Dashed lines are drawn as alternating
    segments, each with the length of an element in dash. Thus the overall
    length of the dash pattern, in pixels, is the sum of all elements of dash.
    When the pattern is used up but the line to draw is longer it used from the
    start again. You have to call this one whenever xfdata.FL_USERDASH is used
    to set the dash pattern, otherwise whatever the last pattern was, it will
    be used. After the sequence, the pattern repeats.

    --

    :Parameters:
      `dash` : list_of_int
        sequence list of dashes to use. If it's 'None', use default dash
        pattern.
      `ndash` : int
        length of dashes list

    :note: e.g. dashlist = [9, 3, 2, 3]
    :note: e.g. fl_dashedlinestyle(dashlist, 4)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_dashedlinestyle = libr.cfuncproto(
        libr.load_so_libforms(), "fl_dashedlinestyle",\
        None, [xfdata.STRING, cty.c_int],\
        """void fl_dashedlinestyle(const char * dash, int ndash)""")
    libr.check_if_initialized()
    if not dash:                # it's None
        libr.verify_tuplelist_type(dash)
        sdash = libr.convert_to_string(dash)
    indash = libr.convert_to_int(ndash)
    libr.keep_elem_refs(dash, ndash, sdash, indash)
    _fl_dashedlinestyle(sdash, indash)


def fl_update_display(block):
    """Flushes properly the output buffer. It resolves the problem of the
    form being only partially redrawn, due to the two way buffering mechanism
    of Xlib, if fl_show_form() is followed by something that blocks (e.g.,
    waiting for a device other than X devices to come online). For typical
    programs that use fl_do_forms() or fl_check_forms() after fl_show_form(),
    flushing is not necessary as the output buffer is flushed automatically.
    Excessive call to fl_update_display() degrades performance.

    --

    :Parameters:
      `block` : int
        mode of X buffer flushing. Values 0 (it's flushed so the drawing
        requests are on their way to the server) or 1 (it's flushed and
        waits until all the events are received and processed by the server)

    :note: e.g. fl_update_display()

    :postcondition: to be used after fl_show_form()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_update_display = libr.cfuncproto(
        libr.load_so_libforms(), "fl_update_display",\
        None, [cty.c_int],\
        """void fl_update_display(int block)""")
    libr.check_if_initialized()
    iblock = libr.convert_to_int(block)
    libr.keep_elem_refs(block, iblock)
    _fl_update_display(iblock)


def fl_diagline(x, y, w, h, colr):
    """Draws a line along the diagonal of a box (to draw a horizontal line
    set h to 1, not to 0).

    --

    :Parameters:
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value

    :note: e.g. fl_diagline(180, 90, 5, 2, xfdata.FL_BISQUE)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_line(x, y, (x) + (w) - 1, (y) + (h) - 1, colr)


# Line attributes

def fl_linewidth(lw):
    """Changes the line width.

    --

    :Parameters:
      `lw` : int
        width of line in coord units. If it's 0, reset to the server's
        default

    :note: e.g. fl_linewidth(2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_linewidth = libr.cfuncproto(
        libr.load_so_libforms(), "fl_linewidth",\
        None, [cty.c_int],\
        """void fl_linewidth(int n)""")
    libr.check_if_initialized()
    ilw = libr.convert_to_int(lw)
    libr.keep_elem_refs(lw, ilw)
    _fl_linewidth(ilw)


fl_set_linewidth = fl_linewidth


def fl_linestyle(linestyle):
    """Changes the line style.

    --

    :Parameters:
      `linestyle` : int
        style of the line to draw. Values (from xfdata.py) FL_SOLID,
        FL_USERDASH, FL_USERDOUBLEDASH, FL_DOT, FL_DOTDASH, FL_DASH,
        FL_LONGDASH

    :note: e.g. fl_linestyle(xfdata.FL_DOT)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_linestyle = libr.cfuncproto(
        libr.load_so_libforms(), "fl_linestyle",\
        None, [cty.c_int],\
        """void fl_linestyle(int n)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(linestyle, xfdata.LINESTYLE_list)
    ilinestyle = libr.convert_to_int(linestyle)
    libr.keep_elem_refs(linestyle, ilinestyle)
    _fl_linestyle(ilinestyle)


fl_set_linestyle = fl_linestyle


def fl_drawmode(mode):
    """Changes the drawing mode so the destination pixel values play a role
    in the final pixel value. By default, all lines are drawn so they
    overwrite the destination pixel values.

    --

    :Parameters:
      `mode` : int
        requested mode setting. Values (from xfdata module) FL_XOR, FL_COPY,
        FL_AND

    :note: e.g. fl_drawmode(xfdata.FL_AND)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_drawmode = libr.cfuncproto(
        libr.load_so_libforms(), "fl_drawmode",\
        None, [cty.c_int],\
        """void fl_drawmode(int request)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(mode, xfdata.DRAWMODE_list)
    imode = libr.convert_to_int(mode)
    libr.keep_elem_refs(mode, imode)
    _fl_drawmode(imode)


def fl_get_linewidth():
    """Returns the width of line.

    --

    :return: line width (lw)
    :rtype: int

    :note: e.g. wid = fl_get_linewidth()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_linewidth = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_linewidth", \
        cty.c_int, [], \
        """int fl_get_linewidth()""")
    libr.check_if_initialized()
    retval = _fl_get_linewidth()
    return retval


def fl_get_linestyle():
    """Returns the style of line (from xfdata.py, e.g. FL_SOLID, FL_DOT,
    etc..).

    --

    :return: line style
    :rtype: int

    :note: e.g. currstl = fl_get_linestyle()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_linestyle = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_linestyle", \
        cty.c_int, [], \
        """int fl_get_linestyle()""")
    libr.check_if_initialized()
    retval = _fl_get_linestyle()
    return retval


def fl_get_drawmode():
    """Obtains the drawing mode of lines (from xfdata.py, e.g. FL_AND, FL_XOR
    etc..).

    --

    :return: drawing mode
    :rtype: int

    :note: e.g. currdrw = fl_get_draw_mode()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_drawmode = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_drawmode",\
        cty.c_int, [],\
        """int fl_get_drawmode()""")
    libr.check_if_initialized()
    retval = _fl_get_drawmode()
    return retval


fl_set_drawmode = fl_drawmode


# Ellipses

def fl_oval(fill, x, y, w, h, colr):
    """Draws an ellipse, either filled or open. Use w equal to h to get a
    circle.

    --

    :Parameters:
      `fill` : int
        flag if filled or open ellipse. Values 1 (if filled ellipse) or 0
        (if open)
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value

    :note: e.g. fl_oval(1, 125, 256, 145, 320, xfdata.FL_BURLYWOOD)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_oval = libr.cfuncproto(
        libr.load_so_libforms(), "fl_oval",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR], \
        """void fl_oval(int fill, FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, FL_COLOR col)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ifill = libr.convert_to_int(fill)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(fill, x, y, w, h, colr, ifill, ix, iy, iw, ih,
                        ulcolr)
    _fl_oval(ifill, ix, iy, iw, ih, ulcolr)


def fl_ovalbound(x, y, w, h, colr):
    """Draws a filled ellipse with a black outline. Use w equal to h to get a
    circle.

    --

    :Parameters:
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value

    :note: e.g. fl_ovalbound(1, 125, 256, 145, 320, xfdata.FL_BLANCHEDALMOND)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_ovalbound = libr.cfuncproto(
        libr.load_so_libforms(), "fl_ovalbound",\
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR],
        """void fl_ovalbound(FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, FL_COLOR col)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(x, y, w, h, colr, ix, iy, iw, ih, ulcolr)
    _fl_ovalbound(ix, iy, iw, ih, ulcolr)


def fl_ovalarc(fill, x, y, w, h, stheta, dtheta, colr):
    """Draws an elliptical arc, either filled or open.

    --

    :Parameters:
      `fill` : int
        flag if filled or open. Values 1 (if filled) or 0 (if open)
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `stheta` : int
        starting angle, measured in tenth of a degree and with 0 at 3
        o'clock position
      `dtheta` : int
        the directione and the extent of the arc. If positive the arc is
        drawn in counter-clockwise direction from the starting point,
        otherwise in clockwise direction. If it is larger than 3600 it is
        truncated to 3600.
      `colr` : long_pos
        color value

    :note: e.g. fl_ovalarc(1, 275, 256, 145, 320, 200, 900,
        xfdata.FL_DARKSALMON)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_ovalarc = libr.cfuncproto(
        libr.load_so_libforms(), "fl_ovalarc",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, cty.c_int, cty.c_int,
        xfdata.FL_COLOR],
        """void fl_ovalarc(int fill, FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, int t0, int dt, FL_COLOR col)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ifill = libr.convert_to_int(fill)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    istheta = libr.convert_to_int(stheta)
    idtheta = libr.convert_to_int(dtheta)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(fill, x, y, w, h, stheta, dtheta, colr, ifill,
                        ix, iy, iw, ih, istheta, idtheta, ulcolr)
    _fl_ovalarc(ifill, ix, iy, iw, ih, istheta, idtheta, ulcolr)


def fl_ovalf(x, y, w, h, colr):
    """Draws a filled ellipse. Use w equal to h to get a circle.

    --

    :Parameters:
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value

    :note: e.g. fl_ovalf(125, 256, 145, 320, xfdata.FL_CORNFLOWERBLUE)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_oval(1, x, y, w, h, colr)


def fl_ovall(x, y, w, h, colr):
    """Draws an open ellipse. Use w equal to h to get a circle.

    --

    :Parameters:
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value

    :note: e.g. fl_ovall(125, 256, 145, 320, xfdata.FL_DARKERED)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_oval(0, x, y, w, h, colr)


fl_oval_bound = fl_ovalbound


def fl_circf(x, y, r, colr):
    """Draws a filled circle.

    --

    :Parameters:
      `x` : int
        horizontal position of the center of the arc
      `y` : int
        vertical position of the center of the arc
      `r` : int
        radius of the arc
      `colr` : long_pos
        color value

    :note: e.g. fl_circf(200, 250, 69, xfdata.FL_FUCHSIA)

    :status: Tested + NoDoc + Demo = OK

    """
    fl_oval(1, (x) - (r), (y) - (r), 2 * (r), 2 * (r), colr)


def fl_circ(x, y, r, colr):
    """Draws an open circle.

    --

    :Parameters:
      `x` : int
        horizontal position of the center of the arc
      `y` : int
        vertical position of the center of the arc
      `r` : int
        radius of the arc

    :note: e.g. fl_circ(200, 250, 69, xfdata.FL_GAINSBORO)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_oval(0, (x) - (r), (y) - (r), 2 * (r), 2 * (r), colr)


# Arcs

def fl_pieslice(fill, x, y, w, h, stheta, etheta, colr):
    """Draws an elliptical arc, either filled or open.

    --

    :Parameters:
      `fill` : int
        if the arc is filled or open. Values 1 (if filled) or 0 (if open)
      `x` : int
        horizontal position of the bounding box
      `y` : int
        vertical position of the bounding box
      `h` : int
        horizontal axe of the ellipse
      `w` : int
        vertical axe of the ellipse
      `stheta` : int
        starting angle of the arc in units of tenths of a degree (where 0
        stands for a direction of 3 o'clock, i.e. the right-most point of a
        circle)
      `etheta` : int
        ending angle of the arc in units of tenths of a degree (where 0
        stands for a direction of 3 o'clock, i.e. the right-most point of a
        circle)
      `colr` : long_pos
        color value

    :note: e.g. fl_pieslice(1, 120, 253, 400, 100, 60, 70, xfdata.FL_GOLD)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_pieslice = libr.cfuncproto(
        libr.load_so_libforms(), "fl_pieslice",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, cty.c_int, cty.c_int,
        xfdata.FL_COLOR],
        """void fl_pieslice(int fill, FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, int a1, int a2, FL_COLOR col)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ifill = libr.convert_to_int(fill)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    istheta = libr.convert_to_int(stheta)
    ietheta = libr.convert_to_int(etheta)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(fill, x, y, w, h, stheta, etheta, colr, ifill,
                        ix, iy, iw, ih, istheta, ietheta, ulcolr)
    _fl_pieslice(ifill, ix, iy, iw, ih, istheta, ietheta, ulcolr)


def fl_arcf(x, y, r, stheta, etheta, colr):
    """Draws a filled circular arc. If the difference between theta end and
    theta start is larger than 3600 (360 degrees), drawing is truncated to
    360 degrees.

    --

    :Parameters:
      `x` : int
        horizontal position of the center of the arc
      `y` : int
        vertical position of the center of the arc
      `r` : int
        radius of the arc
      `stheta` : int
        starting angle of the arc in units of tenths of a degree (where 0
        stands for a direction of 3 o'clock, i.e. the right-most point of a
        circle)
      `etheta` : int
        ending angle of the arc in units of tenths of a degree (where 0
        stands for a direction of 3 o'clock, i.e. the right-most point of a
        circle)
      `colr` : long_pos
        color value

    :note: e.g. fl_arcf(120, 253, 40, 10, 60, xfdata.FL_FIREBRICK)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_pieslice(1, (x - r), (y - r), (2 * r), (2 * r), stheta, etheta, colr)


def fl_arc(x, y, r, stheta, etheta, colr):
    """Draws an open circular arc. If the difference between theta end and
    theta start is larger than 3600 (360 degrees), drawing is truncated to
    360 degrees.

    --

    :Parameters:
      `x` : int
        horizontal position of the center of the arc
      `y` : int
        vertical position of the center of the arc
      `r` : int
        radius of the arc
      `stheta` : starting angle of the arc in units of tenths of a degree
        (where 0 stands for a direction of 3 o'clock, i.e. the right-most
        point of a circle)
      `etheta` : ending angle of the arc in units of tenths of a degree
        (where 0 stands for a direction of 3 o'clock, i.e. the right-most
        point of a circle)
      `colr` : long_pos
        color value

    :note: e.g. fl_arc(120, 253, 40, 10, 60, xfdata.FL_FORESTGREEN)

    :status: Tested + Doc + NoDemo = OK

    """
    fl_pieslice(0, (x - r), (y - r), (2 * r), (2 * r), stheta, etheta, colr)


# High level drawing routines

def fl_drw_frame(boxtype, x, y, w, h, colr, bw):
    """Draws a frame outside of the bounding box specified.

    --

    :Parameters:
      `boxtype` : int
        type of frame box. Values (from xfdata.py) FL_NO_BOX, FL_UP_BOX,
        FL_DOWN_BOX, FL_BORDER_BOX, FL_SHADOW_BOX, FL_FRAME_BOX,
        FL_ROUNDED_BOX, FL_EMBOSSED_BOX, FL_FLAT_BOX, FL_RFLAT_BOX,
        FL_RSHADOW_BOX, FL_OVAL_BOX, FL_ROUNDED3D_UPBOX, FL_ROUNDED3D_DOWNBOX,
        FL_OVAL3D_UPBOX, FL_OVAL3D_DOWNBOX, FL_OVAL3D_FRAMEBOX,
        FL_OVAL3D_EMBOSSEDBOX
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value
      `bw` : int
        width of boundary

    :note: e.g. fl_drw_frame(xfdata.FL_UP_BOX, 470, 560, 170, 280,
        xfdata.FL_DIMGRAY, 2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_drw_frame = libr.cfuncproto(
        libr.load_so_libforms(), "fl_drw_frame",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_COLOR, cty.c_int],
        """void fl_drw_frame(int style, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR c, int bw)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(boxtype, xfdata.BOXTYPE_list)
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    iboxtype = libr.convert_to_int(boxtype)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    ibw = libr.convert_to_int(bw)
    libr.keep_elem_refs(boxtype, x, y, w, h, colr, bw, iboxtype, ix, iy, iw,
                   ih, ulcolr, ibw)
    _fl_drw_frame(iboxtype, ix, iy, iw, ih, ulcolr, ibw)


def fl_drw_checkbox(boxtype, x, y, w, h, colr, bw):
    """Draws a box rotated 45 degrees.

    --

    :Parameters:
      `boxtype` : int
        type of checkbox to draw. Values (from xfdata.py) FL_NO_BOX,
        FL_UP_BOX, FL_DOWN_BOX, FL_BORDER_BOX, FL_SHADOW_BOX, FL_FRAME_BOX,
        FL_ROUNDED_BOX, FL_EMBOSSED_BOX, FL_FLAT_BOX, FL_RFLAT_BOX,
        FL_RSHADOW_BOX, FL_OVAL_BOX, FL_ROUNDED3D_UPBOX,
        FL_ROUNDED3D_DOWNBOX, FL_OVAL3D_UPBOX, FL_OVAL3D_DOWNBOX,
        FL_OVAL3D_FRAMEBOX, FL_OVAL3D_EMBOSSEDBOX
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value
      `bw` : int
        width of boundary

    :note: e.g. fl_drw_checkbox(xfdata.FL_ROUNDED3D_UPBOX, 470, 560, 170,
        280, xfdata.FL_LEMONCHIFFON, -2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_drw_checkbox = libr.cfuncproto(
        libr.load_so_libforms(), "fl_drw_checkbox",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_COLOR, cty.c_int],
        """void fl_drw_checkbox(int type, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR col, int bw)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(boxtype, xfdata.BOXTYPE_list)
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    iboxtype = libr.convert_to_int(boxtype)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    ibw = libr.convert_to_int(bw)
    libr.keep_elem_refs(boxtype, x, y, w, h, colr, bw, iboxtype, ix, iy, iw,
                        ih, ulcolr, ibw)
    _fl_drw_checkbox(iboxtype, ix, iy, iw, ih, ulcolr, ibw)


# Interfaces

def fl_get_fontstruct(style, size):
    """Returns the X font structure for a particular size and style as used
    in XForms library.

    --

    :Parameters:
      `style` : int
        font style. Values (from xfdata.py) FL_NORMAL_STYLE, FL_BOLD_STYLE,
        FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        font size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE

    :return: XFontStruct class instance
    :rtype: pointer to xfdata.XFontStruct

    :note: e.g. pfstruc = fl_get_fontstruct(FL_ITALIC_STYLE, FL_NORMAL_STYLE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_fontstruct = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_fontstruct",\
        cty.POINTER(xfdata.XFontStruct), [cty.c_int, cty.c_int],\
        """XFontStruct * fl_get_fontstruct(int style, int size)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    istyle = libr.convert_to_int(style)
    isize = libr.convert_to_int(size)
    libr.keep_elem_refs(style, size, istyle, isize)
    retval = _fl_get_fontstruct(istyle, isize)
    return retval


fl_get_font_struct = fl_get_fontstruct
fl_get_fntstruct = fl_get_font_struct


def fl_get_mouse():
    """Obtains the current mouse position relative to the root window, and
    the current state of the modifier keys and pointer buttons.

    --

    :return: window the mouse is in (win), horizontal (x) and vertical
        position (y), keymask
    :rtype: long_pos, int, int, int_pos

    :note: e.g. win, x, y, kmsk = fl_get_mouse()

    :attention: API change from XForms - upstream was
        fl_get_mouse(x, y, keymask)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_mouse = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_mouse",\
        xfdata.Window, [cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord), cty.POINTER(cty.c_uint)],\
        """Window fl_get_mouse(FL_Coord * x, FL_Coord * y,
          unsigned int * keymask)""")
    libr.check_if_initialized()
    x, px = libr.make_FL_Coord_and_pointer()
    y, py = libr.make_FL_Coord_and_pointer()
    keymask, pkeymask = libr.make_uint_and_pointer()
    libr.keep_elem_refs(x, y, keymask, px, py, pkeymask)
    retval = _fl_get_mouse(px, py, pkeymask)
    return retval, x.value, y.value, keymask.value


def fl_set_mouse(x, y):
    """Moves the mouse to a specific location relative to the root window.
    Use this function sparingly, it can be extremely annoying for the user
    if the mouse position is changed by a program.

    --

    :Parameters:
      `x` : int
        horizontal position
      `y` : int
        vertical position

    :note: e.g. fl_set_mouse(200, 120)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_mouse = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_mouse",\
        None, [xfdata.FL_Coord, xfdata.FL_Coord],\
        """void fl_set_mouse(FL_Coord mx, FL_Coord my)""")
    libr.check_if_initialized()
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    libr.keep_elem_refs(x, y, ix, iy)
    _fl_set_mouse(ix, iy)


def fl_get_win_mouse(win):
    """Obtains the position of the mouse relative to a certain window, and
    the current state of the modifier keys and pointer buttons.

    --

    :Parameters:
      `win` : long_pos
        window id

    :return: window the mouse is in (win), horizontal (x) and vertical
        position (y), keymask
    :rtype: long_pos, int, int, int_pos

    :note: e.g. win, x, y, keym = fl_get_win_mouse()

    :attention: API change from XForms - upstream was
        fl_get_win_mouse(win, x, y, keymask)

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_win_mouse = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_win_mouse",\
        xfdata.Window, [xfdata.Window, cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord), cty.POINTER(cty.c_uint)],\
        """Window fl_get_win_mouse(Window win, FL_Coord * x, FL_Coord * y,
        unsigned int * keymask)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    x, px = libr.make_FL_Coord_and_pointer()
    y, py = libr.make_FL_Coord_and_pointer()
    keymask, pkeymask = libr.make_uint_and_pointer()
    libr.keep_elem_refs(win, x, y, keymask, ulwin, px, py, pkeymask)
    retval = _fl_get_win_mouse(ulwin, px, py, pkeymask)
    return retval, x.value, y.value, keymask.value


def fl_get_form_mouse(pFlForm):
    """Obtains the position of the mouse relative to a certain form, and
    the current state of the modifier keys and pointer buttons.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form

    :return: window the mouse is in (win), horizontal (x), vertical
        position (y), keymask
    :rtype: long_pos, int, int, int_pos

    :note: e.g. win, x, y, keym = fl_get_form_mouse()

    :attention: API change from XForms - upstream was
        fl_get_form_mouse(fm, x, y, keymask)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_form_mouse = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_form_mouse",\
        xfdata.Window, [cty.POINTER(xfdata.FL_FORM),
        cty.POINTER(xfdata.FL_Coord), cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(cty.c_uint)],\
        """Window fl_get_form_mouse(FL_FORM * fm, FL_Coord * x,
           FL_Coord * y, unsigned int * keymask)""")
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    x, px = libr.make_FL_Coord_and_pointer()
    y, py = libr.make_FL_Coord_and_pointer()
    keymask, pkeymask = libr.make_uint_and_pointer()
    libr.keep_elem_refs(pFlForm, x, y, keymask)
    retval = _fl_get_form_mouse(pFlForm, px, py, pkeymask)
    return retval, x.value, y.value, keymask.value


def fl_win_to_form(win):
    """Returns the form the specified window belongs to.

    --

    :Parameters:
      `win` : long_pos
        window id

    :return: form (pFlForm) or None (on failure)
    :rtype: pointer to xfdata.FL_FORM

    :note: e.g. pform2 = fl_win_to_form(win1)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_win_to_form = libr.cfuncproto(
        libr.load_so_libforms(), "fl_win_to_form",
        cty.POINTER(xfdata.FL_FORM), [xfdata.Window],\
        """FL_FORM * fl_win_to_form(Window win)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    libr.keep_elem_refs(win, ulwin)
    retval = _fl_win_to_form(ulwin)
    return retval


def fl_set_form_icon(pFlForm, icon, mask):
    """Sets or changes the icon shown when a form is iconified.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form
      `icon` : long_pos
        icon pixmap id
      `mask` : long_pos
        mask pixmap id

    :note: e.g. *todo*

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_form_icon = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_form_icon",\
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.Pixmap, xfdata.Pixmap],\
        """void fl_set_form_icon(FL_FORM * form, Pixmap p, Pixmap m)""")
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    ulicon = libr.convert_to_Pixmap(icon)
    ulmask = libr.convert_to_Pixmap(mask)
    libr.keep_elem_refs(pFlForm, icon, mask, ulicon, ulmask)
    _fl_set_form_icon(pFlForm, ulicon, ulmask)


def fl_get_decoration_sizes(pFlForm):
    """Returns the sizes of the "decorations" the window manager puts around
    a form's window.

    --

    :Parameters:
      `pFlForm` :  pointer to xfdata.FL_FORM
        form

    :return: 0 (on success) or -1 (if the form isn't visible or it's a form
        embedded into another form), top size, right size, bottom size, left
        size
    :rtype: int, int, int, int

    :note: e.g. dsize = fl_get_decoration_sizes(pform)

    :attention: API change from XForms - upstream was
        fl_get_decoration_sizes(pFlForm, top, right, bottom, left)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_decoration_sizes = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_decoration_sizes",
        cty.c_int, [cty.POINTER(xfdata.FL_FORM), cty.POINTER(cty.c_int),\
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int)],\
        """int fl_get_decoration_sizes(FL_FORM * form, int * top,
           int * right, int * bottom, int * left)""")
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    top, ptop = libr.make_int_and_pointer()
    right, pright = libr.make_int_and_pointer()
    bottom, pbottom = libr.make_int_and_pointer()
    left, pleft = libr.make_int_and_pointer()
    libr.keep_elem_refs(pFlForm, top, right, bottom, left, ptop, pright,
                        pbottom, pleft)
    retval = _fl_get_decoration_sizes(pFlForm, ptop, pright, pbottom, pleft)
    return retval, top.value, right.value, bottom.value, left.value


def fl_raise_form(pFlForm):
    """Raises a form to the top of the screen so no other forms obscure it.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form to be raised

    :note: e.g. fl_raise_form(pform2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_raise_form = libr.cfuncproto(
        libr.load_so_libforms(), "fl_raise_form",\
        None, [cty.POINTER(xfdata.FL_FORM)],\
        """void fl_raise_form(FL_FORM * p1)""")
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    _fl_raise_form(pFlForm)


def fl_lower_form(pFlForm):
    """Lowers a form to the bottom of the stack.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form to be lowered

    :note: e.g. fl_lower_form(pform2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_lower_form = libr.cfuncproto(
        libr.load_so_libforms(), "fl_lower_form",\
        None, [cty.POINTER(xfdata.FL_FORM)],\
        """void fl_lower_form(FL_FORM * p1)""")
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    _fl_lower_form(pFlForm)


# TODO: verify how to handle GC class
def fl_set_foreground(gc, colr):
    """Sets foreground color in Graphics Contexts (GCs) other than the XForms
    library's default.

    --

    :Parameters:
      `gc` : pointer to xfdata.GC?
        Graphics context number
      `colr` : long_pos
        color value to be set as foreground

    :note: e.g. gc = fl_state[fl_get_vclass()].gc[0] ??
    :note: e.g. fl_set_foreground(gc, xfdata.FL_LAWNGREEN)

    :status: Untested + NoDoc + NoDemo = NOT OK (NULL pointer access)

    """
    _fl_set_foreground = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_foreground",\
        None, [xfdata.GC, xfdata.FL_COLOR],\
        """void fl_set_foreground(GC gc, FL_COLOR col)""")
    libr.check_if_initialized()
    libr.verify_otherclassptr_type(gc, xfdata.GC)
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(gc, colr, ulcolr)
    _fl_set_foreground(gc, ulcolr)


# TODO: verify how to handle GC class
def fl_set_background(gc, colr):
    """Sets background color in Graphics contexts (GCs) other than the XForms
    library's default.

    --

    :Parameters:
      `gc` : pointer to xfdata.GC?
        Graphics context number
      `colr` : long_pos
        color value to be set as background

    :note: e.g. gc = fl_state[fl_get_vclass()].gc[0] ??
        fl_set_foreground(gc, xfdata.FL_HONEYDEW)

    :status: Untested + NoDoc + NoDemo = NOT OK (NULL pointer access)

    """
    _fl_set_background = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_background",\
        None, [xfdata.GC, xfdata.FL_COLOR],\
        """void fl_set_background(GC gc, FL_COLOR col)""")
    libr.check_if_initialized()
    libr.verify_otherclassptr_type(gc, xfdata.GC)
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(gc, colr, ulcolr)
    _fl_set_background(gc, ulcolr)


# General windowing support

def fl_wincreate(title):
    """Creates a window with a specified title.

    --

    :Parameters:
      `title` : str
        title of the window

    :return: created window id (win)
    :rtype: long_pos

    :note: e.g. win2 = fl_wincreate("My long title")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_wincreate = libr.cfuncproto(
        libr.load_so_libforms(), "fl_wincreate",\
        xfdata.Window, [xfdata.STRING],\
        """Window fl_wincreate(const char * label)""")
    libr.check_if_initialized()
    stitle = libr.convert_to_string(title)
    libr.keep_elem_refs(title, stitle)
    retval = _fl_wincreate(stitle)
    return retval


def fl_winshow(win):
    """Shows the window (created with fl_wincreate).

    --

    :Parameters:
      `win` : long_pos
        window id to show

    :return: window id shown (win)
    :rtype: long_pos

    :note: e.g. winw = fl_winshow(win2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winshow = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winshow",\
        xfdata.Window, [xfdata.Window],\
        """Window fl_winshow(Window win)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    libr.keep_elem_refs(win, ulwin)
    retval = _fl_winshow(ulwin)
    return retval


def fl_winopen(title):
    """Opens (creates and shows) a toplevel window with the specified title.

    --

    :Parameters:
      `title` : str
        title of the window

    :return: created window id (win)
    :rtype: long_pos

    :note: e.g. win2 = fl_winopen("My long title")

    :status: Tested + Doc + Demo = OK

    """
    _fl_winopen = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winopen", \
        xfdata.Window, [xfdata.STRING], \
        """Window fl_winopen(const char * label)""")
    libr.check_if_initialized()
    stitle = libr.convert_to_string(title)
    libr.keep_elem_refs(title, stitle)
    retval = _fl_winopen(stitle)
    return retval


def fl_winhide(win):
    """Hides a shown window.

    --

    :Parameters:
      `win` : long_pos
        window id to hide

    :note: e.g. fl_winhide(win2)

    :status: Tested + Doc + Demo = OK

    """
    _fl_winhide = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winhide", \
        None, [xfdata.Window], \
        """void fl_winhide(Window win)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    libr.keep_elem_refs(win, ulwin)
    _fl_winhide(ulwin)


def fl_winclose(win):
    """Closes (hides and destroys) the specified window.

    --

    :Parameters:
      `win` : long_pos
        window id to close

    :note: e.g. fl_winclose(win2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winclose = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winclose", \
        None, [xfdata.Window], \
        """void fl_winclose(Window win)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    libr.keep_elem_refs(win, ulwin)
    _fl_winclose(win, ulwin)


def fl_winset(win):
    """Sets the "current window", defined as the window the object that uses
    the drawing routine belongs to.

    --

    :Parameters:
      `win` : long_pos
        window id to be set

    :note: e.g. fl_winset(win3)

    :status: Tested + Doc + Demo = OK

    """
    _fl_winset = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winset", \
        None, [xfdata.Window], \
        """void fl_winset(Window win)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    libr.keep_elem_refs(win, ulwin)
    _fl_winset(ulwin)


def fl_winreparent(win, winnewparent):
    """Makes a toplevel window a subwindow of another (new parent) window;
    both the window and the parent window must be valid ones.

    --

    :Parameters:
      `win` : long_pos
        window id to be made a subwindow
      `winnewparent` : long_pos
        window id to become its new parent window

    :return: num., or -1 (on failure)
    :rtype: int

    :note: e.g. exitval = fl_winreparent(win1, win3)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winreparent = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winreparent", \
        cty.c_int, [xfdata.Window, xfdata.Window], \
        """int fl_winreparent(Window win, Window new_parent)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    ulwinnewparent = libr.convert_to_Window(winnewparent)
    libr.keep_elem_refs(win, winnewparent, ulwin, ulwinnewparent)
    retval = _fl_winreparent(ulwin, ulwinnewparent)
    return retval


def fl_winfocus(win):
    """Keyboard input is directed to the specified window, overriding the
    keyboard focus assignment.

    --

    :Parameters:
      `win` : long_pos
        window id

    :note: e.g. fl_winfocus(win3)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winfocus = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winfocus", \
        None, [xfdata.Window], \
        """void fl_winfocus(Window win)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    libr.keep_elem_refs(win, ulwin)
    _fl_winfocus(ulwin)


def fl_winget():
    """Queries the current window. One caveat about fl_winget() is that it
    can return None if called outside of an object's event handler, depending
    on where the mouse is. Thus, the return value of this function should be
    checked when called outside of an object handler.

    --

    :return: window id (win)
    :rtype: long_pos

    :note: e.g. currwin = fl_winget()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winget = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winget", \
        xfdata.Window, [], \
        """Window fl_winget()""")
    libr.check_if_initialized()
    retval = _fl_winget()
    return retval


def fl_iconify(win):
    """Iconifies the specified window.

    --

    :Parameters:
      `win` : long_pos
        window id

    :return: num.
    :rtype: int

    :note: e.g. fl_iconify(win2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_iconify = libr.cfuncproto(
        libr.load_so_libforms(), "fl_iconify", \
        cty.c_int, [xfdata.Window], \
        """int fl_iconify(Window win)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    libr.keep_elem_refs(win, ulwin)
    retval = _fl_iconify(ulwin)
    return retval


def fl_winresize(win, w, h):
    """Resizes a window.

    --

    :Parameters:
      `win` : long_pos
        window id to resize
      `w` : int
        new width in coord units
      `h` : int
        new height in coord units

    :note: e.g. fl_winresize(win6, 547, 624)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winresize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winresize", \
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord], \
        """void fl_winresize(Window win, FL_Coord neww, FL_Coord newh)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    iw = libr.convert_to_int(w)
    ih = libr.convert_to_int(h)
    libr.keep_elem_refs(win, w, h, ulwin, iw, ih)
    _fl_winresize(ulwin, iw, ih)


def fl_winmove(win, x, y):
    """Moves the specified window to a new position.

    --

    :Parameters:
      `win` : long_pos
        window id to move to a new position
      `x` : int
        new horizontal position (upper-left corner)
      `y` : int
        new vertical position (upper-left corner)

    :note: e.g. fl_winmove(win5, 116, 331)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winmove = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winmove", \
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord], \
        """void fl_winmove(Window win, FL_Coord dx, FL_Coord dy)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    ix = libr.convert_to_int(x)
    iy = libr.convert_to_int(y)
    libr.keep_elem_refs(win, x, y, ulwin, ix, iy)
    _fl_winmove(ulwin, ix, iy)


def fl_winreshape(win, x, y, w, h):
    """Reshapes (resizes and moves) a window.

    --

    :Parameters:
      `win` : long_pos
        window id to reshape
      `x` : int
        new horizontal position (upper-left corner)
      `y` : int
        new vertical position (upper-left corner)
      `w` : int
        new width in coord units
      `h` : int
        new height in coord units

    :note: e.g. fl_winreshape(win5, 116, 331, 144, 182)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winreshape = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winreshape", \
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord], \
        """void fl_winreshape(Window win, FL_Coord dx, FL_Coord dy,
           FL_Coord w, FL_Coord h)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    ix = libr.convert_to_int(x)
    iy = libr.convert_to_int(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    libr.keep_elem_refs(win, x, y, w, h, ulwin, ix, iy, iw, ih)
    _fl_winreshape(ulwin, ix, iy, iw, ih)


def fl_winicon(win, icon, mask):
    """Installs an icon for the window.

    --

    :Parameters:
      `win` : long_pos
        window id
      `icon` : long_pos
        pixmap icon id to be installed in window
      `mask` : long_pos
        pixmap mask id

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_winicon = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winicon", \
        None, [xfdata.Window, xfdata.Pixmap, xfdata.Pixmap], \
        """void fl_winicon(Window win, Pixmap p, Pixmap m)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    ulicon = libr.convert_to_Pixmap(icon)
    ulmask = libr.convert_to_Pixmap(mask)
    libr.keep_elem_refs(win, icon, mask, ulwin, ulicon, ulmask)
    _fl_winicon(ulwin, ulicon, ulmask)


def fl_winbackground(win, bkcolr):
    """Sets the background of window to a certain color.

    --

    :Parameters:
      `win` : long_pos
        window id
      `bkcolr` : long_pos
        background color to be set

    :note: e.g. fl_winbackground(win1, xfdata.FL_GHOSTWHITE)

    :status: Tested + NoDoc + Demo = OK

    """
    _fl_winbackground = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winbackground", \
        None, [xfdata.Window, xfdata.FL_COLOR], \
        """void fl_winbackground(Window win, FL_COLOR bk)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(bkcolr, xfdata.COLOR_list)
    ulwin = libr.convert_to_Window(win)
    ulbkcolr = libr.convert_to_FL_COLOR(bkcolr)
    libr.keep_elem_refs(win, bkcolr, ulwin, ulbkcolr)
    _fl_winbackground(ulwin, ulbkcolr)


fl_win_background = fl_winbackground


def fl_winstepsize(win, xunit, yunit):
    """Sets the steps by which the size of a window can be changed. Changes
    to the window size will be multiples of specified units after this
    call. Note that this only applies to interactive resizing.

    --

    :Parameters:
      `win` : long_pos
        window id
      `xunit` : int
        number of pixels of changes per unit in horizontal direction
      `yunit` : int
        number of pixels of changes per unit in vertical direction

    :note: e.g. fl_winstepsize(win0, 10, 10)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winstepsize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winstepsize", \
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord], \
        """void fl_winstepsize(Window win, FL_Coord dx, FL_Coord dy)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    ixunit = libr.convert_to_int(xunit)
    iyunit = libr.convert_to_int(yunit)
    libr.keep_elem_refs(win, xunit, yunit, ulwin, ixunit, iyunit)
    _fl_winstepsize(ulwin, ixunit, iyunit)


fl_winstepunit = fl_winstepsize
fl_set_winstepunit = fl_winstepsize
fl_set_winstepunit = fl_winstepunit


def fl_winisvalid(win):
    """Checks if a window id is valid or not. Note that excessive use of
    this function may negatively impact performance.

    --

    :Parameters:
      `win` : long_pos
        window id to evaluate

    :return: num.
    :rtype: int

    :note: e.g. if fl_winisvalid(win3): ...

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winisvalid = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winisvalid", \
        cty.c_int, [xfdata.Window], \
        """int fl_winisvalid(Window win)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    libr.keep_elem_refs(win, ulwin)
    retval = _fl_winisvalid(ulwin)
    return retval


def fl_wintitle(win, title):
    """Changes the window title (and its associated icon title).

    --

    :Parameters:
      `win` : long_pos
        window id
      `title` : str
        window title to be set

    :note: e.g. fl_wintitle("My brand new title")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_wintitle = libr.cfuncproto(
        libr.load_so_libforms(), "fl_wintitle", \
        None, [xfdata.Window, xfdata.STRING], \
        """void fl_wintitle(Window win, const char * title)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    stitle = libr.convert_to_string(title)
    libr.keep_elem_refs(win, title, ulwin, stitle)
    _fl_wintitle(ulwin, stitle)


def fl_winicontitle(win, title):
    """Changes only the icon title for the window.

    --

    :Parameters:
      `win` : long_pos
        window id
      `title` : str
        icon title to be set

    :note: e.g. fl_winicontitle(win0, "My icon label")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winicontitle = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winicontitle", \
        None, [xfdata.Window, xfdata.STRING], \
        """void fl_winicontitle(Window win, const char * title)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    stitle = libr.convert_to_string(title)
    libr.keep_elem_refs(win, title, ulwin, stitle)
    _fl_winicontitle(ulwin, stitle)


def fl_winposition(x, y):
    """Sets the position of a window to be opened.

    --

    :Parameters:
      `x` : int
        horizontal position of window (upper-left corner)
      `y` : int
        vertical position of window (upper-left corner)

    :note: e.g. fl_winposition(140, 123)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winposition = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winposition",
        None, [xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_winposition(FL_Coord x, FL_Coord y)""")
    libr.check_if_initialized()
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    libr.keep_elem_refs(x, y, ix, iy)
    _fl_winposition(ix, iy)


fl_pref_winposition = fl_winposition


def fl_winminsize(win, w, h):
    """Sets a constraint for a resizable window whose size will be within a
    range not less than minumum (to be used before calling fl_winopen).

    --

    :Parameters:
      `win` : long_pos
        window id to be set
      `w` : int
        minimum width of window in coord units
      `h` : int
        minimum height of window in coord units

    :note: e.g. fl_winminsize(win1, 500, 500)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winminsize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winminsize",
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_winminsize(Window win, FL_Coord w, FL_Coord h)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    libr.keep_elem_refs(win, w, h, ulwin, iw, ih)
    _fl_winminsize(ulwin, iw, ih)


def fl_winmaxsize(win, w, h):
    """Sets a constraint for a resizable window whose size will be within a
    range not bigger than maximum (before calling fl_winopen).

    --

    :Parameters:
      `win` : long_pos
        window id to be set
      `w` : int
        maximum width of window in coord units
      `h` : int
        maximum height of window in coord units

    :note: e.g. fl_winmaxsize(win1, 500, 500)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winmaxsize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winmaxsize",
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_winmaxsize(Window win, FL_Coord w, FL_Coord h)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    libr.keep_elem_refs(win, w, h, ulwin, iw, ih)
    _fl_winmaxsize(ulwin, iw, ih)


def fl_winaspect(win, x, y):
    """Sets the aspect ratio of the window for later interactive resizing.

    --

    :Parameters:
      `win` : long_pos
        window id to be set
      `x` : int
        horizontal aspect ratio in coord units
      `y` : int
        vertical aspect ratio in coord units

    :note: e.g. fl_winaspect(win0, 2, 4)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winaspect = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winaspect",
        None, [xfdata.Window, xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_winaspect(Window win, FL_Coord x, FL_Coord y)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    libr.keep_elem_refs(win, x, y, ulwin, ix, iy)
    _fl_winaspect(ulwin, ix, iy)


def fl_reset_winconstraints(win):
    """Changes constraints (size and aspect ratio) on an active window.

    --

    :Parameters:
      `win` : long_pos
        window to be reset

    :note: e.g. fl_reset_constraints(win0)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_reset_winconstraints = libr.cfuncproto(
        libr.load_so_libforms(), "fl_reset_winconstraints",
        None, [xfdata.Window],
        """void fl_reset_winconstraints(Window win)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    libr.keep_elem_refs(win)
    _fl_reset_winconstraints(ulwin)


def fl_winsize(w, h):
    """Sets the preferred window size (before calling fl_winopen), and
    makes the window non-resizeable.

    --

    :Parameters:
      `w` : int
        width in coord units
      `h` : int
        height in coord units

    :note: e.g. fl_winsize(700, 600)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_winsize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_winsize",
        None, [xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_winsize(FL_Coord w, FL_Coord h)""")
    libr.check_if_initialized()
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    libr.keep_elem_refs(w, h, iw, ih)
    _fl_winsize(iw, ih)


fl_pref_winsize = fl_winsize


def fl_initial_winsize(w, h):
    """Sets the preferred window size (before calling fl_winopen).

    --

    :Parameters:
      `w` : int
        width in coord units
      `h` : int
        height in coord units

    :note: e.g. fl_initial_winsize(700, 600)

    :status: Tested + Doc + Demo = OK

    """
    _fl_initial_winsize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_initial_winsize",
        None, [xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_initial_winsize(FL_Coord w, FL_Coord h)""")
    libr.check_if_initialized()
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    libr.keep_elem_refs(w, h, iw, ih)
    _fl_initial_winsize(iw, ih)


# TODO: verify if it's supposed to be used in python
def fl_initial_winstate(state):
    """Sets initial state, normal or iconic, of the window.

    --

    :Parameters:
      `state` : int
        window state to be set. Values (from xfdata.py) NormalState,
        IconicState

    :note: e.g. fl_initial_winstate(xfdata.IconicState)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_initial_winstate = libr.cfuncproto(
        libr.load_so_libforms(), "fl_initial_winstate",
        None, [cty.c_int],
        """void fl_initial_winstate(int state)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(state, xfdata.WINSTATE_list)
    istate = libr.convert_to_int(state)
    libr.keep_elem_refs(state, istate)
    _fl_initial_winstate(istate)


def fl_create_colormap(pXVisualInfo, nfill):
    """Creates a colormap appropriate for a given visual to be used with
    a canvas.

    --

    :Parameters:
      `pXVisualInfo` : pointer to xfdata.XVisualInfo
        XVisualInfo class instance
      `nfill` : int
        how many colors in the newly created colormap should be filled with
        XForms' default colors (to avoid flashing effects)

    :return: created colormap
    :rtype: long_pos

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _fl_create_colormap = libr.cfuncproto(
        libr.load_so_libforms(), "fl_create_colormap",
        xfdata.Colormap, [cty.POINTER(xfdata.XVisualInfo), cty.c_int],
        """Colormap fl_create_colormap(XVisualInfo * xv, int nfill)""")
    libr.check_if_initialized()
    infill = libr.convert_to_int(nfill)
    libr.keep_elem_refs(pXVisualInfo, nfill, infill)
    retval = _fl_create_colormap(pXVisualInfo, infill)
    return retval


def fl_wingeometry(x, y, w, h):
    """Sets the initial geometry (position and size) of the window to be
    opened; the window will not be resizable.

    --

    :Parameters:
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units

    :note: e.g. fl_wingeometry(192, 231, 450, 550)

    :status: Tested + Doc + Demo = OK

    """
    _fl_wingeometry = libr.cfuncproto(
        libr.load_so_libforms(), "fl_wingeometry",
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord],
        """void fl_wingeometry(FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h)""")
    libr.check_if_initialized()
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    libr.keep_elem_refs(x, y, w, h, ix, iy, iw, ih)
    _fl_wingeometry(ix, iy, iw, ih)


fl_pref_wingeometry = fl_wingeometry


def fl_initial_wingeometry(x, y, w, h):
    """Sets the initial geometry (position and size) of the window to be
    opened.

    --

    :Parameters:
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units

    :note: e.g. fl_initial_wingeometry(192, 231, 450, 550)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_initial_wingeometry = libr.cfuncproto(
        libr.load_so_libforms(), "fl_initial_wingeometry",
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord],
        """void fl_initial_wingeometry(FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h)""")
    libr.check_if_initialized()
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    libr.keep_elem_refs(x, y, w, h, ix, iy, iw, ih)
    _fl_initial_wingeometry(ix, iy, iw, ih)


def fl_noborder():
    """Suppresses the window manager's decoration (before creating the
    window).

    --

    :note: e.g. fl_noborder()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_noborder = libr.cfuncproto(
        libr.load_so_libforms(), "fl_noborder",
        None, [],
        """void fl_noborder()""")
    libr.check_if_initialized()
    _fl_noborder()


def fl_transient():
    """Makes a window a transient one (before creating the window).

    --

    :note: e.g. fl_transient()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_transient = libr.cfuncproto(
        libr.load_so_libforms(), "fl_transient",
        None, [], \
        """void fl_transient()""")
    libr.check_if_initialized()
    _fl_transient()


def fl_get_winsize(win):
    """Obtains the size of the specified window.

    --

    :Parameters:
      `win` : long_pos
        window id to evaluate

    :return: width (w), height (h) of window
    :rtype: int, int

    :note: e.g. wid, hei = fl_get_winsize(win0)

    :attention: API change from XForms - upstream was
        fl_get_winsize(win, w, h)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_winsize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_winsize",
        None, [xfdata.Window, cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord)],
        """void fl_get_winsize(Window win, FL_Coord * w, FL_Coord * h)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    w, pw = libr.make_int_and_pointer()
    h, ph = libr.make_int_and_pointer()
    libr.keep_elem_refs(win, ulwin, w, h, pw, ph)
    _fl_get_winsize(ulwin, pw, ph)
    return w.value, h.value


def fl_get_winorigin(win):
    """Obtains the origin (position) of the specified window.

    --

    :Parameters:
      `win` : long_pos
        window id to evaluate

    :return: horizontal (x) and vertical position (y) of window
    :rtype: int, int

    :note: e.g. xpos, ypos = fl_get_winorigin(win0)

    :attention: API change from XForms - upstream was
        fl_get_winorigin(win, x, y)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_winorigin = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_winorigin",
        None, [xfdata.Window, cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord)],
        """void fl_get_winorigin(Window win, FL_Coord * x, FL_Coord * y)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    x, px = libr.make_FL_Coord_and_pointer()
    y, py = libr.make_FL_Coord_and_pointer()
    libr.keep_elem_refs(win, ulwin, x, y, px, py)
    _fl_get_winorigin(win, px, py)
    return x.value, y.value


def fl_get_wingeometry(win):
    """Obtains geometry (position and size) of a window.

    --

    :Parameters:
      `win` : long_pos
        window id to evaluate

    :return: horizontal (x), vertical position (y), width (w) and height (h)
        of window
    :rtype: int, int, int, int

    :note: e.g. xpos, ypos, wid, hei = fl_get_wingeometry(win0)

    :attention: API change from XForms - upstream was
        fl_get_wingeometry(win, x, y, w, h)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_wingeometry = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_wingeometry",
        None, [xfdata.Window, cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord), cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord)],
        """void fl_get_wingeometry(Window win, FL_Coord * x,
           FL_Coord * y, FL_Coord * w, FL_Coord * h)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    x, px = libr.make_FL_Coord_and_pointer()
    y, py = libr.make_FL_Coord_and_pointer()
    w, pw = libr.make_FL_Coord_and_pointer()
    h, ph = libr.make_FL_Coord_and_pointer()
    libr.keep_elem_refs(win, x, y, w, h, ulwin, px, py, pw, ph)
    _fl_get_wingeometry(ulwin, px, py, pw, ph)
    return x.value, y.value, w.value, h.value


# fl_get_win_size placeholder (backwards)
# fl_get_win_origin (backwards)
# fl_get_win_geometry (backwards)
# fl_initial_winposition (backwards)


def fl_get_display():
    libr.check_if_initialized()
    return fl_display


def FL_FormDisplay(pFlForm):
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    return fl_display


# undocumented data maybe dismissed? --LK
def FL_ObjectDisplay(pFlObject):
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    return fl_display


def FL_IS_CANVAS(pFlObject):
    if (flbasic.fl_get_object_objclass(pFlObject) == xfdata.FL_CANVAS) or \
        (flbasic.fl_get_object_objclass(pFlObject) == xfdata.FL_GLCANVAS):
        return True
    else:
        return False


# The window an object belongs to - for drawing
def FL_ObjWin(pFlObject):
    """Obtains the window id an object belongs to (for general use).

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object

    :return: window id (win)
    :rtype: long_pos

    :note: e.g. wind = FL_ObjWin(pobj)

    :status: Tested + Doc + Demo = OK

    """
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    if FL_IS_CANVAS(pFlObject):
        return flcanvas.fl_get_canvas_id(pFlObject)
    else:
        return pFlObject.contents.form.contents.window


def fl_get_real_object_window(pFlObject):
    """ Obtains the real window id an object belongs to (to be used for
    cursor or pointer routines).

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object

    :return: window id (win)
    :rtype: long_pos

    :note: e.g. wind = fl_get_real_object_window(pobj)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_real_object_window = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_real_object_window",
        xfdata.Window, [cty.POINTER(xfdata.FL_OBJECT)],
        """Window fl_get_real_object_window(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_real_object_window(pFlObject)
    return retval


FL_OBJECT_WID = FL_ObjWin


# Replacements for X functions that access the event queue

def fl_XNextEvent(pXEvent):
    """*todo*

    --

    :Parameters:
      `pXEvent` : pointer to xfdata.XEvent
        XEvent class instance

    :return: event num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_XNextEvent = libr.cfuncproto(
        libr.load_so_libforms(), "fl_XNextEvent",
        cty.c_int, [cty.POINTER(xfdata.XEvent)],
        """int fl_XNextEvent(XEvent * xev)""")
    libr.check_if_initialized()
    libr.verify_otherclassptr_type(pXEvent, cty.POINTER(xfdata.XEvent))
    libr.keep_elem_refs(pXEvent)
    retval = _fl_XNextEvent(pXEvent)
    return retval


def fl_XPeekEvent(pXEvent):
    """*todo*

    --

    :Parameters:
      `pXEvent` : pointer to xfdata.XEvent
        XEvent class instance

    :return: event num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_XPeekEvent = libr.cfuncproto(
        libr.load_so_libforms(), "fl_XPeekEvent",
        cty.c_int, [cty.POINTER(xfdata.XEvent)],
        """int fl_XPeekEvent(XEvent * xev)""")
    libr.check_if_initialized()
    libr.verify_otherclassptr_type(pXEvent, cty.POINTER(xfdata.XEvent))
    libr.keep_elem_refs(pXEvent)
    retval = _fl_XPeekEvent(pXEvent)
    return retval


def fl_XEventsQueued(mode):
    """*todo*

    --

    :Parameters:
      `mode` : int
        mode

    :return: event num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_XEventsQueued = libr.cfuncproto(
        libr.load_so_libforms(), "fl_XEventsQueued",
        cty.c_int, [cty.c_int],
        """int fl_XEventsQueued(int mode)""")
    libr.check_if_initialized()
    imode = libr.convert_to_int(mode)
    libr.keep_elem_refs(mode, imode)
    retval = _fl_XEventsQueued(imode)
    return retval


def fl_XPutBackEvent(pXEvent):
    """ fl_XPutBackEvent(pXEvent)

    --

    :Parameters:
      `pXEvent` : pointer to xfdata.XEvent
        XEvent class instance

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_XPutBackEvent = libr.cfuncproto(
        libr.load_so_libforms(), "fl_XPutBackEvent",
        None, [cty.POINTER(xfdata.XEvent)],
        """void fl_XPutBackEvent(XEvent * xev)""")
    libr.check_if_initialized()
    libr.verify_otherclassptr_type(pXEvent, cty.POINTER(xfdata.XEvent))
    libr.keep_elem_refs(pXEvent)
    _fl_XPutBackEvent(pXEvent)


def fl_last_event():
    """*todo*

    --

    :return: XEvent class instance (pXEvent)
    :rtype: pointer to xfdata.XEvent

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_last_event = libr.cfuncproto(
        libr.load_so_libforms(), "fl_last_event",
        cty.POINTER(xfdata.XEvent), [],
        """const char * fl_last_event()""")
    libr.check_if_initialized()
    retval = _fl_last_event()
    return retval


def fl_set_event_callback(py_AppEventCb, vdata):
    """Sets up an event callback routine. Whenever an event happens, the
    callback function is invoked with the event as the first argument.
    This assumes the application program solicits the events and further,
    the callback routine should be prepared to handle all X Event for all
    non-form windows. The callback function normally should return 0
    unless the event isn't for one of the applcation-managed windows.
    This routine will be called whenever an X Event is pending for the
    application's own window.

    --

    :Parameters:
      `py_AppEventCb` : python function callback, returning value
        name referring to function(pXEvent, ptr_void) -> num.
      `vdata` : None or long or pointer to xfdata.FL_OBJECT
        user data to be passed to function

    :return: old event callback
    :rtype: pointer to xfdata.FL_APPEVENT_CB

    :note: e.g. def eventcb(pxev, vdata): > ... ; return 0
    :note: e.g. fl_set_event_callback(eventcb, None)

    :status: Tested + Doc + Demo = OK

    """
    #FL_APPEVENT_CB = cty.CFUNCTYPE(cty.c_int, cty.POINTER(XEvent),
    #                               cty.c_void_p)
    _fl_set_event_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_event_callback",
        xfdata.FL_APPEVENT_CB, [xfdata.FL_APPEVENT_CB, cty.c_void_p],
        """FL_APPEVENT_CB fl_set_event_callback(FL_APPEVENT_CB callback,
           void * user_data)""")
    libr.check_if_initialized()
    c_AppEventCb = xfdata.FL_APPEVENT_CB(py_AppEventCb)
    if vdata is None:
        pvdata = cty.cast(vdata, cty.c_void_p)
    elif isinstance(vdata, long):
        ldata = libr.convert_to_long(vdata)
        pvdata = cty.cast(ldata, cty.POINTER(cty.c_long))
    else:
        pvdata = vdata          # it is pFlObject
        libr.verify_flobjectptr_type(pvdata)
    libr.keep_cfunc_refs(c_AppEventCb, py_AppEventCb)
    libr.keep_elem_refs(vdata, pvdata)
    retval = _fl_set_event_callback(c_AppEventCb, pvdata)
    return retval


def fl_set_idle_callback(py_AppEventCb, vdata):
    """Registers an idle callback. Interaction with it  can used for periodic
    tasks, e.g. rotating an image, checking the status of some external
    device or application state etc. An idle callback is an application
    function that is registered with the system and is called whenever there
    are no events pending for forms (or application windows). If called with
    a function as callback who does nothing, it removes idle callback.
    The time interval between invocations of the idle callback can vary
    considerably depending on interface activity and other factors. A
    range between 50 and 300 msec should be expected.

    --

    :Parameters:
      `py_AppEventCb` : python function callback, returning unused value
        name referring to function(pXEvent, ptr_void) -> num.
      `vdata` : None or long or pointer to xfdata.FL_OBJECT
        user data to be passed to function

    :return: old event callback function
    :rtype: pointer to xfdata.FL_APPEVENT_CB

    :note: e.g. def idlecb(xev, userdata): > ... ; return 0
    :note: e.g. appevtcb = fl_set_idle_callback(idlecb, None)
    :note: e.g. def donothing_idlecb(xev, userdata): > pass
    :note: e.g. removedcb = fl_set_idle_callback(donothing_idlecb, None)

    :status: Tested + Doc + NoDemo = OK

    """
    #FL_APPEVENT_CB = cty.CFUNCTYPE(cty.c_int, cty.POINTER(XEvent),
    #                               cty.c_void_p)
    _fl_set_idle_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_idle_callback",
        xfdata.FL_APPEVENT_CB, [xfdata.FL_APPEVENT_CB, cty.c_void_p],
        """FL_APPEVENT_CB fl_set_idle_callback(FL_APPEVENT_CB callback,
           void * user_data)""")
    libr.check_if_initialized()
    c_AppEventCb = xfdata.FL_APPEVENT_CB(py_AppEventCb)
    if vdata is None:
        pvdata = cty.cast(vdata, cty.c_void_p)
    elif isinstance(vdata, long):
        ldata = libr.convert_to_long(vdata)
        pvdata = cty.cast(ldata, cty.POINTER(cty.c_long))
    else:
        pvdata = vdata          # it is pFlObject
        libr.verify_flobjectptr_type(pvdata)
    libr.keep_cfunc_refs(c_AppEventCb, py_AppEventCb)
    libr.keep_elem_refs(vdata, pvdata)
    retval = _fl_set_idle_callback(c_AppEventCb, pvdata)
    return retval


def fl_addto_selected_xevent(win, mask):
    """Adds solicited event masks on the fly without altering other masks
    already selected.

    --

    :Parameters:
      `win` : long_pos
        window id
      `mask` : long
        event mask

    :return: num.
    :rtype: long

    :note: e.g. lnum = fl_addto_selected_xevent(win7, xfdata.ButtonMotionMask)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_addto_selected_xevent = libr.cfuncproto(
        libr.load_so_libforms(), "fl_addto_selected_xevent",
        cty.c_long, [xfdata.Window, cty.c_long],
        """long int fl_addto_selected_xevent(Window win, long int mask)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    lmask = libr.convert_to_long(mask)
    libr.keep_elem_refs(win, mask, ulwin, lmask)
    retval = _fl_addto_selected_xevent(ulwin, lmask)
    return retval


def fl_remove_selected_xevent(win, mask):
    """ Removes solicited event masks on the fly without altering other masks
    already selected.

    --

    :Parameters:
      `win` : long_pos
        window id
      `mask` : long
        event mask

    :return: num.
    :rtype: long

    :note: e.g. lnum = fl_remove_selected_xevent(win7, xfdata.ButtonMotionMask)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_remove_selected_xevent = libr.cfuncproto(
        libr.load_so_libforms(), "fl_remove_selected_xevent",
        cty.c_long, [xfdata.Window, cty.c_long],
        """long int fl_remove_selected_xevent(Window win, long int mask)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    lmask = libr.convert_to_long(mask)
    libr.keep_elem_refs(win, mask, ulwin, lmask)
    retval = _fl_remove_selected_xevent(ulwin, lmask)
    return retval


fl_add_selected_xevent = fl_addto_selected_xevent


def fl_set_idle_delta(msec):
    """ Changes what the library considers to be "idle". Be aware that under
    some conditions ad idle callback can be called sooner than the minimum
    interval; if the timing of the idle callback is of concerned, timeouts
    should be used.

    --

    :Parameters:
      `msec` : long
        minimum time interval of inactivity, after which the main loop is
        considered to be in idle state

    :note: e.g. fl_set_idle_delta(800)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_idle_delta = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_idle_delta",
        None, [cty.c_long],
        """void fl_set_idle_delta(long int delta)""")
    libr.check_if_initialized()
    lmsec = libr.convert_to_long(msec)
    libr.keep_elem_refs(msec, lmsec)
    _fl_set_idle_delta(lmsec)


def fl_add_event_callback(win, evttype, py_AppEventCb, vdata):
    """Adds an event handler for a window. Manipulates the event callback
    functions for the window specified, which will be called when an
    event of specified type is pending for the window. It does not
    solicit any event for the caller, i.e. the XForms library assumes
    the caller opens the window and solicits all events before calling
    these routines.

    --

    :Parameters:
      `win` : long_pos
        window id to add event handler to
      `evttype` : int
        event type number. If it's 0, the callback is for all events for the
        window
      `py_AppEventCb` : python function callback, returning value
        name referring function(pXEvent, ptr_void) -> num.
      `vdata` : None or long or pointer to xfdata.FL_OBJECT
        user data to be passed to function

    :return: old event callback
    :rtype: pointer to xfdata.FL_APPEVENT_CB

    :note: e.g. def eventcb(pxev, vdata): > ... ; return 0
    :note: e.g. fl_add_event_callback(win2, 0, eventcb, None)

    :status: Tested + Doc + NoDemo = OK

    """
    #FL_APPEVENT_CB = cty.CFUNCTYPE(cty.c_int, cty.POINTER(XEvent),
    #                               cty.c_void_p)
    _fl_add_event_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_add_event_callback",
        xfdata.FL_APPEVENT_CB, [xfdata.Window, cty.c_int,
        xfdata.FL_APPEVENT_CB, cty.c_void_p],
        """FL_APPEVENT_CB fl_add_event_callback(Window win, int ev,
           FL_APPEVENT_CB wincb, void * user_data)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    ievttype = libr.convert_to_int(evttype)
    c_AppEventCb = xfdata.FL_APPEVENT_CB(py_AppEventCb)
    if vdata is None:
        pvdata = cty.cast(vdata, cty.c_void_p)
    elif isinstance(vdata, long):
        ldata = libr.convert_to_long(vdata)
        pvdata = cty.cast(ldata, cty.POINTER(cty.c_long))
    else:
        pvdata = vdata          # it is pFlObject
        libr.verify_flobjectptr_type(pvdata)
    libr.keep_cfunc_refs(c_AppEventCb, py_AppEventCb)
    libr.keep_elem_refs(win, evttype, vdata, ulwin, ievttype, pvdata)
    retval = _fl_add_event_callback(ulwin, ievttype, c_AppEventCb, pvdata)
    return retval


def fl_remove_event_callback(win, evttype):
    """ Removes one or all event callbacks for a window and for an event of
    specified type. May be called with for a window for which no event
    callbacks have been set.

    --

    :Parameters:
      `win` : long_pos
        window id
      `evttype` : int
        event type number

    :note: e.g. fl_remove_event_callback(win2, 0)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_remove_event_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_remove_event_callback",
        None, [xfdata.Window, cty.c_int],
        """void fl_remove_event_callback(Window win, int ev)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    ievttype = libr.convert_to_int(evttype)
    libr.keep_elem_refs(win, evttype, ulwin, ievttype)
    _fl_remove_event_callback(ulwin, ievttype)


def fl_activate_event_callbacks(win):
    """Handles event solicitation. Activates the default mapping of events
    to event masks built-in in the XForms Library, and causes the system
    to solicit the events for you. Note however, the mapping of events to
    masks are not unique and depending on applications, the default mapping
    may or may not be the one you want.

    --

    :Parameters:
      `win` : long_pos
        window whose events are referred to

    :note: e.g. fl_activate_event_callback(win3)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_activate_event_callbacks = libr.cfuncproto(
        libr.load_so_libforms(), "fl_activate_event_callbacks",
        None, [xfdata.Window],
        """void fl_activate_event_callbacks(Window win)""")
    libr.check_if_initialized()
    ulwin = libr.convert_to_Window(win)
    libr.keep_elem_refs(win, ulwin)
    _fl_activate_event_callbacks(ulwin)


def fl_print_xevent_name(where, pXEvent):
    """Print the name of an XEvent and some other infos.

    --

    :Parameters:
      `where` : str
        text, it can indicate where this function is called.
      `pXEvent` : pointer to xfdata.XEvent
        XEvent class instance

    :return: event (pXEvent)
    :rtype: pointer to xfdata.XEvent

    :note: e.g. pxev = fl_print_xevent_name("from whatever.py", pxev)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_print_xevent_name = libr.cfuncproto(
        libr.load_so_libforms(), "fl_print_xevent_name",
        cty.POINTER(xfdata.XEvent), [xfdata.STRING,
        cty.POINTER(xfdata.XEvent)],
        """XEvent * fl_print_xevent_name(const char * where,
           const Xevent * xev)""")
    libr.check_if_initialized()
    swhere = libr.convert_to_string(where)
    libr.keep_elem_refs(where, pXEvent, swhere)
    retval = _fl_print_xevent_name(swhere, pXEvent)
    return retval


def fl_XFlush():
    """Flushes the output buffer. Convenience replacement for X11 XFlush()
    function.

    --

    :note: e.g. fl_XFlush()

    :status: Tested + Doc + Demo = OK

    """
    _fl_XFlush = libr.cfuncproto(
        libr.load_so_libforms(), "fl_XFlush",
        None, [],
        """void fl_XFlush(void)""")
    _fl_XFlush()


def metakey_down(mask):
    return (mask & xfdata.Mod1Mask)


def shiftkey_down(mask):
    return (mask & xfdata.ShiftMask)


def controlkey_down(mask):
    return (mask & xfdata.ControlMask)


def button_down(mask):
    if (mask & xfdata.Button1Mask) or (mask & xfdata.Button2Mask) or \
     (mask & xfdata.Button3Mask) or (mask & xfdata.Button4Mask) or \
     (mask & xfdata.Button5Mask):
        return True
    else:
        return False


# Resources

def fl_initialize(numargs, argslist, appname="", appoptions=0, nappopts=0):
    """Initializes XForms libr. It should always be called before any
    other calls to the XForms Library (except fl_set_defaults() and a few
    other functions that alter some of the defaults of the library.
    Command line arguments are NOT supported here, but you can always set
    most of parameters with relative functions.

    --

    :Parameters:
      `numargs` : int
        number of arguments passed to command line, unused in python
      `argslist` : list_of_str
        arguments passed to command line, unused in python
      `appname` : str
        application class name
      `appoptions` : instance of xfdata.FL_CMD_OPT
        options passed as a flcmdopt class instance
      `nappopts` : int
        number of options

    :return: display (pDisplay) or None (on failure, if a connection
        couldn't be made)
    :rtype: pointer to xfdata.Display

    :note: e.g. import sys
    :note: e.g. fl_initialize(len(sys.argv), sys.argv, "MyFormDemo", 0, 0)

    :status: HalfTested + Doc + Demo = HALF OK (not for command line args)

    """
    _fl_initialize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_initialize",
        cty.POINTER(xfdata.Display), [cty.POINTER(cty.c_int),
        cty.POINTER(xfdata.STRING), xfdata.STRING,
        cty.POINTER(xfdata.FL_CMD_OPT), cty.c_int],
        """Display * fl_initialize(int * na, char * * arg,
            const char * appclass, FL_CMD_OPT * appopt, int nappopt)""")
    # verify if installed XForms is compatible with this one
    libr.verify_version_compatibility()
    libr.set_initialized()
    numargs = 1
    inumargs = libr.convert_to_int(numargs)
    argslist = " "          # discard any script arguments
    sargslist = libr.convert_to_string(argslist)
    sappname = libr.convert_to_string(appname)
    pappoptions = cty.cast(appoptions, cty.POINTER(xfdata.FL_CMD_OPT))
    inappopts = libr.convert_to_int(nappopts)
    libr.keep_elem_refs(numargs, inumargs, argslist, sargslist, appname,
                   sappname, appoptions, pappoptions, nappopts, inappopts)
    retval = _fl_initialize(inumargs, sargslist, sappname, pappoptions,
                            inappopts)
    return retval


def fl_finish():
    """It is a final cleanup routine, restores all X server defaults, shuts
    down the connection and frees dynamically allocated memory.

    --

    :note: e.g. fl_finish()

    :status: Tested + Doc + Demo = OK

    """
    _fl_finish = libr.cfuncproto(
        libr.load_so_libforms(), "fl_finish",
        None, [],
        """void fl_finish()""")
    libr.check_if_initialized()
    _fl_finish()


def fl_get_resource(rname, cname, dtype, defval, val, size):
    """*todo*

    --

    :Parameters:
      `rname` : str
        complete resource name specification (minus the application name)
        and should not contain wildcards of any kind
      `cname` : str
        complete resource class specification (minus the application name)
        and should not contain wildcards of any kind
      `dtype` : int
        type of resource. Values (from xfdata.py) FL_NONE, FL_SHORT, FL_BOOL,
        FL_INT, FL_LONG, FL_FLOAT, FL_STRING
      `defval` : str
        default value
      `val` : pointer to void?
        *todo*
      `size` : int
        number of bytes, used only if dtype is FL_STRING

    :return: text representation of the resource value
    :rtype: str

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_get_resource = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_resource",
        xfdata.STRING, [xfdata.STRING, xfdata.STRING,
        xfdata.FL_RTYPE, xfdata.STRING, cty.c_void_p, cty.c_int],
        """const char * fl_get_resource(const char * rname,
           const char * cname, FL_RTYPE dtype, const char * defval,
           void * val, int size)""")
    libr.check_admitted_value_in_list(dtype, xfdata.RTYPE_list)
    srname = libr.convert_to_string(rname)
    scname = libr.convert_to_string(cname)
    idtype = libr.convert_to_int(dtype)
    sdefval = libr.convert_to_string(defval)
    pval = cty.cast(val, cty.c_void_p)
    isize = libr.convert_to_int(size)
    libr.keep_elem_refs(rname, cname, dtype, defval, val, size, srname,
                        scname, idtype, sdefval, pval, isize)
    retval = _fl_get_resource(srname, scname, idtype, sdefval, pval, isize)
    return retval


def fl_set_resource(resstr, txtval):
    """Changes some of the built-in button labels with proper resource names.

    --

    :Parameters:
      `resstr` : str
        resource name
      `txtval` : str
        new string value for resource

    :note: e.g. *todo*

    :status: Tested + NoDoc + Demo = OK

    """
    _fl_set_resource = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_resource",
        None, [xfdata.STRING, xfdata.STRING],
        """void fl_set_resource(const char * str, const char * val)""")
    sresstr = libr.convert_to_string(resstr)
    stxtval = libr.convert_to_string(txtval)
    libr.keep_elem_refs(resstr, txtval, sresstr, stxtval)
    _fl_set_resource(sresstr, stxtval)


def fl_get_app_resources(pResource, nresources):
    """*todo*

    --

    :Parameters:
      `pResource` : pointer to xfdata.FL_RESOURCE
        an array of resource class instances
      `nresources` : int
        number of resources (starting from 1) passed with pResource array

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_get_app_resources = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_app_resources",
        None, [cty.POINTER(xfdata.FL_RESOURCE), cty.c_int],
        """void fl_get_app_resources(FL_RESOURCE * appresource, int n)""")
    libr.check_if_initialized()
    libr.verify_otherclassptr_type(pResource, cty.POINTER(xfdata.FL_RESOURCE))
    inresources = libr.convert_to_int(nresources)
    libr.keep_elem_refs(pResource, nresources, inresources)
    _fl_get_app_resources(pResource, inresources)


def fl_set_graphics_mode(mode, doublebuf):
    """*todo*

    --

    :Parameters:
      `mode` : int
        graphics mode to be set
      `doublebuf` : int
        *todo*

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_graphics_mode = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_graphics_mode",
        None, [cty.c_int, cty.c_int],
        """void fl_set_graphics_mode(int mode, int doublebuf)""")
    libr.check_if_initialized()
    imode = libr.convert_to_int(mode)
    idoublebuf = libr.convert_to_int(doublebuf)
    libr.keep_elem_refs(mode, doublebuf, imode, idoublebuf)
    _fl_set_graphics_mode(imode, idoublebuf)


def fl_set_visualID(idnum):
    """Sets visual and depth. By default, X Server's visual and depth values
    are used.

    --

    :Parameters:
      `idnum` : int
        visual id. Values (from xfdata.py) TrueColor, PseudoColor, etc..

    :note: e.g. *todo*

    :precondition: to be called before fl_initialize()

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_visualID = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_visualID",
        None, [cty.c_long],
        """void fl_set_visualID(long int id)""")
    libr.check_admitted_value_in_list(idnum, xfdata.VISUALMODE_list)
    lidnum = libr.convert_to_long(idnum)
    libr.keep_elem_refs(idnum, lidnum)
    _fl_set_visualID(lidnum)


def fl_keysym_pressed(keysym):
    """*todo*

    --

    :Parameters:
      `keysym` : long_pos
        *todo*

    :return: num., or 0 (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_keysym_pressed = libr.cfuncproto(
        libr.load_so_libforms(), "fl_keysym_pressed",
        cty.c_int, [xfdata.KeySym],
        """int fl_keysym_pressed(KeySym k)""")
    libr.check_if_initialized()
    ulkeysym = libr.convert_to_ulong(keysym)
    libr.keep_elem_refs(keysym, ulkeysym)
    retval = _fl_keysym_pressed(ulkeysym)
    return retval


fl_keypressed = fl_keysym_pressed


# Program default masks

def fl_set_defaults(mask, pIopt):
    """ fl_set_defaults(mask, pIopt)

    --

    :Parameters:
      `mask` : long_pos
        Mask of program defaults. Values (from xfdata.py) FL_PDDepth,
        FL_PDClass, FL_PDDouble, FL_PDSync, FL_PDPrivateMap,
        FL_PDScrollbarType, FL_PDPupFontSize, FL_PDButtonFontSize,
        FL_PDInputFontSize, FL_PDSliderFontSize, FL_PDVisual,
        FL_PDULThickness, FL_PDULPropWidth, FL_PDBS, FL_PDCoordUnit,
        FL_PDDebug, FL_PDSharedMap, FL_PDStandardMap, FL_PDBorderWidth,
        FL_PDSafe, FL_PDMenuFontSize, FL_PDBrowserFontSize,
        FL_PDChoiceFontSize, FL_PDLabelFontSize, FL_PDButtonLabelSize,
        FL_PDSliderLabelSize, FL_PDInputLabelSize, FL_PDButtonLabel
      `pIopt` : pointer to xfdata.FL_IOPT array
        an array of program defaults class instances

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_defaults = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_defaults",
        None, [cty.c_ulong, cty.POINTER(xfdata.FL_IOPT)],
        """void fl_set_defaults(long unsigned int mask, FL_IOPT * cntl)""")
    libr.check_admitted_value_in_list(mask, xfdata.PRGDEFAULTS_list)
    ulmask = libr.convert_to_ulong(mask)
    libr.keep_elem_refs(mask, pIopt, ulmask)
    _fl_set_defaults(ulmask, pIopt)


def fl_set_tabstop(tabtext):
    """Adjusts the distance by setting the tab stops. For proportional font,
    substituting tabs with spaces is not always appropriate because this
    most likely will fail to align text properly. Instead, a tab is
    treated as an absolute measure of distance, in pixels, and a tab
    stop will always end at multiples of this distance. The default is
    "aaaaaaaa", i.e. eight 'a's.

    --

    :Parameters:
      `tabtext` : str
        text string whose width in pixel is to be used as the tab length.
        The font used to calculate the width is the same font that is used
        to render the string in which the tab is embedded.

    :note: e.g. fl_set_tabstop("aaaa")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_tabstop = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_tabstop",
        None, [xfdata.STRING],
        """void fl_set_tabstop(const char * s)""")
    libr.check_if_initialized()
    stabtext = libr.convert_to_string(tabtext)
    libr.keep_elem_refs(tabtext, stabtext)
    _fl_set_tabstop(stabtext)


def fl_get_defaults():
    """Obtains program defaults from the resource database.

    --

    :return: program defaults class instance
    :rtype: instance of xfdata.FL_IOPT

    :note: e.g. defprgres = fl_get_defaults()

    :attention: API change from XForms - upstream was
        fl_get_defaults(pIopt)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_defaults = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_defaults",
        None, [cty.POINTER(xfdata.FL_IOPT)],
        """void fl_get_defaults(FL_IOPT * cntl)""")
    libr.check_if_initialized()
    Iopt = xfdata.FL_IOPT()
    pIopt = cty.byref(Iopt)
    libr.keep_elem_refs(pIopt, Iopt)
    _fl_get_defaults(pIopt)
    return Iopt


def fl_get_visual_depth():
    """Obtains the visual depth.

    --

    :return: visual depth for current mode
    :rtype: int

    :note: e.g. curdepth = fl_get_visual_depth()

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_visual_depth = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_visual_depth",
        cty.c_int, [],
        """int fl_get_visual_depth()""")
    libr.check_if_initialized()
    retval = _fl_get_visual_depth()
    return retval


def fl_vclass_name(mode):
    """Obtains name corresponding to a visual mode.

    --

    :Parameters:
      `mode` : int
        visual mode.

    :return: vclass name
    :rtype: str

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_vclass_name = libr.cfuncproto(
        libr.load_so_libforms(), "fl_vclass_name",
        xfdata.STRING, [cty.c_int],
        """const char * fl_vclass_name(int n)""")
    libr.check_if_initialized()
    imode = libr.convert_to_int(mode)
    libr.keep_elem_refs(mode, imode)
    _fl_vclass_name(imode)


def fl_vclass_val(name):
    """Obtains value of visual mode.

    --

    :Parameters:
      `name` : str
        name of visual mode

    :return: vclass num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_vclass_val = libr.cfuncproto(
        libr.load_so_libforms(), "fl_vclass_val",
        cty.c_int, [xfdata.STRING],
        """int fl_vclass_val(const char * v)""")
    libr.check_if_initialized()
    sname = libr.convert_to_string(name)
    libr.keep_elem_refs(name, sname)
    retval = _fl_vclass_val(sname)
    return retval


def fl_set_ul_property(proportional, thickness):
    """Sets property of an underlined text.

    --

    :Parameters:
      `proportional` : int
        if width is proportional or not. Values 0 (if fixed) or 1 (if
        proportional)
      `thickness` : int
        thickness of underline.

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_ul_property = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_ul_property",
        None, [cty.c_int, cty.c_int],
        """void fl_set_ul_property(int prop, int thickness)""")
    iproportional = libr.convert_to_int(proportional)
    ithickness = libr.convert_to_int(thickness)
    libr.keep_elem_refs(proportional, thickness, iproportional, ithickness)
    _fl_set_ul_property(iproportional, ithickness)


def fl_set_clipping(x, y, w, h):
    """Sets a clipping region in the Forms Library's default GC (gc[0]).
    This defines the area (delimited by arguments passed) drawing is to
    restrict to and are relative to the window/form that will be drawn to.
    In this way you can prevent drawing over other object and outside the
    box.

    --

    :Parameters:
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units

    :note: e.g. fl_set_clipping(250, 200, 100, 80)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_clipping = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_clipping",
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord],
        """void fl_set_clipping(FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h)""")
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    libr.keep_elem_refs(x, y, w, h, ix, iy, iw, ih)
    _fl_set_clipping(ix, iy, iw, ih)


# commented as it gives a NULL pointer access. Maybe GCs other than
# default are not viable in python.
#def fl_set_gc_clipping(gc, x, y, w, h):
#    """Sets a clipping region in the specified graphics context (GC).
#    This defines the area (delimited by arguments passed) drawing is to
#    restrict to and are relative to the window/form that will be drawn to.
#    In this way you can prevent drawing over other object and outside the
#    box.
#
#   --
#
#   :Parameters:
#     `gc` : xfdata.GC class instance
#       Graphics Context number
#     `x` : int
#       horizontal position (upper-left corner)
#     `y` : int
#       vertical position (upper-left corner)
#     `w` : int
#       width in coord units
#     `h` : int
#       height in coord units
#
#    :note: e.g. *todo*
#
#    :status: Untested + NoDoc + NoDemo = NOT OK
#
#    """
#    _fl_set_gc_clipping = libr.cfuncproto(
#        libr.load_so_libforms(), "fl_set_gc_clipping",
#        None, [xfdata.GC, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
#        xfdata.FL_Coord],
#        """void fl_set_gc_clipping(GC gc, FL_Coord x, FL_Coord y,
#           FL_Coord w, FL_Coord h)""")
#    ix = libr.convert_to_FL_Coord(x)
#    iy = libr.convert_to_FL_Coord(y)
#    iw = libr.convert_to_FL_Coord(w)
#    ih = libr.convert_to_FL_Coord(h)
#    libr.keep_elem_refs(gc, x, y, w, h, ix, iy, iw, ih)
#    _fl_set_gc_clipping(gc, ix, iy, iw, ih)


# commented as it gives a NULL pointer access. Maybe GCs other than
# default are not viable in python.
#def fl_unset_gc_clipping(gc):
#    """ fl_unset_gc_clipping(gc)
#
#   --
#
#   :Parameters:
#     `gc` : xfdata.GC class instance
#       Graphics Context number
#
#    :status: Untested + NoDoc + NoDemo = NOT OK
#
#    """
#    _fl_unset_gc_clipping = libr.cfuncproto(
#        libr.load_so_libforms(), "fl_unset_gc_clipping",
#        None, [xfdata.GC],
#        """void fl_unset_gc_clipping(GC gc)""")
#    libr.keep_elem_refs(gc)
#    _fl_unset_gc_clipping(gc)


def fl_set_clippings(pRect, nrect):
    """*todo*

    --

    :Parameters:
      `pRect` : pointer to xfdata.FL_RECT
        rectangle class instance
      `nrect` : int
        number of rectangles

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_clippings = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_clippings",
        None, [cty.POINTER(xfdata.FL_RECT), cty.c_int],
        """void fl_set_clippings(FL_RECT * xrect, int n)""")
    inrect = libr.convert_to_int(nrect)
    libr.keep_elem_refs(pRect, nrect, inrect)
    _fl_set_clippings(pRect, inrect)


def fl_unset_clipping():
    """Stops clipping and removes clipping area defined with
    fl_set_clipping()

    --

    :note: e.g. fl_unset_clipping()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_unset_clipping = libr.cfuncproto(
        libr.load_so_libforms(), "fl_unset_clipping",
        None, [],
        """void fl_unset_clipping()""")
    _fl_unset_clipping()


def fl_set_text_clipping(x, y, w, h):
    """Sets a clipping region for text in the Forms Library's default GC
    (gc[0]). This defines the area (delimited by arguments passed) drawing
    is to restrict to and are relative to the window/form that will be
    drawn to. In this way you can prevent drawing over other object and
    outside the box.

    --

    :Parameters:
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units

    :note: e.g. fl_set_text_clipping(200, 200, 300, 50)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_text_clipping = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_text_clipping",
        None, [xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord],
        """void fl_set_text_clipping(FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h)""")
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    libr.keep_elem_refs(x, y, w, h, ix, iy, iw, ih)
    _fl_set_text_clipping(ix, iy, iw, ih)


def fl_unset_text_clipping():
    """Stops clipping for text and removes clipping area defined with
    fl_set_text_clipping()

    --

    :note: e.g. fl_unset_text_clipping()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_unset_text_clipping = libr.cfuncproto(
        libr.load_so_libforms(), "fl_unset_text_clipping",
        None, [],
        """void fl_unset_text_clipping()""")
    _fl_unset_text_clipping()


# How we pack and unpack colors

def FL_PCCLAMP(a):
    if (a > xfdata.FL_PCMAX):
        return xfdata.FL_PCMAX
    elif (a < 0):
        return 0
    else:
        return a


# If PCBITS is not 8, we need to apply the RGBmask

def FL_GETR(packed):
    return ((packed >> xfdata.FL_RSHIFT) & xfdata.FL_RMASK)

def FL_GETG(packed):
    return ((packed) >> xfdata.FL_GSHIFT) & xfdata.FL_PCMAX

def FL_GETB(packed):
    return ((packed) >> xfdata.FL_BSHIFT) & xfdata.FL_PCMAX

def FL_GETA(packed):
    return ((packed) >> xfdata.FL_ASHIFT) & xfdata.FL_PCMAX

def FL_PACK3(r, g, b ):
    return (r << xfdata.FL_RSHIFT) | (g << xfdata.FL_GSHIFT) | \
        (b << xfdata.FL_BSHIFT)

FL_PACK = FL_PACK3

def FL_PACK4(r, g, b, a):
    return (FL_PACK3(r, g, b) | (a << xfdata.FL_ASHIFT))

def FL_UNPACK(packed):
    r = FL_GETR(packed)
    g = FL_GETG(packed)
    b = FL_GETB(packed)
    return r, g, b

FL_UNPACK3 = FL_UNPACK

def FL_UNPACK4(p, r, g, b, a):
    r, g, b = FL_UNPACK3(p, r, g, b)
    a = FL_GETA(p)
    return r, g, b, a

