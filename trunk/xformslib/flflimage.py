#!/usr/bin/env python
# -*- coding: iso8859-1 -*-

""" xforms-python's functions to manage image objects.
"""

#    Copyright (C) 2009, 2010  Luca Lazzaroni "LukenShiro"
#    e-mail: <lukenshiro@ngi.it>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Lesser General Public License as
#    published by the Free Software Foundation, version 2.1 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU Lesser General Public License for more details.
#
#    You should have received a copy of the GNU LGPL along with this
#    program. If not, see <http://www.gnu.org/licenses/>.
#
#    See CREDITS file to read acknowledgements and thanks to XForms,
#    ctypes and other developers.

# originally generated by 'h2xml+gccxml' and 'xml2py'
# then heavily reordered and reworked

# ############################################# #
# Interface to XForms shared object libraries   #
# ############################################# #


import ctypes as cty
from xformslib import library
from xformslib import xfdata


#########################
# flimage.h
# Image related routines
#########################

# fl_safe_free function placeholder (low-level)


def FL_RGB2GRAY(r, g, b):
    uir = library.convert_to_uint(r)
    uig = library.convert_to_uint(g)
    uib = library.convert_to_uint(b)
    return ((78 * (uir) + 150 * (uig) + 28 * (uib)) >> 8)   # cty.c_uint


# if PCBITS is not 8, we need to apply the RGBmask

def FL_IsRGB(pImage):
    library.verify_flflimageptr_type(pImage)
    return (pImage.contents.type == xfdata.FL_IMAGE_RGB)


def FL_IsPacked(pImage):
    library.verify_flflimageptr_type(pImage)
    return (pImage.contents.type == xfdata.FL_IMAGE_PACKED)


def flimage_setup(pImageSetup):
    """flimage_setup(pImageSetup)
    
    Sets up and configures image objects support and initializes
    xfdata.FLIMAGE_SETUP class instance.

    Parameters
    ----------
        pImageSetup : pointer to xfdata.FLIMAGE_SETUP
            imagesetup class instance

    Examples
    ---------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_setup = library.cfuncproto(
        library.load_so_libflimage(), "flimage_setup",
        None, [cty.POINTER(xfdata.FLIMAGE_SETUP)],
        """void flimage_setup(FLIMAGE_SETUP * setup)""")
    library.check_if_initialized()
    library.verify_otherclassptr_type(pImageSetup, cty.POINTER( \
            xfdata.FLIMAGE_SETUP))
    library.keep_elem_refs(pImageSetup)
    _flimage_setup(pImageSetup)


# basic IO routines

def flimage_load(fname):
    """flimage_load(fname)
    
    Loads an image file into memory.

    Parameters
    ----------
        fname : str
            name of image file to load

    Returns
    -------
        pImage : pointer to xfdata.FL_IMAGE
            an image class instance, or None (on failure)

    Examples
    --------
        >>> pimg = flimage_load("/mydir/myimage.xpm")

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_load = library.cfuncproto(
        library.load_so_libflimage(), "flimage_load",
        cty.POINTER(xfdata.FL_IMAGE), [xfdata.STRING],
        """FL_IMAGE * flimage_load(const char * file)""")
    library.check_if_initialized()
    sfname = library.convert_to_string(fname)
    library.keep_elem_refs(fname, sfname)
    retval = _flimage_load(sfname)
    return retval


def flimage_read(pImage):
    """flimage_read(pImage)
    
    Takes a xfdata.FL_IMAGE class instance returned by flimage_open()
    and fills the image structure.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image class instance

    Returns
    -------
        pImage : pointer to xfdata.FL_IMAGE
            an image class instance, or None (on failure)

    Examples
    --------
        >>> emptyimg = flimage_open("/mydir/myfile.xpm")
        >>> imgfilled = flimage_read(emptyimg)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_read = library.cfuncproto(
        library.load_so_libflimage(), "flimage_read",
        cty.POINTER(xfdata.FL_IMAGE), [cty.POINTER(xfdata.FL_IMAGE)],
        """FL_IMAGE * flimage_read(FL_IMAGE * im)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    retval = _flimage_read(pImage)
    return retval


def flimage_dump(pImage, fname, fmt):
    """flimage_dump(pImage, fname, fmt)
    
    Takes an image, either returned by flimage_load() (possibly after some
    processing) or created on the fly by the application, attempts to create
    a file to store the image.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image class instance
        fname : str
            name of file to be saved
        fmt : str
            formal name or short name of a supported image format. Values:
            jpeg, ppm, gif, bmp, etc... or some other formats the application
            knows how to write. If it is 'None', the original format the image
            was in is used.

    Returns
    -------
        result : int
            non-negative, or negative num. (on failure)

    Examples
    --------
        >>> resl = flimage_dump(pimg, "/mydir/mynewfile.ppm", "ppm")

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_dump = library.cfuncproto(
        library.load_so_libflimage(), "flimage_dump",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.STRING,
        xfdata.STRING],
        """int flimage_dump(FL_IMAGE * p1, const char * p2,
           const char * p3)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    sfname = library.convert_to_string(fname)
    # *todo* take note of 'None' case
    sfmt = library.convert_to_string(fmt)
    library.keep_elem_refs(pImage, fname, fmt, sfname, sfmt)
    retval = _flimage_dump(pImage, sfname, sfmt)
    return retval


def flimage_close(pImage):
    """flimage_close(pImage)

    Closes all file streams used to create the image.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image to be closed

    Returns
    -------
        result : int
            0?, or -1 (on failure)

    Examples
    --------
        >>> if flimage_close(pimg) == -1:
        >>> ... print("Error closing image file!")

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_close = library.cfuncproto(
        library.load_so_libflimage(), "flimage_close",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_close(FL_IMAGE * p1)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    retval = _flimage_close(pImage)
    return retval


# TODO: not sure if it is necessary in python, low-level only?
def flimage_alloc():
    """flimage_alloc()
    
    Creates an image structure whose dynamically allocated memory is
    properly initialized, and returning it.

    Returns
    -------
        pImage : pointer to xfdata.FL_IMAGE
            image class instance

    Examples
    --------
        >>> pimg = flimage_alloc()

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_alloc = library.cfuncproto(
        library.load_so_libflimage(), "flimage_alloc",
        cty.POINTER(xfdata.FL_IMAGE), [],
        """FL_IMAGE * flimage_alloc()""")
    library.check_if_initialized()
    retval = _flimage_alloc()
    return retval


def flimage_getmem(pImage):
    """flimage_getmem(pImage)
    
    Allocates the proper amount of memory appropriate for the image type,
    including colormaps when needed.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> bum = flimage_getmem(pimg)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_getmem = library.cfuncproto(
        library.load_so_libflimage(), "flimage_getmem",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_getmem(FL_IMAGE * p1)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    retval = _flimage_getmem(pImage)
    return retval


def flimage_is_supported(fname):
    """flimage_is_supported(fname)
    
    Finds out if a specific file is a known image file or not.

    Parameters
    ----------
        fname : str
            name of file to be evaluated

    Returns
    -------
        isknown : int
            1 (if it is a known image file), or 0 (on failure)

    Examples
    --------
        >>> known = flimage_is_supported("/mydir/file.bmp")

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_is_supported = library.cfuncproto(
        library.load_so_libflimage(), "flimage_is_supported",
        cty.c_int, [xfdata.STRING],
        """int flimage_is_supported(const char * p1)""")
    library.check_if_initialized()
    sfname = library.convert_to_string(fname)
    library.keep_elem_refs(fname, sfname)
    retval = _flimage_is_supported(sfname)
    return retval


def flimage_description_via_filter(pImage, cmds, what, verbose):
    """flimage_description_via_filter(pImage, cmds, what, verbose)
    
    Adds a description to be used with flimage_add_format() to add image
    formats via an external filter's command.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        cmds : str?
            a list of shell commands (filters) that convert the format in
            question into one of the supported formats.
        what : str
            text for reporting purpose
        verbose : int
            controls if some information and error messages should be printed
            (mainly for debugging purpose). Values 0 (to disable) or 1
            (to enable)

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_description_via_filter = library.cfuncproto(
        library.load_so_libflimage(), "flimage_description_via_filter",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER(xfdata.STRING),
        xfdata.STRING, cty.c_int],
        """int flimage_description_via_filter(FL_IMAGE * im, char *const
           *cmds, const char *what, int verbose)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    scmds = library.convert_to_string(cmds)                # to be verified
    swhat = library.convert_to_string(what)
    iverbose = library.convert_to_int(verbose)
    library.keep_elem_refs(pImage, cmds, swhat, verbose, scmds, swhat, iverbose)
    retval = _flimage_description_via_filter(pImage, scmds, swhat, iverbose)
    return retval


def flimage_write_via_filter(pImage, cmds, formats, verbose):
    """flimage_write_via_filter(pImage, cmds, formats, verbose)
    
    Uses external filters to add image formats, in order to convert
    an unsupported format into one that is. pbmplus or netpbm are excellent
    packages for this purpose.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        cmds : str?
            a list of shell commands (filters) that convert the format in
            question into one of the supported formats.
        formats : str?
            list of strings. Values ppm, pgm, pbm, .. etc..
        verbose : int
            controls if some information and error messages should be printed
            (mainly for debugging purpose). Values 0 (to disable) or 1
            (to enable)

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_write_via_filter = library.cfuncproto(
        library.load_so_libflimage(), "flimage_write_via_filter",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER(xfdata.STRING),
        cty.POINTER(xfdata.STRING), cty.c_int],
        """int flimage_write_via_filter(FL_IMAGE * p1, const * char * cmds,
           const char * formats[], int verbose)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    # cmds to be handled
    sformats = library.convert_to_string(formats)
    iverbose = library.convert_to_int(verbose)
    library.keep_elem_refs(pImage, cmds, formats, sformats, verbose, iverbose)
    retval = _flimage_write_via_filter(pImage, cmds, sformats, iverbose)
    return retval


def flimage_free(pImage):
    """flimage_free(pImage)
    
    Frees all memory allocated for the image, then the image structure
    itself. After the function returns, the image should not be referenced.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> flimage_free(pimg)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_free = library.cfuncproto(
        library.load_so_libflimage(), "flimage_free",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_free(FL_IMAGE * p1)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    _flimage_free(pImage)


def flimage_display(pImage, win):
    """flimage_display(pImage, win)
    
    Displays a single or multiple images in a window.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        win : long_pos
            window

    Returns
    -------
        result : int
            non-negative num., or negative num. (on failure)

    Examples
    --------
        >>> flimage_display(pimg, win0)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_display = library.cfuncproto(
        library.load_so_libflimage(), "flimage_display",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.Window],
        """int flimage_display(FL_IMAGE * p1, Window p2)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    ulwin = library.convert_to_Window(win)
    library.keep_elem_refs(pImage, win, ulwin)
    retval = _flimage_display(pImage, ulwin)
    return retval


def flimage_sdisplay(pImage, win):
    """flimage_sdisplay(pImage, win)
    
    Displays a single image in a window.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        win : long_pos
            window

    Returns
    -------
        result : int
            non-negative num., or negative num. (on failure)

    Examples
    --------
        >>> flimage_sdisplay(pImage, win)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_sdisplay = library.cfuncproto(
        library.load_so_libflimage(), "flimage_sdisplay",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.Window],
        """int flimage_sdisplay(FL_IMAGE * p1, Window p2)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    ulwin = library.convert_to_Window(win)
    library.keep_elem_refs(pImage, win, ulwin)
    retval = _flimage_sdisplay(pImage, ulwin)
    return retval


def flimage_convert(pImage, newtype, ncolors):
    """flimage_convert(pImage, newtype, ncolors)
    
    Converts an image to a new type. Depending on which quantization
    function is used, the number of quantized colors may not be more than 256.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        newtype : int
            one of supported image type to convert to. Values (from xfdata.py)
            FL_IMAGE_NONE, FL_IMAGE_MONO, FL_IMAGE_GRAY, FL_IMAGE_CI,
            FL_IMAGE_RGB, FL_IMAGE_PACKED, FL_IMAGE_GRAY16, FL_IMAGE_RGB16,
            FL_IMAGE_FLEX
        ncolors : int
            number of colors to generate. It makes sense only when newtype is
            xfdata.FL_IMAGE_CI.

    Returns
    -------
        result : int
            non-negative num., or negative num. (on failure)

    Examples
    --------
        >>> flimage_convert(pimg, xfdata.FL_IMAGE_RGB, 0)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_convert = library.cfuncproto(
        library.load_so_libflimage(), "flimage_convert",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int],
        """int flimage_convert(FL_IMAGE * p1, int p2, int p3)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.checkfatal_allowed_value_in_list(newtype, xfdata.FLIMAGETYPE_list)
    inewtype = library.convert_to_int(newtype)
    incolors = library.convert_to_int(ncolors)
    library.keep_elem_refs(pImage, newtype, ncolors, inewtype, incolors)
    retval = _flimage_convert(pImage, inewtype, incolors)
    return retval


def flimage_type_name(imagetype):
    """flimage_type_name(imagetype)
    
    Obtains the image type name in string format, e.g., for reporting
    purposes.

    Parameters
    ----------
        imagetype : int
            type of a supported image. Values (from xfdata.py)
            FL_IMAGE_NONE, FL_IMAGE_MONO, FL_IMAGE_GRAY, FL_IMAGE_CI,
            FL_IMAGE_RGB, FL_IMAGE_PACKED, FL_IMAGE_GRAY16,
            FL_IMAGE_RGB16, FL_IMAGE_FLEX

    Returns
    -------
        typename : str
            name string

    Examples
    --------
        >>> flimage_type_name(imagetype)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_type_name = library.cfuncproto(
        library.load_so_libflimage(), "flimage_type_name",
        xfdata.STRING, [cty.c_int],
        """const char * flimage_type_name(int type)""")
    library.check_if_initialized()
    library.checkfatal_allowed_value_in_list(imagetype, xfdata.FLIMAGETYPE_list)
    iimagetype = library.convert_to_int(imagetype)
    library.keep_elem_refs(imagetype, iimagetype)
    retval = _flimage_type_name(iimagetype)
    return retval


def flimage_add_text(pImage, text, length, style, size, txtcolr, bgcolr,
                     nobk, tx, ty, rot):
    """flimage_add_text(pImage, text, length, style, size, txtcolr, bgcolr,
    nobk, tx, ty, rot)
    
    Places text into the image, passing parameters individually. If text
    starts with character '@' a symbol is drawn.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        text : str
            text string to be placed in image
        length : int
            length of text
        style : int
            label style. Values (from xfdata.py) FL_NORMAL_STYLE,
            FL_BOLD_STYLE, FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE,
            FL_FIXED_STYLE, FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE,
            FL_FIXEDBOLDITALIC_STYLE, FL_TIMES_STYLE, FL_TIMESBOLD_STYLE,
            FL_TIMESITALIC_STYLE, FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE,
            FL_MISCBOLD_STYLE, FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE,
            FL_SHADOW_STYLE, FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      size : int
        label size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE
      txtcolr : int_pos
        color to use for text
      bgcolr : int_pos
        color to use for background (only if nobk is 0)
      nobk : int
        flag to enable/disable background. Values 0 (drawn with background)
        or 1 (text is drawn without a background)
      tx : float
        horizontal location of the text relative to the image origin. The
        location specified is the lower-right corner of the text.
      ty : float
        vertical location of the text relative to the image origin. The
        location specified is the lower-right corner of the text.
      rot : int
        rotation

    Returns
    -------
        nstrings : int
            current number of strings for the image

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_add_text = library.cfuncproto(
        library.load_so_libflimage(), "flimage_add_text",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.STRING, cty.c_int,
        cty.c_int, cty.c_int, cty.c_uint, cty.c_uint, cty.c_int,
        cty.c_double, cty.c_double, cty.c_int],
        """int flimage_add_text(FL_IMAGE * im, const char * str, int len,
           int style, int size, unsigned int tcol, unsigned int bcol,
           int tran, double tx, double ty, int rot)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.checkfatal_allowed_value_in_list(style, xfdata.TEXTSTYLE_list)
    library.checknonfatal_allowed_value_in_list(size, xfdata.FONTSIZE_list)
    stext = library.convert_to_string(text)
    ilength = library.convert_to_int(length)
    istyle = library.convert_to_int(style)
    isize = library.convert_to_int(size)
    uitxtcolr = library.convert_to_uint(txtcolr)
    uibgcolr = library.convert_to_uint(bgcolr)
    inobk = library.convert_to_int(nobk)
    ftx = library.convert_to_double(tx)
    fty = library.convert_to_double(ty)
    irot = library.convert_to_int(rot)
    library.keep_elem_refs(pImage, text, length, style, size, txtcolr, bgcolr,
                nobk, tx, ty, rot, stext, ilength, istyle, isize, uitxtcolr,
                uibgcolr, inobk, ftx, fty, irot)
    retval = _flimage_add_text(pImage, stext, ilength, istyle, isize,
                uitxtcolr, uibgcolr, inobk, ftx, fty, irot)
    return retval


def flimage_add_text_struct(pImage, pImageText):
    """flimage_add_text_struct(pImage, pImageText)
    
    Places text into the image, using xfdata.FLIMAGE_TEXT class instance.
    If text starts with character '@' a symbol is drawn.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        pImageText : pointer to xfdata.FLIMAGE_TEXT
            flimagetext class instance

    Returns
    -------
        nstrings : int
            current number of strings for the image

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_add_text_struct = library.cfuncproto(
        library.load_so_libflimage(), "flimage_add_text_struct",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE),
        cty.POINTER(xfdata.FLIMAGE_TEXT)],
        """int flimage_add_text_struct(FL_IMAGE * p1, const char * p2)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.verify_otherclassptr_type(pImageText, cty.POINTER( \
                                   xfdata.FLIMAGE_TEXT))
    library.keep_elem_refs(pImage, pImageText)
    retval = _flimage_add_text_struct(pImage, pImageText)
    return retval


def flimage_delete_all_text(pImage):
    """flimage_delete_all_text(pImage)
    
    Deletes all the texts you added to an image.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> flimage_delete_all_text(pimg)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_delete_all_text = library.cfuncproto(
        library.load_so_libflimage(), "flimage_delete_all_text",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_delete_all_text(FL_IMAGE * p1)""")
    library.check_if_initialized()
    library.keep_elem_refs(pImage)
    _flimage_delete_all_text(pImage)


def flimage_add_marker(pImage, name, x, y, w, h, style, fill, rot, \
                       colr, bcolr):
    """flimage_add_marker(pImage, name, x, y, w, h, style, fill, rot,
    colr, bcolr)
    
    Adds simple markers (arrows, circles etc) to an image, passing
    parameters individually.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        name : str
            marker name *todo*
        x : float
            horizontal position of the center of the marker in physical
            coordinates relative to the origin of the image
        y : float
            vertical position of the center of the marker in physical
            coordinates relative to the origin of the image
        w : float
            width of the bounding box of the marker in physical coordinates
        h : float
            height of the bounding box of the marker in physical coordinates
        style : int
            style of the line to draw. Values (from xfdata.py) FL_SOLID,
            FL_USERDASH, FL_USERDOUBLEDASH, FL_DOT, FL_DOTDASH, FL_DASH,
            FL_LONGDASH
        fill : int
            flag if the marker should be filled or not. Values 1 (filled)
            or 0 (not filled)
        rot : int
            angle of rotation in tenth of degree
        colr : long_pos
            color of the marker (in packed RGB format)
        bcolr : long_pos
            currently unused

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_add_marker = library.cfuncproto(
        library.load_so_libflimage(), "flimage_add_marker",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.STRING, cty.c_double,
        cty.c_double, cty.c_double, cty.c_double, cty.c_int, cty.c_int,
        cty.c_int, xfdata.FL_COLOR, xfdata.FL_COLOR],
        """int flimage_add_marker(FL_IMAGE * p1, const char * p2,
           double p3, double p4, double p5, double p6, int p7,
           int p8, int p9, FL_COLOR p10, FL_COLOR p11)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.checkfatal_allowed_value_in_list(style, xfdata.LINESTYLE_list)
    sname = library.convert_to_string(name)
    fx = library.convert_to_double(x)
    fy = library.convert_to_double(y)
    fw = library.convert_to_double(w)
    fh = library.convert_to_double(h)
    istyle = library.convert_to_int(style)
    ifill = library.convert_to_int(fill)
    irot = library.convert_to_int(rot)
    ulcolr = library.convert_to_FL_COLOR(colr)
    ulbcolr = library.convert_to_FL_COLOR(bcolr)
    library.keep_elem_refs(pImage, name, x, y, w, h, style, fill, rot, ulcolr,
            ulbcolr, sname, fx, fy, fw, fh, istyle, ifill, irot, ulcolr,
            ulbcolr)
    retval = _flimage_add_marker(pImage, sname, fx, fy, fw, fh, istyle,
            ifill, irot, ulcolr, ulbcolr)
    return retval


def flimage_add_marker_struct(pImage, pImageMarker):
    """flimage_add_marker_struct(pImage, pImageMarker)
    
    Adds simple markers (arrows, circles etc) to an image, using
    xfdata.FLIMAGE_MARKER class instance.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        pImageMarker : pointer to xfdata.FLIMAGE_MARKER
            flimagemarker class instance

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_add_marker_struct = library.cfuncproto(
        library.load_so_libflimage(), "flimage_add_marker_struct",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER( \
        xfdata.FLIMAGE_MARKER)],
        """int flimage_add_marker_struct(FL_IMAGE * p1, const char * p2)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.verify_otherclassptr_type(pImageMarker, cty.POINTER( \
                                            xfdata.FL_IMAGE))
    library.keep_elem_refs(pImage, pImageMarker)
    retval = _flimage_add_marker_struct(pImage, pImageMarker)
    return retval


def flimage_define_marker(mkname, py_FlimageMarkerDraw, psdraw):
    """flimage_define_marker(mkname, py_FlimageMarkerDraw, psdraw)
    
    Defines a custom marker, using a specific function for drawing it.

    Parameters
    ----------
        mkname : str
            name of the marker *todo*
        py_FlimageMarkerDraw : python function to draw marker, no return
            name referring to function(pImageMarker)
        psdraw : str
            string that draws a marker in a square with the corner coordinates
            (-1, -1), (-1, 1), (1, 1) and (1, -1) in PostScript. e.g. the
            rectangle marker has the following psdraw string: "-1 -1 moveto -1
            1 lineto 1  1 lineto  1 -1 lineto  closepath"

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    # cfunc_none_flimagemarker = cty.CFUNCTYPE(None, cty.POINTER( \
    #   xfdata.FLIMAGE_MARKER))
    _flimage_define_marker = library.cfuncproto(
        library.load_so_libflimage(), "flimage_define_marker",
        cty.c_int, [xfdata.STRING, xfdata.cfunc_none_flimagemarker,
        xfdata.STRING],
        """int flimage_define_marker(const char *, void ( * )
           (FLIMAGE_MARKER *), const char *)""")
    smkname = library.convert_to_string(mkname)
    spsdraw = library.convert_to_string(psdraw)
    library.verify_function_type(py_FlimageMarkerDraw)
    c_FlimageMarkerDraw = xfdata.cfunc_none_flimagemarker( \
            py_FlimageMarkerDraw)
    library.keep_elem_refs(mkname, psdraw, smkname, spsdraw)
    library.keep_cfunc_refs(c_FlimageMarkerDraw, py_FlimageMarkerDraw)
    retval = _flimage_define_marker(smkname, c_FlimageMarkerDraw, spsdraw)
    return retval


def flimage_delete_all_markers(pImage):
    """flimage_delete_all_markers(pImage)
    
    Deletes all markers added to an image

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> flimage_delete_all_markers(pimg)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_delete_all_markers = library.cfuncproto(
        library.load_so_libflimage(), "flimage_delete_all_markers",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_delete_all_markers(FL_IMAGE * p1)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    _flimage_delete_all_markers(pImage)


def flimage_render_annotation(pImage, win):
    """flimage_render_annotation(pImage, win)
    
    Makes the annotations a part of the image pixel. By default annotations
    placed on the image are kept seperate from the image pixels themselves, as
    keeping the annotation seperate makes it possible to later edit the
    annotations, and typically the screen has a lower resolutions than other
    output devices (by keeping the annotations separate from the pixels makes
    it possible to obtain better image qualities when the annotations are
    rendered on higher-resolution devices, e.g. a PostScript printer). Note
    that during rendering the image type may change depending on the
    capabilities of win. Annotations that were kept separately are deleted.
    The image must have been displayed at least once prior to calling this
    function for it to work correctly.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        win : long_pos
            window

    Returns
    -------
        num. : int
            num., or -1 (on failure)

    Examples
    --------
        >>> if flimage_render_annotation(pImage, win0) != -1:
        >>> ... <something>

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_render_annotation = library.cfuncproto(
        library.load_so_libflimage(), "flimage_render_annotation",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.FL_WINDOW],
        """int flimage_render_annotation(FL_IMAGE * p1, FL_WINDOW p2)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    ulwin = library.convert_to_Window(win)
    library.keep_elem_refs(pImage, win, ulwin)
    retval = _flimage_render_annotation(pImage, ulwin)
    return retval


def flimage_error(pImage, text):
    """flimage_error(pImage, text)
    
    Calls the error message handler for an image.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image to be worked on
        text : str
            a brief message, such as "memory allocation failed" etc..

    Examples
    --------
        >>> flimage_error(pimg, "Memory allocation failed!")

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_error = library.cfuncproto(
        library.load_so_libflimage(), "flimage_error",
        None, [cty.POINTER(xfdata.FL_IMAGE), xfdata.STRING],
        """void flimage_error(FL_IMAGE * p1, const char * p2)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    stext = library.convert_to_Window(text)
    library.keep_elem_refs(pImage, text, stext)
    _flimage_error(pImage, stext)


# built-in format supports

def flimage_enable_pnm():
    """flimage_enable_pnm()
    
    Enables use of PNM (Portable anymap) image format.

    Examples
    --------
        >>> flimage_enable_pnm()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_pnm = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_pnm",
        None, [],
        """void flimage_enable_pnm()""")
    library.check_if_initialized()
    _flimage_enable_pnm()


def flimage_set_fits_bits(nbits):
    """flimage_set_fits_bits(nbits)
    
    Sets the number of bit of a FITS image.

    Parameters
    ----------
        nbits : int
            number of bit to be set

    Returns
    -------
        oldbit : int
            old number of bit, or negative number (on failure)

    Examples
    --------
        >>> oldnumbit = flimage_set_fits_bits(16)

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK

    """
    _flimage_set_fits_bits = library.cfuncproto(
        library.load_so_libflimage(), "flimage_set_fits_bits",
        cty.c_int, [cty.c_int],
        """int flimage_set_fits_bits(int p1)""")
    library.check_if_initialized()
    inbits = library.convert_to_int(nbits)
    library.keep_elem_refs(nbits, inbits)
    retval = _flimage_set_fits_bits(inbits)
    return retval


def flimage_jpeg_output_options(pImageJpegOption):
    """flimage_jpeg_output_options(pImageJpegOption)
    
    Sets quality and smoothing options of a JPEG image, using
    xfdata.FLIMAGE_JPEG_OPTION. The default quality factor for JPEG output
    is 75. In general, the higher the quality factor the better the image
    is, but the file size gets larger. The default smoothing factor is 0.

    Parameters
    ----------
        pImageJpegOption : pointer to xfdata.FLIMAGE_JPEG_OPTION
            flimage jpeg option class instance

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_jpeg_output_options = library.cfuncproto(
        library.load_so_libflimage(), "flimage_jpeg_output_options",
        None, [cty.POINTER(xfdata.FLIMAGE_JPEG_OPTION)],
        """void flimage_jpeg_output_options(FLIMAGE_JPEG_OPTION * p1)""")
    library.check_if_initialized()
    library.verify_otherclassptr_type(pImageJpegOption, cty.POINTER( \
                                    xfdata.FLIMAGE_JPEG_OPTION))
    library.keep_elem_refs(pImageJpegOption)
    _flimage_jpeg_output_options(pImageJpegOption)


def flimage_pnm_output_options(rawformat):
    """flimage_pnm_output_options(rawformat)
    
    Sets variant options for PNM (ppm, pgm and pbm) images.

    Parameters
    ----------
        rawformat : int
            flag of supported variants. Values 1 (binary raw format, default)
            or 0 (ASCII format). If the output image is of type
            xfdata.FL_IMAGE_GRAY16, it is always ASCII format

    Examples
    --------
        >>> flimage_pnm_output_options(1)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_pnm_output_options = library.cfuncproto(
        library.load_so_libflimage(), "flimage_pnm_output_options",
        None, [cty.c_int],
        """void flimage_pnm_output_options(int p1)""")
    library.check_if_initialized()
    irawformat = library.convert_to_int(rawformat)
    library.keep_elem_refs(rawformat, irawformat)
    _flimage_pnm_output_options(irawformat)


def flimage_gif_output_options(interlace):
    """flimage_gif_output_options(interlace)
    
    Sets options of GIF images.

    Parameters
    ----------
        interlace : int
            flag if interlace is enabled/disabled. Values 1 (interlaced)
            or 0 (not interlaced).

    Examples
    --------
        >>> flimage_gif_output_options(1)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_gif_output_options = library.cfuncproto(
        library.load_so_libflimage(), "flimage_gif_output_options",
        None, [cty.c_int],
        """void flimage_gif_output_options(int p1)""")
    library.check_if_initialized()
    iinterlace = library.convert_to_int(interlace)
    library.keep_elem_refs(interlace, iinterlace)
    _flimage_gif_output_options(iinterlace)


def flimage_ps_options():
    """flimage_ps_options()
    
    Sets reading and writing options for PostScript.

    Returns
    -------
        pFlpsControl : pointer to xfdata.FLPS_CONTROL
            flpscontrol class instance

    Examples
    --------
        flimage_ps_options()

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_ps_options = library.cfuncproto(
        library.load_so_libflimage(), "flimage_ps_options",
        cty.POINTER(xfdata.FLPS_CONTROL), [],
        """FLPS_CONTROL * flimage_ps_options()""")
    library.check_if_initialized()
    retval = _flimage_ps_options()
    return retval


flimage_jpeg_options = flimage_jpeg_output_options
flimage_pnm_options = flimage_pnm_output_options
flimage_gif_options = flimage_gif_output_options


def flimage_get_number_of_formats():
    """flimage_get_number_of_formats()
    
    Obtains the number of currently supported image format.

    Returns
    -------
        nformats : int
            number of formats supported, for reading or writing or both

    Examples
    --------
        >>> flimage_get_number_of_formats()

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_get_number_of_formats = library.cfuncproto(
        library.load_so_libflimage(), "flimage_get_number_of_formats",
        cty.c_int, [],
        """int flimage_get_number_of_formats()""")
    library.check_if_initialized()
    retval = _flimage_get_number_of_formats()
    return retval


def flimage_get_format_info(nformat):
    """flimage_get_format_info(nformat)
    
    Obtains detailed information for each image format.

    Parameters
    ----------
        nformat : int
            number between 1 and the return value of
            flimage_get_number_of_formats() ??

    Returns
    -------
        pImageFormatInfo : pointer to xfdata.FLIMAGE_FORMAT_INFO
            ImageFormatInfo class instance

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_get_format_info = library.cfuncproto(
        library.load_so_libflimage(), "flimage_get_format_info",
        cty.POINTER(xfdata.FLIMAGE_FORMAT_INFO), [cty.c_int],
        """const FLIMAGE_FORMAT_INFO * flimage_get_format_info(int p1)""")
    library.check_if_initialized()
    informat = library.convert_to_int(nformat)
    library.keep_elem_refs(nformat, informat)
    retval = _flimage_get_format_info(informat)
    return retval


def fl_get_matrix(nrows, ncols, elemsize):
    """fl_get_matrix(nrows, ncols, elemsize)
    
    Creates a 2-dimensional array of entities of size elemsize. The array
    is of nrows by ncols in size.

    Parameters
    ----------
        nrows : int
            number of rows
        ncols : int
            number of columns
        elemsize : int_pos
            size of matrix in bytes

    Returns
    -------
        num : *todo*
            a matrix?

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_get_matrix = library.cfuncproto(
        library.load_so_libflimage(), "fl_get_matrix",
        cty.c_void_p, [cty.c_int, cty.c_int, cty.c_uint],
        """void * fl_get_matrix(int p1, int p2, unsigned int p3)""")
    library.check_if_initialized()
    inrows = library.convert_to_int(nrows)
    incols = library.convert_to_int(ncols)
    uielemsize = library.convert_to_uint(elemsize)
    library.keep_elem_refs(nrows, ncols, elemsize, inrows, incols, uielemsize)
    retval = _fl_get_matrix(inrows, incols, uielemsize)
    return retval


def fl_make_matrix(nrows, ncols, elemsize, mem):
    """fl_make_matrix(nrows, ncols, elemsize, mem)
    
    Makes a matrix out of a given piece of memory.

    Parameters
    ----------
        nrows : int
            number of rows
        ncols : int
            number of columns
        elemsize : int_pos
            size of matrix in bytes
        mem : *todo*
            memory

    Returns
    -------
        num : *todo*
            a matrix?

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_make_matrix = library.cfuncproto(
        library.load_so_libflimage(), "fl_make_matrix",
        cty.c_void_p, [cty.c_int, cty.c_int, cty.c_uint, cty.c_void_p],
        """void * fl_make_matrix(int p1, int p2, unsigned int p3,
           void * p4)""")
    library.check_if_initialized()
    inrows = library.convert_to_int(nrows)
    incols = library.convert_to_int(ncols)
    uielemsize = library.convert_to_uint(elemsize)
    pmem = cty.cast(mem, cty.c_void_p)
    library.keep_elem_refs(nrows, ncols, elemsize, mem, inrows, incols,
                        uielemsize, pmem)
    retval = _fl_make_matrix(inrows, incols, uielemsize, pmem)
    return retval


def fl_free_matrix(mtrx):
    """fl_free_matrix(mtrx)
    
    Frees a matrix allocated using fl_get_matrix() or fl_make_matrix().

    Parameters
    ----------
        mtrx : *todo*
            a matrix?

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_free_matrix = library.cfuncproto(
        library.load_so_libflimage(), "fl_free_matrix",
        None, [cty.c_void_p],
        """void fl_free_matrix(void * p1)""")
    library.check_if_initialized()
    pmtrx = cty.cast(mtrx, cty.c_void_p)
    library.keep_elem_refs(mtrx, pmtrx)
    _fl_free_matrix(pmtrx)


# fl_init_RGBdatabase(text) function prototype (deprecated)


def fl_lookup_RGBcolor(colrname):
    """fl_lookup_RGBcolor(colrname)
    
    *todo*

    Parameters
    ----------
        colrname : str
            text of color name

    Returns
    -------
        result : int
            0 o or -1 (on failure)
        red : int
            red value
        green : int
            green value
        blue : int
            blue value

    Examples
    --------
        >>> *todo*

    API_diversion
    ----------
        API changed from XForms, upstream was
        fl_lookup_RGBcolor(text, r, g, b)

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_lookup_RGBcolor = library.cfuncproto(
        library.load_so_libflimage(), "fl_lookup_RGBcolor",
        cty.c_int, [xfdata.STRING, cty.POINTER(cty.c_int), \
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],
        """int fl_lookup_RGBcolor(const char * p1, int * p2,
           int * p3, int * p4)""")
    library.check_if_initialized()
    scolrname = library.convert_to_string(colrname)
    r, pr = library.make_int_and_pointer()
    g, pg = library.make_int_and_pointer()
    b, pb = library.make_int_and_pointer()
    library.keep_elem_refs(colrname, r, g, b, colrname, pr, pg, pb)
    retval = _fl_lookup_RGBcolor(scolrname, pr, pg, pb)
    return retval, r.value, g.value, b.value


def flimage_add_format(formalname, shortname, extension, imagetype,
        py_ImageIdentify, py_ImageDescription, py_ImageReadPixels,
        py_ImageWriteImage):
    """flimage_add_format(formalname, shortname, extension, imagetype,
    py_ImageIdentify, py_ImageDescription, py_ImageReadPixels,
    py_ImageWriteImage)
    
    Adds the newly specified image format to a recognized image format
    pool in the library.

    Parameters
    ----------
        formalname : str
            the formal name of image format
        shortname : str
            an abbreviated name for the image format
        extension : str
            file extension. If it is None, shortname will be substituted
        imagetype : int
            The image type, generally one of the supported image types (e.g.
            xfdata.FL_IMAGE_RGB), but it does not have to. For image file
            formats that are capable of holding more than one type of images,
            this field can be set to indicate this by ORing the supported
            types together (e.g., xfdata.FL_IMAGE_RGB|FL_IMAGE_GRAY).
            However, when description returns, the image type should be set
            to the actual type in the file.
        py_ImageIdentify : function to identify format, returned value
            name referring to function(pFile) -> num.
            This function should return 1 if the file pointed to by the file
            pointer passed in is the expected image format (e.g by checking
            signature). It should return a negative number if the file is
            not recognized. The decision if the file pointer should be
            rewound or not is between this function and the description
            function.
        py_ImageDescription : function to set description, returned value
            name referring to function(pImage) -> num.
            This function in general should set the image dimension and type
            fields (and colormap length for color index images) if
            successful, so the driver can allocate the necessary memory for
            read pixel. Of course, if read_pixels elects to allocate memory
            itself, the description function does not have to set any fields.
            However, if reading should continue, the function should return
            1, otherwise a negative number.
        py_ImageReadPixels : python function to read pixels, returned value
            name referring to function(pImage) -> num.
            This function reads the pixels from the file and fills one of the
            pixel matrix in the image structure depending on the type. If
            reading is successful, a non-negative number should be returned
            otherwise a negative number should be returned. Upon entry,
            pImage.contents.completed is set to zero. The function should not
            close the file.
        py_ImageWriteImage : python function to write image, returned value
            name referring to function(pImage) -> num.
            This function takes an image structure and should write the image
            out in a format it knows. Prior to calling this routine, the
            driver will have already converted the image type to the type it
            wants. The function should return 1 on success and a negative
            number otherwise. If only reading of the image format is
            supported this parameter can be set to None. The function should
            write to file stream pImage.contents.fpout.

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    #FLIMAGE_Identify = cty.CFUNCTYPE(cty.c_int, cty.POINTER(xfdata.FILE))
    #FLIMAGE_Description = cty.CFUNCTYPE(cty.c_int, cty.POINTER( \
    #    xfdata.FL_IMAGE))
    #FLIMAGE_Read_Pixels = cty.CFUNCTYPE(cty.c_int, cty.POINTER( \
    #    xfdata.FL_IMAGE))
    #FLIMAGE_Write_Image = cty.CFUNCTYPE(cty.c_int, cty.POINTER( \
    #    xfdata.FL_IMAGE))
    _flimage_add_format = library.cfuncproto(
        library.load_so_libflimage(), "flimage_add_format",
        cty.c_int, [xfdata.STRING, xfdata.STRING, xfdata.STRING, cty.c_int,
        xfdata.FLIMAGE_Identify, xfdata.FLIMAGE_Description,
        xfdata.FLIMAGE_Read_Pixels, xfdata.FLIMAGE_Write_Image],
        """int flimage_add_format(const char * p1, const char * p2,
           const char * p3, int p4, FLIMAGE_Identify p5,
           FLIMAGE_Description p6, FLIMAGE_Read_Pixels p7,
           FLIMAGE_Write_Image p8)""")
    library.check_if_initialized()
    library.checkfatal_allowed_value_in_list(imagetype, \
            xfdata.FLIMAGETYPE_list)
    sformalname = library.convert_to_string(formalname)
    sshortname = library.convert_to_string(shortname)
    sextension = library.convert_to_string(extension)
    iimagetype = library.convert_to_int(imagetype)
    library.verify_function_type(py_ImageIdentify)
    c_ImageIdentify = xfdata.FLIMAGE_Identify(py_ImageIdentify)
    library.verify_function_type(py_ImageDescription)
    c_ImageDescription = xfdata.FLIMAGE_Description(py_ImageDescription)
    library.verify_function_type(py_ImageReadPixels)
    c_ImageReadPixels = xfdata.FLIMAGE_Read_Pixels(py_ImageReadPixels)
    library.verify_function_type(py_ImageWriteImage)
    c_ImageWriteImage = xfdata.FLIMAGE_Write_Image(py_ImageWriteImage)
    library.keep_cfunc_refs(c_ImageIdentify, py_ImageIdentify,
            c_ImageDescription, py_ImageDescription, c_ImageReadPixels,
            py_ImageReadPixels, c_ImageWriteImage, py_ImageWriteImage)
    library.keep_elem_refs(formalname, shortname, extension, imagetype, \
                   sformalname, sshortname, sextension, iimagetype)
    retval = _flimage_add_format(sformalname, sshortname, sextension, \
                    iimagetype, c_ImageIdentify, c_ImageDescription, \
                    c_ImageReadPixels, c_ImageWriteImage)
    return retval


def flimage_set_annotation_support(imgnum, yesno):
    """flimage_set_annotation_support(imgnum, yesno)
    
    Sets support for annotations.

    Parameters
    ----------
        imgnum : int
            image number?. Values between 0 and number of images?
        yesno : int
            flag to enable/disable support. Values 1 (to enable) or 0
            (to disable)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_set_annotation_support = library.cfuncproto(
        library.load_so_libflimage(), "flimage_set_annotation_support",
        None, [cty.c_int, cty.c_int],
        """void flimage_set_annotation_support(int p1, int p2)""")
    library.check_if_initialized()
    iimgnum = library.convert_to_int(imgnum)
    iyesno = library.convert_to_int(yesno)
    library.keep_elem_refs(imgnum, yesno, iimgnum, iyesno)
    _flimage_set_annotation_support(iimgnum, iyesno)


def flimage_getcolormap(pImage):
    """flimage_getcolormap(pImage)
    
    Obtains color map for an image.

    Parameters
    ----------
      pImage : pointer to xfdata.FL_IMAGE
        image

    Returns
    -------
        result : int
            0, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_getcolormap = library.cfuncproto(
        library.load_so_libflimage(), "flimage_getcolormap",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_getcolormap(FL_IMAGE * p1)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    retval = _flimage_getcolormap(pImage)
    return retval


def fl_select_mediancut_quantizer():
    """fl_select_mediancut_quantizer()
    
    Selects median cut quantizer, who uses Heckbert's median cut algorithm
    followed by Floyd-Steinberg dithering after which the pixels are mapped
    to the colors selected. This tends to give better images because of the
    dithering step. However, in this particular implementation, the number
    of quantized colors is limited to 256. Color quantization is one way of
    reduce the number of colors in the original image to display a RGB image
    on a color-mapped device of limited depth.

    Examples
    --------
        >>> flimage_select_mediancut_quantizer()

    Notes
    -----
        Status: Tested + Doc + NoDemo = NOT OK

    """
    _fl_select_mediancut_quantizer = library.cfuncproto(
        library.load_so_libflimage(), "fl_select_mediancut_quantizer",
        None, [],
        """void fl_select_mediancut_quantizer()""")
    library.check_if_initialized()
    _fl_select_mediancut_quantizer()


# simple image processing routines

def flimage_convolve(pImage, kernel, krows, kcols):
    """flimage_convolve(pImage, kernel, krows, kcols)
    
    Takes a convolution kernel of krows by kcols and convolves it with
    the image. The result replaces the input image.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        kernel : *todo*
            The kernel size should be odd, and should be allocated by
            fl_get_matrix(). *todo*
        krows : int
            number of kernel rows
        kcols : int
            number of kernel cols

    Returns
    -------
        num. : int
            positive num., or negative num (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_convolve = library.cfuncproto(
        library.load_so_libflimage(), "flimage_convolve",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE),
        cty.POINTER(cty.POINTER(cty.c_int)), cty.c_int, cty.c_int],
        """int flimage_convolve(FL_IMAGE * p1, int * * p2, int p3,
           int p4)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    ikrows = library.convert_to_int(krows)
    ikcols = library.convert_to_int(kcols)
    library.keep_elem_refs(pImage, kernel, krows, kcols, ikrows, ikcols)
    retval = _flimage_convolve(pImage, kernel, ikrows, ikcols)
    return retval


def flimage_convolvea(pImage, kernel, krow, kcol):
    """flimage_convolvea(pImage, kernel, krow, kcol)
    
    Takes a convolution kernel of krow by kcol and convolves it with
    the image. The result replaces the input image. It uses a kernel that's a
    C 2-dimensional array (cast to a pointer to int).

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        kernel : *todo*
            C 2-dimensional array *todo*
        krow : int
            number of kernel rows
        kcol : int
            number of kernel columns

    Returns
    -------
        num. : int
            positive num., or negative num (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_convolvea = library.cfuncproto(
        library.load_so_libflimage(), "flimage_convolvea",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER(cty.c_int),
        cty.c_int, cty.c_int],
        """int flimage_convolvea(FL_IMAGE * p1, int * p2, int p3, int p4)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    pkernel = cty.cast(kernel, cty.POINTER(cty.c_int))
    ikrow = library.convert_to_int(krow)
    ikcol = library.convert_to_int(kcol)
    library.keep_elem_refs(pImage, kernel, krow, kcol, pkernel, ikrow, ikcol)
    retval = _flimage_convolvea(pImage, pkernel, krow, kcol)
    return retval


def flimage_tint(pImage, packed, opacity):
    """flimage_tint(pImage, packed, opacity)
    
    Emulates the effect of looking at an image through a piece of colored
    glass. Tint is most useful in cases where you want to put some annotations
    on the image, but do not want to use a uniform and opaque background that
    completely obscures the image behind. By using tint, you can have a
    background that provides some contrast to the text, yet not obscures the
    image beneath completely. Tint operation uses the subimage settings.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        packed : int_pos
            packed RGB color, specifying the color of the glass.
        opacity : float
            how much the color of the image is absorbed by the glass. Values
            between 0 (the glass is totally transparent, i.e. the glass has
            no effect) and 1.0 (total opaqueness, i.e. all you see is the
            color of the glass. Any value between these two extremes results
            in a color that is a combination of the pixel color and the
            glass color.

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> pkdcolr = flxbasic.FL_PACK3(20, 30, 40)
        >>> exval = flimage_tint(pimg, pkdcolr, 0.5)

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK

    """
    _flimage_tint = library.cfuncproto(
        library.load_so_libflimage(), "flimage_tint",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_uint, cty.c_double],
        """int flimage_tint(FL_IMAGE * p1, unsigned int p2, double p3)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    uipacked = library.convert_to_uint(packed)
    fopacity = library.convert_to_float(opacity)
    library.keep_elem_refs(pImage, packed, opacity, uipacked, fopacity)
    retval = _flimage_tint(pImage, uipacked, fopacity)
    return retval


def flimage_rotate(pImage, angle, subpixel):
    """flimage_rotate(pImage, angle, subpixel)
    
    Does an image rotation. Repeated rotations should be avoided if possible.
    If you have to call it more than once it is a good idea to crop after
    rotations in order to get rid of the regions that contain only fill color.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        angle : int
            the angle in one-tenth of a degree (i.e., a 45 degree rotation
            should be specified as 450) with a positive sign for counter-clock
            rotation.
        subpixel : int
            if subpixel sampling should be enabled. Values (from xfdata.py)
            FLIMAGE_NOSUBPIXEL or FLIMAGE_SUBPIXEL. If enabled, the resulting
            image pixels are interpolated from the original pixels; this
            usually has an "anti-aliasing" effect that leads to less severe
            jagged edges and similar artifacts commonly encountered in
            rotations. However, it also means that a color indexed image gets
            converted to a RGB image. If preserving the pixel value is
            important, you should not turn subpixel sampling on.

    Returns
    -------
        num. : int
            num., or negative num. (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_rotate = library.cfuncproto(
        library.load_so_libflimage(), "flimage_rotate",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int],
        """int flimage_rotate(FL_IMAGE * p1, int p2, int p3)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.checkfatal_allowed_value_in_list(subpixel, xfdata.FLIMAGESUBPIXROT_list)
    iangle = library.convert_to_int(angle)
    isubpixel = library.convert_to_int(subpixel)
    library.keep_elem_refs(pImage, angle, subpixel, iangle, isubpixel)
    retval = _flimage_rotate(pImage, iangle, isubpixel)
    return retval


def flimage_flip(pImage, what):
    """flimage_flip(pImage, what)
    
    Does the mirror operation in x- or y-direction at the center. For
    example, to flip the columns of an image, the left and right of the
    image are flipped (just like having a vertical mirror in the center of
    the image) thus the first pixel on any given row becomes the last, and
    the last pixel becomes the first etc.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        what : int or char
            desired direction of flipping. Values 'c' (column, horizontal
            flipping) or 'r' (row, vertical flipping)

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> resl = flimage_filp(pimg, 'c')

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_flip = library.cfuncproto(
        library.load_so_libflimage(), "flimage_flip",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int],
        """int flimage_flip(FL_IMAGE * p1, int p2)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    if isinstance(what, str):
        # workaround to let a character as int argument
        ordwhat = ord(what)
    else:
        ordwhat = what
    iwhat = library.convert_to_int(ordwhat)
    library.keep_elem_refs(pImage, what, ordwhat, iwhat)
    retval = _flimage_flip(pImage, iwhat)
    return retval


def flimage_scale(pImage, newwidth, newheight, option):
    """flimage_scale(pImage, newwidth, newheight, option)
    
    Scales an image to any desired size with or without subpixel sampling.
    Without subpixel sampling simple pixel replication is used, otherwise a
    box average algorithm is employed that yields an anti-aliased image with
    much less artifacts.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        newwidth : int
            desired image width
        newheight : int
            desired image height
        option : int
            option to scale the image to the desired size but keeping the
            aspect ratio of the image the same by filling the part of the
            image that  would otherwise be empty. Values (from xfdata.py)
            FLIMAGE_NOSUBPIXEL, FLIMAGE_SUBPIXEL, FLIMAGE_ASPECT,
            FLIMAGE_CENTER, FLIMAGE_NOCENTER. Any value can be single or
            bitwise-ORed.

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_scale = library.cfuncproto(
        library.load_so_libflimage(), "flimage_scale",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int,
        cty.c_int],
        """int flimage_scale(FL_IMAGE * p1, int p2, int p3, int p4)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    inewwidth = library.convert_to_int(newwidth)
    inewheight = library.convert_to_int(newheight)
    ioption = library.convert_to_int(option)
    library.keep_elem_refs(pImage, newwidth, newwidth, option, inewwidth,
                        inewwidth, ioption)
    retval = _flimage_scale(pImage, inewwidth, inewheight, ioption)
    return retval


def flimage_warp(pImage, mtrx, newwidth, newheight, subpixel):
    """flimage_warp(pImage, mtrx, newwidth, newheight, subpixel)
    
    Does transformation of pixel coordinates. Rotation, scaling, shearing
    etc. are examples of (linear and non-perspective) image warping. User can
    specify whatever size he/she wants and the warp function will fill the
    empty grid location with the fill color. This is how the aspect ratio
    preserving scaling is implemented. The image is transformed in place.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        mtrx : *todo*
            the warp matrix
        newwidth : int
            desired image width
        newheight : int
            desired image height
        subpixel : int
            if subpixel sampling should be used. Although subpixel sampling
            adds processing time, it generally improves image quality
            significantly. Values (from xfdata.py) any logical OR of
            FLIMAGE_NOSUBPIXEL, FLIMAGE_SUBPIXEL and FLIMAGE_NOCENTER (only
            useful if you specify an image dimension that is larger than the
            warped image, and in that case the warped image is flushed
            top-left within the image grid, otherwise it is centered).

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_warp = library.cfuncproto(
        library.load_so_libflimage(), "flimage_warp",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER(cty.c_float * 2),
        cty.c_int, cty.c_int, cty.c_int],
        """int flimage_warp(FL_IMAGE * p1, float * p2, int p3, int p4,
           int p5)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    # mtrx to be handled
    inewwidth = library.convert_to_int(newwidth)
    inewheight = library.convert_to_int(newheight)
    isubpixel = library.convert_to_int(subpixel)
    library.keep_elem_refs(pImage, mtrx, newwidth, newheight, subpixel,
                        inewwidth, inewheight, isubpixel)
    retval = _flimage_warp(pImage, mtrx, inewwidth, inewheight, isubpixel)
    return retval


def flimage_autocrop(pImage, bgcolr):
    """flimage_autocrop(pImage, bgcolr)
    
    Automatically crops an image using the background as the color to crop,
    by searching the image from all four sides and removing all contiguous
    regions of the uniform background from the sides. The image is modified
    in place.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        bgcolr : int_pos
            background color to crop. If it is xfdata.FLIMAGE_AUTOCOLOR, the
            background is chosen as the first pixel of the image.

    Returns
    -------
        num. : int
            non-negative num., or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_autocrop = library.cfuncproto(
        library.load_so_libflimage(), "flimage_autocrop",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_uint],
        """int flimage_autocrop(FL_IMAGE * p1, unsigned int p2)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    uibgcolr = library.convert_to_uint(bgcolr)
    library.keep_elem_refs(pImage, bgcolr, uibgcolr)
    retval = _flimage_autocrop(pImage, uibgcolr)
    return retval


def flimage_get_autocrop(pImage, bgcolr):
    """flimage_get_autocrop(pImage, bgcolr)
    
    Obtains the auto-cropping offsets (from left, right, top and bottom
    sides) of an image.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        bgcolr : int_pos
            background color to crop. If it is xfdata.FLIMAGE_AUTOCOLOR, the
            background is chosen as the first pixel of the image.

    Returns
    -------
    num. : int
        *todo*
    xl : int
        offset from left side
    yt : int
        offset from top side
    xr : int
        offset from right side
    yb : int
        offset from bottom side

    Examples
    --------
        >>> *todo*

    API_diversion
    ----------
        API changed from XForms, upstream was
        flimage_get_autocrop(pImage, bk, xl, yt, xr, yb)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_get_autocrop = library.cfuncproto(
        library.load_so_libflimage(), "flimage_get_autocrop",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_uint,
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],
        """int flimage_get_autocrop(FL_IMAGE * p1, unsigned int p2,
           int * p3, int * p4, int * p5, int * p6)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    uibgcolr = library.convert_to_uint(bgcolr)
    xl, pxl = library.make_int_and_pointer()
    yt, pyt = library.make_int_and_pointer()
    xr, pxr = library.make_int_and_pointer()
    yb, pyb = library.make_int_and_pointer()
    library.keep_elem_refs(pImage, bgcolr, uibgcolr, xl, pxl, yt, pyt, xr, pxr,
                        yb, pyb)
    retval = _flimage_get_autocrop(pImage, uibgcolr, pxl, pyt, pxr, pyb)
    return retval, xl.value, yt.value, xr.value, yb.value


def flimage_crop(pImage, xl, yt, xr, yb):
    """flimage_crop(pImage, xl, yt, xr, yb)
    
    Crops an image, using offsets supplied by the user.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        xl : int
            offset from left side. If it is negative, it indicates
            enlargement of the image. (e.g. if it is 1 the cropping
            removes the first column from the image).
        yt : int
            offset from top side. If it is negative, it indicates
            enlargement of the image. (e.g. if it is 1 the cropping
            removes the first row from the image).
        xr : int
            offset from right side. If it is negative, it indicates
            enlargement of the image. (e.g. if it is 1 the cropping
            removes the last column from the image).
        yb : int
            offset from bottom side. If it is negative, it indicates
            enlargement of the image. (e.g. if it is 1 the cropping
            removes the last row from the image).

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_crop = library.cfuncproto(
        library.load_so_libflimage(), "flimage_crop",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int,
        cty.c_int, cty.c_int],
        """int flimage_crop(FL_IMAGE * p1, int p2, int p3,
           int p4, int p5)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    ixl = library.convert_to_int(xl)
    iyt = library.convert_to_int(yt)
    ixr = library.convert_to_int(xr)
    iyb = library.convert_to_int(yb)
    library.keep_elem_refs(pImage, xl, yt, xr, yb, ixl, iyt, ixr, iyb)
    retval = _flimage_crop(pImage, ixl, iyt, ixr, iyb)
    return retval


def flimage_replace_pixel(pImage, targetcolr, newcolr):
    """flimage_replace_pixel(pImage, targetcolr, newcolr)
    
    Replaces all color targetcolr with the new desired color.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        targetcolr : int_pos
            color to be replaced
        newcolr : int_pos
            new color to be used

    Returns
    -------
        result : int
            0, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_replace_pixel = library.cfuncproto(
        library.load_so_libflimage(), "flimage_replace_pixel",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_uint, cty.c_uint],
        """int flimage_replace_pixel(FL_IMAGE * p1, unsigned int p2,
           unsigned int p3)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    uitargetcolr = library.convert_to_uint(targetcolr)
    uinewcolr = library.convert_to_uint(newcolr)
    library.keep_elem_refs(pImage, targetcolr, newcolr, uitargetcolr, uinewcolr)
    retval = _flimage_replace_pixel(pImage, uitargetcolr, uinewcolr)
    return retval


def flimage_transform_pixels(pImage, red, green, blue):
    """flimage_transform_pixels(pImage, red, green, blue)
    
    Processes an image in place with RGB transformation and replaces it.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        red : int
            lookup tables for red color of a length of at least
            FL_PCMAX + 1 (256).
        green : int
            lookup tables for green color of a length of at least
            FL_PCMAX + 1 (256).
        blue : int
            lookup tables for blue color of a length of at least
            FL_PCMAX + 1 (256).

    Returns
    -------
        num. : int
            positive num., or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_transform_pixels = library.cfuncproto(
        library.load_so_libflimage(), "flimage_transform_pixels",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],
        """int flimage_transform_pixels(FL_IMAGE * p1, int * p2,
           int * p3, int * p4)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    pred = cty.cast(red, cty.POINTER(cty.c_int))
    pgreen = cty.cast(green, cty.POINTER(cty.c_int))
    pblue = cty.cast(blue, cty.POINTER(cty.c_int))
    library.keep_elem_refs(pImage, red, green, blue, pred, pgreen, pblue)
    retval = _flimage_transform_pixels(pImage, pred, pgreen, pblue)
    return retval


def flimage_windowlevel(pImage, winlvl, width):
    """flimage_windowlevel(pImage, winlvl, width)
    
    Sets the window level for an image. It points to a multiple image,
    window level parameters are changed for all images.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        winlvl : int
            new level of window
        width : int
            width. If zero disables window leveling.

    Returns
    -------
        result : int
            1 (if window level parameters are modified), otherwise 0 is
            returned.

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_windowlevel = library.cfuncproto(
        library.load_so_libflimage(), "flimage_windowlevel",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int],
        """int flimage_windowlevel(FL_IMAGE * p1, int p2, int p3)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    iwinlvl = library.convert_to_int(winlvl)
    iwidth = library.convert_to_int(width)
    library.keep_elem_refs(pImage, winlvl, width, iwinlvl, iwidth)
    retval = _flimage_windowlevel(pImage, iwinlvl, iwidth)
    return retval


def flimage_enhance(pImage, delta):
    """flimage_enhance(pImage, delta)
    
    *todo*

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        delta : int
            unused.

    Returns
    -------
        num. : int
            0?

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_enhance = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enhance",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int],
        """int flimage_enhance(FL_IMAGE * p1, int p2)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    idelta = library.convert_to_int(delta)     # unused
    library.keep_elem_refs(pImage, delta, idelta)
    retval = _flimage_enhance(pImage, idelta)
    return retval


def flimage_from_pixmap(pImage, pixmap):
    """flimage_from_pixmap(pImage, pixmap)
    
    Converts a Pixmap to an image. *todo*

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        pixmap : long_pos
            pixmap id

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_from_pixmap = library.cfuncproto(
        library.load_so_libflimage(), "flimage_from_pixmap",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.Pixmap],
        """int flimage_from_pixmap(FL_IMAGE * p1, Pixmap p2)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    ulpixmap = library.convert_to_Pixmap(pixmap)
    library.keep_elem_refs(pImage, pixmap, ulpixmap)
    retval = _flimage_from_pixmap(pImage, ulpixmap)
    return retval


def flimage_to_pixmap(pImage, win):
    """flimage_to_pixmap(pImage, win)
    
    Converts an image into a Pixmap (a server side resource) that
    can be used in the pixmap object.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        win : long_pos
            window id

    Returns
    -------
        pixmap : long_pos
            pixmap id

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_to_pixmap = library.cfuncproto(
        library.load_so_libflimage(), "flimage_to_pixmap",
        xfdata.Pixmap, [cty.POINTER(xfdata.FL_IMAGE), xfdata.FL_WINDOW],
        """Pixmap flimage_to_pixmap(FL_IMAGE * p1, FL_WINDOW p2)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    ulwin = library.convert_to_Window(win)
    library.keep_elem_refs(pImage, win, ulwin)
    retval = _flimage_to_pixmap(pImage, ulwin)
    return retval


def flimage_dup(pImage):
    """flimage_dup(pImage)
    
    Duplicates an image and returns the duplicated image. At the moment,
    only the first image is duplicated even if the input image has multiple
    frames. Furthermore, markers and annotations are not duplicated.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image to be duplicated

    Returns
    -------
        pImage : pointer to xfdata.FL_IMAGE
            duplicated image class instance

    Examples
    --------
        >>> pimg2 = flimage_dup(pimg1)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_dup = library.cfuncproto(
        library.load_so_libflimage(), "flimage_dup",
        cty.POINTER(xfdata.FL_IMAGE), [cty.POINTER(xfdata.FL_IMAGE)],
        """FL_IMAGE * flimage_dup(FL_IMAGE * p1)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    retval = _flimage_dup(pImage)
    return retval


# Miscellaneous prototypes

def fl_get_submatrix(inmtrx, nrows, ncols, r1, c1, rs, cs, elemsize):
    """fl_get_submatrix(inmtrx, nrows, ncols, r1, c1, rs, cs, elemsize)
    
    Grabs a piece of an image matrix. The piece is of nrows by ncols in
    size.

    Parameters
    ----------
        inmtrx : *todo*
            image matrix
        nrows : int
            number of rows
        ncols : int
            number of columns
        r1 : int
            initial row?
        c1 : int
            initial column?
        rs : int
            final row?
        cs : int
            final column?
        elemsize : int_pos
            size of matrix in bytes

    Returns
    -------
        num. : *todo*
            a matrix?

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_get_submatrix = library.cfuncproto(
        library.load_so_libflimage(), "fl_get_submatrix",
        cty.c_void_p, [cty.c_void_p, cty.c_int, cty.c_int, cty.c_int,
        cty.c_int, cty.c_int, cty.c_int, cty.c_uint],
        """void * fl_get_submatrix(void * p1, int p2, int p3, int p4,
           int p5, int p6, int p7, unsigned int p8)""")
    library.check_if_initialized()
    pinmtrx = cty.cast(inmtrx, cty.c_void_p)
    inrows = library.convert_to_int(nrows)
    incols = library.convert_to_int(ncols)
    ir1 = library.convert_to_int(r1)
    ic1 = library.convert_to_int(c1)
    irs = library.convert_to_int(rs)
    ics = library.convert_to_int(cs)
    uielemsize = library.convert_to_uint(elemsize)
    library.keep_elem_refs(inmtrx, nrows, ncols, r1, c1, rs, cs, elemsize,
                    pinmtrx, inrows, incols, ir1, ic1, irs, ics, uielemsize)
    retval = _fl_get_submatrix(pinmtrx, inrows, incols, ir1, ic1, irs, ics, \
                               uielemsize)
    return retval


def fl_j2pass_quantize_packed(packed, w, h, maxcolr, ci, actualcolr, redlut,
                              greenlut, bluelut, pImage):
    """fl_j2pass_quantize_packed(packed, w, h, maxcolr, ci, actualcolr,
    redlut, greenlut, bluelut, pImage)
    
    *todo*

    Parameters
    ----------
        packed : *todo*
            *todo*
        w : int
            *todo*
        h : int
            *todo*
        maxcolr : int
            *todo*
        ci : *todo*
            *todo*
        actualcolr : int
            *todo*
        redlut : int
            *todo*
        greenlut : int
            *todo*
        bluelut : int
            *todo*
        pImage : pointer to xfdata.FL_IMAGE
            image

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_j2pass_quantize_packed = library.cfuncproto(
        library.load_so_libflimage(), "fl_j2pass_quantize_packed",
        cty.c_int, [cty.POINTER(cty.POINTER(cty.c_uint)), cty.c_int,
        cty.c_int, cty.c_int, cty.POINTER(cty.POINTER(cty.c_ushort)),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(xfdata.FL_IMAGE)],
        """int fl_j2pass_quantize_packed(unsigned int * * p1, int p2,
           int p3, int p4, short unsigned int * * p5, int * p6,
           int * p7, int * p8, int * p9, FL_IMAGE * p10)""")
    library.check_if_initialized()
    # packed to be handled
    iw = library.convert_to_int(w)
    ih = library.convert_to_int(h)
    imaxcolr = library.convert_to_int(maxcolr)
    # ci to be handled
    iactualcolr = library.convert_to_int(actualcolr)
    predlut = cty.cast(redlut, cty.POINTER(cty.c_int))
    pgreenlut = cty.cast(greenlut, cty.POINTER(cty.c_int))
    pbluelut = cty.cast(bluelut, cty.POINTER(cty.c_int))
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(packed, w, h, maxcolr, ci, actualcolr, redlut,
            greenlut, bluelut, pImage, iw, ih, imaxcolr, iactualcolr,
            predlut, pgreenlut, pbluelut)
    retval = _fl_j2pass_quantize_packed(packed, iw, iw, imaxcolr, ci,
                iactualcolr, predlut, pgreenlut, pbluelut, pImage)
    return retval


def fl_j2pass_quantize_rgb(red, green, blue, w, h, maxcolr, ci, actualcolr,
                        redlut, greenlut, bluelut, pImage):
    """fl_j2pass_quantize_rgb(red, green, blue, w, h, maxcolr, ci,
    actualcolr, redlut, greenlut, bluelut, pImage)
    
    *todo*

    Parameters
    ----------
        red : *todo*
            *todo*
        green : *todo*
            *todo*
        blue : *todo*
            *todo*
        w : int
            *todo*
        h : int
            *todo*
        maxcolr : int
            *todo*
        ci : *todo*
            *todo*
        actualcolr : int
            *todo*
        redlut : int
            *todo*
        greenlut : int
            *todo*
        bluelut : int
            *todo*
        pImage : pointer to xfdata.FL_IMAGE
            image

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_j2pass_quantize_rgb = library.cfuncproto(
        library.load_so_libflimage(), "fl_j2pass_quantize_rgb",
        cty.c_int, [cty.POINTER(cty.POINTER(cty.c_ubyte)),
        cty.POINTER(cty.POINTER(cty.c_ubyte)),
        cty.POINTER(cty.POINTER(cty.c_ubyte)), cty.c_int, cty.c_int,
        cty.c_int, cty.POINTER(cty.POINTER(cty.c_ushort)),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(xfdata.FL_IMAGE)],
        """int fl_j2pass_quantize_rgb(unsigned char * * p1,
           unsigned char * * p2, unsigned char * * p3, int p4, int p5,
           int p6, short unsigned int * * p7, int * p8, int * p9,
           int * p10, int * p11, FL_IMAGE * p12)""")
    library.check_if_initialized()
    # red to be handled
    # green to be handled
    # blue to be handled
    iw = library.convert_to_int(w)
    ih = library.convert_to_int(h)
    imaxcolr = library.convert_to_int(maxcolr)
    # ci to be handled
    iactualcolr = library.convert_to_int(actualcolr)
    predlut = cty.cast(redlut, cty.POINTER(cty.c_int))
    pgreenlut = cty.cast(greenlut, cty.POINTER(cty.c_int))
    pbluelut = cty.cast(bluelut, cty.POINTER(cty.c_int))
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(red, green, blue, w, h, maxcolr, ci, actualcolr,
                redlut, greenlut, bluelut, pImage, iw, ih, imaxcolr,
                iactualcolr, predlut, pgreenlut, pbluelut)
    retval = _fl_j2pass_quantize_rgb(red, green, blue, iw, iw, imaxcolr, ci,
                        iactualcolr, predlut, pgreenlut, pbluelut, pImage)
    return retval


def fl_make_submatrix(inmtrx, nrows, ncols, r1, c1, rs, cs, elemsize):
    """fl_make_submatrix(inmtrx, nrows, ncols, r1, c1, rs, cs, elemsize)
    
    *todo*

    Parameters
    ----------
        inmtrx : *todo*
            image matrix
        nrows : int
            number of rows
        ncols : int
            number of columns
        r1 : int
            initial row?
        c1 : int
            initial column?
        rs : int
            final row?
        cs : int
            final column?
        elemsize : int_pos
            size of matrix in bytes

    Returns
    -------
        num : *todo*
            a matrix?

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_make_submatrix = library.cfuncproto(
        library.load_so_libflimage(), "fl_make_submatrix",
        cty.c_void_p, [cty.c_void_p, cty.c_int, cty.c_int, cty.c_int,
        cty.c_int, cty.c_int, cty.c_int, cty.c_uint],
        """void * fl_make_submatrix(void * p1, int p2, int p3, int p4,
           int p5, int p6, int p7, unsigned int p8)""")
    library.check_if_initialized()
    # inmtrx has to be handled
    inrows = library.convert_to_int(nrows)
    incols = library.convert_to_int(ncols)
    ir1 = library.convert_to_int(r1)
    ic1 = library.convert_to_int(c1)
    irs = library.convert_to_int(rs)
    ics = library.convert_to_int(cs)
    uielemsize = library.convert_to_uint(elemsize)
    library.keep_elem_refs(inmtrx, nrows, ncols, r1, c1, rs, cs, elemsize,
            inrows, incols, ir1, ic1, irs, ics, uielemsize)
    retval = _fl_make_submatrix(inmtrx, inrows, incols, ir1, ic1, irs, ics, \
                                uielemsize)
    return retval


def fl_pack_bits(inval, lng):
    """fl_pack_bits(inval, lng)
    
    Packs color index (0 or 1) into bytes.

    Parameters
    ----------
        inval : short_pos
            input value to be packed
        lng : int
            number of indexes

    Returns
    -------
        outval : byte_pos
            output value after packing

    Examples
    --------
        >>> *todo*

    API_diversion
    ----------
        API changed from XForms, upstream was
        fl_pack_bits(outval, inval, lng)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _fl_pack_bits = library.cfuncproto(
        library.load_so_libflimage(), "fl_pack_bits",
        None, [cty.POINTER(cty.c_ubyte), cty.POINTER(cty.c_ushort), cty.c_int],
        """void fl_pack_bits(unsigned char * p1, short unsigned int * p2,
           int p3)""")
    library.check_if_initialized()
    uboutval, poutval = library.make_ubyte_and_pointer()
    uiinval = library.convert_to_uint(inval)
    puiinval = cty.cast(uiinval, cty.POINTER(cty.c_uint))
    ilng = library.convert_to_int(lng)
    library.keep_elem_refs(uboutval, poutval, inval, uiinval, puiinval, lng, ilng)
    _fl_pack_bits(poutval, puiinval, ilng)
    return uboutval.value


def fl_unpack_bits(inval, lng):
    """fl_unpack_bits(inval, lng)
    
    Unpacks packed bits into color indexes (0 or 1).

    Parameters
    ----------
        inval : byte_pos
            input value to be unpacked
        lng : int
            length of packed bytes.

    Returns
    -------
        outval : short_pos
            output value after unpacking

    Examples
    --------
        >>> *todo*

    API_diversion
    ----------
        API changed from XForms, upstream was
        fl_unpack_bits(outval, inval, lng)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
    
    """
    _fl_unpack_bits = library.cfuncproto(
        library.load_so_libflimage(), "fl_unpack_bits",
        None, [cty.POINTER(cty.c_ushort), cty.POINTER(cty.c_ubyte),
        cty.c_int],
        """void fl_unpack_bits(short unsigned int * p1,
           unsigned char * p2, int p3)""")
    library.check_if_initialized()
    usoutval, poutval = library.make_ushort_and_pointer()
    ubinval = library.convert_to_ubyte(inval)
    pubinval = cty.cast(ubinval, cty.POINTER(cty.c_ubyte))
    ilng = library.convert_to_int(lng)
    library.keep_elem_refs(usoutval, poutval, inval, ubinval, pubinval, \
            lng, ilng)
    _fl_unpack_bits(poutval, pubinval, ilng)
    return usoutval.value


def fl_value_to_bits(val):
    """fl_value_to_bits(val)
    
    *todo*

    Parameters
    ----------
        val : int_pos
            value to convert to bits

    Returns
    -------
        num. : int_pos
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_value_to_bits = library.cfuncproto(
        library.load_so_libflimage(), "fl_value_to_bits",
        cty.c_uint, [cty.c_uint],
        """unsigned int fl_value_to_bits(unsigned int p1)""")
    library.check_if_initialized()
    uival = library.convert_to_uint(val)
    library.keep_elem_refs(val, uival)
    retval = _fl_value_to_bits(uival)
    return retval


def flimage_add_comments(pImage, text, lng):
    """flimage_add_comments(pImage, text, lng)
    
    Adds a comment to an image.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        text : str
            comment to be added
        lng : int
            length of comment

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_add_comments = library.cfuncproto(
        library.load_so_libflimage(), "flimage_add_comments",
        None, [cty.POINTER(xfdata.FL_IMAGE), xfdata.STRING, cty.c_int],
        """void flimage_add_comments(FL_IMAGE * p1, const char * p2,
           int p3)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    stext = library.convert_to_string(text)
    ilng = library.convert_to_int(lng)
    library.keep_elem_refs(pImage, text, lng, stext, ilng)
    _flimage_add_comments(pImage, stext, ilng)


def flimage_color_to_pixel(pImage, r, g, b):
    """flimage_color_to_pixel(pImage, r, g, b)
    
    Convert an RGB triple to a pixel.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        r : int
            value for red color
        g : int
            value for green color
        b : int
            value for blue color

    Returns
    -------
        pixid : long_pos
            pixel id
        pixel : int
            new pixel

    Examples
    --------
        >>> *todo*

    API_diversion
    ----------
        API changed from XForms, upstream was
        flimage_color_to_pixel(pImage, r, g, b, newpix)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_color_to_pixel = library.cfuncproto(
        library.load_so_libflimage(), "flimage_color_to_pixel",
        cty.c_ulong, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int,
        cty.c_int, cty.POINTER(cty.c_int)],
        """long unsigned int flimage_color_to_pixel(FL_IMAGE * p1,
               int p2, int p3, int p4, int * p5)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    ir = library.convert_to_int(r)
    ig = library.convert_to_int(g)
    ib = library.convert_to_int(b)
    inewpix, pnewpix = library.make_int_and_pointer()
    library.keep_elem_refs(pImage, r, g, b, ir, ig, ib, inewpix, pnewpix)
    retval = _flimage_color_to_pixel(pImage, ir, ig, ib, pnewpix)
    return retval, inewpix.value


def flimage_combine(pImage1, pImage2, alpha):
    """flimage_combine(pImage1, pImage2, alpha)
    
    Combines two images with alpha level?, returning a new image.

    Parameters
    ----------
        pImage1 : pointer to xfdata.FL_IMAGE
            first image to combine
        pImage2 : pointer to xfdata.FL_IMAGE
            second image to combine
        alpha : float
            alpha level?

    Returns
    -------
        pImage : pointer to xfdata.FL_IMAGE
            image class instance

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_combine = library.cfuncproto(
        library.load_so_libflimage(), "flimage_combine",
        cty.POINTER(xfdata.FL_IMAGE), [cty.POINTER(xfdata.FL_IMAGE),
        cty.POINTER(xfdata.FL_IMAGE), cty.c_double],
        """FL_IMAGE * flimage_combine(FL_IMAGE * p1, FL_IMAGE * p2,
           double p3)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage1)
    library.verify_flflimageptr_type(pImage2)
    falpha = library.convert_to_double(alpha)
    library.keep_elem_refs(pImage1, pImage2, alpha, falpha)
    retval = _flimage_combine(pImage1, pImage2, falpha)
    return retval


def flimage_display_markers(pImage):
    """flimage_display_markers(pImage)
    
    Displays markers added to an image.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> flimage_display_markers(pimg)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_display_markers = library.cfuncproto(
        library.load_so_libflimage(), "flimage_display_markers",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_display_markers(FL_IMAGE * p1)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    _flimage_display_markers(pImage)


def flimage_dup_(pImage, pix):
    """flimage_dup_(pImage, pix)
    
    Duplicates an image, with or without the pixels

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        pix : int
            pixel?

    Returns
    -------
        pImage : pointer to xfdata.FL_IMAGE
            image class instance

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_dup_ = library.cfuncproto(
        library.load_so_libflimage(), "flimage_dup_",
        cty.POINTER(xfdata.FL_IMAGE), [cty.POINTER(xfdata.FL_IMAGE),
        cty.c_int],
        """FL_IMAGE * flimage_dup_(FL_IMAGE * p1, int p2)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    ipix = library.convert_to_int(pix)
    library.keep_elem_refs(pImage, pix, ipix)
    retval = _flimage_dup_(pImage, ipix)
    return retval


def flimage_enable_bmp():
    """flimage_enable_bmp()
    
    Enables use of BMP (Windows/OS2 Bitmap) image format.

    Examples
    --------
        >>> flimage_enable_bmp()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_bmp = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_bmp",
        None, [],
        """void flimage_enable_bmp()""")
    library.check_if_initialized()
    _flimage_enable_bmp()


def flimage_enable_fits():
    """flimage_enable_fits()
    
    Enables use of NASA/NOTS standard FITS image format.

    Examples
    --------
        >>> flimage_enable_fits()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_fits = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_fits",
        None, [],
        """void flimage_enable_fits()""")
    _flimage_enable_fits()


# TODO: try to understand what kind of images is this one.
def flimage_enable_genesis():
    """flimage_enable_genesis()
    
    Enables use of Genesis image format.

    Examples
    --------
        >>> flimage_enable_genesis()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_genesis = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_genesis",
        None, [],
        """void flimage_enable_genesis()""")
    library.check_if_initialized()
    _flimage_enable_genesis()


def flimage_enable_gif():
    """flimage_enable_gif()
    
    Enables use of GIF (Compuserve Graphics Interchange format)
    image format.

    Examples
    --------
        >>> flimage_enable_gif()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_gif = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_gif",
        None, [],
        """void flimage_enable_gif()""")
    library.check_if_initialized()
    _flimage_enable_gif()


def flimage_enable_gzip():
    """flimage_enable_gzip()
    
    Enables use of gzip compression filter for images.

    Examples
    --------
        >>> flimage_enable_gzip()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_gzip = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_gzip",
        None, [],
        """void flimage_enable_gzip()""")
    library.check_if_initialized()
    _flimage_enable_gzip()


def flimage_enable_jpeg():
    """flimage_enable_jpeg()
    
    Enables use of JPEG/JFIF (Joint Photographic Experts Group) image
    format.

    Examples
    --------
        >>> flimage_enable_jpeg()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_jpeg = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_jpeg",
        None, [],
        """void flimage_enable_jpeg()""")
    library.check_if_initialized()
    _flimage_enable_jpeg()


def flimage_enable_png():
    """flimage_enable_png()
    
    Enables use of PNG (Portable Network Graphics) image format. It
    requires netpbm library to be installed.

    Examples
    --------
        >>> flimage_enable_png()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_png = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_png",
        None, [],
        """void flimage_enable_png()""")
    library.check_if_initialized()
    _flimage_enable_png()


def flimage_enable_ps():
    """flimage_enable_ps()
    
    Enables use of PS (Adobe PostScript) image format. It needs gs
    (ghostscript) for reading.

    Examples
    --------
        >>> flimage_enable_ps()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_ps = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_ps",
        None, [],
        """void flimage_enable_ps()""")
    library.check_if_initialized()
    _flimage_enable_ps()


def flimage_enable_sgi():
    """flimage_enable_sgi()
    
    Enables use of SGI (Silicon Graphics-Iris) image format. It requires
    pbmplus/netpbm library to be installed.

    Examples
    --------
        >>> flimage_enable_sgi()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_sgi = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_sgi",
        None, [],
        """void flimage_enable_sgi()""")
    library.check_if_initialized()
    _flimage_enable_sgi()


def flimage_enable_tiff():
    """flimage_enable_tiff()
    
    Enables use of TIFF (Tagged Image file, with no compression) image
    format.

    Examples
    --------
        >>> flimage_enable_tiff()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_tiff = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_tiff",
        None, [],
        """void flimage_enable_tiff()""")
    library.check_if_initialized()
    _flimage_enable_tiff()


def flimage_enable_xbm():
    """flimage_enable_xbm()
    
    Enables use of XBM (X Window Bitmap) image format.

    Examples
    --------
        >>> flimage_enable_xbm()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_xbm = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_xbm",
        None, [],
        """void flimage_enable_xbm()""")
    library.check_if_initialized()
    _flimage_enable_xbm()


def flimage_enable_xpm():
    """flimage_enable_xpm()
    
    Enables use of XPM3 (X Window PixMap) image format.

    Examples
    --------
        >>> flimage_enable_xpm()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_xpm = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_xpm",
        None, [],
        """void flimage_enable_xpm()""")
    library.check_if_initialized()
    _flimage_enable_xpm()


def flimage_enable_xwd():
    """flimage_enable_xwd()
    
    Enables use of XWD (X Window Dump) image format.

    Examples
    --------
        >>> flimage_enable_xwd()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_xwd = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_xwd",
        None, [],
        """void flimage_enable_xwd()""")
    library.check_if_initialized()
    _flimage_enable_xwd()


def flimage_free_ci(pImage):
    """flimage_free_ci(pImage)
    
    Frees an image of type xfdata.FL_IMAGE_CI?

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_free_ci = library.cfuncproto(
        library.load_so_libflimage(), "flimage_free_ci",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_free_ci(FL_IMAGE * p1)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    _flimage_free_ci(pImage)


def flimage_free_gray(pImage):
    """flimage_free_gray(pImage)
    
    Frees an image of type xfdata.FL_IMAGE_GRAY?.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_free_gray = library.cfuncproto(
        library.load_so_libflimage(), "flimage_free_gray",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_free_gray(FL_IMAGE * p1)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    _flimage_free_gray(pImage)


def flimage_free_linearlut(pImage):
    """flimage_free_linearlut(pImage)
    
    *todo*

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_free_linearlut = library.cfuncproto(
        library.load_so_libflimage(), "flimage_free_linearlut",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_free_linearlut(FL_IMAGE * p1)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    _flimage_free_linearlut(pImage)


def flimage_free_rgb(pImage):
    """flimage_free_rgb(pImage)
    
    Frees an image of type xfdata.FL_IMAGE_RGB?.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_free_rgb = library.cfuncproto(
        library.load_so_libflimage(), "flimage_free_rgb",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_free_rgb(FL_IMAGE * p1)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    _flimage_free_rgb(pImage)


def flimage_freemem(pImage):
    """flimage_freemem(pImage)
    
    Frees all allocated memory associated with the image.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_freemem = library.cfuncproto(
        library.load_so_libflimage(), "flimage_freemem",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_freemem(FL_IMAGE * p1)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    _flimage_freemem(pImage)


def flimage_get_closest_color_from_map(pImage, colr):
    """flimage_get_closest_color_from_map(pImage, colr)
    
    Gets closest color from color map?

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        colr : int_pos
            color to evaluate

    Returns
    -------
        colr : int
            color that is close?

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_get_closest_color_from_map = library.cfuncproto(
        library.load_so_libflimage(), "flimage_get_closest_color_from_map",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_uint],
        """int flimage_get_closest_color_from_map(FL_IMAGE * p1,
           unsigned int p2)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    uicolr = library.convert_to_uint(colr)
    library.keep_elem_refs(pImage, colr, uicolr)
    retval = _flimage_get_closest_color_from_map(pImage, uicolr)
    return retval


def flimage_get_linearlut(pImage):
    """flimage_get_linearlut(pImage)
    
    *todo*

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image

    Returns
    -------
        num : int
            num., or -1 (on failure?)

    Examples
    --------
        >>> flimage_get_linearlut(pimg)

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_get_linearlut = library.cfuncproto(
        library.load_so_libflimage(), "flimage_get_linearlut",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_get_linearlut(FL_IMAGE * p1)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    retval = _flimage_get_linearlut(pImage)
    return retval


def flimage_invalidate_pixels(pImage):
    """
    
    Invalidates/frees all other types of image, before we modify the
    current image.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_invalidate_pixels = library.cfuncproto(
        library.load_so_libflimage(), "flimage_invalidate_pixels",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_invalidate_pixels(FL_IMAGE * p1)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    _flimage_invalidate_pixels(pImage)


def flimage_open(fname):
    """flimage_open(fname)
    
    Opens an image file. Use flimage_read to read it.

    Parameters
    ----------
        fname : str
            name of file to open

    Returns
    -------
        pImage : pointer to xfdata.FL_IMAGE
            image class instance opened, or None (on failure)

    Examples
    --------
        pimg = flimage_open("something.ppm")

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_open = library.cfuncproto(
        library.load_so_libflimage(), "flimage_open",
        cty.POINTER(xfdata.FL_IMAGE), [xfdata.STRING],
        """FL_IMAGE * flimage_open(const char * p1)""")
    library.check_if_initialized()
    sfname = library.convert_to_string(fname)
    library.keep_elem_refs(fname, sfname)
    retval = _flimage_open(sfname)
    return retval


def flimage_read_annotation(pImage):
    """flimage_read_annotation(pImage)
    
    Reads annotation in the image?

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image

    Returns
    -------
        result : int
            0, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_read_annotation = library.cfuncproto(
        library.load_so_libflimage(), "flimage_read_annotation",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_read_annotation(FL_IMAGE * p1)""")
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    retval = _flimage_read_annotation(pImage)
    return retval


def flimage_replace_image(pImage, w, h, r, g, b):
    """flimage_replace_image(pImage, w, h, r, g, b)
    
    Replaces an image?

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        w : int
            width
        h : int
            heigth
        r : int
            value for red color
        g : int
            value for green color
        b : int
            value for blue color

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_replace_image = library.cfuncproto(
        library.load_so_libflimage(), "flimage_replace_image",
        None, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int,
        cty.c_void_p, cty.c_void_p, cty.c_void_p],
        """void flimage_replace_image(FL_IMAGE * p1, int p2, int p3,
           void * p4, void * p5, void * p6)""")
    library.check_if_initialized()
    iw = library.convert_to_int(w)
    ih = library.convert_to_int(h)
    pr = cty.cast(r, cty.c_void_p)
    pg = cty.cast(g, cty.c_void_p)
    pb = cty.cast(b, cty.c_void_p)
    library.keep_elem_refs(pImage, w, h, r, g, b, iw, ih, pr, pg, pb)
    _flimage_replace_image(pImage, iw, ih, pr, pg, pb)


def flimage_swapbuffer(pImage):
    """flimage_swapbuffer(pImage)
    
    Swaps buffer of an image?

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image

    Returns
    -------
        num. : int
            0?

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_swapbuffer = library.cfuncproto(
        library.load_so_libflimage(), "flimage_swapbuffer",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_swapbuffer(FL_IMAGE * p1) """)
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    retval = _flimage_swapbuffer(pImage)
    return retval


def flimage_to_ximage(pImage, win, pXWindowAttributes):
    """flimage_to_ximage(pImage, win, pXWindowAttributes)
    
    Converts an FL_IMAGE into an XImage.

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image
        win : window id
            long_pos
        pXWindowAttributes : pointer to xfdata.XWindowAttributes
            class instance

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_to_ximage = library.cfuncproto(
        library.load_so_libflimage(), "flimage_to_ximage",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.FL_WINDOW,
        cty.POINTER(xfdata.XWindowAttributes)],
        """int flimage_to_ximage(FL_IMAGE * p1, FL_WINDOW p2,
           XWindowAttributes * p3) """)
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    ulwin = library.convert_to_Window(win)
    library.verify_otherclassptr_type(pXWindowAttributes, cty.POINTER( \
            xfdata.XWindowAttributes))
    library.keep_elem_refs(pImage, win, pXWindowAttributes, ulwin)
    retval = _flimage_to_ximage(pImage, ulwin, pXWindowAttributes)
    return retval


def flimage_write_annotation(pImage):
    """flimage_write_annotation(pImage)
    
    Writes annotation in the image?

    Parameters
    ----------
        pImage : pointer to xfdata.FL_IMAGE
            image

    Returns
    -------
        num. : int
            0, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_write_annotation = library.cfuncproto(
        library.load_so_libflimage(), "flimage_write_annotation",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_write_annotation(FL_IMAGE * p1) """)
    library.check_if_initialized()
    library.verify_flflimageptr_type(pImage)
    library.keep_elem_refs(pImage)
    retval = _flimage_write_annotation(pImage)
    return retval

