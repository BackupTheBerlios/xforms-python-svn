#!/usr/bin/env python
# -*- coding: iso8859-1 -*-

""" xforms-python's functions to manage image objects.

    Copyright (C) 2009, 2010  Luca Lazzaroni "LukenShiro"
    e-mail: <lukenshiro@ngi.it>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, version 2.1 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU LGPL along with this
    program. If not, see <http://www.gnu.org/licenses/>.

    See CREDITS file to read acknowledgements and thanks to XForms,
    ctypes and other developers.
"""


# originally generated by 'h2xml+gccxml' and 'xml2py'
# then heavily reordered and reworked

# ############################################# #
# Interface to XForms shared object libraries   #
# ############################################# #


import ctypes as cty
from xformslib import library as libr
from xformslib import xfdata


#########################
# flimage.h
# Image related routines
#########################

# fl_safe_free function placeholder (low-level)


def FL_RGB2GRAY(r, g, b):
    uir = libr.convert_to_uint(r)
    uig = libr.convert_to_uint(g)
    uib = libr.convert_to_uint(b)
    return ((78 * (uir) + 150 * (uig) + 28 * (uib)) >> 8)   # cty.c_uint


# if PCBITS is not 8, we need to apply the RGBmask

def FL_IsRGB(pImage):
    libr.verify_flflimageptr_type(pImage)
    return (pImage.contents.type == xfdata.FL_IMAGE_RGB)


def FL_IsPacked(pImage):
    libr.verify_flflimageptr_type(pImage)
    return (pImage.contents.type == xfdata.FL_IMAGE_PACKED)


def flimage_setup(pImageSetup):
    """Sets up and configures image objects support and initializes
    xfdata.FLIMAGE_SETUP class instance.

    --

    :Parameters:
      `pImageSetup` : pointer to xfdata.FLIMAGE_SETUP
        imagesetup class instance


    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_setup = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_setup",
        None, [cty.POINTER(xfdata.FLIMAGE_SETUP)],
        """void flimage_setup(FLIMAGE_SETUP * setup)""")
    libr.check_if_initialized()
    libr.verify_otherclassptr_type(pImageSetup, cty.POINTER( \
                                     xfdata.FLIMAGE_SETUP))
    libr.keep_elem_refs(pImageSetup)
    _flimage_setup(pImageSetup)


# basic IO routines

def flimage_load(fname):
    """Reads an image file.

    --

    :Parameters:
        `fname` : str
          name of image file to load

    :return: an image class instance (pImage), or None (on failure)
    :rtype: pointer to xfdata.FL_IMAGE

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_load = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_load",
        cty.POINTER(xfdata.FL_IMAGE), [xfdata.STRING],
        """FL_IMAGE * flimage_load(const char * file)""")
    libr.check_if_initialized()
    sfname = libr.convert_to_string(fname)
    libr.keep_elem_refs(fname, sfname)
    retval = _flimage_load(sfname)
    return retval


def flimage_read(pImage):
    """Takes a xfdata.FL_IMAGE class instance returned by flimage_open() and
    fills the image structure.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image class instance

    :return: an image class instance (pImage), or None (on failure)
    :rtype: pointer to xfdata.FL_IMAGE

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_read = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_read",
        cty.POINTER(xfdata.FL_IMAGE), [cty.POINTER(xfdata.FL_IMAGE)],
        """FL_IMAGE * flimage_read(FL_IMAGE * im)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    retval = _flimage_read(pImage)
    return retval


def flimage_dump(pImage, fname, fmt):
    """Takes an image, either returned by flimage_load() (possibly after some
    processing) or created on the fly by the application, attempts to create
    a file to store the image.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image class instance
      `fname` : str
        name of file to be saved
      `fmt` : str
        formal name or short name of a supported image format. Values: jpeg,
        ppm, gif, bmp, etc... or some other formats the application knows
        how to write. If it is 'None', the original format the image was in
        is used.

    :return: non-negative, or negative num. (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_dump = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_dump",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.STRING,
        xfdata.STRING],
        """int flimage_dump(FL_IMAGE * p1, const char * p2,
           const char * p3)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    sfname = libr.convert_to_string(fname)
    sfmt = libr.convert_to_string(fmt)
    libr.keep_elem_refs(pImage, fname, fmt, sfname, sfmt)
    retval = _flimage_dump(pImage, sfname, sfmt)
    return retval


def flimage_close(pImage):
    """Closes all file streams used to create the image.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
         image to be closed

    :return: 0?, or -1 (on failure)
    :rtype: int

    :note: e.g. flimage_close(pimg)

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_close = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_close",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_close(FL_IMAGE * p1)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    retval = _flimage_close(pImage)
    return retval


# TODO: not sure if it's necessary in python, low-level only?
def flimage_alloc():
    """Creates an image structure whose dynamically allocated memory is
    properly initialized, and returning it.

    --

    :return: image class instance (pImage)
    :rtype: pointer to xfdata.FL_IMAGE

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_alloc = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_alloc",
        cty.POINTER(xfdata.FL_IMAGE), [],
        """FL_IMAGE * flimage_alloc()""")
    libr.check_if_initialized()
    retval = _flimage_alloc()
    return retval


def flimage_getmem(pImage):
    """Allocates the proper amount of memory appropriate for the image type,
    including colormaps when needed.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_getmem = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_getmem",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_getmem(FL_IMAGE * p1)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    retval = _flimage_getmem(pImage)
    return retval


def flimage_is_supported(fname):
    """Finds out if a specific file is a known image file or not.

    --

    :Parameters:
      `fname` : str
        name of file to be evaluated

    :return: 1 (if it's a known image file), or 0 (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_is_supported = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_is_supported",
        cty.c_int, [xfdata.STRING],
        """int flimage_is_supported(const char * p1)""")
    libr.check_if_initialized()
    sfname = libr.convert_to_string(fname)
    libr.keep_elem_refs(fname, sfname)
    retval = _flimage_is_supported(sfname)
    return retval


def flimage_description_via_filter(pImage, cmds, what, verbose):
    """Adds a description to be used with flimage_add_format() to add image
    formats via an external filter's command.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `cmds` : str?
        a list of shell commands (filters) that convert the format in
        question into one of the supported formats.
      `what` : str
        text for reporting purpose
      `verbose` : int
        controls if some information and error messages should be printed
        (mainly for debugging purpose). Values 0 (to disable) or 1 (to enable)

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_description_via_filter = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_description_via_filter",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER(xfdata.STRING),
        xfdata.STRING, cty.c_int],
        """int flimage_description_via_filter(FL_IMAGE * im, char *const
           *cmds, const char *what, int verbose)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    scmds = libr.convert_to_string(cmds)                # to be verified
    swhat = libr.convert_to_string(what)
    iverbose = libr.convert_to_int(verbose)
    libr.keep_elem_refs(pImage, cmds, swhat, verbose, scmds, swhat, iverbose)
    retval = _flimage_description_via_filter(pImage, scmds, swhat, iverbose)
    return retval


def flimage_write_via_filter(pImage, cmds, formats, verbose):
    """Uses external filters to add image formats, in order to convert
    an unsupported format into one that is. pbmplus or netpbm are excellent
    packages for this purpose.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `cmds` : str?
        a list of shell commands (filters) that convert the format in
        question into one of the supported formats.
      `formats` : str?
        list of strings. Values ppm, pgm, pbm, .. etc..
      `verbose` : int
        controls if some information and error messages should be printed
        (mainly for debugging purpose). Values 0 (to disable) or 1 (to enable)

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_write_via_filter = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_write_via_filter",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER(xfdata.STRING),
        cty.POINTER(xfdata.STRING), cty.c_int],
        """int flimage_write_via_filter(FL_IMAGE * p1, const * char * cmds,
           const char * formats[], int verbose)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    # cmds to be handled
    sformats = libr.convert_to_string(formats)
    iverbose = libr.convert_to_int(verbose)
    libr.keep_elem_refs(pImage, cmds, formats, sformats, verbose, iverbose)
    retval = _flimage_write_via_filter(pImage, cmds, sformats, iverbose)
    return retval


def flimage_free(pImage):
    """ Frees all memory allocated for the image, then the image structure
    itself. After the function returns, the image should not be referenced.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_free = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_free",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_free(FL_IMAGE * p1)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    _flimage_free(pImage)


def flimage_display(pImage, win):
    """Displays a single or multiple images in a window.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `win` : long_pos
        window

    :return: non-negative num., or negative num. (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_display = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_display",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.Window],
        """int flimage_display(FL_IMAGE * p1, Window p2)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    ulwin = libr.convert_to_Window(win)
    libr.keep_elem_refs(pImage, win, ulwin)
    retval = _flimage_display(pImage, ulwin)
    return retval


def flimage_sdisplay(pImage, win):
    """Displays a single image in a window.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `win` : long_pos
        window

    :return: non-negative num., or negative num. (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_sdisplay = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_sdisplay",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.Window],
        """int flimage_sdisplay(FL_IMAGE * p1, Window p2)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    ulwin = libr.convert_to_Window(win)
    libr.keep_elem_refs(pImage, win, ulwin)
    retval = _flimage_sdisplay(pImage, ulwin)
    return retval


def flimage_convert(pImage, newtype, ncolors):
    """Convert an image to a new type. Depending on which quantization
    function is used, the number of quantized colors may not be more than 256.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `newtype` : int
        one of supported image type to convert to. Values (from xfdata.py)
        FL_IMAGE_NONE, FL_IMAGE_MONO, FL_IMAGE_GRAY, FL_IMAGE_CI, FL_IMAGE_RGB,
        FL_IMAGE_PACKED, FL_IMAGE_GRAY16, FL_IMAGE_RGB16, FL_IMAGE_FLEX
      `ncolors` : int
        number of colors to generate. It makes sense only when newtype is
        xfdata.FL_IMAGE_CI.

    :return: non-negative num., or negative num. (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_convert = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_convert",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int],
        """int flimage_convert(FL_IMAGE * p1, int p2, int p3)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.check_admitted_value_in_list(newtype, xfdata.FLIMAGETYPE_list)
    inewtype = libr.convert_to_int(newtype)
    incolors = libr.convert_to_int(ncolors)
    libr.keep_elem_refs(pImage, newtype, ncolors, inewtype, incolors)
    retval = _flimage_convert(pImage, inewtype, incolors)
    return retval


def flimage_type_name(imagetype):
    """Obtains the image type name in string format, e.g., for reporting
    purposes.

    --

    :Parameters:
      `imagetype` : int
        type of image

    :return: name string
    :rtype: str

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_type_name = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_type_name",
        xfdata.STRING, [cty.c_int],
        """const char * flimage_type_name(int type)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(imagetype, xfdata.FLIMAGETYPE_list)
    iimagetype = libr.convert_to_int(imagetype)
    libr.keep_elem_refs(imagetype, iimagetype)
    retval = _flimage_type_name(iimagetype)
    return retval


def flimage_add_text(pImage, text, length, style, size, txtcolr, bgcolr,
                     nobk, tx, ty, rot):
    """Place text into the image, passing parameters individually. If text
    starts with character '@' a symbol is drawn.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `text` : str
        text string to be placed in image
      `length` : int
        length of text
      `style` : int
        label style. Values (from xfdata.py) FL_NORMAL_STYLE, FL_BOLD_STYLE,
        FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        label size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE
      `txtcolr` : int_pos
        color to use for text
      `bgcolr` : int_pos
        color to use for background (only if nobk is 0)
      `nobk` : int
        flag to enable/disable background. Values 0 (drawn with background)
        or 1 (text is drawn without a background)
      `tx` : float
        horizontal location of the text relative to the image origin. The
        location specified is the lower-right corner of the text.
      `ty` : float
        vertical location of the text relative to the image origin. The
        location specified is the lower-right corner of the text.
      `rot` : int
        rotation

    :return: current number of strings for the image
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_add_text = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_add_text",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.STRING, cty.c_int,
        cty.c_int, cty.c_int, cty.c_uint, cty.c_uint, cty.c_int,
        cty.c_double, cty.c_double, cty.c_int],
        """int flimage_add_text(FL_IMAGE * im, const char * str, int len,
           int style, int size, unsigned int tcol, unsigned int bcol,
           int tran, double tx, double ty, int rot)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    stext = libr.convert_to_string(text)
    ilength = libr.convert_to_int(length)
    istyle = libr.convert_to_int(style)
    isize = libr.convert_to_int(size)
    uitxtcolr = libr.convert_to_uint(txtcolr)
    uibgcolr = libr.convert_to_uint(bgcolr)
    inobk = libr.convert_to_int(nobk)
    ftx = libr.convert_to_double(tx)
    fty = libr.convert_to_double(ty)
    irot = libr.convert_to_int(rot)
    libr.keep_elem_refs(pImage, text, length, style, size, txtcolr, bgcolr,
                nobk, tx, ty, rot, stext, ilength, istyle, isize, uitxtcolr,
                uibgcolr, inobk, ftx, fty, irot)
    retval = _flimage_add_text(pImage, stext, ilength, istyle, isize,
                uitxtcolr, uibgcolr, inobk, ftx, fty, irot)
    return retval


def flimage_add_text_struct(pImage, pImageText):
    """Places text into the image, using xfdata.FLIMAGE_TEXT class instance.
    If text starts with character '@' a symbol is drawn.
    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `pImageText` : pointer to xfdata.FLIMAGE_TEXT
        flimagetext class instance

    :return: current number of strings for the image
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_add_text_struct = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_add_text_struct",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE),
        cty.POINTER(xfdata.FLIMAGE_TEXT)],
        """int flimage_add_text_struct(FL_IMAGE * p1, const char * p2)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.verify_otherclassptr_type(pImageText, cty.POINTER( \
                                   xfdata.FLIMAGE_TEXT))
    libr.keep_elem_refs(pImage, pImageText)
    retval = _flimage_add_text_struct(pImage, pImageText)
    return retval


def flimage_delete_all_text(pImage):
    """Deletes all the texts you added to an image.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_delete_all_text = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_delete_all_text",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_delete_all_text(FL_IMAGE * p1)""")
    libr.check_if_initialized()
    libr.keep_elem_refs(pImage)
    _flimage_delete_all_text(pImage)


def flimage_add_marker(pImage, name, x, y, w, h, style, fill, rot, \
                       colr, bcolr):
    """Adds simple markers (arrows, circles etc) to an image, passing
    parameters individually.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `name` : str
        marker name *todo*
      `x` : float
        horizontal position of the center of the marker in physical
        coordinates relative to the origin of the image
      `y` : float
        vertical position of the center of the marker in physical
        coordinates relative to the origin of the image
      `w` : float
        width of the bounding box of the marker in physical coordinates
      `h` : float
        height of the bounding box of the marker in physical coordinates
      `style` : int
        style of the line to draw. Values (from xfdata.py) FL_SOLID,
        FL_USERDASH, FL_USERDOUBLEDASH, FL_DOT, FL_DOTDASH, FL_DASH,
        FL_LONGDASH
      `fill` : int
        flag if the marker should be filled or not. Values 1 (filled) or 0
        (not filled)
      `rot` : int
        angle of rotation in tenth of degree
      `colr` : long_pos
        color of the marker (in packed RGB format)
      `bcolr` : long_pos
        currently unused

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_add_marker = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_add_marker",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.STRING, cty.c_double,
        cty.c_double, cty.c_double, cty.c_double, cty.c_int, cty.c_int,
        cty.c_int, xfdata.FL_COLOR, xfdata.FL_COLOR],
        """int flimage_add_marker(FL_IMAGE * p1, const char * p2,
           double p3, double p4, double p5, double p6, int p7,
           int p8, int p9, FL_COLOR p10, FL_COLOR p11)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.check_admitted_value_in_list(style, xfdata.LINESTYLE_list)
    sname = libr.convert_to_string(name)
    fx = libr.convert_to_double(x)
    fy = libr.convert_to_double(y)
    fw = libr.convert_to_double(w)
    fh = libr.convert_to_double(h)
    istyle = libr.convert_to_int(style)
    ifill = libr.convert_to_int(fill)
    irot = libr.convert_to_int(rot)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    ulbcolr = libr.convert_to_FL_COLOR(bcolr)
    libr.keep_elem_refs(pImage, name, x, y, w, h, style, fill, rot, ulcolr,
            ulbcolr, sname, fx, fy, fw, fh, istyle, ifill, irot, ulcolr,
            ulbcolr)
    retval = _flimage_add_marker(pImage, sname, fx, fy, fw, fh, istyle,
                                 ifill, irot, ulcolr, ulbcolr)
    return retval


def flimage_add_marker_struct(pImage, pImageMarker):
    """Adds simple markers (arrows, circles etc) to an image, using
    xfdata.FLIMAGE_MARKER class instance.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `pImageMarker` : pointer to xfdata.FLIMAGE_MARKER
        flimagemarker class instance

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_add_marker_struct = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_add_marker_struct",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER( \
        xfdata.FLIMAGE_MARKER)],
        """int flimage_add_marker_struct(FL_IMAGE * p1, const char * p2)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.verify_otherclassptr_type(pImageMarker, cty.POINTER( \
                                            xfdata.FL_IMAGE))
    libr.keep_elem_refs(pImage, pImageMarker)
    retval = _flimage_add_marker_struct(pImage, pImageMarker)
    return retval


def flimage_define_marker(mkname, py_FlimageMarkerDraw, psdraw):
    """Defines a custom marker, using a specific function for drawing it.

    --

    :Parameters:
      `mkname` : str
        name of the marker *todo*
      `py_FlimageMarkerDraw` : python function to draw marker, no return?
        name referring to function(pImageMarker)
      `psdraw` : str
        string that draws a marker in a square with the corner coordinates
        (-1, -1), (-1, 1), (1, 1) and (1, -1) in PostScript. e.g. the rectangle
        marker has the following psdraw string: "-1 -1 moveto -1  1 lineto
        1  1 lineto  1 -1 lineto  closepath"

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    # cfunc_none_flimagemarker = cty.CFUNCTYPE(None, cty.POINTER( \
    #   xfdata.FLIMAGE_MARKER))
    _flimage_define_marker = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_define_marker",
        cty.c_int, [xfdata.STRING, xfdata.cfunc_none_flimagemarker,
        xfdata.STRING],
        """int flimage_define_marker(const char *, void ( * )
           (FLIMAGE_MARKER *), const char *)""")
    smkname = libr.convert_to_string(mkname)
    spsdraw = libr.convert_to_string(psdraw)
    c_FlimageMarkerDraw = xfdata.cfunc_none_flimagemarker(py_FlimageMarkerDraw)
    libr.keep_elem_refs(mkname, psdraw, smkname, spsdraw)
    libr.keep_cfunc_refs(c_FlimageMarkerDraw, py_FlimageMarkerDraw)
    retval = _flimage_define_marker(smkname, c_FlimageMarkerDraw, spsdraw)
    return retval


def flimage_delete_all_markers(pImage):
    """Deletes all markers added to an image

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_delete_all_markers = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_delete_all_markers",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_delete_all_markers(FL_IMAGE * p1)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    _flimage_delete_all_markers(pImage)


def flimage_render_annotation(pImage, win):
    """Makes the annotations a part of the image pixel. By default annotations
    placed on the image are kept seperate from the image pixels themselves, as
    keeping the annotation seperate makes it possible to later edit the
    annotations, and typically the screen has a lower resolutions than other
    output devices (by keeping the annotations separate from the pixels makes
    it possible to obtain better image qualities when the annotations are
    rendered on higher-resolution devices, e.g. a PostScript printer). Note
    that during rendering the image type may change depending on the
    capabilities of win. Annotations that were kept separately are deleted.
    The image must have been displayed at least once prior to calling this
    function for it to work correctly.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `win` : long_pos
        window

    :return: num., or -1 (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_render_annotation = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_render_annotation",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.FL_WINDOW],
        """int flimage_render_annotation(FL_IMAGE * p1, FL_WINDOW p2)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    ulwin = libr.convert_to_Window(win)
    libr.keep_elem_refs(pImage, win, ulwin)
    retval = _flimage_render_annotation(pImage, ulwin)
    return retval


def flimage_error(pImage, text):
    """Calls the error message handler for an image.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image to be worked on
      `text` : str
        a brief message, such as "memory allocation failed" etc..

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_error = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_error",
        None, [cty.POINTER(xfdata.FL_IMAGE), xfdata.STRING],
        """void flimage_error(FL_IMAGE * p1, const char * p2)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    stext = libr.convert_to_Window(text)
    libr.keep_elem_refs(pImage, text, stext)
    _flimage_error(pImage, stext)


# built-in format supports

def flimage_enable_pnm():
    """Enables use of PNM (Portable anymap) image format

    --

    :note: e.g. flimage_enable_pnm()

    :status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_pnm = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_enable_pnm",
        None, [],
        """void flimage_enable_pnm()""")
    libr.check_if_initialized()
    _flimage_enable_pnm()


def flimage_set_fits_bits(nbits):
    """Sets the number of bit of a FITS image.

    --

    :Parameters:
      `nbits` : int
        number of bit to be set

    :return: old number of bit, or negative number (on failure)
    :rtype: int

    :note: e.g. flimage_set_fits_bits(16)

    :status: Tested + Doc + NoDemo = OK

    """
    _flimage_set_fits_bits = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_set_fits_bits",
        cty.c_int, [cty.c_int],
        """int flimage_set_fits_bits(int p1)""")
    libr.check_if_initialized()
    inbits = libr.convert_to_int(nbits)
    libr.keep_elem_refs(nbits, inbits)
    retval = _flimage_set_fits_bits(inbits)
    return retval


def flimage_jpeg_output_options(pImageJpegOption):
    """Sets quality and smoothing options of a JPEG image, using
    xfdata.FLIMAGE_JPEG_OPTION. The default quality factor for JPEG output
    is 75. In general, the higher the quality factor rhe better the image
    is, but the file size gets larger. The default smoothing factor is 0.

    --

    :Parameters:
      `pImageJpegOption` : pointer to xfdata.FLIMAGE_JPEG_OPTION
        flimage jpeg option class instance

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_jpeg_output_options = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_jpeg_output_options",
        None, [cty.POINTER(xfdata.FLIMAGE_JPEG_OPTION)],
        """void flimage_jpeg_output_options(FLIMAGE_JPEG_OPTION * p1)""")
    libr.check_if_initialized()
    libr.verify_otherclassptr_type(pImageJpegOption, cty.POINTER( \
                                    xfdata.FLIMAGE_JPEG_OPTION))
    libr.keep_elem_refs(pImageJpegOption)
    _flimage_jpeg_output_options(pImageJpegOption)


def flimage_pnm_output_options(rawformat):
    """Sets variant options for PNM (ppm, pgm and pbm) images.

    --

    :Parameters:
      `rawformat` : int
        flag of supported variants. Values 1 (binary raw format, default)
        or 0 (ASCII format). If the output image is of type
        xfdata.FL_IMAGE_GRAY16, it is always ASCII format

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_pnm_output_options = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_pnm_output_options",
        None, [cty.c_int],
        """void flimage_pnm_output_options(int p1)""")
    libr.check_if_initialized()
    irawformat = libr.convert_to_int(rawformat)
    libr.keep_elem_refs(rawformat, irawformat)
    _flimage_pnm_output_options(irawformat)


def flimage_gif_output_options(interlace):
    """Sets options of GIF images.

    --

    :Parameters:
      `interlace` : int
        flag if interlace is enabled/disabled. Values 1 (interlaced) or 0
        (not interlaced).

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_gif_output_options = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_gif_output_options",
        None, [cty.c_int],
        """void flimage_gif_output_options(int p1)""")
    libr.check_if_initialized()
    iinterlace = libr.convert_to_int(interlace)
    libr.keep_elem_refs(interlace, iinterlace)
    _flimage_gif_output_options(iinterlace)


def flimage_ps_options():
    """Sets reading and writing options for PostScript.

    --

    :return: flpscontrol class instance (pFlpsControl)
    :rtype: pointer to xfdata.FLPS_CONTROL

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_ps_options = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_ps_options",
        cty.POINTER(xfdata.FLPS_CONTROL), [],
        """FLPS_CONTROL * flimage_ps_options()""")
    libr.check_if_initialized()
    retval = _flimage_ps_options()
    return retval


flimage_jpeg_options = flimage_jpeg_output_options
flimage_pnm_options = flimage_pnm_output_options
flimage_gif_options = flimage_gif_output_options


def flimage_get_number_of_formats():
    """Obtains the number of currently supported image format.

    --

    :return: number of formats supported, for reading or writing or both
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_get_number_of_formats = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_get_number_of_formats",
        cty.c_int, [],
        """int flimage_get_number_of_formats()""")
    libr.check_if_initialized()
    retval = _flimage_get_number_of_formats()
    return retval


def flimage_get_format_info(nformat):
    """Obtains detailed information for each image format.

    --

    :Parameters:
      `nformat` : int
        number between 1 and the return value of
        flimage_get_number_of_formats()

    :return: ImageFormatInfo class instance
    :rtype: pointer to xfdata.FLIMAGE_FORMAT_INFO

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_get_format_info = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_get_format_info",
        cty.POINTER(xfdata.FLIMAGE_FORMAT_INFO), [cty.c_int],
        """const FLIMAGE_FORMAT_INFO * flimage_get_format_info(int p1)""")
    libr.check_if_initialized()
    informat = libr.convert_to_int(nformat)
    libr.keep_elem_refs(nformat, informat)
    retval = _flimage_get_format_info(informat)
    return retval


def fl_get_matrix(nrows, ncols, elemsize):
    """Creates a 2-dimensional array of entities of size elemsize. The array
    is of nrows by ncols in size.

    --

    :Parameters:
      `nrows` : int
        number of rows
      `ncols` : int
        number of columns
      `elemsize` : int_pos
        size of matrix in bytes

    :return: a matrix?
    :rtype: *todo*

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_get_matrix = libr.cfuncproto(
        libr.load_so_libflimage(), "fl_get_matrix",
        cty.c_void_p, [cty.c_int, cty.c_int, cty.c_uint],
        """void * fl_get_matrix(int p1, int p2, unsigned int p3)""")
    libr.check_if_initialized()
    inrows = libr.convert_to_int(nrows)
    incols = libr.convert_to_int(ncols)
    uielemsize = libr.convert_to_uint(elemsize)
    libr.keep_elem_refs(nrows, ncols, elemsize, inrows, incols, uielemsize)
    retval = _fl_get_matrix(inrows, incols, uielemsize)
    return retval


def fl_make_matrix(nrows, ncols, elemsize, mem):
    """Makes a matrix out of a given piece of memory.

    --

    :Parameters:
      `nrows` : int
        number of rows
      `ncols` : int
        number of columns
      `elemsize` : int_pos
        size of matrix in bytes
      `mem` : *todo*
        memory

    :return: *todo*
    :rtype: *todo*

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_make_matrix = libr.cfuncproto(
        libr.load_so_libflimage(), "fl_make_matrix",
        cty.c_void_p, [cty.c_int, cty.c_int, cty.c_uint, cty.c_void_p],
        """void * fl_make_matrix(int p1, int p2, unsigned int p3,
           void * p4)""")
    libr.check_if_initialized()
    inrows = libr.convert_to_int(nrows)
    incols = libr.convert_to_int(ncols)
    uielemsize = libr.convert_to_uint(elemsize)
    pmem = cty.cast(mem, cty.c_void_p)
    libr.keep_elem_refs(nrows, ncols, elemsize, mem, inrows, incols,
                        uielemsize, pmem)
    retval = _fl_make_matrix(inrows, incols, uielemsize, pmem)
    return retval


def fl_free_matrix(mtrx):
    """Frees a matrix allocated using fl_get_matrix() or fl_make_matrix().

    --

    :Parameters:
      `mtrx` : *todo*
        *todo*

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_free_matrix = libr.cfuncproto(
        libr.load_so_libflimage(), "fl_free_matrix",
        None, [cty.c_void_p],
        """void fl_free_matrix(void * p1)""")
    libr.check_if_initialized()
    pmtrx = cty.cast(mtrx, cty.c_void_p)
    libr.keep_elem_refs(mtrx, pmtrx)
    _fl_free_matrix(pmtrx)


# fl_init_RGBdatabase(text) function prototype (deprecated)


def fl_lookup_RGBcolor(colrname):
    """ *todo*

    --

    :Parameters:
      `colrname` : str
         text of color name

    :return: o or -1 (on failure), red value, green value, blue value
    :rtype: int, int, int, int

    :note: e.g. *todo*

    :attention: API change from XForms - upstream was
        fl_lookup_RGBcolor(text, r, g, b)

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_lookup_RGBcolor = libr.cfuncproto(
        libr.load_so_libflimage(), "fl_lookup_RGBcolor",
        cty.c_int, [xfdata.STRING, cty.POINTER(cty.c_int), \
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],
        """int fl_lookup_RGBcolor(const char * p1, int * p2,
           int * p3, int * p4)""")
    libr.check_if_initialized()
    scolrname = libr.convert_to_string(colrname)
    r, pr = libr.make_int_and_pointer()
    g, pg = libr.make_int_and_pointer()
    b, pb = libr.make_int_and_pointer()
    libr.keep_elem_refs(colrname, r, g, b, colrname, pr, pg, pb)
    retval = _fl_lookup_RGBcolor(scolrname, pr, pg, pb)
    return retval, r.value, g.value, b.value


def flimage_add_format(formalname, shortname, extension, imagetype,
        py_ImageIdentify, py_ImageDescription, py_ImageReadPixels,
        py_ImageWriteImage):
    """Adds the newly specified image format to a recognized image format
    pool in the library.

    --

    :Parameters:
      `formalname` : str
        the formal name of image format
      `shortname` : str
        an abbreviated name for the image format
      `extension` : str
        file extension. If it is None, shortname will be substituted
      `imagetype` : int
        The image type, generally one of the supported image types (e.g.
        xfdata.FL_IMAGE_RGB), but it does not have to. For image file formats
        that are capable of holding more than one type of images, this field
        can be set to indicate this by ORing the supported types together
        (e.g., xfdata.FL_IMAGE_RGB|FL_IMAGE_GRAY). However, when description
        returns, the image type should be set to the actual type in the file.
      `py_ImageIdentify` : function to identify format, returning value
        name referring to function(pFile) -> num.
        This function should return 1 if the file pointed to by the file
        pointer passed in is the expected image format (e.g by checking
        signature). It should return a negative number if the file is not
        recognized. The decision if the file pointer should be rewound or not
        is between this function and the description function.
      `py_ImageDescription` : function to set description, returning value
        name referring to function(pImage) -> num.
        This function in general should set the image dimension and type
        fields (and colormap length for color index images) if successful, so
        the driver can allocate the necessary memory for read pixel. Of
        course, if read_pixels elects to allocate memory itself, the
        description function does not have to set any fields. However, if
        reading should continue, the function should return 1 otherwise a
        negative number.
      `py_ImageReadPixels` : python function to read pixels, returning value
        name referring to function(pImage) -> num.
        This function reads the pixels from the file and fills one of the
        pixel matrix in the image structure depending on the type. If reading
        is successful, a non-negative number should be returned otherwise a
        negative number should be returned. Upon entry,
        pImage.contents.completed is set to zero. The function should not
        close the file.
      `py_ImageWriteImage` : python function to write image, returning value
        name referring to function(pImage) -> num.
        This function takes an image structure and should write the image out
        in a format it knows. Prior to calling this routine, the driver will
        have already converted the image type to the type it wants. The
        function should return 1 on success and a negative number otherwise.
        If only reading of the image format is supported this parameter can
        be set to None. The function should write to file stream
        pImage.contents.fpout.

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    #FLIMAGE_Identify = cty.CFUNCTYPE(cty.c_int, cty.POINTER(xfdata.FILE))
    #FLIMAGE_Description = cty.CFUNCTYPE(cty.c_int, cty.POINTER( \
    #    xfdata.FL_IMAGE))
    #FLIMAGE_Read_Pixels = cty.CFUNCTYPE(cty.c_int, cty.POINTER( \
    #    xfdata.FL_IMAGE))
    #FLIMAGE_Write_Image = cty.CFUNCTYPE(cty.c_int, cty.POINTER( \
    #    xfdata.FL_IMAGE))
    _flimage_add_format = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_add_format",
        cty.c_int, [xfdata.STRING, xfdata.STRING, xfdata.STRING, cty.c_int,
        xfdata.FLIMAGE_Identify, xfdata.FLIMAGE_Description,
        xfdata.FLIMAGE_Read_Pixels, xfdata.FLIMAGE_Write_Image],
        """int flimage_add_format(const char * p1, const char * p2,
           const char * p3, int p4, FLIMAGE_Identify p5,
           FLIMAGE_Description p6, FLIMAGE_Read_Pixels p7,
           FLIMAGE_Write_Image p8)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(imagetype, xfdata.FLIMAGETYPE_list)
    sformalname = libr.convert_to_string(formalname)
    sshortname = libr.convert_to_string(shortname)
    sextension = libr.convert_to_string(extension)
    iimagetype = libr.convert_to_int(imagetype)
    c_ImageIdentify = xfdata.FLIMAGE_Identify(py_ImageIdentify)
    c_ImageDescription = xfdata.FLIMAGE_Description(py_ImageDescription)
    c_ImageReadPixels = xfdata.FLIMAGE_Read_Pixels(py_ImageReadPixels)
    c_ImageWriteImage = xfdata.FLIMAGE_Write_Image(py_ImageWriteImage)
    libr.keep_cfunc_refs(c_ImageIdentify, py_ImageIdentify,
            c_ImageDescription, py_ImageDescription, c_ImageReadPixels,
            py_ImageReadPixels, c_ImageWriteImage, py_ImageWriteImage)
    libr.keep_elem_refs(formalname, shortname, extension, imagetype, \
                   sformalname, sshortname, sextension, iimagetype)
    retval = _flimage_add_format(sformalname, sshortname, sextension, \
                    iimagetype, c_ImageIdentify, c_ImageDescription, \
                    c_ImageReadPixels, c_ImageWriteImage)
    return retval


def flimage_set_annotation_support(in_, yesno):
    """Set support for annotations.

    --

    :Parameters:
      `in_` : int
        image number?. Values between 0 and number of images?
      `yesno` : int
       flag to enable/disable support. Values 1 (to enable) or 0 (to disable)

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_set_annotation_support = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_set_annotation_support",
        None, [cty.c_int, cty.c_int],
        """void flimage_set_annotation_support(int p1, int p2)""")
    libr.check_if_initialized()
    iin_ = libr.convert_to_int(in_)
    iyesno = libr.convert_to_int(yesno)
    libr.keep_elem_refs(in_, yesno, iin_, iyesno)
    _flimage_set_annotation_support(iin_, iyesno)


def flimage_getcolormap(pImage):
    """Obtains color map for an image

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :return: 0, or -1 (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_getcolormap = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_getcolormap",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_getcolormap(FL_IMAGE * p1)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    retval = _flimage_getcolormap(pImage)
    return retval


def fl_select_mediancut_quantizer():
    """Selects median cut quantizer, who uses Heckbert's median cut algorithm
    followed by Floyd-Steinberg dithering after which the pixels are mapped
    to the colors selected. This tends to give better images because of the
    dithering step. However, in this particular implementation, the number
    of quantized colors is limited to 256. Color quantization is one way of
    reduce the number of colors in the original image to display a RGB image
    on a color-mapped device of limited depth.

    --

    :note: e.g. flimage_select_mediancut_quantizer()

    :status: Tested + Doc + NoDemo = NOT OK

    """
    _fl_select_mediancut_quantizer = libr.cfuncproto(
        libr.load_so_libflimage(), "fl_select_mediancut_quantizer",
        None, [],
        """void fl_select_mediancut_quantizer()""")
    libr.check_if_initialized()
    _fl_select_mediancut_quantizer()


# simple image processing routines

def flimage_convolve(pImage, kernel, krows, kcols):
    """Takes a convolution kernel of krows by kcols and convolves it with
    the image. The result replaces the input image.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `kernel` : *todo*
        The kernel size should be odd, and should be allocated by
        fl_get_matrix(). *todo*
      `krows` : int
        number of kernel rows
      `kcols` : int
        number of kernel cols

    :return: positive num., or negative num (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_convolve = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_convolve",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE),
        cty.POINTER(cty.POINTER(cty.c_int)), cty.c_int, cty.c_int],
        """int flimage_convolve(FL_IMAGE * p1, int * * p2, int p3,
           int p4)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    ikrows = libr.convert_to_int(krows)
    ikcols = libr.convert_to_int(kcols)
    libr.keep_elem_refs(pImage, kernel, krows, kcols, ikrows, ikcols)
    retval = _flimage_convolve(pImage, kernel, ikrows, ikcols)
    return retval


def flimage_convolvea(pImage, kernel, krow, kcol):
    """Takes a convolution kernel of krow by kcol and convolves it with
    the image. The result replaces the input image. It uses a kernel that's a
    C 2-dimensional array (cast to a pointer to int).

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `kernel` : *todo*
        C 2-dimensional array *todo*
      `krow` : int
        number of kernel rows
      `kcol` : int
        number of kernel columns

    :return: positive num., or negative num (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_convolvea = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_convolvea",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER(cty.c_int),
        cty.c_int, cty.c_int],
        """int flimage_convolvea(FL_IMAGE * p1, int * p2, int p3, int p4)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    pkernel = cty.cast(kernel, cty.POINTER(cty.c_int))
    ikrow = libr.convert_to_int(krow)
    ikcol = libr.convert_to_int(kcol)
    libr.keep_elem_refs(pImage, kernel, krow, kcol, pkernel, ikrow, ikcol)
    retval = _flimage_convolvea(pImage, pkernel, krow, kcol)
    return retval


def flimage_tint(pImage, packed, opacity):
    """Emulates the effect of looking at an image through a piece of colored
    glass. Tint is most useful in cases where you want to put some annotations
    on the image, but do not want to use a uniform and opaque background that
    completely obscures the image behind. By using tint, you can have a
    background that provides some contrast to the text, yet not obscures the
    image beneath completely. Tint operation uses the subimage settings.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `packed` : int_pos
        packed RGB color, specifying the color of the glass.
      `opacity` : float
        how much the color of the image is absorbed by the glass. Values
        between 0 (the glass is totally transparent, i.e. the glass has no
        effect) and 1.0 (total opaqueness, i.e. all you see is the color of
        the glass. Any value between these two extremes results in a color
        that is a combination of the pixel color and the glass color.

    :return: num.
    :rtype: int

    :note: e.g. pkdcolr = flxbasic.FL_PACK3(20, 30, 40)
    :note: e.g. exval = flimage_tint(pimg, pkdcolr, 0.5)

    :status: Tested + Doc + NoDemo = OK

    """
    _flimage_tint = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_tint",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_uint, cty.c_double],
        """int flimage_tint(FL_IMAGE * p1, unsigned int p2, double p3)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    uipacked = libr.convert_to_uint(packed)
    fopacity = libr.convert_to_float(opacity)
    libr.keep_elem_refs(pImage, packed, opacity, uipacked, fopacity)
    retval = _flimage_tint(pImage, uipacked, fopacity)
    return retval


def flimage_rotate(pImage, angle, subpixel):
    """Does an image rotation. Repeated rotations should be avoided if
    possible. If you have to call it more than once it's a good idea to crop
    after rotations in order to get rid of the regions that contain only fill
    color.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `angle` : int
        the angle in one-tenth of a degree (i.e., a 45 degree rotation should
        be specified as 450) with a positive sign for counter-clock rotation.
      `subpixel` : int
        if subpixel sampling should be enabled. Values (from xfdata.py)
        FLIMAGE_NOSUBPIXEL or FLIMAGE_SUBPIXEL. If enabled, the resulting image
        pixels are interpolated from the original pixels; this usually has an
        "anti-aliasing" effect that leads to less severe jagged edges and
        similar artifacts commonly encountered in rotations. However, it also
        means that a color indexed image gets converted to a RGB image. If
        preserving the pixel value is important, you should not turn subpixel
        sampling on.

    :return: num., or negative num. (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_rotate = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_rotate",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int],
        """int flimage_rotate(FL_IMAGE * p1, int p2, int p3)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.check_admitted_value_in_list(subpixel, xfdata.FLIMAGESUBPIXROT_list)
    iangle = libr.convert_to_int(angle)
    isubpixel = libr.convert_to_int(subpixel)
    libr.keep_elem_refs(pImage, angle, subpixel, iangle, isubpixel)
    retval = _flimage_rotate(pImage, iangle, isubpixel)
    return retval


def flimage_flip(pImage, what):
    """Does the mirror operation in x- or y-direction at the center. For
    example, to flip the columns of an image, the left and right of the
    image are flipped (just like having a vertical mirror in the center of
    the image) thus the first pixel on any given row becomes the last, and
    the last pixel becomes the first etc.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `what` : int or char
        desired direction of flipping. Values 'c' (column, horizontal flipping)
        or 'r' (row, vertical flipping)

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_flip = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_flip",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int],
        """int flimage_flip(FL_IMAGE * p1, int p2)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    if isinstance(what, str):
        # workaround to let a character as int argument
        ordwhat = ord(what)
    else:
        ordwhat = what
    iwhat = libr.convert_to_int(ordwhat)
    libr.keep_elem_refs(pImage, what, ordwhat, iwhat)
    retval = _flimage_flip(pImage, iwhat)
    return retval


def flimage_scale(pImage, newwidth, newheight, option):
    """Scales an image to any desired size with or without subpixel sampling.
    Without subpixel sampling simple pixel replication is used, otherwise a
    box average algorithm is employed that yields an anti-aliased image with
    much less artifacts.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `newwidth` : int
        desired image width
      `newheight` : int
        desired image height
      `option` : int
        option to scale the image to the desired size but keeping the aspect
        ratio of the image the same by filling the part of the image that
        would otherwise be empty. Values (from xfdata.py) FLIMAGE_NOSUBPIXEL,
        FLIMAGE_SUBPIXEL, FLIMAGE_ASPECT, FLIMAGE_CENTER, FLIMAGE_NOCENTER.
        Any value can be single or bitwise-ORed.

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_scale = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_scale",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int,
        cty.c_int],
        """int flimage_scale(FL_IMAGE * p1, int p2, int p3, int p4)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    inewwidth = libr.convert_to_int(newwidth)
    inewheight = libr.convert_to_int(newheight)
    ioption = libr.convert_to_int(option)
    libr.keep_elem_refs(pImage, newwidth, newwidth, option, inewwidth,
                        inewwidth, ioption)
    retval = _flimage_scale(pImage, inewwidth, inewheight, ioption)
    return retval


def flimage_warp(pImage, mtrx, newwidth, newheight, subpixel):
    """Does transformation of pixel coordinates. Rotation, scaling, shearing
    etc. are examples of (linear and non-perspective) image warping. User can
    specify whatever size he/she wants and the warp function will fill the
    empty grid location with the fill color. This is how the aspect ratio
    preserving scaling is implemented. The image is transformed in place.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `mtrx` : *todo*
        the warp matrix
      `newwidth` : int
        desired image width
      `newheight` : int
        desired image height
      `subpixel` : int
        if subpixel sampling should be used. Although subpixel sampling adds
        processing time, it generally improves image quality significantly.
        Values (from xfdata.py) any logical OR of FLIMAGE_NOSUBPIXEL,
        FLIMAGE_SUBPIXEL and FLIMAGE_NOCENTER (only useful if you specify an
        image dimension that is larger than the warped image, and in that
        case the warped image is flushed top-left within the image grid,
        otherwise it is centered).

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_warp = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_warp",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER(cty.c_float * 2),
        cty.c_int, cty.c_int, cty.c_int],
        """int flimage_warp(FL_IMAGE * p1, float * p2, int p3, int p4,
           int p5)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    # mtrx to be handled
    inewwidth = libr.convert_to_int(newwidth)
    inewheight = libr.convert_to_int(newheight)
    isubpixel = libr.convert_to_int(subpixel)
    libr.keep_elem_refs(pImage, mtrx, newwidth, newheight, subpixel,
                        inewwidth, inewheight, isubpixel)
    retval = _flimage_warp(pImage, mtrx, inewwidth, inewheight, isubpixel)
    return retval


def flimage_autocrop(pImage, bgcolr):
    """Automatically crops an image using the background as the color to crop,
    by searching the image from all four sides and removing all contiguous
    regions of the uniform background from the sides. The image is modified in
    place.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `bgcolr` : int_pos
        background color to crop. If it's xfdata.FLIMAGE_AUTOCOLOR, the
        background is chosen as the first pixel of the image.

    :return: non-negative num., or -1 (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_autocrop = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_autocrop",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_uint],
        """int flimage_autocrop(FL_IMAGE * p1, unsigned int p2)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    uibgcolr = libr.convert_to_uint(bgcolr)
    libr.keep_elem_refs(pImage, bgcolr, uibgcolr)
    retval = _flimage_autocrop(pImage, uibgcolr)
    return retval


def flimage_get_autocrop(pImage, bgcolr):
    """Obtains the auto-cropping offsets (from left, right, top and bottom
    sides) of an image.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `bgcolr` : int_pos
        background color to crop. If it's xfdata.FLIMAGE_AUTOCOLOR, the
        background is chosen as the first pixel of the image.

    :return: num., from left side (xl), from top side (yt), from right side
        (xr), from bottom side (yb) offsets
    :rtype: int, int, int, int, int

    :note: e.g. *todo*

    :attention: API change from XForms - upstream was
        flimage_get_autocrop(pImage, bk, xl, yt, xr, yb)

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_get_autocrop = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_get_autocrop",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_uint,
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],
        """int flimage_get_autocrop(FL_IMAGE * p1, unsigned int p2,
           int * p3, int * p4, int * p5, int * p6)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    uibgcolr = libr.convert_to_uint(bgcolr)
    xl, pxl = libr.make_int_and_pointer()
    yt, pyt = libr.make_int_and_pointer()
    xr, pxr = libr.make_int_and_pointer()
    yb, pyb = libr.make_int_and_pointer()
    libr.keep_elem_refs(pImage, bgcolr, uibgcolr, xl, pxl, yt, pyt, xr, pxr,
                        yb, pyb)
    retval = _flimage_get_autocrop(pImage, uibgcolr, pxl, pyt, pxr, pyb)
    return retval, xl.value, yt.value, xr.value, yb.value


def flimage_crop(pImage, xl, yt, xr, yb):
    """Crops an image, using offsets supplied by the user.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `xl` : int
        offset from left side. If it is negative, it indicates enlargement of
        the image. (e.g. if it is 1 the cropping removes the first column from
        the image).
      `yt` : int
        offset from top side. If it is negative, it indicates enlargement of
        the image. (e.g. if it is 1 the cropping removes the first row from
        the image).
      `xr` : int
        offset from right side. If it is negative, it indicates enlargement
        of the image. (e.g. if it is 1 the cropping removes the last column
        from the image).
      `yb` : int
        offset from bottom side. If it is negative, it indicates enlargement
        of the image. (e.g. if it is 1 the cropping removes the last row from
        the image).

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK
    """

    _flimage_crop = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_crop",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int,
        cty.c_int, cty.c_int],
        """int flimage_crop(FL_IMAGE * p1, int p2, int p3,
           int p4, int p5)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    ixl = libr.convert_to_int(xl)
    iyt = libr.convert_to_int(yt)
    ixr = libr.convert_to_int(xr)
    iyb = libr.convert_to_int(yb)
    libr.keep_elem_refs(pImage, xl, yt, xr, yb, ixl, iyt, ixr, iyb)
    retval = _flimage_crop(pImage, ixl, iyt, ixr, iyb)
    return retval


def flimage_replace_pixel(pImage, targetcolr, newcolr):
    """Replaces all color targetcolr with the new desired color.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `targetcolr` : int_pos
        color to be replaced
      `newcolr` : int_pos
        new color to be used

    :return: 0, or -1 (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_replace_pixel = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_replace_pixel",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_uint, cty.c_uint],
        """int flimage_replace_pixel(FL_IMAGE * p1, unsigned int p2,
           unsigned int p3)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    uitargetcolr = libr.convert_to_uint(targetcolr)
    uinewcolr = libr.convert_to_uint(newcolr)
    libr.keep_elem_refs(pImage, targetcolr, newcolr, uitargetcolr, uinewcolr)
    retval = _flimage_replace_pixel(pImage, uitargetcolr, uinewcolr)
    return retval


def flimage_transform_pixels(pImage, red, green, blue):
    """Processes an image in place with RGB transformation and replaces it.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `red` : int
        lookup tables for red color of a length of at least FL_PCMAX + 1 (256).
      `green` : int
        lookup tables for green color of a length of at least FL_PCMAX + 1
        (256).
      `blue` : int
        lookup tables for blue color of a length of at least FL_PCMAX + 1
        (256).

    :return: positive num., or -1 (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_transform_pixels = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_transform_pixels",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],
        """int flimage_transform_pixels(FL_IMAGE * p1, int * p2,
           int * p3, int * p4)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    pred = cty.cast(red, cty.POINTER(cty.c_int))
    pgreen = cty.cast(green, cty.POINTER(cty.c_int))
    pblue = cty.cast(blue, cty.POINTER(cty.c_int))
    libr.keep_elem_refs(pImage, red, green, blue, pred, pgreen, pblue)
    retval = _flimage_transform_pixels(pImage, pred, pgreen, pblue)
    return retval


def flimage_windowlevel(pImage, winlvl, width):
    """Sets the window level for an image. It it points to a multiple image,
    window level parameters are changed for all images.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `winlvl` : int
        new level of window
      `width` : int
        width. If zero disables window leveling.

    :return: 1 (if window level parameters are modified), otherwise 0 is
        returned.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_windowlevel = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_windowlevel",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int],
        """int flimage_windowlevel(FL_IMAGE * p1, int p2, int p3)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    iwinlvl = libr.convert_to_int(winlvl)
    iwidth = libr.convert_to_int(width)
    libr.keep_elem_refs(pImage, winlvl, width, iwinlvl, iwidth)
    retval = _flimage_windowlevel(pImage, iwinlvl, iwidth)
    return retval


def flimage_enhance(pImage, delta):
    """*todo*

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `delta` : int
        unused.

    :return: 0
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_enhance = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_enhance",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int],
        """int flimage_enhance(FL_IMAGE * p1, int p2)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    idelta = libr.convert_to_int(delta)     # unused
    libr.keep_elem_refs(pImage, delta, idelta)
    retval = _flimage_enhance(pImage, idelta)
    return retval


def flimage_from_pixmap(pImage, pixmap):
    """Converts a Pixmap to an image. *todo*

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `pixmap` : long_pos
        pixmap id

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_from_pixmap = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_from_pixmap",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.Pixmap],
        """int flimage_from_pixmap(FL_IMAGE * p1, Pixmap p2)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    ulpixmap = libr.convert_to_Pixmap(pixmap)
    libr.keep_elem_refs(pImage, pixmap, ulpixmap)
    retval = _flimage_from_pixmap(pImage, ulpixmap)
    return retval


def flimage_to_pixmap(pImage, win):
    """Converts an image into a Pixmap (a server side resource) that can be
    used in the pixmap object.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `win` : long_pos
        window id

    :return: pixmap id
    :rtype: long_pos

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_to_pixmap = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_to_pixmap",
        xfdata.Pixmap, [cty.POINTER(xfdata.FL_IMAGE), xfdata.FL_WINDOW],
        """Pixmap flimage_to_pixmap(FL_IMAGE * p1, FL_WINDOW p2)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    ulwin = libr.convert_to_Window(win)
    libr.keep_elem_refs(pImage, win, ulwin)
    retval = _flimage_to_pixmap(pImage, ulwin)
    return retval


def flimage_dup(pImage):
    """Duplicates an image and returns the duplicated image. At the moment,
    only the first image is duplicated even if the input image has multiple
    frames. Furthermore, markers and annotations are not duplicated.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image to be duplicated

    :return: duplicated image class instance
    :rtype: pointer to xfdata.FL_IMAGE

    :note: e.g. pimg2 = flimage_dup(pimg1)

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_dup = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_dup",
        cty.POINTER(xfdata.FL_IMAGE), [cty.POINTER(xfdata.FL_IMAGE)],
        """FL_IMAGE * flimage_dup(FL_IMAGE * p1)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    retval = _flimage_dup(pImage)
    return retval


# Miscellaneous prototypes

def fl_get_submatrix(inmtrx, nrows, ncols, r1, c1, rs, cs, elemsize):
    """Grabs a piece of an image matrix. The piece is of nrows by ncols in
    size.

    --

    :Parameters:
      `inmtrx` : *todo*
        image matrix
      `nrows` : int
        number of rows
      `ncols` : int
        number of columns
      `r1` : int
        initial row?
      `c1` : int
        initial column?
      `rs` : int
        final row?
      `cs` : int
        final column?
      `elemsize` : int_pos
        size of matrix in bytes

    :return: matrix?
    :rtype: *todo*

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_get_submatrix = libr.cfuncproto(
        libr.load_so_libflimage(), "fl_get_submatrix",
        cty.c_void_p, [cty.c_void_p, cty.c_int, cty.c_int, cty.c_int,
        cty.c_int, cty.c_int, cty.c_int, cty.c_uint],
        """void * fl_get_submatrix(void * p1, int p2, int p3, int p4,
           int p5, int p6, int p7, unsigned int p8)""")
    libr.check_if_initialized()
    pinmtrx = cty.cast(inmtrx, cty.c_void_p)
    inrows = libr.convert_to_int(nrows)
    incols = libr.convert_to_int(ncols)
    ir1 = libr.convert_to_int(r1)
    ic1 = libr.convert_to_int(c1)
    irs = libr.convert_to_int(rs)
    ics = libr.convert_to_int(cs)
    uielemsize = libr.convert_to_uint(elemsize)
    libr.keep_elem_refs(inmtrx, nrows, ncols, r1, c1, rs, cs, elemsize,
                    pinmtrx, inrows, incols, ir1, ic1, irs, ics, uielemsize)
    retval = _fl_get_submatrix(pinmtrx, inrows, incols, ir1, ic1, irs, ics, \
                               uielemsize)
    return retval


def fl_j2pass_quantize_packed(packed, w, h, maxcolr, ci, actualcolr, redlut,
                              greenlut, bluelut, pImage):
    """*todo*

    --

    :Parameters:
      `packed` : *todo*
        *todo*
      `w` : int
        *todo*
      `h` : int
        *todo*
      `maxcolr` : int
        *todo*
      `ci` : *todo*
        *todo*
      `actualcolr` : int
        *todo*
      `redlut` : int
        *todo*
      `greenlut` : int
        *todo*
      `bluelut` : int
        *todo*
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_j2pass_quantize_packed = libr.cfuncproto(
        libr.load_so_libflimage(), "fl_j2pass_quantize_packed",
        cty.c_int, [cty.POINTER(cty.POINTER(cty.c_uint)), cty.c_int,
        cty.c_int, cty.c_int, cty.POINTER(cty.POINTER(cty.c_ushort)),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(xfdata.FL_IMAGE)],
        """int fl_j2pass_quantize_packed(unsigned int * * p1, int p2,
           int p3, int p4, short unsigned int * * p5, int * p6,
           int * p7, int * p8, int * p9, FL_IMAGE * p10)""")
    libr.check_if_initialized()
    # packed to be handled
    iw = libr.convert_to_int(w)
    ih = libr.convert_to_int(h)
    imaxcolr = libr.convert_to_int(maxcolr)
    # ci to be handled
    iactualcolr = libr.convert_to_int(actualcolr)
    predlut = cty.cast(redlut, cty.POINTER(cty.c_int))
    pgreenlut = cty.cast(greenlut, cty.POINTER(cty.c_int))
    pbluelut = cty.cast(bluelut, cty.POINTER(cty.c_int))
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(packed, w, h, maxcolr, ci, actualcolr, redlut,
            greenlut, bluelut, pImage, iw, ih, imaxcolr, iactualcolr, predlut,
            pgreenlut, pbluelut)
    retval = _fl_j2pass_quantize_packed(packed, iw, iw, imaxcolr, ci,
                iactualcolr, predlut, pgreenlut, pbluelut, pImage)
    return retval


def fl_j2pass_quantize_rgb(red, green, blue, w, h, maxcolr, ci, actualcolr,
                        redlut, greenlut, bluelut, pImage):
    """*todo*

    --

    :Parameters:
      `red` : *todo*
        *todo*
      `green` : *todo*
        *todo*
      `blue` : *todo*
        *todo*
      `w` : int
        *todo*
      `h` : int
        *todo*
      `maxcolr` : int
        *todo*
      `ci` : *todo*
        *todo*
      `actualcolr` : int
        *todo*
      `redlut` : int
        *todo*
      `greenlut` : int
        *todo*
      `bluelut` : int
        *todo*
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_j2pass_quantize_rgb = libr.cfuncproto(
        libr.load_so_libflimage(), "fl_j2pass_quantize_rgb",
        cty.c_int, [cty.POINTER(cty.POINTER(cty.c_ubyte)),
        cty.POINTER(cty.POINTER(cty.c_ubyte)),
        cty.POINTER(cty.POINTER(cty.c_ubyte)), cty.c_int, cty.c_int,
        cty.c_int, cty.POINTER(cty.POINTER(cty.c_ushort)),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(xfdata.FL_IMAGE)],
        """int fl_j2pass_quantize_rgb(unsigned char * * p1,
           unsigned char * * p2, unsigned char * * p3, int p4, int p5,
           int p6, short unsigned int * * p7, int * p8, int * p9,
           int * p10, int * p11, FL_IMAGE * p12)""")
    libr.check_if_initialized()
    # red to be handled
    # green to be handled
    # blue to be handled
    iw = libr.convert_to_int(w)
    ih = libr.convert_to_int(h)
    imaxcolr = libr.convert_to_int(maxcolr)
    # ci to be handled
    iactualcolr = libr.convert_to_int(actualcolr)
    predlut = cty.cast(redlut, cty.POINTER(cty.c_int))
    pgreenlut = cty.cast(greenlut, cty.POINTER(cty.c_int))
    pbluelut = cty.cast(bluelut, cty.POINTER(cty.c_int))
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(red, green, blue, w, h, maxcolr, ci, actualcolr,
                redlut, greenlut, bluelut, pImage, iw, ih, imaxcolr,
                iactualcolr, predlut, pgreenlut, pbluelut)
    retval = _fl_j2pass_quantize_rgb(red, green, blue, iw, iw, imaxcolr, ci,
                        iactualcolr, predlut, pgreenlut, pbluelut, pImage)
    return retval


def fl_make_submatrix(inmtrx, nrows, ncols, r1, c1, rs, cs, elemsize):
    """*todo*

    --

    :Parameters:
      `inmtrx` : *todo*
        image matrix
      `nrows` : int
        number of rows
      `ncols` : int
        number of columns
      `r1` : int
        initial row?
      `c1` : int
        initial column?
      `rs` : int
        final row?
      `cs` : int
        final column?
      `elemsize` : int_pos
        size of matrix in bytes

    :return: matrix?
    :rtype: *todo*

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_make_submatrix = libr.cfuncproto(
        libr.load_so_libflimage(), "fl_make_submatrix",
        cty.c_void_p, [cty.c_void_p, cty.c_int, cty.c_int, cty.c_int,
        cty.c_int, cty.c_int, cty.c_int, cty.c_uint],
        """void * fl_make_submatrix(void * p1, int p2, int p3, int p4,
           int p5, int p6, int p7, unsigned int p8)""")
    libr.check_if_initialized()
    # inmtrx has to be handled
    inrows = libr.convert_to_int(nrows)
    incols = libr.convert_to_int(ncols)
    ir1 = libr.convert_to_int(r1)
    ic1 = libr.convert_to_int(c1)
    irs = libr.convert_to_int(rs)
    ics = libr.convert_to_int(cs)
    uielemsize = libr.convert_to_uint(elemsize)
    libr.keep_elem_refs(inmtrx, nrows, ncols, r1, c1, rs, cs, elemsize,
            inrows, incols, ir1, ic1, irs, ics, uielemsize)
    retval = _fl_make_submatrix(inmtrx, inrows, incols, ir1, ic1, irs, ics, \
                                uielemsize)
    return retval


def fl_pack_bits(inval, lng):
    """Packs color index (0 or 1) into bytes.

    --

    :Parameters:
      `inval` : short_pos
        input value to be packed
      `lng` : int
        number of indexes

    :return: output value after packing (outval)
    :rtype: byte_pos

    :note: e.g. *todo*

    :attention: API change from XForms - upstream was
        fl_pack_bits(outval, inval, lng)

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _fl_pack_bits = libr.cfuncproto(
        libr.load_so_libflimage(), "fl_pack_bits",
        None, [cty.POINTER(cty.c_ubyte), cty.POINTER(cty.c_ushort), cty.c_int],
        """void fl_pack_bits(unsigned char * p1, short unsigned int * p2,
           int p3)""")
    libr.check_if_initialized()
    uboutval, poutval = libr.make_ubyte_and_pointer()
    uiinval = libr.convert_to_uint(inval)
    puiinval = cty.cast(uiinval, cty.POINTER(cty.c_uint))
    ilng = libr.convert_to_int(lng)
    libr.keep_elem_refs(uboutval, poutval, inval, uiinval, puiinval, lng, ilng)
    _fl_pack_bits(poutval, puiinval, ilng)
    return uboutval.value


def fl_unpack_bits(inval, lng):
    """Unpacks packed bits into color indexes (0 or 1).

    --

    :Parameters:
      `inval` : byte_pos
        input value to be unpacked
      `lng` : int
        length of packed bytes.

    :return: output value after unpacking (outval)
    :rtype: short_pos

    :note: e.g. *todo*

    :attention: API change from XForms - upstream was
        fl_unpack_bits(outval, inval, lng)

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _fl_unpack_bits = libr.cfuncproto(
        libr.load_so_libflimage(), "fl_unpack_bits",
        None, [cty.POINTER(cty.c_ushort), cty.POINTER(cty.c_ubyte),
        cty.c_int],
        """void fl_unpack_bits(short unsigned int * p1,
           unsigned char * p2, int p3)""")
    libr.check_if_initialized()
    usoutval, poutval = libr.make_ushort_and_pointer()
    ubinval = libr.convert_to_ubyte(inval)
    pubinval = cty.cast(ubinval, cty.POINTER(cty.c_ubyte))
    ilng = libr.convert_to_int(lng)
    libr.keep_elem_refs(usoutval, poutval, inval, ubinval, pubinval, lng, ilng)
    _fl_unpack_bits(poutval, pubinval, ilng)
    return usoutval.value


def fl_value_to_bits(val):
    """*todo*

    --

    :Parameters:
      `val` : int_pos
        value to convert to bits

    :return: num.
    :rtype: int_pos

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_value_to_bits = libr.cfuncproto(
        libr.load_so_libflimage(), "fl_value_to_bits",
        cty.c_uint, [cty.c_uint],
        """unsigned int fl_value_to_bits(unsigned int p1)""")
    libr.check_if_initialized()
    uival = libr.convert_to_uint(val)
    libr.keep_elem_refs(val, uival)
    retval = _fl_value_to_bits(uival)
    return retval


def flimage_add_comments(pImage, text, lng):
    """Adds a comment to an image.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `text` : str
        comment to be added
      `lng` : int
        length of comment

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_add_comments = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_add_comments",
        None, [cty.POINTER(xfdata.FL_IMAGE), xfdata.STRING, cty.c_int],
        """void flimage_add_comments(FL_IMAGE * p1, const char * p2,
           int p3)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    stext = libr.convert_to_string(text)
    ilng = libr.convert_to_int(lng)
    libr.keep_elem_refs(pImage, text, lng, stext, ilng)
    _flimage_add_comments(pImage, stext, ilng)


def flimage_color_to_pixel(pImage, r, g, b):
    """Convert an RGB triple to a pixel.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `r` : int
        value for red color
      `g` : int
        value for green color
      `b` : int
        value for blue color

    :return: pixel id, new pixel
    :rtype: long_pos, int

    :note: e.g. *todo*

    :attention: API change from XForms - upstream was
        flimage_color_to_pixel(pImage, r, g, b, newpix)

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_color_to_pixel = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_color_to_pixel",
        cty.c_ulong, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int,
        cty.c_int, cty.POINTER(cty.c_int)],
        """long unsigned int flimage_color_to_pixel(FL_IMAGE * p1,
               int p2, int p3, int p4, int * p5)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    ir = libr.convert_to_int(r)
    ig = libr.convert_to_int(g)
    ib = libr.convert_to_int(b)
    inewpix, pnewpix = libr.make_int_and_pointer()
    libr.keep_elem_refs(pImage, r, g, b, ir, ig, ib, inewpix, pnewpix)
    retval = _flimage_color_to_pixel(pImage, ir, ig, ib, pnewpix)
    return retval, inewpix.value


def flimage_combine(pImage1, pImage2, alpha):
    """Combines two images with alpha level?, returning a new image.

    --

    :Parameters:
      `pImage1` : pointer to xfdata.FL_IMAGE
        first image to combine
      `pImage2` : pointer to xfdata.FL_IMAGE
        second image to combine
      `alpha` : float
        alpha level?

    :return: image class instance
    :rtype: pointer to xfdata.FL_IMAGE

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_combine = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_combine",
        cty.POINTER(xfdata.FL_IMAGE), [cty.POINTER(xfdata.FL_IMAGE),
        cty.POINTER(xfdata.FL_IMAGE), cty.c_double],
        """FL_IMAGE * flimage_combine(FL_IMAGE * p1, FL_IMAGE * p2,
           double p3)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage1)
    libr.verify_flflimageptr_type(pImage2)
    falpha = libr.convert_to_double(alpha)
    libr.keep_elem_refs(pImage1, pImage2, alpha, falpha)
    retval = _flimage_combine(pImage1, pImage2, falpha)
    return retval


def flimage_display_markers(pImage):
    """Displays markers added to an image.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :note: e.g. flimage_display_markers(pimg)

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_display_markers = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_display_markers",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_display_markers(FL_IMAGE * p1)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    _flimage_display_markers(pImage)


def flimage_dup_(pImage, pix):
    """Duplicates an image, with or without the pixels

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `pix` : int
        pixel

    :return: image class instance
    :rtype: pointer to xfdata.FL_IMAGE

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_dup_ = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_dup_",
        cty.POINTER(xfdata.FL_IMAGE), [cty.POINTER(xfdata.FL_IMAGE),
        cty.c_int],
        """FL_IMAGE * flimage_dup_(FL_IMAGE * p1, int p2)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    ipix = libr.convert_to_int(pix)
    libr.keep_elem_refs(pImage, pix, ipix)
    retval = _flimage_dup_(pImage, ipix)
    return retval


def flimage_enable_bmp():
    """Enables use of BMP (Windows/OS2 Bitmap) image format.

    --

    :note: e.g. flimage_enable_bmp()

    :status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_bmp = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_enable_bmp",
        None, [],
        """void flimage_enable_bmp()""")
    libr.check_if_initialized()
    _flimage_enable_bmp()


def flimage_enable_fits():
    """Enables use of NASA/NOTS standard FITS image format.

    --

    :note: e.g. flimage_enable_fits()

    :status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_fits = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_enable_fits",
        None, [],
        """void flimage_enable_fits()""")
    _flimage_enable_fits()


# TODO: try to understand what kind of images is this one.
def flimage_enable_genesis():
    """Enables use of Genesis image format.

    --

    :note: e.g. flimage_enable_genesis()

    :status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_genesis = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_enable_genesis",
        None, [],
        """void flimage_enable_genesis()""")
    libr.check_if_initialized()
    _flimage_enable_genesis()


def flimage_enable_gif():
    """Enables use of GIF (Compuserve Graphics Interchange format) image
    format.

    --

    :note: e.g. flimage_enable_gif()

    :status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_gif = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_enable_gif",
        None, [],
        """void flimage_enable_gif()""")
    libr.check_if_initialized()
    _flimage_enable_gif()


def flimage_enable_gzip():
    """Enables use of gzip compression filter for images.

    --

    :note: e.g. flimage_enable_gzip()

    :status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_gzip = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_enable_gzip",
        None, [],
        """void flimage_enable_gzip()""")
    libr.check_if_initialized()
    _flimage_enable_gzip()


def flimage_enable_jpeg():
    """Enables use of JPEG/JFIF (Joint Photographic Experts Group) image
    format.

    --

    :note: e.g. flimage_enable_jpeg()

    :status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_jpeg = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_enable_jpeg",
        None, [],
        """void flimage_enable_jpeg()""")
    libr.check_if_initialized()
    _flimage_enable_jpeg()


def flimage_enable_png():
    """Enables use of PNG (Portable Network Graphics) image format. It
    requires netpbm library to be installed.

    --

    :note: e.g. flimage_enable_png()

    :status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_png = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_enable_png",
        None, [],
        """void flimage_enable_png()""")
    libr.check_if_initialized()
    _flimage_enable_png()


def flimage_enable_ps():
    """Enables use of PS (Adobe PostScript) image format. It needs gs
    (ghostscript) for reading.

    --

    :note: e.g. flimage_enable_ps()

    :status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_ps = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_enable_ps",
        None, [],
        """void flimage_enable_ps()""")
    libr.check_if_initialized()
    _flimage_enable_ps()


def flimage_enable_sgi():
    """Enables use of SGI (Silicon Graphics-Iris) image format. It requires
    pbmplus/netpbm library to be installed.

    --

    :note: e.g. flimage_enable_sgi()

    :status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_sgi = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_enable_sgi",
        None, [],
        """void flimage_enable_sgi()""")
    libr.check_if_initialized()
    _flimage_enable_sgi()


def flimage_enable_tiff():
    """Enables use of TIFF (Tagged Image file, with no compression) image
    format.

    --

    :note: e.g. flimage_enable_tiff()

    :status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_tiff = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_enable_tiff",
        None, [],
        """void flimage_enable_tiff()""")
    libr.check_if_initialized()
    _flimage_enable_tiff()


def flimage_enable_xbm():
    """Enables use of XBM (X Window Bitmap) image format.

    --

    :note: e.g. flimage_enable_xbm()

    :status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_xbm = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_enable_xbm",
        None, [],
        """void flimage_enable_xbm()""")
    libr.check_if_initialized()
    _flimage_enable_xbm()


def flimage_enable_xpm():
    """Enables use of XPM3 (X Window PixMap) image format.

    --

    :note: e.g. flimage_enable_xpm()

    :status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_xpm = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_enable_xpm",
        None, [],
        """void flimage_enable_xpm()""")
    libr.check_if_initialized()
    _flimage_enable_xpm()


def flimage_enable_xwd():
    """Enables use of XWD (X Window Dump) image format.

    --

    :note: e.g. flimage_enable_xwd()

    :status: Tested + Doc + NoDemo = OK

    """
    _flimage_enable_xwd = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_enable_xwd",
        None, [],
        """void flimage_enable_xwd()""")
    libr.check_if_initialized()
    _flimage_enable_xwd()


def flimage_free_ci(pImage):
    """Frees an image of type xfdata.FL_IMAGE_CI?

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_free_ci = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_free_ci",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_free_ci(FL_IMAGE * p1)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    _flimage_free_ci(pImage)


def flimage_free_gray(pImage):
    """Frees an image of type xfdata.FL_IMAGE_GRAY?.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_free_gray = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_free_gray",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_free_gray(FL_IMAGE * p1)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    _flimage_free_gray(pImage)


def flimage_free_linearlut(pImage):
    """*todo*

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_free_linearlut = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_free_linearlut",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_free_linearlut(FL_IMAGE * p1)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    _flimage_free_linearlut(pImage)


def flimage_free_rgb(pImage):
    """Frees an image of type xfdata.FL_IMAGE_RGB?.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_free_rgb = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_free_rgb",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_free_rgb(FL_IMAGE * p1)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    _flimage_free_rgb(pImage)


def flimage_freemem(pImage):
    """Frees all allocated memory associated with the image.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_freemem = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_freemem",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_freemem(FL_IMAGE * p1)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    _flimage_freemem(pImage)


def flimage_get_closest_color_from_map(pImage, colr):
    """Gets closest color from color map?

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `colr` : int_pos
        color to evaluate

    :return: color that is close?
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_get_closest_color_from_map = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_get_closest_color_from_map",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_uint],
        """int flimage_get_closest_color_from_map(FL_IMAGE * p1,
           unsigned int p2)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    uicolr = libr.convert_to_uint(colr)
    libr.keep_elem_refs(pImage, colr, uicolr)
    retval = _flimage_get_closest_color_from_map(pImage, uicolr)
    return retval


def flimage_get_linearlut(pImage):
    """*todo*

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :return: num., or -1 (on failure?)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_get_linearlut = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_get_linearlut",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_get_linearlut(FL_IMAGE * p1)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    retval = _flimage_get_linearlut(pImage)
    return retval


def flimage_invalidate_pixels(pImage):
    """Invalidates/frees all other types of image, before we modify the
    current image.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_invalidate_pixels = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_invalidate_pixels",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_invalidate_pixels(FL_IMAGE * p1)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    _flimage_invalidate_pixels(pImage)


def flimage_open(fname):
    """Opens an image file.

    --

    :Parameters:
      `fname` : str
        name of file to open

    :return: image class instance opened, or None (on failure)
    :rtype: pointer to xfdata.FL_IMAGE

    :note: e.g. pimg = flimage_open("something.ppm")

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_open = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_open",
        cty.POINTER(xfdata.FL_IMAGE), [xfdata.STRING],
        """FL_IMAGE * flimage_open(const char * p1)""")
    libr.check_if_initialized()
    sfname = libr.convert_to_string(fname)
    libr.keep_elem_refs(fname, sfname)
    retval = _flimage_open(sfname)
    return retval


def flimage_read_annotation(pImage):
    """Reads annotation in the image?

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :return: 0, or -1 (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_read_annotation = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_read_annotation",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_read_annotation(FL_IMAGE * p1)""")
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    retval = _flimage_read_annotation(pImage)
    return retval


def flimage_replace_image(pImage, w, h, r, g, b):
    """Replace an image?

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `w` : int
        width
      `h` : int
          heigth
      `r` : int
        value for red color
      `g` : int
        value for green color
      `b` : int
        value for blue color

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_replace_image = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_replace_image",
        None, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int,
        cty.c_void_p, cty.c_void_p, cty.c_void_p],
        """void flimage_replace_image(FL_IMAGE * p1, int p2, int p3,
           void * p4, void * p5, void * p6)""")
    libr.check_if_initialized()
    iw = libr.convert_to_int(w)
    ih = libr.convert_to_int(h)
    pr = cty.cast(r, cty.c_void_p)
    pg = cty.cast(g, cty.c_void_p)
    pb = cty.cast(b, cty.c_void_p)
    libr.keep_elem_refs(pImage, w, h, r, g, b, iw, ih, pr, pg, pb)
    _flimage_replace_image(pImage, iw, ih, pr, pg, pb)


def flimage_swapbuffer(pImage):
    """Swaps buffer of an image?

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :return: 0
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_swapbuffer = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_swapbuffer",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_swapbuffer(FL_IMAGE * p1) """)
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    retval = _flimage_swapbuffer(pImage)
    return retval


def flimage_to_ximage(pImage, win, pXWindowAttributes):
    """Converts an FL_IMAGE into an XImage.

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image
      `win` : window id
        long_pos
      `pXWindowAttributes` : pointer to xfdata.XWindowAttributes
        class instance

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _flimage_to_ximage = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_to_ximage",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.FL_WINDOW,
        cty.POINTER(xfdata.XWindowAttributes)],
        """int flimage_to_ximage(FL_IMAGE * p1, FL_WINDOW p2,
           XWindowAttributes * p3) """)
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    ulwin = libr.convert_to_Window(win)
    libr.verify_otherclassptr_type(pXWindowAttributes, cty.POINTER( \
                            xfdata.XWindowAttributes))
    libr.keep_elem_refs(pImage, win, pXWindowAttributes, ulwin)
    retval = _flimage_to_ximage(pImage, ulwin, pXWindowAttributes)
    return retval


def flimage_write_annotation(pImage):
    """Writes annotation in the image?

    --

    :Parameters:
      `pImage` : pointer to xfdata.FL_IMAGE
        image

    :return: 0, or -1 (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _flimage_write_annotation = libr.cfuncproto(
        libr.load_so_libflimage(), "flimage_write_annotation",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_write_annotation(FL_IMAGE * p1) """)
    libr.check_if_initialized()
    libr.verify_flflimageptr_type(pImage)
    libr.keep_elem_refs(pImage)
    retval = _flimage_write_annotation(pImage)
    return retval
