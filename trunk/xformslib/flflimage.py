#!/usr/bin/env python
# -*- coding: iso8859-1 -*-

""" xforms-python's functions to manage image flobjects.
"""

#    Copyright (C) 2009, 2010, 2011  Luca Lazzaroni "LukenShiro"
#    e-mail: <lukenshiro@ngi.it>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Lesser General Public License as
#    published by the Free Software Foundation, version 2.1 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU Lesser General Public License for more details.
#
#    You should have received a copy of the GNU LGPL along with this
#    program. If not, see <http://www.gnu.org/licenses/>.
#
#    See CREDITS file to read acknowledgements and thanks to XForms,
#    ctypes and other developers.

# originally generated by 'h2xml+gccxml' and 'xml2py'
# then heavily reordered and reworked

# ############################################# #
# Interface to XForms shared flobject libraries #
# ############################################# #


import ctypes as cty
from xformslib import library
from xformslib import xfdata


#########################
# flimage.h
# Image related routines
#########################

# fl_safe_free function placeholder (low-level)


def FL_RGB2GRAY(r, g, b):
    uir = library.convert_to_uintc(r)
    uig = library.convert_to_uintc(g)
    uib = library.convert_to_uintc(b)
    return ((78 * (uir) + 150 * (uig) + 28 * (uib)) >> 8)   # cty.c_uint


# if PCBITS is not 8, we need to apply the RGBmask

def FL_IsRGB(ptr_flimage):
    library.verify_flflimageptr_type(ptr_flimage)
    return (ptr_flimage.contents.type == xfdata.FL_IMAGE_RGB)


def FL_IsPacked(ptr_flimage):
    library.verify_flflimageptr_type(ptr_flimage)
    return (ptr_flimage.contents.type == xfdata.FL_IMAGE_PACKED)


def flimage_setup(ptr_flimagesetup):
    """flimage_setup(ptr_flimagesetup)

    Defines up and configures image flobjects support and initializes
    xfdata.FLIMAGE_SETUP class instance.

    Parameters
    ----------
        ptr_flimagesetup : pointer to xfdata.FLIMAGE_SETUP
            imagesetup class instance

    Examples
    ---------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_setup = library.cfuncproto(
        library.load_so_libflimage(), "flimage_setup",
        None, [cty.POINTER(xfdata.FLIMAGE_SETUP)],
        """void flimage_setup(FLIMAGE_SETUP * setup)""")
    #library.check_if_initialized()
    library.verify_otherclassptr_type(ptr_flimagesetup, \
            cty.POINTER(xfdata.FLIMAGE_SETUP))
    library.keep_elem_refs(ptr_flimagesetup)
    _flimage_setup(ptr_flimagesetup)


# basic IO routines

def flimage_load(fname):
    """flimage_load(fname) -> ptr_flimage

    Loads an image file into memory.

    Parameters
    ----------
        fname : str
            name of image file to load

    Returns
    -------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            an image class instance, or None (on failure)

    Examples
    --------
        >>> pimg = flimage_load("/mydir/myimage.xpm")

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_load = library.cfuncproto(
        library.load_so_libflimage(), "flimage_load",
        cty.POINTER(xfdata.FL_IMAGE), [xfdata.STRING],
        """FL_IMAGE * flimage_load(const char * file)""")
    #library.check_if_initialized()
    s_fname = library.convert_to_stringc(fname)
    library.keep_elem_refs(fname, s_fname)
    retval = _flimage_load(s_fname)
    return retval


def flimage_read(ptr_flimage):
    """flimage_read(ptr_flimage) -> ptr_flimage

    Takes a xfdata.FL_IMAGE class instance returned by flimage_open()
    and fills the image structure.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image class instance

    Returns
    -------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            an image class instance, or None (on failure)

    Examples
    --------
        >>> emptyimg = flimage_open("/mydir/myfile.xpm")
        >>> imgfilled = flimage_read(emptyimg)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_read = library.cfuncproto(
        library.load_so_libflimage(), "flimage_read",
        cty.POINTER(xfdata.FL_IMAGE), [cty.POINTER(xfdata.FL_IMAGE)],
        """FL_IMAGE * flimage_read(FL_IMAGE * im)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    retval = _flimage_read(ptr_flimage)
    return retval


def flimage_dump(ptr_flimage, fname, fmt):
    """flimage_dump(ptr_flimage, fname, fmt) -> result

    Takes an image, either returned by flimage_load() (possibly after
    some processing) or created on the fly by the application, attempts
    to create a file to store the image.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image class instance
        fname : str
            name of file to be saved
        fmt : str
            formal name or short name of a supported image format.
            Values: jpeg, ppm, gif, bmp, etc... or some other formats the
            application knows how to write. If it is None, the original
            format the image was in is used.

    Returns
    -------
        result : int
            non-negative, or negative num. (on failure)

    Examples
    --------
        >>> resl = flimage_dump(pimg, "/mydir/mynewfile.ppm", "ppm")

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_dump = library.cfuncproto(
        library.load_so_libflimage(), "flimage_dump",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.STRING,
        xfdata.STRING],
        """int flimage_dump(FL_IMAGE * p1, const char * p2,
           const char * p3)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    s_fname = library.convert_to_stringc(fname)
    # *todo* take note of None case
    s_fmt = library.convert_to_stringc(fmt)
    library.keep_elem_refs(ptr_flimage, fname, fmt, s_fname, s_fmt)
    retval = _flimage_dump(ptr_flimage, s_fname, s_fmt)
    return retval


def flimage_close(ptr_flimage):
    """flimage_close(ptr_flimage) -> result

    Closes all file streams used to create the image.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image to be closed

    Returns
    -------
        result : int
            0?, or -1 (on failure)

    Examples
    --------
        >>> if flimage_close(pimg) == -1:
        >>> ... print("Error closing image file!")

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_close = library.cfuncproto(
        library.load_so_libflimage(), "flimage_close",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_close(FL_IMAGE * p1)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    retval = _flimage_close(ptr_flimage)
    return retval


# TODO: not sure if it is necessary in python, low-level only?
def flimage_alloc():
    """flimage_alloc() -> ptr_flimage

    Creates an image structure whose dynamically allocated memory is
    properly initialized, and returning it.

    Returns
    -------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image class instance

    Examples
    --------
        >>> pimg = flimage_alloc()

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_alloc = library.cfuncproto(
        library.load_so_libflimage(), "flimage_alloc",
        cty.POINTER(xfdata.FL_IMAGE), [],
        """FL_IMAGE * flimage_alloc()""")
    #library.check_if_initialized()
    retval = _flimage_alloc()
    return retval


# TODO: verify if is of any use in python
def flimage_getmem(ptr_flimage):
    """flimage_getmem(ptr_flimage) -> result

    Allocates the proper amount of memory appropriate for the image type,
    including colormaps when needed.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Returns
    -------
        result : int
            0, or -1 (on errors)

    Examples
    --------
        >>> bum = flimage_getmem(pimg)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_getmem = library.cfuncproto(
        library.load_so_libflimage(), "flimage_getmem",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_getmem(FL_IMAGE * p1)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    retval = _flimage_getmem(ptr_flimage)
    return retval


def flimage_is_supported(fname):
    """flimage_is_supported(fname) -> yesno

    Finds out if a specific file is a known image file or not.

    Parameters
    ----------
        fname : str
            name of file to be evaluated

    Returns
    -------
        yesno : int
            1 (if it is a known image file), or 0 (on failure)

    Examples
    --------
        >>> known = flimage_is_supported("/mydir/file.bmp")

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_is_supported = library.cfuncproto(
        library.load_so_libflimage(), "flimage_is_supported",
        cty.c_int, [xfdata.STRING],
        """int flimage_is_supported(const char * p1)""")
    #library.check_if_initialized()
    s_fname = library.convert_to_stringc(fname)
    library.keep_elem_refs(fname, s_fname)
    retval = _flimage_is_supported(s_fname)
    return retval


def flimage_description_via_filter(ptr_flimage, cmds, what, verbose):
    """flimage_description_via_filter(ptr_flimage, cmds, what, verbose) -> result

    Adds a description to be used with flimage_add_format() to add image
    formats via an external filter's command.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        cmds : list of str?
            a list of shell commands (filters) that convert the format in
            question into one of the supported formats.
        what : str
            text for reporting purpose
        verbose : int
            controls if some information and error messages should be
            printed (mainly for debugging purpose). Values 0 (to disable)
            or 1 (to enable)

    Returns
    -------
        result : int
            *todo*, or  -1 (on errors)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_description_via_filter = library.cfuncproto(
        library.load_so_libflimage(), "flimage_description_via_filter",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER(xfdata.STRING),
        xfdata.STRING, cty.c_int],
        """int flimage_description_via_filter(FL_IMAGE * im, char *const
           *cmds, const char *what, int verbose)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    #s_cmds = library.convert_to_stringc(cmds)                # to be verified
    s_cmds = library.convert_to_ptr_stringc(cmds)
    s_what = library.convert_to_stringc(what)
    i_verbose = library.convert_to_intc(verbose)
    library.keep_elem_refs(ptr_flimage, cmds, s_what, verbose, s_cmds, \
            s_what, i_verbose)
    retval = _flimage_description_via_filter(ptr_flimage, s_cmds, s_what, \
            i_verbose)
    return retval


def flimage_write_via_filter(ptr_flimage, cmds, formats, verbose):
    """flimage_write_via_filter(ptr_flimage, cmds, formats, verbose) -> result

    Uses external filters to add image formats, in order to convert
    an unsupported format into one that is. pbmplus or netpbm are excellent
    packages for this purpose.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        cmds : list of str?
            a list of shell commands (filters) that convert the format in
            question into one of the supported formats.
        formats : str?
            list of strings. Values ppm, pgm, pbm, .. etc..
        verbose : int
            controls if some information and error messages should be printed
            (mainly for debugging purpose). Values 0 (to disable) or 1
            (to enable)

    Returns
    -------
        result : int
            0, or -1 (on errors)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_write_via_filter = library.cfuncproto(
        library.load_so_libflimage(), "flimage_write_via_filter",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER(xfdata.STRING),
        cty.POINTER(xfdata.STRING), cty.c_int],
        """int flimage_write_via_filter(FL_IMAGE * p1, const * char * cmds,
           const char * formats[], int verbose)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    s_cmds = library.convert_to_ptr_stringc(cmds)    # *todo* to be verified
    s_formats = library.convert_to_stringc(formats)
    i_verbose = library.convert_to_intc(verbose)
    library.keep_elem_refs(ptr_flimage, cmds, formats, s_formats, verbose, \
            i_verbose)
    retval = _flimage_write_via_filter(ptr_flimage, s_cmds, s_formats, \
            i_verbose)
    return retval


def flimage_free(ptr_flimage):
    """flimage_free(ptr_flimage)

    Frees all memory allocated for the image, then the image structure
    itself. After the function returns, the image should not be referenced.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> flimage_free(pimg)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_free = library.cfuncproto(
        library.load_so_libflimage(), "flimage_free",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_free(FL_IMAGE * p1)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    _flimage_free(ptr_flimage)


def flimage_display(ptr_flimage, win):
    """flimage_display(ptr_flimage, win) -> result

    Displays a single or multiple images in a window.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        win : long_pos
            window id

    Returns
    -------
        result : int
            non-negative num., or negative num. (on failure)

    Examples
    --------
        >>> flimage_display(pimg, win0)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_display = library.cfuncproto(
        library.load_so_libflimage(), "flimage_display",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.Window],
        """int flimage_display(FL_IMAGE * p1, Window p2)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    ul_win = library.convert_to_Window(win)
    library.keep_elem_refs(ptr_flimage, win, ul_win)
    retval = _flimage_display(ptr_flimage, ul_win)
    return retval


def flimage_sdisplay(ptr_flimage, win):
    """flimage_sdisplay(ptr_flimage, win) -> result

    Displays a single image in a window.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        win : long_pos
            window id

    Returns
    -------
        result : int
            non-negative num., or negative num. (on failure)

    Examples
    --------
        >>> flimage_sdisplay(ptr_flimage, win)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_sdisplay = library.cfuncproto(
        library.load_so_libflimage(), "flimage_sdisplay",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.Window],
        """int flimage_sdisplay(FL_IMAGE * p1, Window p2)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    ul_win = library.convert_to_Window(win)
    library.keep_elem_refs(ptr_flimage, win, ul_win)
    retval = _flimage_sdisplay(ptr_flimage, ul_win)
    return retval


def flimage_convert(ptr_flimage, newimagetype, numcolors):
    """flimage_convert(ptr_flimage, newimagetype, numcolors) -> result

    Converts an image to a new type. Depending on which quantization
    function is used, the number of quantized colors may not be more than 256.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        newimagetype : int
            one of supported image type to convert to. Values (from xfdata.py)
            FL_IMAGE_NONE, FL_IMAGE_MONO, FL_IMAGE_GRAY, FL_IMAGE_CI,
            FL_IMAGE_RGB, FL_IMAGE_PACKED, FL_IMAGE_GRAY16, FL_IMAGE_RGB16,
            FL_IMAGE_FLEX
        numcolors : int
            number of colors to generate. It makes sense only when newtype is
            xfdata.FL_IMAGE_CI.

    Returns
    -------
        result : int
            non-negative num., or negative num. (on failure)

    Examples
    --------
        >>> flimage_convert(pimg, xfdata.FL_IMAGE_RGB, 0)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_convert = library.cfuncproto(
        library.load_so_libflimage(), "flimage_convert",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int],
        """int flimage_convert(FL_IMAGE * p1, int p2, int p3)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.checkfatal_allowed_value_in_list(newimagetype, \
            xfdata.FLIMAGETYPE_list)
    i_newimagetype = library.convert_to_intc(newimagetype)
    i_numcolors = library.convert_to_intc(numcolors)
    library.keep_elem_refs(ptr_flimage, newimagetype, numcolors, \
            i_newimagetype, i_numcolors)
    retval = _flimage_convert(ptr_flimage, i_newimagetype, i_numcolors)
    return retval


def flimage_type_name(imagetype):
    """flimage_type_name(imagetype) -> typename

    Finds out the image type name in string format, e.g., for reporting
    purposes.

    Parameters
    ----------
        imagetype : int
            type of a supported image. Values (from xfdata.py)
            FL_IMAGE_MONO (b&w. 1bit bitmaps. 0=white 1=black), FL_IMAGE_GRAY
            (gray-scale image, 8 bit), FL_IMAGE_CI (generic colormmaped index
            image), FL_IMAGE_RGB (24 bit RGB-A image, 8bit each),
            FL_IMAGE_PACKED (24 bit RGB-A packed into an int), FL_IMAGE_GRAY16
            (gray-scale image, 9 to 16 bit), FL_IMAGE_RGB16 (36bits color
            image), FL_IMAGE_FLEX (all formats). FL_IMAGE_NONE should not be
            used here.

    Returns
    -------
        typename : str
            name string

    Examples
    --------
        >>> flimage_type_name(imagetype)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_type_name = library.cfuncproto(
        library.load_so_libflimage(), "flimage_type_name",
        xfdata.STRING, [cty.c_int],
        """const char * flimage_type_name(int type)""")
    #library.check_if_initialized()
    library.checkfatal_allowed_value_in_list(imagetype, \
            xfdata.FLIMAGETYPE_list)
    i_imagetype = library.convert_to_intc(imagetype)
    library.keep_elem_refs(imagetype, i_imagetype)
    retval = _flimage_type_name(i_imagetype)
    return retval


def flimage_add_text(ptr_flimage, text, length, style, size, txtcolr, bgcolr,
                     nobk, txtxpos, txtypos, rot):
    """flimage_add_text(ptr_flimage, text, length, style, size, txtcolr,
    bgcolr, nobk, txtxpos, txtypos, rot) -> numstrings

    Places text into the image, passing parameters individually.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        text : str
            text string to be placed in image. If it starts with character
            '@' a symbol is drawn.
        length : int
            length of text
        style : int
            label style. Values (from xfdata.py)
            FL_NORMAL_STYLE (Helvetica normal text), FL_BOLD_STYLE (Helvetica
            boldface text), FL_ITALIC_STYLE (Helvetica italic text),
            FL_BOLDITALIC_STYLE (Helvetica boldface and italic text),
            FL_FIXED_STYLE (Courier fixed width, good for tables),
            FL_FIXEDBOLD_STYLE (Courier bold fixed text), FL_FIXEDITALIC_STYLE
            (Courier italic fixed text), FL_FIXEDBOLDITALIC_STYLE (Courier
            boldface and italic fixed text), FL_TIMES_STYLE (Times-Roman like
            normal font), FL_TIMESBOLD_STYLE (Times-Roman like boldface text),
            FL_TIMESITALIC_STYLE (Times-Roman like italic text),
            FL_TIMESBOLDITALIC_STYLE (Times-Roman like boldface and italic
            text), FL_MISC_STYLE (Charter normal text), FL_MISCBOLD_STYLE
            (Charter boldface text), FL_MISCITALIC_STYLE (Charter italic text),
            FL_SYMBOL_STYLE (Symbol text), FL_SHADOW_STYLE (Text casting a
            shadow, modifier mask), FL_ENGRAVED_STYLE (Text engraved into the
            form, modifier mask), FL_EMBOSSED_STYLE (Text standing out,
            modifier mask). Bitwise OR with any of modifiers is allowed.
        size : int
            label size. Values (from xfdata.py)
            FL_TINY_SIZE (8 points font), FL_SMALL_SIZE or FL_DEFAULT_SIZE (10
            points font, default), FL_NORMAL_SIZE (12 points font),
            FL_MEDIUM_SIZE (14 points font), FL_LARGE_SIZE (18 points font),
            FL_HUGE_SIZE (24 points font), or other numeric odd or even value
        txtcolr : int_pos
            color to use for text
        bgcolr : int_pos
            color to use for background (only if nobk is 0)
        nobk : int
            flag to enable/disable background. Values 0 (drawn with
            background) or 1 (text is drawn without a background)
        txtxpos : float
            horizontal location of the text relative to the image origin.
            The location specified is the lower-right corner of the text.
        txtypos : float
            vertical location of the text relative to the image origin.
            The location specified is the lower-right corner of the text.
        rot : int
            rotation

    Returns
    -------
        numstrings : int
            current number of strings for the image

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_add_text = library.cfuncproto(
        library.load_so_libflimage(), "flimage_add_text",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.STRING, cty.c_int,
        cty.c_int, cty.c_int, cty.c_uint, cty.c_uint, cty.c_int,
        cty.c_double, cty.c_double, cty.c_int],
        """int flimage_add_text(FL_IMAGE * im, const char * str, int len,
           int style, int size, unsigned int tcol, unsigned int bcol,
           int tran, double tx, double ty, int rot)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    s_text = library.convert_to_stringc(text)
    i_length = library.convert_to_intc(length)
    library.checkfatal_allowed_value_in_list(style, xfdata.TEXTSTYLE_list)
    i_style = library.convert_to_intc(style)
    i_size = library.convert_to_intc(size)
    ui_txtcolr = library.convert_to_uintc(txtcolr)
    ui_bgcolr = library.convert_to_uintc(bgcolr)
    i_nobk = library.convert_to_intc(nobk)
    f_txtxpos = library.convert_to_doublec(txtxpos)
    f_txtypos = library.convert_to_doublec(txtypos)
    i_rot = library.convert_to_intc(rot)
    library.keep_elem_refs(ptr_flimage, text, length, style, size, txtcolr, \
                bgcolr, nobk, txtxpos, txtypos, rot, s_text, i_length, \
                i_style, i_size, ui_txtcolr, ui_bgcolr, i_nobk, f_txtxpos, \
                f_txtypos, i_rot)
    retval = _flimage_add_text(ptr_flimage, s_text, i_length, i_style, i_size,
                ui_txtcolr, ui_bgcolr, i_nobk, f_txtxpos, f_txtypos, i_rot)
    return retval


def flimage_add_text_struct(ptr_flimage, ptr_flimagetext):
    """flimage_add_text_struct(ptr_flimage, ptr_flimagetext) -> numstrings

    Places text into the image, using xfdata.FLIMAGE_TEXT class instance.
    If text starts with character '@' a symbol is drawn.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        ptr_flimagetext : pointer to xfdata.FLIMAGE_TEXT
            flimagetext class instance

    Returns
    -------
        numstrings : int
            current number of strings for the image, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_add_text_struct = library.cfuncproto(
        library.load_so_libflimage(), "flimage_add_text_struct",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE),
        cty.POINTER(xfdata.FLIMAGE_TEXT)],
        """int flimage_add_text_struct(FL_IMAGE * p1, const char * p2)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.verify_otherclassptr_type(ptr_flimagetext, \
            cty.POINTER(xfdata.FLIMAGE_TEXT))
    library.keep_elem_refs(ptr_flimage, ptr_flimagetext)
    retval = _flimage_add_text_struct(ptr_flimage, ptr_flimagetext)
    return retval


def flimage_delete_all_text(ptr_flimage):
    """flimage_delete_all_text(ptr_flimage)

    Deletes all the texts you added to an image.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> flimage_delete_all_text(pimg)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_delete_all_text = library.cfuncproto(
        library.load_so_libflimage(), "flimage_delete_all_text",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_delete_all_text(FL_IMAGE * p1)""")
    #library.check_if_initialized()
    library.keep_elem_refs(ptr_flimage)
    _flimage_delete_all_text(ptr_flimage)


def flimage_add_marker(ptr_flimage, name, xpos, ypos, width, height, lnstyle,
                       fill, rot, colr, bcolr):
    """flimage_add_marker(ptr_flimage, name, xpos, ypos, width, height,
    lnstyle, fill, rot, colr, bcolr) -> nummarkers

    Adds simple markers (e.g. arrows, circles, etc) to an image, passing
    parameters individually.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        name : str
            name of the marker to be added
        xpos : float
            horizontal position of the center of the marker in physical
            coordinates relative to the origin of the image
        ypos : float
            vertical position of the center of the marker in physical
            coordinates relative to the origin of the image
        width : float
            width of the bounding box of the marker in physical coordinates
        height : float
            height of the bounding box of the marker in physical coordinates
        lnstyle : int
            style of the line to draw. Values (from xfdata.py)
            FL_SOLID (Solid line. Default and most efficient), FL_USERDASH
            (Dashed line, but the dash pattern is used-definable via
            fl_dashedlinestyle(). Only the odd numbered segments are
            drawn with the foreground color), FL_USERDOUBLEDASH (Similar to
            FL_LINE_USERDASH but both even and odd numbered segments are
            drawn, with the even numbered segments drawn in the background
            color (as set by fl_bk_color()), FL_DOT (Dotted line [....]),
            FL_DOTDASH (Dash-dot-dash line [-.-.]), FL_DASH (Dashed line
            [----]), FL_LONGDASH (Long dashed line [--------]).
        fill : int
            flag if the marker should be filled or not. Values 1 (filled)
            or 0 (not filled)
        rot : int
            angle of rotation in tenth of degree
        colr : long_pos
            color of the marker (in packed RGB format)
        bcolr : long_pos
            currently unused

    Returns
    -------
        nummarkers : int
            current number of markers, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_add_marker = library.cfuncproto(
        library.load_so_libflimage(), "flimage_add_marker",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.STRING, cty.c_double,
        cty.c_double, cty.c_double, cty.c_double, cty.c_int, cty.c_int,
        cty.c_int, xfdata.FL_COLOR, xfdata.FL_COLOR],
        """int flimage_add_marker(FL_IMAGE * p1, const char * p2,
           double p3, double p4, double p5, double p6, int p7,
           int p8, int p9, FL_COLOR p10, FL_COLOR p11)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    s_name = library.convert_to_stringc(name)
    f_xpos = library.convert_to_doublec(xpos)
    f_ypos = library.convert_to_doublec(ypos)
    f_width = library.convert_to_doublec(width)
    f_height = library.convert_to_doublec(height)
    library.checkfatal_allowed_value_in_list(lnstyle, xfdata.LINESTYLE_list)
    i_lnstyle = library.convert_to_intc(lnstyle)
    i_fill = library.convert_to_intc(fill)
    i_rot = library.convert_to_intc(rot)
    ul_colr = library.convert_to_FL_COLOR(colr)
    ul_bcolr = library.convert_to_FL_COLOR(bcolr)
    library.keep_elem_refs(ptr_flimage, name, xpos, ypos, width, height, \
            lnstyle, fill, rot, colr, bcolr, s_name, f_xpos, f_ypos, \
            f_width, f_height, i_lnstyle, i_fill, i_rot, ul_colr, ul_bcolr)
    retval = _flimage_add_marker(ptr_flimage, s_name, f_xpos, f_ypos, f_width,
            f_height, i_lnstyle, i_fill, i_rot, ul_colr, ul_bcolr)
    return retval


def flimage_add_marker_struct(ptr_flimage, ptr_flimagemarker):
    """flimage_add_marker_struct(ptr_flimage, ptr_flimagemarker) -> nummarkers

    Adds simple markers (e.g. arrows, circles, etc) to an image, using
    xfdata.FLIMAGE_MARKER class instance.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        ptr_flimagemarker : pointer to xfdata.FLIMAGE_MARKER
            flimagemarker class instance

    Returns
    -------
        nummarkers : int
            current number of markers, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_add_marker_struct = library.cfuncproto(
        library.load_so_libflimage(), "flimage_add_marker_struct",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER( \
        xfdata.FLIMAGE_MARKER)],
        """int flimage_add_marker_struct(FL_IMAGE * p1, const char * p2)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.verify_otherclassptr_type(ptr_flimagemarker, \
            cty.POINTER(xfdata.FL_IMAGE))
    library.keep_elem_refs(ptr_flimage, ptr_flimagemarker)
    retval = _flimage_add_marker_struct(ptr_flimage, ptr_flimagemarker)
    return retval


def flimage_define_marker(mkrname, pyfn_FlimageMarkerDraw, psdraw):
    """flimage_define_marker(mkrname, pyfn_FlimageMarkerDraw, psdraw) -> result

    Defines a custom marker, using a specific function for drawing it.

    Parameters
    ----------
        mkrname : str
            name of the marker
        pyfn_FlimageMarkerDraw : python function to draw marker, no return
            name referring to function(ptr_flimageMarker)
        psdraw : str
            string that draws a marker in a square with the corner coordinates
            (-1, -1), (-1, 1), (1, 1) and (1, -1) in PostScript. e.g. the
            rectangle marker has the following psdraw string: "-1 -1 moveto -1
            1 lineto 1  1 lineto  1 -1 lineto  closepath"

    Returns
    -------
        result : int
            0, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    cfunc_none_flimagemarker = cty.CFUNCTYPE(None, cty.POINTER( \
            xfdata.FLIMAGE_MARKER))
    _flimage_define_marker = library.cfuncproto(
        library.load_so_libflimage(), "flimage_define_marker",
        cty.c_int, [xfdata.STRING, cfunc_none_flimagemarker,
        xfdata.STRING],
        """int flimage_define_marker(const char *, void ( * )
           (FLIMAGE_MARKER *), const char *)""")
    s_mkrname = library.convert_to_stringc(mkrname)
    library.verify_function_type(pyfn_FlimageMarkerDraw)
    cfn_FlimageMarkerDraw = cfunc_none_flimagemarker( \
            pyfn_FlimageMarkerDraw)
    s_psdraw = library.convert_to_stringc(psdraw)
    library.keep_elem_refs(mkrname, psdraw, s_mkrname, s_psdraw)
    library.keep_cfunc_refs(cfn_FlimageMarkerDraw, pyfn_FlimageMarkerDraw)
    retval = _flimage_define_marker(s_mkrname, cfn_FlimageMarkerDraw, \
            s_psdraw)
    return retval


def flimage_delete_all_markers(ptr_flimage):
    """flimage_delete_all_markers(ptr_flimage)

    Deletes all markers added to an image

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> flimage_delete_all_markers(pimg)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_delete_all_markers = library.cfuncproto(
        library.load_so_libflimage(), "flimage_delete_all_markers",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_delete_all_markers(FL_IMAGE * p1)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    _flimage_delete_all_markers(ptr_flimage)


def flimage_render_annotation(ptr_flimage, win):
    """flimage_render_annotation(ptr_flimage, win) -> result

    Makes the annotations a part of the image pixel. By default annotations
    placed on the image are kept seperate from the image pixels themselves,
    as keeping the annotation seperate makes it possible to later edit the
    annotations, and typically the screen has a lower resolutions than other
    output devices (by keeping the annotations separate from the pixels makes
    it possible to obtain better image qualities when the annotations are
    rendered on higher-resolution devices, e.g. a PostScript printer). Note
    that during rendering the image type may change depending on the
    capabilities of win. Annotations that were kept separately are deleted.
    The image must have been displayed at least once prior to calling this
    function for it to work correctly.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        win : long_pos
            window id

    Returns
    -------
        result : int
            0 (on success or if no markers and no texts), or -1 (on failure)

    Examples
    --------
        >>> if flimage_render_annotation(ptr_flimage, win0) != -1:
        >>> ... <something>

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_render_annotation = library.cfuncproto(
        library.load_so_libflimage(), "flimage_render_annotation",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.FL_WINDOW],
        """int flimage_render_annotation(FL_IMAGE * p1, FL_WINDOW p2)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    ul_win = library.convert_to_Window(win)
    library.keep_elem_refs(ptr_flimage, win, ul_win)
    retval = _flimage_render_annotation(ptr_flimage, ul_win)
    return retval


def flimage_error(ptr_flimage, text):
    """flimage_error(ptr_flimage, text)

    Calls the error message handler for an image.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image to be worked on
        text : str
            a brief message, such as "memory allocation failed" etc..

    Examples
    --------
        >>> flimage_error(pimg, "Memory allocation failed!")

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_error = library.cfuncproto(
        library.load_so_libflimage(), "flimage_error",
        None, [cty.POINTER(xfdata.FL_IMAGE), xfdata.STRING],
        """void flimage_error(FL_IMAGE * p1, const char * p2)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    s_text = library.convert_to_Window(text)
    library.keep_elem_refs(ptr_flimage, text, s_text)
    _flimage_error(ptr_flimage, s_text)


# built-in format supports

def flimage_enable_pnm():
    """flimage_enable_pnm()

    Enables use of PNM (Portable anymap) image format.

    Examples
    --------
        >>> flimage_enable_pnm()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_enable_pnm = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_pnm",
        None, [],
        """void flimage_enable_pnm()""")
    #library.check_if_initialized()
    _flimage_enable_pnm()


def flimage_set_fits_bits(numbits):
    """flimage_set_fits_bits(numbits) -> oldnumbits

    Defines the number of bits of a FITS image.

    Parameters
    ----------
        numbits : int
            number of bits to be set

    Returns
    -------
        oldnumbits : int
            old number of bits, or negative number (on failure)

    Examples
    --------
        >>> oldnbit = flimage_set_fits_bits(16)

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_set_fits_bits = library.cfuncproto(
        library.load_so_libflimage(), "flimage_set_fits_bits",
        cty.c_int, [cty.c_int],
        """int flimage_set_fits_bits(int p1)""")
    #library.check_if_initialized()
    i_numbits = library.convert_to_intc(numbits)
    library.keep_elem_refs(numbits, i_numbits)
    retval = _flimage_set_fits_bits(i_numbits)
    return retval


def flimage_jpeg_output_options(ptr_flimagejpegoption):
    """flimage_jpeg_output_options(ptr_flimagejpegoption)

    Defines quality and smoothing options of a JPEG image, using
    xfdata.FLIMAGE_JPEG_OPTION. The default quality factor for JPEG output
    is 75. In general, the higher the quality factor the better the image
    is, but the file size gets larger. The default smoothing factor is 0.

    Parameters
    ----------
        ptr_flimagejpegoption : pointer to xfdata.FLIMAGE_JPEG_OPTION
            flimage jpeg option class instance

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_jpeg_output_options = library.cfuncproto(
        library.load_so_libflimage(), "flimage_jpeg_output_options",
        None, [cty.POINTER(xfdata.FLIMAGE_JPEG_OPTION)],
        """void flimage_jpeg_output_options(FLIMAGE_JPEG_OPTION * p1)""")
    #library.check_if_initialized()
    library.verify_otherclassptr_type(ptr_flimagejpegoption, \
            cty.POINTER(xfdata.FLIMAGE_JPEG_OPTION))
    library.keep_elem_refs(ptr_flimagejpegoption)
    _flimage_jpeg_output_options(ptr_flimagejpegoption)


def flimage_pnm_output_options(rawformat):
    """flimage_pnm_output_options(rawformat)

    Defines variant options for PNM (ppm, pgm and pbm) images.

    Parameters
    ----------
        rawformat : int
            flag of supported variants. Values 1 (binary raw format,
            default) or 0 (ASCII format). If the output image is of type
            xfdata.FL_IMAGE_GRAY16, it is always ASCII format

    Examples
    --------
        >>> flimage_pnm_output_options(1)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_pnm_output_options = library.cfuncproto(
        library.load_so_libflimage(), "flimage_pnm_output_options",
        None, [cty.c_int],
        """void flimage_pnm_output_options(int p1)""")
    #library.check_if_initialized()
    i_rawformat = library.convert_to_intc(rawformat)
    library.keep_elem_refs(rawformat, i_rawformat)
    _flimage_pnm_output_options(i_rawformat)


def flimage_gif_output_options(interlace):
    """flimage_gif_output_options(interlace)

    Defines options of GIF images.

    Parameters
    ----------
        interlace : int
            flag if interlace is enabled/disabled. Values 1 (interlaced)
            or 0 (not interlaced).

    Examples
    --------
        >>> flimage_gif_output_options(1)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_gif_output_options = library.cfuncproto(
        library.load_so_libflimage(), "flimage_gif_output_options",
        None, [cty.c_int],
        """void flimage_gif_output_options(int p1)""")
    #library.check_if_initialized()
    i_interlace = library.convert_to_intc(interlace)
    library.keep_elem_refs(interlace, i_interlace)
    _flimage_gif_output_options(i_interlace)


def flimage_ps_options():
    """flimage_ps_options() -> ptr_flpscontrol

    Defines reading and writing options for PostScript.

    Returns
    -------
        ptr_flpscontrol : pointer to xfdata.FLPS_CONTROL
            flps control class instance

    Examples
    --------
        >>> flimage_ps_options()

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_ps_options = library.cfuncproto(
        library.load_so_libflimage(), "flimage_ps_options",
        cty.POINTER(xfdata.FLPS_CONTROL), [],
        """FLPS_CONTROL * flimage_ps_options()""")
    #library.check_if_initialized()
    retval = _flimage_ps_options()
    return retval


flimage_jpeg_options = flimage_jpeg_output_options
flimage_pnm_options = flimage_pnm_output_options
flimage_gif_options = flimage_gif_output_options


def flimage_get_number_of_formats():
    """flimage_get_number_of_formats() -> numformats

    Finds out the number of currently supported image formats.

    Returns
    -------
        numformats : int
            number of formats supported, for reading or writing or both

    Examples
    --------
        >>> flimage_get_number_of_formats()

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_get_number_of_formats = library.cfuncproto(
        library.load_so_libflimage(), "flimage_get_number_of_formats",
        cty.c_int, [],
        """int flimage_get_number_of_formats()""")
    #library.check_if_initialized()
    retval = _flimage_get_number_of_formats()
    return retval


def flimage_get_format_info(imgfmtnum):
    """flimage_get_format_info(imgfmtnum) -> ptr_flimageformatinfo

    Finds out detailed information for each image format.

    Parameters
    ----------
        imgfmtnum : int
            number between 1 and the return value of
            flimage_get_number_of_formats()

    Returns
    -------
        ptr_flimageformatinfo : pointer to xfdata.FLIMAGE_FORMAT_INFO
            ImageFormatInfo class instance

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_get_format_info = library.cfuncproto(
        library.load_so_libflimage(), "flimage_get_format_info",
        cty.POINTER(xfdata.FLIMAGE_FORMAT_INFO), [cty.c_int],
        """const FLIMAGE_FORMAT_INFO * flimage_get_format_info(int p1)""")
    #library.check_if_initialized()
    i_imgfmtnum = library.convert_to_intc(imgfmtnum)
    library.keep_elem_refs(imgfmtnum, i_imgfmtnum)
    retval = _flimage_get_format_info(i_imgfmtnum)
    return retval


# TODO: verify if it is useful in python
def fl_get_matrix(numrows, numcols, elemsize):
    """fl_get_matrix(numrows, numcols, elemsize) -> matrix

    Creates a 2-dimensional array of entities of size elemsize. The array
    is of numrows by numcols in size.

    Parameters
    ----------
        numrows : int
            number of rows
        numcols : int
            number of columns
        elemsize : int_pos
            size of matrix in bytes

    Returns
    -------
        num : *todo*
            a matrix?

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _fl_get_matrix = library.cfuncproto(
        library.load_so_libflimage(), "fl_get_matrix",
        cty.c_void_p, [cty.c_int, cty.c_int, cty.c_uint],
        """void * fl_get_matrix(int p1, int p2, unsigned int p3)""")
    #library.check_if_initialized()
    i_numrows = library.convert_to_intc(numrows)
    i_numcols = library.convert_to_intc(numcols)
    ui_elemsize = library.convert_to_uintc(elemsize)
    library.keep_elem_refs(numrows, numcols, elemsize, i_numrows, \
            i_numcols, ui_elemsize)
    retval = _fl_get_matrix(i_numrows, i_numcols, ui_elemsize)
    return retval


# TODO: verify if it is useful in python
def fl_make_matrix(numrows, numcols, elemsize, mem):
    """fl_make_matrix(numrows, numcols, elemsize, mem) -> matrix

    Makes a matrix out of a given piece of memory.

    Parameters
    ----------
        numrows : int
            number of rows
        numcols : int
            number of columns
        elemsize : int_pos
            size of matrix in bytes
        mem : *todo*
            memory

    Returns
    -------
        num : *todo*
            a matrix?

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _fl_make_matrix = library.cfuncproto(
        library.load_so_libflimage(), "fl_make_matrix",
        cty.c_void_p, [cty.c_int, cty.c_int, cty.c_uint, cty.c_void_p],
        """void * fl_make_matrix(int p1, int p2, unsigned int p3,
           void * p4)""")
    #library.check_if_initialized()
    i_numrows = library.convert_to_intc(numrows)
    i_numcols = library.convert_to_intc(numcols)
    ui_elemsize = library.convert_to_uintc(elemsize)
    ptr_mem = cty.cast(mem, cty.c_void_p)
    library.keep_elem_refs(numrows, numcols, elemsize, mem, i_numrows, \
            i_numcols, ui_elemsize, ptr_mem)
    retval = _fl_make_matrix(i_numrows, i_numcols, ui_elemsize, ptr_mem)
    return retval


# TODO: verify if it is useful in python
def fl_free_matrix(matrix):
    """fl_free_matrix(matrix)

    Frees a matrix allocated using fl_get_matrix() or fl_make_matrix().

    Parameters
    ----------
        matrix : *todo*
            a matrix?

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _fl_free_matrix = library.cfuncproto(
        library.load_so_libflimage(), "fl_free_matrix",
        None, [cty.c_void_p],
        """void fl_free_matrix(void * p1)""")
    #library.check_if_initialized()
    ptr_matrix = cty.cast(matrix, cty.c_void_p)
    library.keep_elem_refs(matrix, ptr_matrix)
    _fl_free_matrix(ptr_matrix)


# fl_init_RGBdatabase(text) function prototype (deprecated)


def fl_lookup_RGBcolor(colrname):
    """fl_lookup_RGBcolor(colrname) -> result, red, green, blue

    Finds out red, green and blue value corresponding to a color name.

    Parameters
    ----------
        colrname : str
            text of color name

    Returns
    -------
        result : int
            0 o or -1 (on failure)
        red : int
            red value
        green : int
            green value
        blue : int
            blue value

    Examples
    --------
        >>> *todo*

    API_diversion
    ----------
        API changed from XForms, upstream is
        fl_lookup_RGBcolor(text, r, g, b)

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _fl_lookup_RGBcolor = library.cfuncproto(
        library.load_so_libflimage(), "fl_lookup_RGBcolor",
        cty.c_int, [xfdata.STRING, cty.POINTER(cty.c_int), \
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],
        """int fl_lookup_RGBcolor(const char * p1, int * p2,
           int * p3, int * p4)""")
    #library.check_if_initialized()
    scolrname = library.convert_to_stringc(colrname)
    i_red, ptr_red = library.make_intc_and_pointer()
    i_green, ptr_green = library.make_intc_and_pointer()
    i_blue, ptr_blue = library.make_intc_and_pointer()
    library.keep_elem_refs(colrname, i_red, i_green, i_blue, colrname, \
            ptr_red, ptr_green, ptr_blue)
    retval = _fl_lookup_RGBcolor(scolrname, ptr_red, ptr_green, ptr_blue)
    return retval, i_red.value, i_green.value, i_blue.value


def flimage_add_format(formalname, shortname, extension, imagetype,
        pyfn_ImageIdentify, pyfn_ImageDescription, pyfn_ImageReadPixels,
        pyfn_ImageWriteImage):
    """flimage_add_format(formalname, shortname, extension, imagetype,
    pyfn_ImageIdentify, pyfn_ImageDescription, pyfn_ImageReadPixels,
    pyfn_ImageWriteImage) -> result

    Adds the newly specified image format to a recognized image format
    pool in the library.

    Parameters
    ----------
        formalname : str
            the formal name of image format, e.g. "Tag Image File Format"
        shortname : str
            an abbreviated name for the image format, e.g. "tiff"
        extension : str
            file extension, e.g. "tif". If it is empty (""), shortname will
            be used, instead
        imagetype : int
            the image type, generally one of the supported image types (e.g.
            xfdata.FL_IMAGE_RGB), but it does not have to. For image file
            formats that are capable of holding more than one type of images,
            this field can be set to indicate this by OR-ing the supported
            types together (e.g., xfdata.FL_IMAGE_RGB|FL_IMAGE_GRAY).
            However, when description returns, the image type should be set
            to the actual type in the file.
        pyfn_ImageIdentify : function to identify format, returned value
            name referring to function(ptr_file) -> num.
            This function should return 1 if the file pointed to by the file
            pointer passed in is the expected image format (e.g by checking
            signature). It should return a negative number if the file is
            not recognized. The decision if the file pointer should be
            rewound or not is between this function and the description
            function.
        pyfn_ImageDescription : function to set description, returned value
            name referring to function(ptr_flimage) -> num.
            This function in general should set the image dimension and type
            fields (and colormap length for color index images) if
            successful, so the driver can allocate the necessary memory for
            read pixel. Of course, if read_pixels elects to allocate memory
            itself, the description function does not have to set any fields.
            However, if reading should continue, the function should return
            1, otherwise a negative number.
        pyfn_ImageReadPixels : python function to read pixels, returned value
            name referring to function(ptr_flimage) -> num.
            This function reads the pixels from the file and fills one of the
            pixel matrix in the image structure depending on the type. If
            reading is successful, a non-negative number should be returned
            otherwise a negative number should be returned. Upon entry,
            ptr_flimage.contents.completed is set to zero. The function should
            not close the file.
        pyfn_ImageWriteImage : python function to write image, returned value
            name referring to function(ptr_flimage) -> num.
            This function takes an image structure and should write the image
            out in a format it knows. Prior to calling this routine, the
            driver will have already converted the image type to the type it
            wants. The function should return 1 on success and a negative
            number otherwise. If only reading of the image format is
            supported this parameter can be set to None. The function should
            write to file stream ptr_flimage.contents.fpout.

    Returns
    -------
        result : int
            num, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    #FLIMAGE_Identify = cty.CFUNCTYPE(cty.c_int, cty.POINTER(xfdata.FILE))
    #FLIMAGE_Description = cty.CFUNCTYPE(cty.c_int, cty.POINTER( \
    #    xfdata.FL_IMAGE))
    #FLIMAGE_Read_Pixels = cty.CFUNCTYPE(cty.c_int, cty.POINTER( \
    #    xfdata.FL_IMAGE))
    #FLIMAGE_Write_Image = cty.CFUNCTYPE(cty.c_int, cty.POINTER( \
    #    xfdata.FL_IMAGE))
    _flimage_add_format = library.cfuncproto(
        library.load_so_libflimage(), "flimage_add_format",
        cty.c_int, [xfdata.STRING, xfdata.STRING, xfdata.STRING, cty.c_int,
        xfdata.FLIMAGE_Identify, xfdata.FLIMAGE_Description,
        xfdata.FLIMAGE_Read_Pixels, xfdata.FLIMAGE_Write_Image],
        """int flimage_add_format(const char * p1, const char * p2,
           const char * p3, int p4, FLIMAGE_Identify p5,
           FLIMAGE_Description p6, FLIMAGE_Read_Pixels p7,
           FLIMAGE_Write_Image p8)""")
    #library.check_if_initialized()
    s_formalname = library.convert_to_stringc(formalname)
    s_shortname = library.convert_to_stringc(shortname)
    s_extension = library.convert_to_stringc(extension)
    library.checkfatal_allowed_value_in_list(imagetype, \
            xfdata.FLIMAGETYPE_list)
    i_imagetype = library.convert_to_intc(imagetype)
    library.verify_function_type(pyfn_ImageIdentify)
    cfn_ImageIdentify = xfdata.FLIMAGE_Identify(pyfn_ImageIdentify)
    library.verify_function_type(pyfn_ImageDescription)
    cfn_ImageDescription = xfdata.FLIMAGE_Description(pyfn_ImageDescription)
    library.verify_function_type(pyfn_ImageReadPixels)
    cfn_ImageReadPixels = xfdata.FLIMAGE_Read_Pixels(pyfn_ImageReadPixels)
    library.verify_function_type(pyfn_ImageWriteImage)
    cfn_ImageWriteImage = xfdata.FLIMAGE_Write_Image(pyfn_ImageWriteImage)
    library.keep_cfunc_refs(cfn_ImageIdentify, pyfn_ImageIdentify,
            cfn_ImageDescription, pyfn_ImageDescription, cfn_ImageReadPixels,
            pyfn_ImageReadPixels, cfn_ImageWriteImage, pyfn_ImageWriteImage)
    library.keep_elem_refs(formalname, shortname, extension, imagetype, \
                   s_formalname, s_shortname, s_extension, i_imagetype)
    retval = _flimage_add_format(s_formalname, s_shortname, s_extension, \
                    i_imagetype, cfn_ImageIdentify, cfn_ImageDescription, \
                    cfn_ImageReadPixels, cfn_ImageWriteImage)
    return retval


def flimage_set_annotation_support(imgnum, yesno):
    """flimage_set_annotation_support(imgnum, yesno)

    Defines support for annotations.

    Parameters
    ----------
        imgnum : int
            image number?. Values between 0 and number of images?
        yesno : int
            flag to enable/disable support. Values 1 (to enable) or 0
            (to disable)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_set_annotation_support = library.cfuncproto(
        library.load_so_libflimage(), "flimage_set_annotation_support",
        None, [cty.c_int, cty.c_int],
        """void flimage_set_annotation_support(int p1, int p2)""")
    #library.check_if_initialized()
    i_imgnum = library.convert_to_intc(imgnum)
    i_yesno = library.convert_to_intc(yesno)
    library.keep_elem_refs(imgnum, yesno, i_imgnum, i_yesno)
    _flimage_set_annotation_support(i_imgnum, i_yesno)


def flimage_getcolormap(ptr_flimage):
    """flimage_getcolormap(ptr_flimage)

    Finds out color map for an image.

    Parameters
    ----------
      ptr_flimage : pointer to xfdata.FL_IMAGE
        image

    Returns
    -------
        result : int
            0, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_getcolormap = library.cfuncproto(
        library.load_so_libflimage(), "flimage_getcolormap",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_getcolormap(FL_IMAGE * p1)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    retval = _flimage_getcolormap(ptr_flimage)
    return retval


def fl_select_mediancut_quantizer():
    """fl_select_mediancut_quantizer()

    Selects median cut quantizer, who uses Heckbert's median cut algorithm
    followed by Floyd-Steinberg dithering after which the pixels are mapped
    to the colors selected. This tends to give better images because of the
    dithering step. However, in this particular implementation, the number
    of quantized colors is limited to 256. Color quantization is one way of
    reduce the number of colors in the original image to display a RGB image
    on a color-mapped device of limited depth.

    Examples
    --------
        >>> flimage_select_mediancut_quantizer()

    Notes
    -----
        Status: Tested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _fl_select_mediancut_quantizer = library.cfuncproto(
        library.load_so_libflimage(), "fl_select_mediancut_quantizer",
        None, [],
        """void fl_select_mediancut_quantizer()""")
    #library.check_if_initialized()
    _fl_select_mediancut_quantizer()


# simple image processing routines

def flimage_convolve(ptr_flimage, kernel, krows, kcols):
    """flimage_convolve(ptr_flimage, kernel, krows, kcols) -> result

    Takes a convolution kernel of krows by kcols and convolves it with
    the image. The result replaces the input image.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        kernel : *todo*
            The kernel size should be odd, and should be allocated by
            fl_get_matrix(). *todo*
        krows : int
            number of kernel rows
        kcols : int
            number of kernel cols

    Returns
    -------
        result : int
            0 , or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK (how to create kernel)
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_convolve = library.cfuncproto(
        library.load_so_libflimage(), "flimage_convolve",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE),
        cty.POINTER(cty.POINTER(cty.c_int)), cty.c_int, cty.c_int],
        """int flimage_convolve(FL_IMAGE * p1, int * * p2, int p3,
           int p4)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    i_krows = library.convert_to_intc(krows)
    i_kcols = library.convert_to_intc(kcols)
    library.keep_elem_refs(ptr_flimage, kernel, krows, kcols, i_krows, i_kcols)
    retval = _flimage_convolve(ptr_flimage, kernel, i_krows, i_kcols)
    return retval


def flimage_convolvea(ptr_flimage, kernel, krows, kcols):
    """flimage_convolvea(ptr_flimage, kernel, krows, kcols) -> result

    Takes a convolution kernel of krows by kcols and convolves it with the
    image. The result replaces the input image. It uses a kernel that is a
    C 2-dimensional array, kernel[krows][kcols] (cast to a pointer to int).

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        kernel : *todo*
            C 2-dimensional array *todo*
        krows : int
            number of kernel rows
        kcols : int
            number of kernel columns

    Returns
    -------
        result : int
            0, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK (how to create kernel)
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_convolvea = library.cfuncproto(
        library.load_so_libflimage(), "flimage_convolvea",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER(cty.c_int),
        cty.c_int, cty.c_int],
        """int flimage_convolvea(FL_IMAGE * p1, int * p2, int p3, int p4)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    ptr_kernel = cty.cast(kernel, cty.POINTER(cty.c_int))   # to be verified
    i_krows = library.convert_to_intc(krows)
    i_kcols = library.convert_to_intc(kcols)
    library.keep_elem_refs(ptr_flimage, kernel, krows, kcols, ptr_kernel, \
            i_krows, i_kcols)
    retval = _flimage_convolvea(ptr_flimage, ptr_kernel, i_krows, i_kcols)
    return retval


def flimage_tint(ptr_flimage, packed, opacity):
    """flimage_tint(ptr_flimage, packed, opacity) -> result

    Emulates the effect of looking at an image through a piece of colored
    glass. Tint is most useful in cases where you want to put some annotations
    on the image, but do not want to use a uniform and opaque background that
    completely obscures the image behind. By using tint, you can have a
    background that provides some contrast to the text, yet not obscures the
    image beneath completely. Tint operation uses the subimage settings.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        packed : int_pos
            packed RGB color, specifying the color of the glass.
        opacity : float
            how much the color of the image is absorbed by the glass. Values
            between 0 (the glass is totally transparent, i.e. the glass has
            no effect) and 1.0 (total opaqueness, i.e. all you see is the
            color of the glass. Any value between these two extremes results
            in a color that is a combination of the pixel color and the
            glass color.

    Returns
    -------
        num. : int
            *todo*, -1 (on failure)

    Examples
    --------
        >>> pkdcolr = flxbasic.FL_PACK3(20, 30, 40)
        >>> exval = flimage_tint(pimg, pkdcolr, 0.5)

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_tint = library.cfuncproto(
        library.load_so_libflimage(), "flimage_tint",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_uint, cty.c_double],
        """int flimage_tint(FL_IMAGE * p1, unsigned int p2, double p3)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    ui_packed = library.convert_to_uintc(packed)
    f_opacity = library.convert_to_floatc(opacity)
    library.keep_elem_refs(ptr_flimage, packed, opacity, ui_packed, f_opacity)
    retval = _flimage_tint(ptr_flimage, ui_packed, f_opacity)
    return retval


def flimage_rotate(ptr_flimage, angle, subpixel):
    """flimage_rotate(ptr_flimage, angle, subpixel) -> result

    Does an image rotation. Repeated rotations should be avoided if possible.
    If you have to call it more than once it is a good idea to crop after
    rotations in order to get rid of the regions that contain only fill color.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        angle : int
            the angle in one-tenth of a degree (i.e., a 45 degree rotation
            should be specified as 450) with a positive sign for
            counter-clock rotation.
        subpixel : int
            if subpixel sampling should be enabled. Values (from xfdata.py)
            FLIMAGE_NOSUBPIXEL (scale with no subpixel sampling) or
            FLIMAGE_SUBPIXEL (scale with subpixel sampling). If enabled, the
            resulting image pixels are interpolated from the original pixels;
            this usually has an "anti-aliasing" effect that leads to less
            severe jagged edges and similar artifacts commonly encountered in
            rotations. However, it also means that a color indexed image gets
            converted to a RGB image. If preserving the pixel value is
            important, you should not turn subpixel sampling on.

    Returns
    -------
        result : int
            0, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_rotate = library.cfuncproto(
        library.load_so_libflimage(), "flimage_rotate",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int],
        """int flimage_rotate(FL_IMAGE * p1, int p2, int p3)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.checkfatal_allowed_value_in_list(subpixel, \
            xfdata.FLIMAGESUBPIXROT_list)
    i_angle = library.convert_to_intc(angle)
    i_subpixel = library.convert_to_intc(subpixel)
    library.keep_elem_refs(ptr_flimage, angle, subpixel, i_angle, i_subpixel)
    retval = _flimage_rotate(ptr_flimage, i_angle, i_subpixel)
    return retval


def flimage_flip(ptr_flimage, flipaxis):
    """flimage_flip(ptr_flimage, flipaxis) -> result

    Does the mirror operation in x- or y-direction at the center. For
    example, to flip the columns of an image, the left and right of the
    image are flipped (just like having a vertical mirror in the center of
    the image) thus the first pixel on any given row becomes the last, and
    the last pixel becomes the first etc.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        flipaxis : int or char
            desired direction of flipping. Values 'c' (column, horizontal
            flipping) or 'r' (row, vertical flipping)

    Returns
    -------
        result : int
            0, or -1 (on failure)

    Examples
    --------
        >>> resl = flimage_filp(pimg, 'c')

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_flip = library.cfuncproto(
        library.load_so_libflimage(), "flimage_flip",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int],
        """int flimage_flip(FL_IMAGE * p1, int p2)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    if isinstance(flipaxis, str):
        # workaround to let a character as int argument
        ordflipaxis = ord(flipaxis)
    else:
        ordflipaxis = flipaxis
    i_flipaxis = library.convert_to_intc(ordflipaxis)
    library.keep_elem_refs(ptr_flimage, flipaxis, ordflipaxis, i_flipaxis)
    retval = _flimage_flip(ptr_flimage, i_flipaxis)
    return retval


def flimage_scale(ptr_flimage, newwidth, newheight, option):
    """flimage_scale(ptr_flimage, newwidth, newheight, option) -> result

    Scales an image to any desired size with or without subpixel sampling.
    Without subpixel sampling simple pixel replication is used, otherwise a
    box average algorithm is employed that yields an anti-aliased image with
    much less artifacts.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        newwidth : int
            desired image width
        newheight : int
            desired image height
        option : int
            option to scale the image to the desired size but keeping the
            aspect ratio of the image the same by filling the part of the
            image that  would otherwise be empty. Values (from xfdata.py)
            FLIMAGE_NOSUBPIXEL, FLIMAGE_SUBPIXEL, FLIMAGE_ASPECT,
            FLIMAGE_CENTER, FLIMAGE_NOCENTER. Any value can be single or
            bitwise-ORed.

    Returns
    -------
        result : int
            0 (on success or if no scaling needed), or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_scale = library.cfuncproto(
        library.load_so_libflimage(), "flimage_scale",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int,
        cty.c_int],
        """int flimage_scale(FL_IMAGE * p1, int p2, int p3, int p4)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    i_newwidth = library.convert_to_intc(newwidth)
    i_newheight = library.convert_to_intc(newheight)
    i_option = library.convert_to_intc(option)
    library.keep_elem_refs(ptr_flimage, newwidth, newwidth, option, \
            i_newwidth, i_newwidth, i_option)
    retval = _flimage_scale(ptr_flimage, i_newwidth, i_newheight, i_option)
    return retval


def flimage_warp(ptr_flimage, matrix, newwidth, newheight, subpixel):
    """flimage_warp(ptr_flimage, matrix, newwidth, newheight, subpixel)
    -> result

    Does transformation of pixel coordinates. Rotation, scaling, shearing
    etc. are examples of (linear and non-perspective) image warping. User can
    specify whatever size he/she wants and the warp function will fill the
    empty grid location with the fill color. This is how the aspect ratio
    preserving scaling is implemented. The image is transformed in place.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        matrix : *todo*
            the warp matrix
        newwidth : int
            desired image width
        newheight : int
            desired image height
        subpixel : int
            if subpixel sampling should be used. Although subpixel sampling
            adds processing time, it generally improves image quality
            significantly. Values (from xfdata.py) any logical OR of
            FLIMAGE_NOSUBPIXEL, FLIMAGE_SUBPIXEL and FLIMAGE_NOCENTER (only
            useful if you specify an image dimension that is larger than the
            warped image, and in that case the warped image is flushed
            top-left within the image grid, otherwise it is centered).

    Returns
    -------
        result : int
            0, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_warp = library.cfuncproto(
        library.load_so_libflimage(), "flimage_warp",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER(cty.c_float * 2),
        cty.c_int, cty.c_int, cty.c_int],
        """int flimage_warp(FL_IMAGE * p1, float p2[][2], int p3, int p4,
           int p5)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    ptr_matrix = cty.cast(matrix, cty.c_void_p)         # to be verified
    i_newwidth = library.convert_to_intc(newwidth)
    i_newheight = library.convert_to_intc(newheight)
    i_subpixel = library.convert_to_intc(subpixel)
    library.keep_elem_refs(ptr_flimage, matrix, newwidth, newheight, subpixel,
            ptr_matrix, i_newwidth, i_newheight, i_subpixel)
    retval = _flimage_warp(ptr_flimage, ptr_matrix, i_newwidth, i_newheight,
            i_subpixel)
    return retval


def flimage_autocrop(ptr_flimage, bgcolr):
    """flimage_autocrop(ptr_flimage, bgcolr) -> result

    Automatically crops an image using the background as the color to crop,
    by searching the image from all four sides and removing all contiguous
    regions of the uniform background from the sides. The image is modified
    in place.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        bgcolr : int_pos
            background color to crop. If it is xfdata.FLIMAGE_AUTOCOLOR, the
            background is chosen as the first pixel of the image.

    Returns
    -------
        result : int
            0, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_autocrop = library.cfuncproto(
        library.load_so_libflimage(), "flimage_autocrop",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_uint],
        """int flimage_autocrop(FL_IMAGE * p1, unsigned int p2)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    ui_bgcolr = library.convert_to_uintc(bgcolr)
    library.keep_elem_refs(ptr_flimage, bgcolr, ui_bgcolr)
    retval = _flimage_autocrop(ptr_flimage, ui_bgcolr)
    return retval


def flimage_get_autocrop(ptr_flimage, bgcolr):
    """flimage_get_autocrop(ptr_flimage, bgcolr) -> result, xloff, ytoff,
    xroff, yboff

    Finds out the auto-cropping offsets (from left, right, top and bottom
    sides) of an image.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        bgcolr : int_pos
            background color to crop. If it is xfdata.FLIMAGE_AUTOCOLOR, the
            background is chosen as the first pixel of the image.

    Returns
    -------
        result : int
            0, or -1 (on failure)
        xloff : int
            offset from left side
        ytoff : int
            offset from top side
        xroff : int
            offset from right side
        yboff : int
            offset from bottom side

    Examples
    --------
        >>> *todo*

    API_diversion
    ----------
        API changed from XForms, upstream is
        flimage_get_autocrop(ptr_flimage, bk, xl, yt, xr, yb)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_get_autocrop = library.cfuncproto(
        library.load_so_libflimage(), "flimage_get_autocrop",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_uint,
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],
        """int flimage_get_autocrop(FL_IMAGE * p1, unsigned int p2,
           int * p3, int * p4, int * p5, int * p6)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    ui_bgcolr = library.convert_to_uintc(bgcolr)
    i_xloff, ptr_xloff = library.make_intc_and_pointer()
    i_ytoff, ptr_ytoff = library.make_intc_and_pointer()
    i_xroff, ptr_xroff = library.make_intc_and_pointer()
    i_yboff, ptr_yboff = library.make_intc_and_pointer()
    library.keep_elem_refs(ptr_flimage, bgcolr, ui_bgcolr, i_xloff, i_ytoff,
            i_xroff, i_yboff, ptr_xloff, ptr_ytoff, ptr_xroff, ptr_yboff)
    retval = _flimage_get_autocrop(ptr_flimage, ui_bgcolr, ptr_xloff,
            ptr_ytoff, ptr_xroff, ptr_yboff)
    return retval, i_xloff.value, i_ytoff.value, i_xroff.value, i_yboff.value


def flimage_crop(ptr_flimage, xloff, ytoff, xroff, yboff):
    """flimage_crop(ptr_flimage, xloff, ytoff, xroff, yboff)

    Crops an image, using offsets supplied by the user.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image to be cropped
        xloff : int
            offset from left side. If it is negative, it indicates
            enlargement of the image. (e.g. if it is 1 the cropping
            removes the first column from the image).
        ytoff : int
            offset from top side. If it is negative, it indicates
            enlargement of the image. (e.g. if it is 1 the cropping
            removes the first row from the image).
        xroff : int
            offset from right side. If it is negative, it indicates
            enlargement of the image. (e.g. if it is 1 the cropping
            removes the last column from the image).
        yboff : int
            offset from bottom side. If it is negative, it indicates
            enlargement of the image. (e.g. if it is 1 the cropping
            removes the last row from the image).

    Returns
    -------
        result : int
            0, or  -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_crop = library.cfuncproto(
        library.load_so_libflimage(), "flimage_crop",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int,
        cty.c_int, cty.c_int],
        """int flimage_crop(FL_IMAGE * p1, int p2, int p3,
           int p4, int p5)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    i_xloff = library.convert_to_intc(xloff)
    i_ytoff = library.convert_to_intc(ytoff)
    i_xroff = library.convert_to_intc(xroff)
    i_yboff = library.convert_to_intc(yboff)
    library.keep_elem_refs(ptr_flimage, xloff, ytoff, xroff, yboff, i_xloff, \
            i_ytoff, i_xroff, i_yboff)
    retval = _flimage_crop(ptr_flimage, i_xloff, i_ytoff, i_xroff, i_yboff)
    return retval


def flimage_replace_pixel(ptr_flimage, targetcolr, newcolr):
    """flimage_replace_pixel(ptr_flimage, targetcolr, newcolr) -> result

    Replaces all color targetcolr with the new desired color.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        targetcolr : int_pos
            color to be replaced
        newcolr : int_pos
            new color to be used

    Returns
    -------
        result : int
            0, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_replace_pixel = library.cfuncproto(
        library.load_so_libflimage(), "flimage_replace_pixel",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_uint, cty.c_uint],
        """int flimage_replace_pixel(FL_IMAGE * p1, unsigned int p2,
           unsigned int p3)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    ui_targetcolr = library.convert_to_uintc(targetcolr)
    ui_newcolr = library.convert_to_uintc(newcolr)
    library.keep_elem_refs(ptr_flimage, targetcolr, newcolr, ui_targetcolr,
            ui_newcolr)
    retval = _flimage_replace_pixel(ptr_flimage, ui_targetcolr, ui_newcolr)
    return retval


def flimage_transform_pixels(ptr_flimage, red, green, blue):
    """flimage_transform_pixels(ptr_flimage, red, green, blue)

    Processes an image in place with RGB transformation and replaces it.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        red : int
            lookup tables for red color of a length of at least
            FL_PCMAX + 1 (256).
        green : int
            lookup tables for green color of a length of at least
            FL_PCMAX + 1 (256).
        blue : int
            lookup tables for blue color of a length of at least
            FL_PCMAX + 1 (256).

    Returns
    -------
        result : int
            0, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_transform_pixels = library.cfuncproto(
        library.load_so_libflimage(), "flimage_transform_pixels",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],
        """int flimage_transform_pixels(FL_IMAGE * p1, int * p2,
           int * p3, int * p4)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    ptr_red = cty.cast(red, cty.POINTER(cty.c_int))        # to be verified
    ptr_green = cty.cast(green, cty.POINTER(cty.c_int))    # to be verified
    ptr_blue = cty.cast(blue, cty.POINTER(cty.c_int))      # to be verified
    library.keep_elem_refs(ptr_flimage, red, green, blue, ptr_red, \
            ptr_green, ptr_blue)
    retval = _flimage_transform_pixels(ptr_flimage, ptr_red, ptr_green, \
             ptr_blue)
    return retval


def flimage_windowlevel(ptr_flimage, winlvl, width):
    """flimage_windowlevel(ptr_flimage, winlvl, width)

    Defines the window level for an image. If it points to a multiple image,
    window level parameters are changed for all images.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        winlvl : int
            new level of window
        width : int
            width. If zero disables window leveling.

    Returns
    -------
        result : int
            1 (if window level parameters are modified), otherwise 0 is
            returned.

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_windowlevel = library.cfuncproto(
        library.load_so_libflimage(), "flimage_windowlevel",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int],
        """int flimage_windowlevel(FL_IMAGE * p1, int p2, int p3)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    i_winlvl = library.convert_to_intc(winlvl)
    i_width = library.convert_to_intc(width)
    library.keep_elem_refs(ptr_flimage, winlvl, width, i_winlvl, i_width)
    retval = _flimage_windowlevel(ptr_flimage, i_winlvl, i_width)
    return retval


def flimage_enhance(ptr_flimage, delta):
    """flimage_enhance(ptr_flimage, delta)

    Enhances an image *todo*

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        delta : int
            unused.

    Returns
    -------
        result : int
            0?

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_enhance = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enhance",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int],
        """int flimage_enhance(FL_IMAGE * p1, int p2)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    i_delta = library.convert_to_intc(delta)     # unused
    library.keep_elem_refs(ptr_flimage, delta, i_delta)
    retval = _flimage_enhance(ptr_flimage, i_delta)
    return retval


# TODO: verify if ptr_flimage should be a returned param, instead.
def flimage_from_pixmap(ptr_flimage, pixmap):
    """flimage_from_pixmap(ptr_flimage, pixmap) -> result

    Converts a Pixmap to an image. *todo*

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        pixmap : long_pos
            pixmap resource id

    Returns
    -------
        num. : int
            *todo*, or -1 (failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_from_pixmap = library.cfuncproto(
        library.load_so_libflimage(), "flimage_from_pixmap",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.Pixmap],
        """int flimage_from_pixmap(FL_IMAGE * p1, Pixmap p2)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    ul_pixmap = library.convert_to_Pixmap(pixmap)
    library.keep_elem_refs(ptr_flimage, pixmap, ul_pixmap)
    retval = _flimage_from_pixmap(ptr_flimage, ul_pixmap)
    return retval


def flimage_to_pixmap(ptr_flimage, win):
    """flimage_to_pixmap(ptr_flimage, win) -> pixmap

    Converts an image into a Pixmap (a server side resource) that
    can be used in the pixmap flobject.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        win : long_pos
            window id

    Returns
    -------
        pixmap : long_pos
            pixmap resource id

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_to_pixmap = library.cfuncproto(
        library.load_so_libflimage(), "flimage_to_pixmap",
        xfdata.Pixmap, [cty.POINTER(xfdata.FL_IMAGE), xfdata.FL_WINDOW],
        """Pixmap flimage_to_pixmap(FL_IMAGE * p1, FL_WINDOW p2)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    ul_win = library.convert_to_Window(win)
    library.keep_elem_refs(ptr_flimage, win, ul_win)
    retval = _flimage_to_pixmap(ptr_flimage, ul_win)
    return retval


def flimage_dup(ptr_flimage):
    """flimage_dup(ptr_flimage) -> ptr_flimage

    Duplicates an image and returns the duplicated image. At the moment,
    only the first image is duplicated even if the input image has multiple
    frames. Furthermore, markers and annotations are not duplicated.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image to be duplicated

    Returns
    -------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            duplicated image class instance, or None (on failure)

    Examples
    --------
        >>> pimg2 = flimage_dup(pimg1)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_dup = library.cfuncproto(
        library.load_so_libflimage(), "flimage_dup",
        cty.POINTER(xfdata.FL_IMAGE), [cty.POINTER(xfdata.FL_IMAGE)],
        """FL_IMAGE * flimage_dup(FL_IMAGE * p1)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    retval = _flimage_dup(ptr_flimage)
    return retval


# Miscellaneous prototypes

def fl_get_submatrix(inmatrix, numrows, numcols, startrow, startcol, \
                     endrow, endcol, elemsize):
    """fl_get_submatrix(inmatrix, numrows, numcols, startrow, startcol,
    endrow, endcol, elemsize)

    Grabs a piece of an image matrix. The piece is of nrows by ncols in
    size.

    Parameters
    ----------
        inmtrx : *todo*
            image matrix
        numrows : int
            number of rows
        numcols : int
            number of columns
        startrow : int
            initial row? (r1)
        startcol : int
            initial column? (c1)
        endrow : int
            final row? (rs)
        endcol : int
            final column? (cs)
        elemsize : int_pos
            size of matrix in bytes

    Returns
    -------
        num. : *todo*
            submatrix

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _fl_get_submatrix = library.cfuncproto(
        library.load_so_libflimage(), "fl_get_submatrix",
        cty.c_void_p, [cty.c_void_p, cty.c_int, cty.c_int, cty.c_int,
        cty.c_int, cty.c_int, cty.c_int, cty.c_uint],
        """void * fl_get_submatrix(void * p1, int p2, int p3, int p4,
           int p5, int p6, int p7, unsigned int p8)""")
    #library.check_if_initialized()
    ptr_inmatrix = cty.cast(inmatrix, cty.c_void_p)
    i_numrows = library.convert_to_intc(numrows)
    i_numcols = library.convert_to_intc(numcols)
    i_startrow = library.convert_to_intc(startrow)
    i_startcol = library.convert_to_intc(startcol)
    i_endrow = library.convert_to_intc(endrow)
    i_endcol = library.convert_to_intc(endcol)
    ui_elemsize = library.convert_to_uintc(elemsize)
    library.keep_elem_refs(inmatrix, numrows, numcols, startrow, startcol, \
            endrow, endcol, elemsize, ptr_inmatrix, i_numrows, i_numcols, \
            i_startrow, i_startcol, i_endrow, i_endcol, ui_elemsize)
    retval = _fl_get_submatrix(ptr_inmatrix, i_numrows, i_numcols, \
            i_startrow, i_startcol, i_endrow, i_endcol, ui_elemsize)
    return retval


def fl_j2pass_quantize_packed(packed, width, height, maxcolr, ci, \
            actualcolr, redlut, greenlut, bluelut, ptr_flimage):
    """fl_j2pass_quantize_packed(packed, width, height, maxcolr, ci,
    actualcolr, redlut, greenlut, bluelut, ptr_flimage) -> num

    *todo*

    Parameters
    ----------
        packed : *todo*
            *todo*
        width : int
            *todo*
        height : int
            *todo*
        maxcolr : int
            *todo*
        ci : *todo*
            *todo*
        actualcolr : int
            *todo*
        redlut : int
            *todo*
        greenlut : int
            *todo*
        bluelut : int
            *todo*
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _fl_j2pass_quantize_packed = library.cfuncproto(
        library.load_so_libflimage(), "fl_j2pass_quantize_packed",
        cty.c_int, [cty.POINTER(cty.POINTER(cty.c_uint)), cty.c_int,
        cty.c_int, cty.c_int, cty.POINTER(cty.POINTER(cty.c_ushort)),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(xfdata.FL_IMAGE)],
        """int fl_j2pass_quantize_packed(unsigned int * * p1, int p2,
           int p3, int p4, short unsigned int * * p5, int * p6,
           int * p7, int * p8, int * p9, FL_IMAGE * p10)""")
    #library.check_if_initialized()
    # packed to be handled
    i_width = library.convert_to_intc(width)
    i_height = library.convert_to_intc(height)
    i_maxcolr = library.convert_to_intc(maxcolr)
    # ci to be handled
    i_actualcolr = library.convert_to_intc(actualcolr)
    ptr_redlut = cty.cast(redlut, cty.POINTER(cty.c_int))
    ptr_greenlut = cty.cast(greenlut, cty.POINTER(cty.c_int))
    ptr_bluelut = cty.cast(bluelut, cty.POINTER(cty.c_int))
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(packed, width, height, maxcolr, ci, actualcolr, \
            redlut, greenlut, bluelut, ptr_flimage, i_width, i_height, \
            i_maxcolr, i_actualcolr, ptr_redlut, ptr_greenlut, ptr_bluelut)
    retval = _fl_j2pass_quantize_packed(packed, i_width, i_width, \
            i_maxcolr, ci, i_actualcolr, ptr_redlut, ptr_greenlut, \
            ptr_bluelut, ptr_flimage)
    return retval


def fl_j2pass_quantize_rgb(red, green, blue, width, height, maxcolr, ci, \
            actualcolr, redlut, greenlut, bluelut, ptr_flimage):
    """fl_j2pass_quantize_rgb(red, green, blue, width, height, maxcolr, ci,
    actualcolr, redlut, greenlut, bluelut, ptr_flimage) -> num

    *todo*

    Parameters
    ----------
        red : *todo*
            *todo*
        green : *todo*
            *todo*
        blue : *todo*
            *todo*
        width : int
            *todo*
        height : int
            *todo*
        maxcolr : int
            *todo*
        ci : *todo*
            *todo*
        actualcolr : int
            *todo*
        redlut : int
            *todo*
        greenlut : int
            *todo*
        bluelut : int
            *todo*
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Returns
    -------
        num. : int
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _fl_j2pass_quantize_rgb = library.cfuncproto(
        library.load_so_libflimage(), "fl_j2pass_quantize_rgb",
        cty.c_int, [cty.POINTER(cty.POINTER(cty.c_ubyte)),
        cty.POINTER(cty.POINTER(cty.c_ubyte)),
        cty.POINTER(cty.POINTER(cty.c_ubyte)), cty.c_int, cty.c_int,
        cty.c_int, cty.POINTER(cty.POINTER(cty.c_ushort)),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int),
        cty.POINTER(xfdata.FL_IMAGE)],
        """int fl_j2pass_quantize_rgb(unsigned char * * p1,
           unsigned char * * p2, unsigned char * * p3, int p4, int p5,
           int p6, short unsigned int * * p7, int * p8, int * p9,
           int * p10, int * p11, FL_IMAGE * p12)""")
    #library.check_if_initialized()
    # red to be handled
    # green to be handled
    # blue to be handled
    i_width = library.convert_to_intc(width)
    i_height = library.convert_to_intc(height)
    i_maxcolr = library.convert_to_intc(maxcolr)
    # ci to be handled
    i_actualcolr = library.convert_to_intc(actualcolr)
    ptr_redlut = cty.cast(redlut, cty.POINTER(cty.c_int))
    ptr_greenlut = cty.cast(greenlut, cty.POINTER(cty.c_int))
    ptr_bluelut = cty.cast(bluelut, cty.POINTER(cty.c_int))
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(red, green, blue, width, height, maxcolr, ci, \
            actualcolr, redlut, greenlut, bluelut, ptr_flimage, i_width, \
            i_height, i_maxcolr, i_actualcolr, ptr_redlut, ptr_greenlut, \
            ptr_bluelut)
    retval = _fl_j2pass_quantize_rgb(red, green, blue, i_width, i_height, \
            i_maxcolr, ci, i_actualcolr, ptr_redlut, ptr_greenlut, \
            ptr_bluelut, ptr_flimage)
    return retval


def fl_make_submatrix(inmatrix, numrows, numcols, startrow, startcol, \
                      endrow, endcol, elemsize):
    """fl_make_submatrix(inmatrix, numrows, numcols, startrow, startcol,
    endrow, endcol, elemsize) -> submatrix

    *todo*

    Parameters
    ----------
        inmatrix : *todo*
            image matrix
        numrows : int
            number of rows
        numcols : int
            number of columns
        startrow : int
            initial row?
        startcol : int
            initial column?
        endrow : int
            final row?
        endcol : int
            final column?
        elemsize : int_pos
            size of matrix in bytes

    Returns
    -------
        num : *todo*
            submatrix

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _fl_make_submatrix = library.cfuncproto(
        library.load_so_libflimage(), "fl_make_submatrix",
        cty.c_void_p, [cty.c_void_p, cty.c_int, cty.c_int, cty.c_int,
        cty.c_int, cty.c_int, cty.c_int, cty.c_uint],
        """void * fl_make_submatrix(void * p1, int p2, int p3, int p4,
           int p5, int p6, int p7, unsigned int p8)""")
    #library.check_if_initialized()
    # inmatrix has to be handled
    i_numrows = library.convert_to_intc(numrows)
    i_numcols = library.convert_to_intc(numcols)
    i_startrow = library.convert_to_intc(startrow)
    i_startcol = library.convert_to_intc(startcol)
    i_endrow = library.convert_to_intc(endrow)
    i_endcol = library.convert_to_intc(endcol)
    ui_elemsize = library.convert_to_uintc(elemsize)
    library.keep_elem_refs(inmatrix, numrows, numcols, startrow, startcol, \
            endrow, endcol, elemsize, i_numrows, i_numcols, i_startrow, \
            i_startcol, i_endrow, i_endcol, ui_elemsize)
    retval = _fl_make_submatrix(inmatrix, i_numrows, i_numcols, i_startrow, \
            i_startcol,  i_endrow, i_endcol, ui_elemsize)
    return retval


def fl_pack_bits(inval, numindxs):
    """fl_pack_bits(inval, numindxs) -> outval

    Packs color index (0 or 1) into bytes.

    Parameters
    ----------
        inval : short_pos
            input value to be packed
        numindxs : int
            number of indices

    Returns
    -------
        outval : byte_pos
            output value after packing

    Examples
    --------
        >>> *todo*

    API_diversion
    ----------
        API changed from XForms, upstream is
        fl_pack_bits(outval, inval, lng)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK (how to pass inval)
        It does not need to call flxbasic.fl_initialize() before

    """
    _fl_pack_bits = library.cfuncproto(
        library.load_so_libflimage(), "fl_pack_bits",
        None, [cty.POINTER(cty.c_ubyte), cty.POINTER(cty.c_ushort), cty.c_int],
        """void fl_pack_bits(unsigned char * p1, short unsigned int * p2,
           int p3)""")
    #library.check_if_initialized()
    ub_outval, ptr_outval = library.make_ubytec_and_pointer()
    ui_inval = library.convert_to_uintc(inval)  # to be verified
    ptr_inval = cty.cast(ui_inval, cty.POINTER(cty.c_uint))  # to be verified
    i_numindxs = library.convert_to_intc(numindxs)
    library.keep_elem_refs(ub_outval, ptr_outval, inval, ui_inval, \
            ptr_inval, numindxs, i_numindxs)
    _fl_pack_bits(ptr_outval, ptr_inval, i_numindxs)
    return ub_outval.value


def fl_unpack_bits(inval, numindxs):
    """fl_unpack_bits(inval, numindxs) -> outval

    Unpacks packed bits into color indexes (0 or 1).

    Parameters
    ----------
        inval : byte_pos
            input value to be unpacked
        numindxs : int
            length of packed bytes.

    Returns
    -------
        outval : short_pos
            output value after unpacking

    Examples
    --------
        >>> *todo*

    API_diversion
    ----------
        API changed from XForms, upstream is
        fl_unpack_bits(outval, inval, lng)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _fl_unpack_bits = library.cfuncproto(
        library.load_so_libflimage(), "fl_unpack_bits",
        None, [cty.POINTER(cty.c_ushort), cty.POINTER(cty.c_ubyte),
        cty.c_int],
        """void fl_unpack_bits(short unsigned int * p1,
           unsigned char * p2, int p3)""")
    #library.check_if_initialized()
    us_outval, ptr_outval = library.make_ushortc_and_pointer()
    ub_inval = library.convert_to_ubyte(inval)
    ptr_inval = cty.cast(ub_inval, cty.POINTER(cty.c_ubyte))
    i_numindxs = library.convert_to_intc(numindxs)
    library.keep_elem_refs(us_outval, ptr_outval, inval, ub_inval, \
            ptr_inval, numindxs, i_numindxs)
    _fl_unpack_bits(ptr_outval, ptr_inval, i_numindxs)
    return us_outval.value


def fl_value_to_bits(val):
    """fl_value_to_bits(val) -> num

    *todo*

    Parameters
    ----------
        val : int_pos
            value to convert to bits

    Returns
    -------
        num. : int_pos
            *todo*

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _fl_value_to_bits = library.cfuncproto(
        library.load_so_libflimage(), "fl_value_to_bits",
        cty.c_uint, [cty.c_uint],
        """unsigned int fl_value_to_bits(unsigned int p1)""")
    #library.check_if_initialized()
    ui_val = library.convert_to_uintc(val)
    library.keep_elem_refs(val, ui_val)
    retval = _fl_value_to_bits(ui_val)
    return retval


def flimage_add_comments(ptr_flimage, text, length):
    """flimage_add_comments(ptr_flimage, text, length)

    Adds a comment to an image.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        text : str
            comment to be added
        length : int
            length of comment

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_add_comments = library.cfuncproto(
        library.load_so_libflimage(), "flimage_add_comments",
        None, [cty.POINTER(xfdata.FL_IMAGE), xfdata.STRING, cty.c_int],
        """void flimage_add_comments(FL_IMAGE * p1, const char * p2,
           int p3)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    s_text = library.convert_to_stringc(text)
    i_length = library.convert_to_intc(length)
    library.keep_elem_refs(ptr_flimage, text, length, s_text, i_length)
    _flimage_add_comments(ptr_flimage, s_text, i_length)


def flimage_color_to_pixel(ptr_flimage, red, green, blue):
    """flimage_color_to_pixel(ptr_flimage, red, green, blue) -> pixelval, pixel

    Convert an RGB triple to a pixel.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        red : int
            value for red color
        green : int
            value for green color
        blue : int
            value for blue color

    Returns
    -------
        pixelval : long_pos
            pixel value, or 0 (on failure)
        pixel : int
            new pixel? *todo*

    Examples
    --------
        >>> *todo*

    API_diversion
    ----------
        API changed from XForms, upstream is
        flimage_color_to_pixel(ptr_flimage, r, g, b, newpix)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_color_to_pixel = library.cfuncproto(
        library.load_so_libflimage(), "flimage_color_to_pixel",
        cty.c_ulong, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int,
        cty.c_int, cty.POINTER(cty.c_int)],
        """long unsigned int flimage_color_to_pixel(FL_IMAGE * p1,
               int p2, int p3, int p4, int * p5)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    i_red = library.convert_to_intc(red)
    i_green = library.convert_to_intc(green)
    i_blue = library.convert_to_intc(blue)
    i_newpix, ptr_newpix = library.make_intc_and_pointer()
    library.keep_elem_refs(ptr_flimage, red, green, blue, i_red, i_green, \
            i_blue, i_newpix, ptr_newpix)
    retval = _flimage_color_to_pixel(ptr_flimage, i_red, i_green, i_blue, \
            ptr_newpix)
    return retval, i_newpix.value


def flimage_combine(ptr_flimage1, ptr_flimage2, alpha):
    """flimage_combine(ptr_flimage1, ptr_flimage2, alpha) -> ptr_flimage

    Combines two images with alpha level?, returning a new image.

    Parameters
    ----------
        ptr_flimage1 : pointer to xfdata.FL_IMAGE
            first image to combine
        ptr_flimage2 : pointer to xfdata.FL_IMAGE
            second image to combine
        alpha : float
            alpha level?

    Returns
    -------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image class instance

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_combine = library.cfuncproto(
        library.load_so_libflimage(), "flimage_combine",
        cty.POINTER(xfdata.FL_IMAGE), [cty.POINTER(xfdata.FL_IMAGE),
        cty.POINTER(xfdata.FL_IMAGE), cty.c_double],
        """FL_IMAGE * flimage_combine(FL_IMAGE * p1, FL_IMAGE * p2,
           double p3)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage1)
    library.verify_flflimageptr_type(ptr_flimage2)
    f_alpha = library.convert_to_doublec(alpha)
    library.keep_elem_refs(ptr_flimage1, ptr_flimage2, alpha, f_alpha)
    retval = _flimage_combine(ptr_flimage1, ptr_flimage2, f_alpha)
    return retval


def flimage_display_markers(ptr_flimage):
    """flimage_display_markers(ptr_flimage)

    Displays markers added to an image.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> flimage_display_markers(pimg)

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_display_markers = library.cfuncproto(
        library.load_so_libflimage(), "flimage_display_markers",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_display_markers(FL_IMAGE * p1)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    _flimage_display_markers(ptr_flimage)


def flimage_dup_(ptr_flimage, copypix):
    """flimage_dup_(ptr_flimage, copypix)

    Duplicates an image, with or without the pixels.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        copypix : int
            flag to copy pixels (1) or not (0)

    Returns
    -------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image class instance, or 0 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_dup_ = library.cfuncproto(
        library.load_so_libflimage(), "flimage_dup_",
        cty.POINTER(xfdata.FL_IMAGE), [cty.POINTER(xfdata.FL_IMAGE),
        cty.c_int],
        """FL_IMAGE * flimage_dup_(FL_IMAGE * p1, int p2)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    i_copypix = library.convert_to_intc(copypix)
    library.keep_elem_refs(ptr_flimage, copypix, i_copypix)
    retval = _flimage_dup_(ptr_flimage, i_copypix)
    return retval


def flimage_enable_bmp():
    """flimage_enable_bmp()

    Enables use of BMP (Windows/OS2 Bitmap) image format.

    Examples
    --------
        >>> flimage_enable_bmp()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_enable_bmp = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_bmp",
        None, [],
        """void flimage_enable_bmp()""")
    #library.check_if_initialized()
    _flimage_enable_bmp()


def flimage_enable_fits():
    """flimage_enable_fits()

    Enables use of NASA/NOTS standard FITS image format.

    Examples
    --------
        >>> flimage_enable_fits()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_enable_fits = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_fits",
        None, [],
        """void flimage_enable_fits()""")
    _flimage_enable_fits()


# TODO: try to understand what kind of images is this one.
def flimage_enable_genesis():
    """flimage_enable_genesis()

    Enables use of Genesis image format.

    Examples
    --------
        >>> flimage_enable_genesis()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_enable_genesis = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_genesis",
        None, [],
        """void flimage_enable_genesis()""")
    #library.check_if_initialized()
    _flimage_enable_genesis()


def flimage_enable_gif():
    """flimage_enable_gif()

    Enables use of GIF (Compuserve Graphics Interchange format)
    image format.

    Examples
    --------
        >>> flimage_enable_gif()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_enable_gif = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_gif",
        None, [],
        """void flimage_enable_gif()""")
    #library.check_if_initialized()
    _flimage_enable_gif()


def flimage_enable_gzip():
    """flimage_enable_gzip()

    Enables use of gzip compression filter for images.

    Examples
    --------
        >>> flimage_enable_gzip()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_enable_gzip = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_gzip",
        None, [],
        """void flimage_enable_gzip()""")
    #library.check_if_initialized()
    _flimage_enable_gzip()


def flimage_enable_jpeg():
    """flimage_enable_jpeg()

    Enables use of JPEG/JFIF (Joint Photographic Experts Group) image
    format.

    Examples
    --------
        >>> flimage_enable_jpeg()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_enable_jpeg = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_jpeg",
        None, [],
        """void flimage_enable_jpeg()""")
    #library.check_if_initialized()
    _flimage_enable_jpeg()


def flimage_enable_png():
    """flimage_enable_png()

    Enables use of PNG (Portable Network Graphics) image format. It
    requires netpbm library to be installed.

    Examples
    --------
        >>> flimage_enable_png()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_enable_png = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_png",
        None, [],
        """void flimage_enable_png()""")
    #library.check_if_initialized()
    _flimage_enable_png()


def flimage_enable_ps():
    """flimage_enable_ps()

    Enables use of PS (Adobe PostScript) image format. It needs gs
    (ghostscript) for reading.

    Examples
    --------
        >>> flimage_enable_ps()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_enable_ps = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_ps",
        None, [],
        """void flimage_enable_ps()""")
    #library.check_if_initialized()
    _flimage_enable_ps()


def flimage_enable_sgi():
    """flimage_enable_sgi()

    Enables use of SGI (Silicon Graphics-Iris) image format. It requires
    pbmplus/netpbm library to be installed.

    Examples
    --------
        >>> flimage_enable_sgi()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_enable_sgi = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_sgi",
        None, [],
        """void flimage_enable_sgi()""")
    #library.check_if_initialized()
    _flimage_enable_sgi()


def flimage_enable_tiff():
    """flimage_enable_tiff()

    Enables use of TIFF (Tagged Image file, with no compression) image
    format.

    Examples
    --------
        >>> flimage_enable_tiff()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_enable_tiff = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_tiff",
        None, [],
        """void flimage_enable_tiff()""")
    #library.check_if_initialized()
    _flimage_enable_tiff()


def flimage_enable_xbm():
    """flimage_enable_xbm()

    Enables use of XBM (X Window Bitmap) image format.

    Examples
    --------
        >>> flimage_enable_xbm()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_enable_xbm = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_xbm",
        None, [],
        """void flimage_enable_xbm()""")
    #library.check_if_initialized()
    _flimage_enable_xbm()


def flimage_enable_xpm():
    """flimage_enable_xpm()

    Enables use of XPM3 (X Window PixMap) image format.

    Examples
    --------
        >>> flimage_enable_xpm()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_enable_xpm = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_xpm",
        None, [],
        """void flimage_enable_xpm()""")
    #library.check_if_initialized()
    _flimage_enable_xpm()


def flimage_enable_xwd():
    """flimage_enable_xwd()

    Enables use of XWD (X Window Dump) image format.

    Examples
    --------
        >>> flimage_enable_xwd()

    Notes
    -----
        Status: Tested + Doc + NoDemo = OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_enable_xwd = library.cfuncproto(
        library.load_so_libflimage(), "flimage_enable_xwd",
        None, [],
        """void flimage_enable_xwd()""")
    #library.check_if_initialized()
    _flimage_enable_xwd()


def flimage_free_ci(ptr_flimage):
    """flimage_free_ci(ptr_flimage)

    Frees an image of type xfdata.FL_IMAGE_CI?

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_free_ci = library.cfuncproto(
        library.load_so_libflimage(), "flimage_free_ci",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_free_ci(FL_IMAGE * p1)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    _flimage_free_ci(ptr_flimage)


def flimage_free_gray(ptr_flimage):
    """flimage_free_gray(ptr_flimage)

    Frees an image of type xfdata.FL_IMAGE_GRAY?.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_free_gray = library.cfuncproto(
        library.load_so_libflimage(), "flimage_free_gray",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_free_gray(FL_IMAGE * p1)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    _flimage_free_gray(ptr_flimage)


def flimage_free_linearlut(ptr_flimage):
    """flimage_free_linearlut(ptr_flimage)

    *todo*

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_free_linearlut = library.cfuncproto(
        library.load_so_libflimage(), "flimage_free_linearlut",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_free_linearlut(FL_IMAGE * p1)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    _flimage_free_linearlut(ptr_flimage)


def flimage_free_rgb(ptr_flimage):
    """flimage_free_rgb(ptr_flimage)

    Frees an image of type xfdata.FL_IMAGE_RGB?.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_free_rgb = library.cfuncproto(
        library.load_so_libflimage(), "flimage_free_rgb",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_free_rgb(FL_IMAGE * p1)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    _flimage_free_rgb(ptr_flimage)


def flimage_freemem(ptr_flimage):
    """flimage_freemem(ptr_flimage)

    Frees all allocated memory associated with the image.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_freemem = library.cfuncproto(
        library.load_so_libflimage(), "flimage_freemem",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_freemem(FL_IMAGE * p1)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    _flimage_freemem(ptr_flimage)


def flimage_get_closest_color_from_map(ptr_flimage, colr):
    """flimage_get_closest_color_from_map(ptr_flimage, colr) -> colr

    Gets closest color from color map?

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        colr : int_pos
            color to evaluate

    Returns
    -------
        colr : int
            color that is close?

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_get_closest_color_from_map = library.cfuncproto(
        library.load_so_libflimage(), "flimage_get_closest_color_from_map",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), cty.c_uint],
        """int flimage_get_closest_color_from_map(FL_IMAGE * p1,
           unsigned int p2)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    ui_colr = library.convert_to_uintc(colr)
    library.keep_elem_refs(ptr_flimage, colr, ui_colr)
    retval = _flimage_get_closest_color_from_map(ptr_flimage, ui_colr)
    return retval


def flimage_get_linearlut(ptr_flimage):
    """flimage_get_linearlut(ptr_flimage) -> result

    *todo*

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Returns
    -------
        result : int
            num., or -1 (on failure?)

    Examples
    --------
        >>> flimage_get_linearlut(pimg)

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_get_linearlut = library.cfuncproto(
        library.load_so_libflimage(), "flimage_get_linearlut",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_get_linearlut(FL_IMAGE * p1)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    retval = _flimage_get_linearlut(ptr_flimage)
    return retval


def flimage_invalidate_pixels(ptr_flimage):
    """flimage_invalidate_pixels(ptr_flimage)

    Invalidates/frees all other types of image, before we modify the
    current image.

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_invalidate_pixels = library.cfuncproto(
        library.load_so_libflimage(), "flimage_invalidate_pixels",
        None, [cty.POINTER(xfdata.FL_IMAGE)],
        """void flimage_invalidate_pixels(FL_IMAGE * p1)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    _flimage_invalidate_pixels(ptr_flimage)


def flimage_open(fname):
    """flimage_open(fname) -> ptr_flimage

    Opens an image file. Use flimage_read() to read it.

    Parameters
    ----------
        fname : str
            name of file to open

    Returns
    -------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image class instance opened, or None (on failure)

    Examples
    --------
        pimg = flimage_open("something.ppm")

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_open = library.cfuncproto(
        library.load_so_libflimage(), "flimage_open",
        cty.POINTER(xfdata.FL_IMAGE), [xfdata.STRING],
        """FL_IMAGE * flimage_open(const char * p1)""")
    #library.check_if_initialized()
    s_fname = library.convert_to_stringc(fname)
    library.keep_elem_refs(fname, s_fname)
    retval = _flimage_open(s_fname)
    return retval


def flimage_read_annotation(ptr_flimage):
    """flimage_read_annotation(ptr_flimage) -> resutl

    Reads annotation in the image?

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Returns
    -------
        result : int
            0, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_read_annotation = library.cfuncproto(
        library.load_so_libflimage(), "flimage_read_annotation",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_read_annotation(FL_IMAGE * p1)""")
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    retval = _flimage_read_annotation(ptr_flimage)
    return retval


def flimage_replace_image(ptr_flimage, width, height, red, green, blue):
    """flimage_replace_image(ptr_flimage, width, height, red, green, blue)

    Replaces an image?

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        width : int
            width
        height : int
            heigth
        red : int
            value for red color
        green : int
            value for green color
        blue : int
            value for blue color

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_replace_image = library.cfuncproto(
        library.load_so_libflimage(), "flimage_replace_image",
        None, [cty.POINTER(xfdata.FL_IMAGE), cty.c_int, cty.c_int,
        cty.c_void_p, cty.c_void_p, cty.c_void_p],
        """void flimage_replace_image(FL_IMAGE * p1, int p2, int p3,
           void * p4, void * p5, void * p6)""")
    #library.check_if_initialized()
    i_width = library.convert_to_intc(width)
    i_height = library.convert_to_intc(height)
    ptr_red = cty.cast(red, cty.c_void_p)
    ptr_green = cty.cast(green, cty.c_void_p)
    ptr_blue = cty.cast(blue, cty.c_void_p)
    library.keep_elem_refs(ptr_flimage, width, height, red, green, blue, \
            i_width, i_height, ptr_red, ptr_green, ptr_blue)
    _flimage_replace_image(ptr_flimage, i_width, i_height,  ptr_red, \
            ptr_green, ptr_blue)


def flimage_swapbuffer(ptr_flimage):
    """flimage_swapbuffer(ptr_flimage) -> result

    Swaps buffer of an image?

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Returns
    -------
        result : int
            0?

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_swapbuffer = library.cfuncproto(
        library.load_so_libflimage(), "flimage_swapbuffer",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_swapbuffer(FL_IMAGE * p1) """)
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    retval = _flimage_swapbuffer(ptr_flimage)
    return retval


def flimage_to_ximage(ptr_flimage, win, ptr_xwindowattributes):
    """flimage_to_ximage(ptr_flimage, win, ptr_xwindowattributes) -> result

    Converts an FL_IMAGE into an XImage. The converted ximage is
    ptr_flimage.contents.ximage if successful *todo*

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image
        win : window id
            long_pos
        ptr_xwindowattributes : pointer to xfdata.XWindowAttributes
            class instance

    Returns
    -------
        num. : int
            *todo*, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + Doc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_to_ximage = library.cfuncproto(
        library.load_so_libflimage(), "flimage_to_ximage",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE), xfdata.FL_WINDOW,
        cty.POINTER(xfdata.XWindowAttributes)],
        """int flimage_to_ximage(FL_IMAGE * p1, FL_WINDOW p2,
           XWindowAttributes * p3) """)
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    ul_win = library.convert_to_Window(win)
    library.verify_otherclassptr_type(ptr_xwindowattributes, \
            cty.POINTER(xfdata.XWindowAttributes))
    library.keep_elem_refs(ptr_flimage, win, ptr_xwindowattributes, ul_win)
    retval = _flimage_to_ximage(ptr_flimage, ul_win, ptr_xwindowattributes)
    return retval


def flimage_write_annotation(ptr_flimage):
    """flimage_write_annotation(ptr_flimage) -> result

    Writes annotation in the image?

    Parameters
    ----------
        ptr_flimage : pointer to xfdata.FL_IMAGE
            image

    Returns
    -------
        result : int
            0, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: Untested + NoDoc + NoDemo = NOT OK
        It does not need to call flxbasic.fl_initialize() before

    """
    _flimage_write_annotation = library.cfuncproto(
        library.load_so_libflimage(), "flimage_write_annotation",
        cty.c_int, [cty.POINTER(xfdata.FL_IMAGE)],
        """int flimage_write_annotation(FL_IMAGE * p1) """)
    #library.check_if_initialized()
    library.verify_flflimageptr_type(ptr_flimage)
    library.keep_elem_refs(ptr_flimage)
    retval = _flimage_write_annotation(ptr_flimage)
    return retval

