#!/usr/bin/env python
# -*- coding: iso8859-1 -*-

""" xforms-python's functions to manage goodies objects.

    Copyright (C) 2009, 2010  Luca Lazzaroni "LukenShiro"
    e-mail: <lukenshiro@ngi.it>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, version 2.1 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU LGPL along with this
    program. If not, see <http://www.gnu.org/licenses/>.

    See CREDITS file to read acknowledgements and thanks to XForms,
    ctypes and other developers.
"""

# originally generated by 'h2xml+gccxml' and 'xml2py'
# then heavily reordered and reworked

# ############################################# #
# Interface to XForms shared object libraries   #
# ############################################# #


import ctypes as cty
from xformslib import library as libr
from xformslib import xfdata
from xformslib import flbasic


######################
# forms.h (goodies.h)
######################

# Resources and misc. goodie routines

def fl_set_goodies_font(style, size):
    """Changes the font used in all messages.

    --

    :Parameters:
      `style` : int
        goodies style. Values (from xfdata.py) FL_NORMAL_STYLE, FL_BOLD_STYLE,
        FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        goodies size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE

    :note: e.g. fl_set_goodies_font(xfdata.FL_BOLD_STYLE, \
        xfdata.FL_MEDIUM_SIZE)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_goodies_font = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_goodies_font",
        None, [cty.c_int, cty.c_int],
        """void fl_set_goodies_font(int style, int size)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    istyle = libr.convert_to_int(style)
    isize = libr.convert_to_int(size)
    libr.keep_elem_refs(style, size, istyle, isize)
    _fl_set_goodies_font(istyle, isize)


# messages and questions

def fl_show_message(msgtxt1, msgtxt2, msgtxt3):
    """Shows a simple form with three lines of text and a button labeled
    OK on it. The mouse pointer is on the button.

    --

    :Parameters:
      `msgtxt1` : str
        first message to show
      `msgtxt2` : str
        second message to show
      `msgtxt3` : str
        third message to show

    :note: e.g. fl_show_message("first message", "second message",
        "third message")

    :status: Tested + Doc + Demo = OK

    """
    _fl_show_message = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_message",
        None, [xfdata.STRING, xfdata.STRING, xfdata.STRING],
        """void fl_show_message(const char * p1, const char * p2,
           const char * p3)""")
    libr.check_if_initialized()
    smsgtxt1 = libr.convert_to_string(msgtxt1)
    smsgtxt2 = libr.convert_to_string(msgtxt2)
    smsgtxt3 = libr.convert_to_string(msgtxt3)
    libr.keep_elem_refs(msgtxt1, msgtxt2, msgtxt3, smsgtxt1, smsgtxt2, \
                           smsgtxt3)
    _fl_show_message(smsgtxt1, smsgtxt2, smsgtxt3)


def fl_show_messages(msgtxt):
    """Shows a message. You can use it with a single line or when you
    know the message in advance. To get multi-line messages use embedded
    newlines. It blocks execution and does not return immediately (but idle
    callback and asynchronous IO continue being run and checked). Execution
    continues when the OK button is pressed or <Return> is hit or when the
    message form is removed from the screen by fl_hide_message().

    --

    :Parameters:
      `msgtxt` : str
        message to show

    :note: e.g. fl_show_messages("Some messages")

    :status: Tested + Doc + Demo = OK

    """
    _fl_show_messages = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_messages",
        None, [xfdata.STRING],
        """void fl_show_messages(const char * p1)""")
    libr.check_if_initialized()
    smsgtxt = libr.convert_to_string(msgtxt)
    libr.keep_elem_refs(msgtxt, smsgtxt)
    _fl_show_messages(smsgtxt)


def fl_show_msg(fmttxt):
    """Shows a formatted text message. The string resulting from expansion
    of the format string using the remaining arguments can have arbitrary
    length and embedded newline characters, producing line breaks. The size
    of the message box gets set in a way that the whole text fits into it.
    It blocks execution and does not return immediately (but idle callback
    and asynchronous IO continue being run and checked). Execution continues
    when the OK button is pressed or <Return> is hit or when the message
    form is removed from the screen by fl_hide_message().

    --

    :Parameters:
      `fmttxt` : str
        the message to show (with format parameters, e.g. %s, %d, %f etc..)

    :note: e.g. fl_show_msg("formatted text %s %d" % (mystr, myval))

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_show_msg = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_msg",
        None, [xfdata.STRING],
        """void fl_show_msg(const char * p1)""")
    libr.check_if_initialized()
    sfmttxt = libr.convert_to_string(fmttxt)
    libr.keep_elem_refs(fmttxt, sfmttxt)
    _fl_show_msg(sfmttxt)


def fl_hide_message():
    """Hides a text message already shown.

    --

    :note: e.g. fl_hide_message()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_hide_message = libr.cfuncproto(
        libr.load_so_libforms(), "fl_hide_message",
        None, [],
        """void fl_hide_message()""")
    libr.check_if_initialized()
    _fl_hide_message()


fl_hide_msg = fl_hide_message
fl_hide_messages = fl_hide_message


def fl_show_question(questmsg, defbtn):
    """Shows a message (with possible embedded newlines in it) with a Yes
    and a No button. It returns whether the user pushed the Yes button. The
    user can also press the <Y> key to mean Yes and the <N> key to mean No.

    --

    :Parameters:
      `questmsg` : str
        text of question message to show
      `defbtn` : int
        which button the mouse pointer should be on. Values 1  (for Yes) or 0
        (for No) and any other value causes the form to be shown so the mouse
        pointer is at the center of the form.

    :return: 1 (if Yes button pushed) or 0 otherwise
    :rtype: int

    :note: e.g. qresp = fl_show_question("My question?", 1)

    :status: Tested + Doc + Demo = OK

    """
    _fl_show_question = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_question",
        cty.c_int, [xfdata.STRING, cty.c_int],
        """int fl_show_question(const char * p1, int p2)""")
    libr.check_if_initialized()
    squestmsg = libr.convert_to_string(questmsg)
    idefbtn = libr.convert_to_int(defbtn)
    libr.keep_elem_refs(questmsg, defbtn, squestmsg, idefbtn)
    retval = _fl_show_question(squestmsg, idefbtn)
    return retval


def fl_hide_question():
    """Hides a question message already shown.

    --

    :note: e.g. fl_hide_question()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_hide_question = libr.cfuncproto(
        libr.load_so_libforms(), "fl_hide_question",
        None, [],
        """void fl_hide_question()""")
    libr.check_if_initialized()
    _fl_hide_question()


def fl_show_alert(title, msg1, msg2, centered):
    """Shows an alert message, with an alert icon (!) is added and the
    first string is shown bold-faced.

    --

    :Parameters:
      `title` : str
        title of alert
      `msg1` : str
        first message text
      `msg2` : str
        other message text
      `centered` : int
        if alert has to be displayed centered on the screen or not. Values 1
        (if centered) or 0 (not centered)

    :note: e.g. fl_show_alert("My title", "first text", "second text", 1)

    :status: Tested + Doc + Demo = OK

    """
    _fl_show_alert = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_alert",
        None, [xfdata.STRING, xfdata.STRING, xfdata.STRING, cty.c_int],
        """void fl_show_alert(const char * p1, const char * p2,
           const char * p3, int p4)""")
    libr.check_if_initialized()
    stitle = libr.convert_to_string(title)
    smsg1 = libr.convert_to_string(msg1)
    smsg2 = libr.convert_to_string(msg2)
    icentered = libr.convert_to_int(centered)
    libr.keep_elem_refs(title, msg1, msg2, centered, stitle, smsg1,
                           smsg2, icentered)
    _fl_show_alert(stitle, smsg1, smsg2, icentered)


def fl_show_alert2(centered, fmttxt):
    """Shows a formatted alert message. The string resulting from expansion
    of the format string using the rest of the arguments can have arbitrary
    length and the first embedded form-feed character (backslash-f) is used
    as the separator between the title string and the message of the alert
    box. Embedded newline characters produce lines break.

    --

    :Parameters:
      `centered` : int
        if alert has to be displayed centered on the screen or not. Values 1
        (if centered) or 0 (not centered)
      `fmttxt` : str
        formatted message text

    :note: e.g. fl_show_alert2(1, "formatted text %s %d" % (mystr, myval))

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_show_alert2 = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_alert2",
        None, [cty.c_int, xfdata.STRING],
        """void fl_show_alert2(int c, const char * fmt)""")
    libr.check_if_initialized()
    icentered = libr.convert_to_int(centered)
    sfmttxt = libr.convert_to_string(fmttxt)
    libr.keep_elem_refs(centered, fmttxt, icentered, sfmttxt)
    _fl_show_alert2(icentered, sfmttxt)


def fl_hide_alert():
    """Hides a previously shown alert message.

    --

    :note: e.g. fl_hide_alert()

    :status: Tested + Doc + Demo = OK

    """
    _fl_hide_alert = libr.cfuncproto(
        libr.load_so_libforms(), "fl_hide_alert",
        None, [],
        """void fl_hide_alert()""")
    libr.check_if_initialized()
    _fl_hide_alert()


def fl_show_input(msgtxt, defstr):
    """Obtains some text from user, showing a default text. It has OK
    and Cancel buttons.

    --

    :Parameters:
      `msgtxt` : str
        text used to ask for input
      `defstr` : str
        default user answer to show

    :return: text inserted by user
    :rtype: str

    :note: e.g. inpstr = fl_show_input("Insert number of eggs: ", "None")

    :status: Tested + Doc + Demo = OK

    """
    _fl_show_input = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_input",
        xfdata.STRING, [xfdata.STRING, xfdata.STRING],
        """const char * fl_show_input(const char * p1, const char * p2)""")
    libr.check_if_initialized()
    smsgtxt = libr.convert_to_string(msgtxt)
    sdefstr = libr.convert_to_string(defstr)
    libr.keep_elem_refs(msgtxt, defstr, smsgtxt, sdefstr)
    retval = _fl_show_input(smsgtxt, sdefstr)
    return retval


def fl_hide_input():
    """Hides a previously shown input object.

    --

    :note: e.g. fl_hide_input()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_hide_input = libr.cfuncproto(
        libr.load_so_libforms(), "fl_hide_input",
        None, [],
        """void fl_hide_input()""")
    libr.check_if_initialized()
    _fl_hide_input()


def fl_show_simple_input(msgtxt, defstr):
    """Asks the user for textual input. It has an OK button only.

    --

    :Parameters:
      `msgtxt` : str
        message used to ask for input
      `defstr` : str
        default user answer in input

    :return: text inserted by user
    :rtype: str

    :note: e.g. inpstr = fl_show_simple_input("Insert name and surname:",
        "John Doe")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_show_simple_input = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_simple_input",
        xfdata.STRING, [xfdata.STRING, xfdata.STRING],
        """const char * fl_show_simple_input(const char * p1,
           const char * p2)""")
    libr.check_if_initialized()
    smsgtxt = libr.convert_to_string(msgtxt)
    sdefstr = libr.convert_to_string(defstr)
    libr.keep_elem_refs(msgtxt, defstr, smsgtxt, sdefstr)
    retval = _fl_show_simple_input(smsgtxt, sdefstr)
    return retval


def fl_show_colormap(oldcolr):
    """Shows a colormap color selector from which the user can select a
    color. The user can decide not to change this color by pressing the
    Cancel button in the form. In a number of applications the user has
    to select a color from the colormap. For this a goody has been created.
    It shows the first 64 entries of the colormap. The user can scroll
    through the colormap to see more entries. Once the user presses the
    mouse one of the entries the corresponding index is returned and the
    colormap is removed from the screen.

    --

    :Parameters:
      `oldcolr` : int
        current or default color num. (Not xfdata.FL_COLOR)

    :return: index of the color selected (or the index of the old color)
    :rtype: int

    :note: e.g. colridx = fl_show_colormap(xfdata.Fl_YELLOWGREEN)

    :status: Tested + Doc + Demo = OK

    """
    _fl_show_colormap = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_colormap",
        cty.c_int, [cty.c_int],
        """int fl_show_colormap(int p1)""")
    libr.check_if_initialized()
    ioldcolr = libr.convert_to_int(oldcolr)
    libr.keep_elem_refs(oldcolr, ioldcolr)
    retval = _fl_show_colormap(ioldcolr)
    return retval


# choices

def fl_show_choices(msgtxt, numb, btn1txt, btn2txt, btn3txt, defcho):
    """Shows a message, as a single string with possible embedded newlines,
    with one, two or three buttons. The user can also press the <1>, <2> or
    <3> key to indicate the first, second, or third button.

    --

    :Parameters:
      `msgtxt` : str
        message text
      `numb` : int
        number of buttons
      `btn1txt` : str
        label of first button from the left
      `btn2txt` : str
        label of second button from the left
      `btn3txt` : str
        label of first button from the right
      `defcho` : int
        default choice (1, 2 or 3)

    :return: number of the button pressed (1, 2 or 3)
    :rtype: int

    :note: e.g. pressbtn = fl_show_choices("some message", 3, "1st", "2nd",
        "3rd", 1)

    :status: Tested + Doc + Demo = OK

    """
    _fl_show_choices = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_choices",
        cty.c_int, [xfdata.STRING, cty.c_int, xfdata.STRING, xfdata.STRING,
        xfdata.STRING, cty.c_int],
        """int fl_show_choices(const char * p1, int p2,
           const char * p3, const char * p4, const char * p5, int p6)""")
    libr.check_if_initialized()
    smsgtxt = libr.convert_to_string(msgtxt)
    inumb = libr.convert_to_int(numb)
    sbtn1txt = libr.convert_to_string(btn1txt)
    sbtn2txt = libr.convert_to_string(btn2txt)
    sbtn3txt = libr.convert_to_string(btn3txt)
    idefcho = libr.convert_to_int(defcho)
    libr.keep_elem_refs(msgtxt, numb, btn1txt, btn2txt, btn3txt, defcho, \
            smsgtxt, inumb, sbtn1txt, sbtn2txt, sbtn3txt, idefcho)
    retval = _fl_show_choices(smsgtxt, inumb, sbtn1txt, sbtn2txt, sbtn3txt, \
                              idefcho)
    return retval


def fl_show_choice(msg1txt, msg2txt, msg3txt, numb, btn1txt, btn2txt, btn3txt,
                   defcho):
    """Shows a message, up to three lines, with one, two or three buttons.
    The user can also press the <1>, <2> or <3> key to indicate the first,
    second, or third button.

    --

    :Parameters:
      `msg1txt` : str
        first message text
      `msg2txt` : str
        second message text
      `msg3txt` : str
        third message text
      `numb` : int
        number of buttons
      `btn1txt` : str
        label of first button from the left
      `btn2txt` : str
        label of second button from the left
      `btn3txt` : str
        label of first button from the right
      `defcho` : int
        default choice (1, 2 or 3)

    :return: number of the button pressed (1, 2 or 3)
    :rtype: int

    :note: e.g. pressbtn = fl_show_choices("some message", "some other",
        "the end", 3, "1st", "2nd", "3rd", 1)

    :status: Tested + Doc + Demo = OK

    """
    _fl_show_choice = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_choice",
        cty.c_int, [xfdata.STRING, xfdata.STRING, xfdata.STRING, cty.c_int,
        xfdata.STRING, xfdata.STRING, xfdata.STRING, cty.c_int],
        """int fl_show_choice(const char * p1, const char * p2,
           const char * p3, int p4, const char * p5, const char * p6,
           const char * p7, int p8)""")
    libr.check_if_initialized()
    smsg1txt = libr.convert_to_string(msg1txt)
    smsg2txt = libr.convert_to_string(msg2txt)
    smsg3txt = libr.convert_to_string(msg3txt)
    inumb = libr.convert_to_int(numb)
    sbtn1txt = libr.convert_to_string(btn1txt)
    sbtn2txt = libr.convert_to_string(btn2txt)
    sbtn3txt = libr.convert_to_string(btn3txt)
    idefcho = libr.convert_to_int(defcho)
    libr.keep_elem_refs(msg1txt, msg2txt, msg3txt, numb, btn1txt,
        btn2txt, btn3txt, defcho, smsg1txt, smsg2txt, smsg3txt, inumb,
        sbtn1txt, sbtn2txt, sbtn3txt, idefcho)
    retval = _fl_show_choice(smsg1txt, smsg2txt, smsg3txt, inumb, sbtn1txt,
        sbtn2txt, sbtn3txt, idefcho)
    return retval


def fl_hide_choice():
    """Hides the choice message.

    --

    :note: e.g. fl_hide_choice()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_hide_choice = libr.cfuncproto(
        libr.load_so_libforms(), "fl_hide_choice",
        None, [],
        """void fl_hide_choice()""")
    libr.check_if_initialized()
    _fl_hide_choice()


def fl_set_choices_shortcut(shc1txt, shc2txt, shc3txt):
    """Defines more mnemonic hotkeys as shortcut text for choices.

      `shc1txt` : str
        shortcut to bind to first button
      `shc2txt` : str
        shortcut to bind to second button
      `shc3txt` : str
        shortcut to bind to third button

    :note: e.g. fl_set_choices_shortcut("a", "B", "^C")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_choices_shortcut = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_choices_shortcut",
        None, [xfdata.STRING, xfdata.STRING, xfdata.STRING],
        """void fl_set_choices_shortcut(const char * p1, const char * p2,
           const char * p3)""")
    libr.check_if_initialized()
    sshc1txt = libr.convert_to_string(shc1txt)
    sshc2txt = libr.convert_to_string(shc2txt)
    sshc3txt = libr.convert_to_string(shc3txt)
    libr.keep_elem_refs(shc1txt, shc2txt, shc3txt, sshc1txt, sshc2txt,
        sshc3txt)
    _fl_set_choices_shortcut(sshc1txt, sshc2txt, sshc3txt)


fl_set_choice_shortcut = fl_set_choices_shortcut


# one liner

def fl_show_oneliner(text, x, y):
    """Shows a one-line message that can only be removed programmatically.
    Multi-line message is possible by embedding the newline character in text.

    --

    :Parameters:
      `text` : str
        oneliner message text
      `x` : int
        horizontal position (relative to root window)
      `y` : int
        vertical position (relative to root window)

    :note: e.g. fl_show_oneliner("Button to close window", 134, 155)

    :status: Tested + Doc + Demo = OK

    """
    _fl_show_oneliner = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_oneliner",
        None, [xfdata.STRING, xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_show_oneliner(const char * p1, FL_Coord p2,
           FL_Coord p3)""")
    libr.check_if_initialized()
    stext = libr.convert_to_string(text)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    libr.keep_elem_refs(text, stext, x, ix, y, iy)
    _fl_show_oneliner(stext, ix, iy)


def fl_hide_oneliner():
    """Hides the oneliner message previously shown.

    --

    :note: e.g. fl_hide_oneliner()

    :status: Tested + Doc + Demo = OK

    """
    _fl_hide_oneliner = libr.cfuncproto(
        libr.load_so_libforms(), "fl_hide_oneliner",
        None, [],
        """void fl_hide_oneliner()""")
    libr.check_if_initialized()
    _fl_hide_oneliner()


def fl_set_oneliner_font(style, size):
    """Sets font style and size to use in a oneliner message.

    --

    :Parameters:
      `style` : int
        label style. Values (from xfdata.py) FL_NORMAL_STYLE, FL_BOLD_STYLE,
        FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        label size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE

    :note: e.g. fl_set_oneliner_font(FL_BOLD_STYLE, FL_NORMAL_SIZE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_oneliner_font = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_oneliner_font",
        None, [cty.c_int, cty.c_int],
        """void fl_set_oneliner_font(int p1, int p2)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    istyle = libr.convert_to_int(style)
    isize = libr.convert_to_int(size)
    libr.keep_elem_refs(style, size, istyle, isize)
    _fl_set_oneliner_font(istyle, isize)


def fl_set_oneliner_color(fgcolr, bgcolr):
    """Sets color to use with oneliner message. By default, the background
    of the message is yellow and the text black.

    --

    :Parameters:
      `fgcolr` : long_pos
        color value for oneliner foreground
      `bgcolr` : long_pos
        color value for oneliner background

    :note: e.g. fl_set_oneliner_color(fgcolr, bgcolr)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_oneliner_color = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_oneliner_color",
        None, [xfdata.FL_COLOR, xfdata.FL_COLOR],
        """void fl_set_oneliner_color(FL_COLOR p1, FL_COLOR p2)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(fgcolr, xfdata.COLOR_list)
    libr.check_admitted_value_in_list(bgcolr, xfdata.COLOR_list)
    ulfgcolr = libr.convert_to_FL_COLOR(fgcolr)
    ulbgcolr = libr.convert_to_FL_COLOR(bgcolr)
    libr.keep_elem_refs(fgcolr, bgcolr, ulfgcolr, ulbgcolr)
    _fl_set_oneliner_color(ulfgcolr, ulbgcolr)


def fl_set_tooltip_font(style, size):
    """Sets the font style and size of the tooltip.

    --

    :Parameters:
      `style` : int
        label style. Values (from xfdata.py) FL_NORMAL_STYLE, FL_BOLD_STYLE,
        FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        label size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE

    :note: e.g. fl_set_tooltip_font(xfdata.FL_SHADOW_STYLE,
        xfdata.FL_DEFAULT_SIZE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_tooltip_font = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_tooltip_font",
        None, [cty.c_int, cty.c_int],
        """void fl_set_tooltip_font(int p1, int p2)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    istyle = libr.convert_to_int(style)
    isize = libr.convert_to_int(size)
    libr.keep_elem_refs(style, size, istyle, isize)
    _fl_set_tooltip_font(istyle, isize)


def fl_set_tooltip_color(fgcolr, bgcolr):
    """Sets the foreground and the background colors of the tooltip.

    --

    :Parameters:
      `fgcolr` : long_pos
        foreground color value
      `bgcolr` : long_pos
        background color value

    :note: e.g. fl_set_tooltip_color(xfdata.FL_BLUE, xfdata.FL_VIOLET)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_tooltip_color = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_tooltip_color",
        None, [xfdata.FL_COLOR, xfdata.FL_COLOR],
        """void fl_set_tooltip_color(FL_COLOR p1, FL_COLOR p2)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(fgcolr, xfdata.COLOR_list)
    libr.check_admitted_value_in_list(bgcolr, xfdata.COLOR_list)
    ulfgcolr = libr.convert_to_FL_COLOR(fgcolr)
    ulbgcolr = libr.convert_to_FL_COLOR(bgcolr)
    libr.keep_elem_refs(fgcolr, bgcolr, ulfgcolr, ulbgcolr)
    _fl_set_tooltip_color(ulfgcolr, ulbgcolr)


def fl_set_tooltip_boxtype(boxtype):
    """Sets the boxtype of the tooltip.

    --

    :Parameters:
      `boxtype` : int
        type of the box to be added. Values (from xfdata.py) FL_NO_BOX,
        FL_UP_BOX, FL_DOWN_BOX, FL_BORDER_BOX, FL_SHADOW_BOX, FL_FRAME_BOX,
        FL_ROUNDED_BOX, FL_EMBOSSED_BOX, FL_FLAT_BOX, FL_RFLAT_BOX,
        FL_RSHADOW_BOX, FL_OVAL_BOX, FL_ROUNDED3D_UPBOX, FL_ROUNDED3D_DOWNBOX,
        FL_OVAL3D_UPBOX, FL_OVAL3D_DOWNBOX, FL_OVAL3D_FRAMEBOX,
        FL_OVAL3D_EMBOSSEDBOX

    :note: e.g. fl_set_tooltip_boxtype(xfdata.FL_OVAL3D_DOWNBOX)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_tooltip_boxtype = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_tooltip_boxtype",
        None, [cty.c_int],
        """void fl_set_tooltip_boxtype(int p1)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(boxtype, xfdata.BOXTYPE_list)
    iboxtype = libr.convert_to_int(boxtype)
    libr.keep_elem_refs(boxtype, iboxtype)
    _fl_set_tooltip_boxtype(iboxtype)


def fl_set_tooltip_lalign(align):
    """Sets the alignment of the tooltip.

    --

    :Parameters:
      `align` : int
        alignment of tooltip. Values (from xfdata.py) FL_ALIGN_CENTER,
        FL_ALIGN_TOP, FL_ALIGN_BOTTOM, FL_ALIGN_LEFT, FL_ALIGN_RIGHT,
        FL_ALIGN_LEFT_TOP, FL_ALIGN_RIGHT_TOP, FL_ALIGN_LEFT_BOTTOM,
        FL_ALIGN_RIGHT_BOTTOM, FL_ALIGN_INSIDE, FL_ALIGN_VERT.
        Bitwise OR with FL_ALIGN_INSIDE is allowed.

    :note: e.g. fl_set_tooltip_lalign(xfdata.FL_ALIGN_RIGHT_TOP)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_tooltip_lalign = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_tooltip_lalign",
        None, [cty.c_int],
        """void fl_set_tooltip_lalign(int p1)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(align, xfdata.ALIGN_list)
    ialign = libr.convert_to_int(align)
    libr.keep_elem_refs(align, ialign)
    _fl_set_tooltip_lalign(ialign)


def fl_exe_command(cmdtxt, block):
    """Forks a new process that runs specified command.

    --

    :Parameters:
      `cmdtxt` : str
        a shell command line
      `block` : int
        blocking flag indicating if the function should wait for the child
        process to finish or not. Values non-zero (for waiting) or 0 (don't
        wait).

    :return: exit status
    :rtype: long

    :note: e.g. *todo*

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _fl_exe_command = libr.cfuncproto(
        libr.load_so_libforms(), "fl_exe_command",
        cty.c_long, [xfdata.STRING, cty.c_int],
        """long int fl_exe_command(const char * p1, int p2)""")
    libr.check_if_initialized()
    scmdtxt = libr.convert_to_string(cmdtxt)
    iblock = libr.convert_to_int(block)
    libr.keep_elem_refs(cmdtxt, block, scmdtxt, iblock)
    retval = _fl_exe_command(scmdtxt, iblock)
    return retval


fl_open_command = fl_exe_command


def fl_end_command(pid):
    """Suspends the current process and waits until the child process is
    completed.

    --

    :Parameters:
      `pid` : long
        process id returned by fl_exe_command()

    :return: exit status of child process, or -1 (if an error has occurred)
    :rtype: long

    :note: e.g. fl_end_command(1488)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_end_command = libr.cfuncproto(
        libr.load_so_libforms(), "fl_end_command",
        cty.c_int, [cty.c_long],
        """int fl_end_command(long int p1)""")
    libr.check_if_initialized()
    lpid = libr.convert_to_long(pid)
    libr.keep_elem_refs(pid, lpid)
    retval = _fl_end_command(lpid)
    return retval


fl_close_command = fl_end_command


def fl_check_command(pid):
    """Polls the status of a child process.

    --

    :Parameters:
      `pid` : long
        process id returned by fl_exe_command()

    :return: 0 if the child process is finished, or 1 if the child process
        still exists (running or stopped), or -1 if an error has occurred
        inside the function
    :rtype: int

    :note: e.g. fl_check_command(1488)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_check_command = libr.cfuncproto(
        libr.load_so_libforms(), "fl_check_command",
        cty.c_int, [cty.c_long],
        """int fl_check_command(long int p1)""")
    libr.check_if_initialized()
    lpid = libr.convert_to_long(pid)
    libr.keep_elem_refs(pid, lpid)
    retval = _fl_check_command(lpid)
    return retval


def fl_popen(cmdtxt, otype):
    """Executes the command in a child process, and logs the stderr messages
    into the command log. If otype is "w", stdout will also be logged into
    the command browser.

    --

    :Parameters:
      `cmdtxt` : str
        existing filename to execute
      `otype` : str
        type of opening (e.g. letter between w, r ..)

    :return: file opened (pFile)
    :rtype: pointer to xfdata.FILE

    :note: e.g. pfile = fl_popen("/usr/bin/somecommand", "r")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_popen = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popen",
        cty.POINTER(xfdata.FILE), [xfdata.STRING, xfdata.STRING],
        """FILE * fl_popen(const char * p1, const char * p2)""")
    libr.check_if_initialized()
    scmdtxt = libr.convert_to_string(cmdtxt)
    sotype = libr.convert_to_string(otype)
    libr.keep_elem_refs(cmdtxt, otype, scmdtxt, sotype)
    retval = _fl_popen(scmdtxt, sotype)
    return retval


def fl_pclose(pFile):
    """Cleans up the child process executed.

    --

    :Parameters:
      `pFile` : pointer to xfdata.FILE
        opened file stream returned by fl_popen()

    :return: non-zero, or -1 (on failure)
    :rtype: int

    :note: e.g. if fl_pclose(pfile) == -1: ...

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_pclose = libr.cfuncproto(
        libr.load_so_libforms(), "fl_pclose",
        cty.c_int, [cty.POINTER(xfdata.FILE)],
        """int fl_pclose(FILE * p1)""")
    libr.check_if_initialized()
    libr.verify_otherclassptr_type(pFile, cty.POINTER(xfdata.FILE))
    libr.keep_elem_refs(pFile)
    retval = _fl_pclose(pFile)
    return retval


def fl_end_all_command():
    """Waits for all the child processes initiated by fl_exe_command()
    to complete.

    --

    :return: exit status of the last child process
    :rtype: int

    :note: e.g. fl_end_all_command()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_end_all_command = libr.cfuncproto(
        libr.load_so_libforms(), "fl_end_all_command",
        cty.c_int, [],
        """int fl_end_all_command()""")
    retval = _fl_end_all_command()
    return retval


def fl_show_command_log(border):
    """Shows the log of the command output.

    --

    :Parameters:
      `border` : int
        window manager decoration. Values (from xfdata.py) FL_FULLBORDER,
        FL_TRANSIENT, FL_NOBORDER

    :note: e.g. fl_show_command_log(xfdata.FL_FULLBORDER)

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _fl_show_command_log = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_command_log",
        None, [cty.c_int],
        """void fl_show_command_log(int p1)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(border, xfdata.DECORATION_list)
    iborder = libr.convert_to_int(border)
    libr.keep_elem_refs(border, iborder)
    _fl_show_command_log(iborder)


def fl_hide_command_log():
    """Hides the log of the command output.

    --

    :note: e.g. fl_hide_command_log()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_hide_command_log = libr.cfuncproto(
        libr.load_so_libforms(), "fl_hide_command_log",
        None, [],
        """void fl_hide_command_log()""")
    libr.check_if_initialized()
    _fl_hide_command_log()


def fl_clear_command_log():
    """Clears the browser and the logging output displayed within it.

    --

    :note: e.g. fl_clear_command_log()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_clear_command_log = libr.cfuncproto(
        libr.load_so_libforms(), "fl_clear_command_log",
        None, [],
        """void fl_clear_command_log()""")
    libr.check_if_initialized()
    _fl_clear_command_log()


def fl_addto_command_log(txtstr):
    """Adds arbitrary text to the command browser.

    --

    :Parameters:
      `txtstr` : str
        text line to be added (with possible embedded newlines)

    :note: e.g. fl_addto_command_log("Another line to add to CmdLog")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_addto_command_log = libr.cfuncproto(
        libr.load_so_libforms(), "fl_addto_command_log",
        None, [xfdata.STRING],
        """void fl_addto_command_log(const char * p1)""")
    libr.check_if_initialized()
    stxtstr = libr.convert_to_string(txtstr)
    libr.keep_elem_refs(txtstr, stxtstr)
    _fl_addto_command_log(stxtstr)


def fl_set_command_log_position(x, y):
    """Changes the default placement of the command log.

    --

    :Parameters:
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)

    :note: e.g. fl_set_command_log_position(174, 288)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_command_log_position = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_command_log_position",
        None, [cty.c_int, cty.c_int],
        """void fl_set_command_log_position(int p1, int p2)""")
    libr.check_if_initialized()
    ix = libr.convert_to_int(x)
    iy = libr.convert_to_int(y)
    libr.keep_elem_refs(x, y, ix, iy)
    _fl_set_command_log_position(ix, iy)


def fl_get_command_log_fdstruct():
    """Obtains the GUI structure of the command browser. From the information
    returned, the application program can change various attributes of the
    command browser and its associated objects. Note however, that you should
    not hide/show the form or free any member of the returned structure.

    --

    :return: command log browser class instance (pCmdlog)
    :rtype: pointer to xfdata.FD_CMDLOG

    :note: e.g. pcmdlogbr = fl_get_command_log_fdstruct()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_command_log_fdstruct = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_command_log_fdstruct",
        cty.POINTER(xfdata.FD_CMDLOG), [],
        """FD_CMDLOG * fl_get_command_log_fdstruct()""")
    libr.check_if_initialized()
    retval = _fl_get_command_log_fdstruct()
    return retval


# file selector

def fl_use_fselector(num):
    """Sets the currently active file selector.

    --

    :Parameters:
      `num` : int
        fselector number to use. Values between 0 and
        xfdata.FL_MAX_FSELECTOR - 1

    :return: old file selector number
    :rtype: int

    :note: e.g. oldfsel = fl_use_fselector(1)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_use_fselector = libr.cfuncproto(
        libr.load_so_libforms(), "fl_use_fselector",
        cty.c_int, [cty.c_int],
        """int fl_use_fselector(int p1)""")
    libr.check_if_initialized()
    inum = libr.convert_to_int(num)
    libr.keep_elem_refs(num, inum)
    retval = _fl_use_fselector(inum)
    return retval


def fl_show_fselector(msgtxt, dirname, pattern, deftxt):
    """Show a file selector, providing an easy and interactive way to let
    the user select files.

    --

    :Parameters:
      `msgtxt` : str
        message text
      `dirname` : str
        directory name
      `pattern` : str
        any kind of regular expression, e.g. "[a-f]*c" which would list all
        files starting with a letter between a and f and ending with c.
      `deftxt` : str
        default file name

    :return: fselector text, or None (if the Cancel button is pressed)
    :rtype: str

    :note: e.g. fstxt = fl_show_fselector("Choose file:", "/home/user",
        "*.*", "")

    :status: Tested + Doc + Demo = OK

    """
    _fl_show_fselector = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_fselector",
        xfdata.STRING, [xfdata.STRING, xfdata.STRING, xfdata.STRING,
        xfdata.STRING],
        """const char * fl_show_fselector(const char * p1,
           const char * p2, const char * p3, const char * p4)""")
    libr.check_if_initialized()
    smsgtxt = libr.convert_to_string(msgtxt)
    sdirname = libr.convert_to_string(dirname)
    spattern = libr.convert_to_string(pattern)
    sdeftxt = libr.convert_to_string(deftxt)
    libr.keep_elem_refs(msgtxt, dirname, pattern, deftxt, smsgtxt,
        sdirname, spattern, sdeftxt)
    retval = _fl_show_fselector(smsgtxt, sdirname, spattern, sdeftxt)
    return retval


fl_show_file_selector = fl_show_fselector


def fl_set_fselector_fontsize(size):
    """Changes the font size of a file selector.

    --

    :Parameters:
      `size` : int
        label size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE

    :note: e.g. fl_set_fselector_fontsize(xfdata.TINY_SIZE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_fselector_fontsize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_fselector_fontsize",
        None, [cty.c_int],
        """void fl_set_fselector_fontsize(int p1)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    isize = libr.convert_to_int(size)
    libr.keep_elem_refs(size, isize)
    _fl_set_fselector_fontsize(isize)


def fl_set_fselector_fontstyle(style):
    """Changes the font style of a file selector.

    --

    :Parameters:
      `style` : int
        label style. Values (from xfdata.py) FL_NORMAL_STYLE, FL_BOLD_STYLE,
        FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE

    :note: e.g. fl_set_fselector_fontstyle(xfdata.FL_SHADOW_STYLE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_fselector_fontstyle = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_fselector_fontstyle",
        None, [cty.c_int],
        """void fl_set_fselector_fontstyle(int p1)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    istyle = libr.convert_to_int(style)
    libr.keep_elem_refs(style, istyle)
    _fl_set_fselector_fontstyle(istyle)


def fl_set_fselector_placement(place):
    """Sets the placement of the file selector. By default it is centered
    on the screen (FL_PLACE_CENTER|FL_FREE_SIZE).

    --

    :Parameters:
      `place` : int
        where to place it. Values (from xfdata.py) FL_PLACE_FREE,
        FL_PLACE_MOUSE, FL_PLACE_CENTER, FL_PLACE_POSITION, FL_PLACE_SIZE,
        FL_PLACE_GEOMETRY, FL_PLACE_ASPECT, FL_PLACE_FULLSCREEN,
        FL_PLACE_HOTSPOT, FL_PLACE_ICONIC, FL_FREE_SIZE, FL_PLACE_FREE_CENTER,
        FL_PLACE_CENTERFREE, FL_PLACE_MOUSE|FL_FREE_SIZE,
        FL_PLACE_FULLSCREEN|FL_FREE_SIZE, FL_PLACE_HOTSPOT|FL_FREE_SIZE

    :note: e.g. fl_set_fselector_placement(xfdata.FL_PLACE_HOTSPOT)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_fselector_placement = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_fselector_placement",
        None, [cty.c_int],
        """void fl_set_fselector_placement(int p1)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(place, xfdata.PLACE_list)
    iplace = libr.convert_to_int(place)
    libr.keep_elem_refs(place, iplace)
    _fl_set_fselector_placement(iplace)


def fl_set_fselector_border(border):
    """Changes the border of file selector. By default it is displayed with
    transient property set (FL_NOBORDER is ignored).

    --

    :Parameters:
      `border` : int
        window manager decoration. Values (from xfdata.py) FL_FULLBORDER,
        FL_TRANSIENT, FL_NOBORDER

    :note: e.g. fl_set_fselector_border(xfdata.FL_FULLBORDER)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_fselector_border = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_fselector_border",
        None, [cty.c_int],
        """void fl_set_fselector_border(int p1)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(border, xfdata.DECORATION_list)
    iborder = libr.convert_to_int(border)
    libr.keep_elem_refs(border, iborder)
    _fl_set_fselector_border(iborder)


def fl_set_fselector_transient(yesno):
    """Set the property of file selector as transient or fullborder.

    --

    :Parameters:
      `yesno` : int
        flag if transient or not. Values 1 (transient) or 0 (not transient)

    :note: e.g. fl_set_fselector_transient(0)

    :status: Tested + Doc + NoDemo = OK

    """
    if yesno:
        argval = xfdata.FL_TRANSIENT
    else:
        argval = xfdata.FL_FULLBORDER
    fl_set_fselector_border(argval)


def fl_set_fselector_callback(py_FSCB, vdata):
    """Sets a callback routine so that whenever the user double clicks on a
    filename, instead of returning the filename, this routine is invoked with
    the filename as the argument. The behavior of the file selector is
    slightly different when a callback is present. Without the callback, a
    file selector is always modal. Please note that when a file selector has
    a callback installed the field for manually entering a file name isn't
    shown.

    --

    :Parameters:
      `py_FSCB` : python function callback, returning (unused) value
        name referring to function(string, vdata) -> num
      `vdata` : any type (e.g. 'None', int, str, etc..)
        user data to be passed to function

    :note: e.g. def fsel_cb(fname, cvoidp): > ... ; return UnusedVal
    :note: e.g. fl_set_fselector_callback(fsel_cb, None)

    :status: Tested + Doc + Demo = OK

    """
    #FL_FSCB = cty.CFUNCTYPE(cty.c_int, xfdata.STRING, cty.c_void_p)
    _fl_set_fselector_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_fselector_callback",
        None, [xfdata.FL_FSCB, cty.c_void_p],
        """void fl_set_fselector_callback(FL_FSCB p1, void * p2)""")
    libr.check_if_initialized()
    libr.verify_function_type(py_FSCB)
    c_FSCB = xfdata.FL_FSCB(py_FSCB)
    if vdata is None:
        zdata = vdata
        pvdata = cty.cast(zdata, cty.c_void_p)
    elif isinstance(vdata, int):
        zdata = libr.convert_to_int(vdata)
        pvdata = zdata
    elif isinstance(vdata, str):
        zdata = libr.convert_to_string(vdata)
        pvdata = cty.cast(zdata, cty.POINTER(xfdata.STRING))
    else:
        zdata = vdata
        pvdata = vdata          # it is pFlObject
        libr.verify_flobjectptr_type(pvdata)
    libr.keep_cfunc_refs(c_FSCB, py_FSCB)
    libr.keep_elem_refs(vdata, zdata, pvdata)
    _fl_set_fselector_callback(c_FSCB, pvdata)


fl_set_fselector_cb = fl_set_fselector_callback


def fl_get_filename():
    """Obtains the file name (without the path) after the user changed it.

    --

    :return: name of file (fname)
    :rtype: str

    :note: e.g. newfname = fl_get_filename()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_filename = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_filename",
        xfdata.STRING, [],
        """const char * fl_get_filename()""")
    libr.check_if_initialized()
    retval = _fl_get_filename()
    return retval


def fl_get_directory():
    """Obtains the directory name after the user changed it.

    --

    :return: name of directory (dirname)
    :rtype: str

    :note: e.g. newdname = fl_get_directory()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_directory = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_directory",
        xfdata.STRING, [],
        """const char * fl_get_directory()""")
    retval = _fl_get_directory()
    return retval


def fl_get_pattern():
    """Obtains the pattern after the user changed it.

    --

    :return: pattern text
    :rtype: str

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_pattern = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_pattern",
        xfdata.STRING, [],
        """const char * fl_get_pattern()""")
    libr.check_if_initialized()
    retval = _fl_get_pattern()
    return retval


def fl_set_directory(dirname):
    """Sets programmatically new value for the default directory.

    --

    :Parameters:
      `dirname` : str
        name of directory to be set

    :return: 0 on success, or 1 (on failure)
    :rtype: int

    :note: e.g. sth = fl_set_directory("/home/user/blabla")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_directory = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_directory",
        cty.c_int, [xfdata.STRING],
        """int fl_set_directory(const char * p1)""")
    libr.check_if_initialized()
    sdirname = libr.convert_to_string(dirname)
    libr.keep_elem_refs(dirname, sdirname)
    retval = _fl_set_directory(sdirname)
    return retval


def fl_set_pattern(pattern):
    """Sets programmatically new value for the default pattern.

    --

    :Parameters:
      `pattern` : str
        text to be used for pattern

    :note: e.g. fl_set_pattern("\*.txt")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_pattern = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_pattern",
        None, [xfdata.STRING],
        """void fl_set_pattern(const char * p1)""")
    libr.check_if_initialized()
    spattern = libr.convert_to_string(pattern)
    libr.keep_elem_refs(pattern, spattern)
    _fl_set_pattern(spattern)


def fl_refresh_fselector():
    """Refreshes the file selector, re-scanning the current directory and
    listing all entries in it.

    --

    :note: e.g. fl_refresh_fselector()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_refresh_fselector = libr.cfuncproto(
        libr.load_so_libforms(), "fl_refresh_fselector",
        None, [],
        """void fl_refresh_fselector()""")
    libr.check_if_initialized()
    _fl_refresh_fselector()


def fl_add_fselector_appbutton(label, py_fn, vdata):
    """Adds an application specific button from file selector and a callback
    routine for it.

    --

    :Parameters:
      `label` : str
        text of label
      `py_fn` : python function callback, no return
        name referring to function(vdata)
      `vdata` : any type (e.g. 'None', int, str, etc..)
        user data to be passed to function; callback has to take care of
        type check

    :note: e.g. def fsbtn_cb(cvoidp): > ...
    :note: e.g. fl_add_fselector_appbutton("SomeButton", fsbtn_cb, None)

    :status: Tested + Doc + NoDemo = OK

    """
    #cfunc_none_voidp = cty.CFUNCTYPE(None, cty.c_void_p)
    _fl_add_fselector_appbutton = libr.cfuncproto(
        libr.load_so_libforms(), "fl_add_fselector_appbutton",
        None, [xfdata.STRING, xfdata.cfunc_none_voidp, cty.c_void_p],
        """void fl_add_fselector_appbutton(const char * p1,
           const char * p2, void * p3)""")
    libr.check_if_initialized()
    slabel = libr.convert_to_string(label)
    libr.verify_function_type(py_fn)
    c_fn = xfdata.cfunc_none_voidp(py_fn)
    pvdata = cty.cast(vdata, cty.c_void_p)
    libr.keep_cfunc_refs(c_fn, py_fn)
    libr.keep_elem_refs(label, vdata, slabel, pvdata)
    _fl_add_fselector_appbutton(slabel, c_fn, pvdata)


def fl_remove_fselector_appbutton(label):
    """Removes an application specific button from file selector.

    --

    :Parameters:
      `label` : str
        text of label

    :note: e.g. fl_remoe_selector_appbutton("SomeButton")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_remove_fselector_appbutton = libr.cfuncproto(
        libr.load_so_libforms(), "fl_remove_fselector_appbutton",
        None, [xfdata.STRING],
        """void fl_remove_fselector_appbutton(const char * p1)""")
    libr.check_if_initialized()
    slabel = libr.convert_to_string(label)
    libr.keep_elem_refs(label, slabel)
    _fl_remove_fselector_appbutton(slabel)


def fl_disable_fselector_cache(yesno):
    """Disable file selector caching.

    --

    :Parameters:
      `yesno` : int
        flag. Values 0 (to enable cache) or 1 (to disable cache)

    :note: e.g. fl_disable_fselector_cache(1)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_disable_fselector_cache = libr.cfuncproto(
        libr.load_so_libforms(), "fl_disable_fselector_cache",
        None, [cty.c_int],
        """void fl_disable_fselector_cache(int p1)""")
    libr.check_if_initialized()
    iyesno = libr.convert_to_int(yesno)
    libr.keep_elem_refs(yesno, iyesno)
    _fl_disable_fselector_cache(iyesno)


def fl_invalidate_fselector_cache():
    """Forces an update of file selector caching programmatically. It forces
    it only once, and on the directory that is to be browsed.

    --

    :note: e.g. fl_invalidate_fselector_cache()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_invalidate_fselector_cache = libr.cfuncproto(
        libr.load_so_libforms(), "fl_invalidate_fselector_cache",
        None, [],
        """void fl_invalidate_fselector_cache()""")
    libr.check_if_initialized()
    _fl_invalidate_fselector_cache()


def fl_get_fselector_form():
    """Obtains the form of file selector.

    --

    :note: e.g. pform = fl_get_fselector_form()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_fselector_form = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_fselector_form",
        cty.POINTER(xfdata.FL_FORM), [],
        """FL_FORM * fl_get_fselector_form()""")
    libr.check_if_initialized()
    retval = _fl_get_fselector_form()
    return retval


def fl_get_fselector_fdstruct():
    """Obtains a FD_FSELECTOR class instance, allowing direct access to the
    individual objects of a file selector.

    --

    :return: file selector class instance
    :rtype: pointer to xfdata.FD_FSELECTOR

    :note: e.g. fdfsel = fl_get_fselector_fdstruct()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_fselector_fdstruct = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_fselector_fdstruct",
        cty.POINTER(xfdata.FD_FSELECTOR), [],
        """FD_FSELECTOR * fl_get_fselector_fdstruct()""")
    libr.check_if_initialized()
    retval = _fl_get_fselector_fdstruct()
    return retval


def fl_hide_fselector():
    """Hides a file selector.

    --

    :note: e.g. fl_hide_fselector()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_hide_fselector = libr.cfuncproto(
        libr.load_so_libforms(), "fl_hide_fselector",
        None, [],
        """void fl_hide_fselector()""")
    libr.check_if_initialized()
    _fl_hide_fselector()


def fl_set_fselector_filetype_marker(dirmk, fifomk, sockmk, cdevmk, bdevmk):
    """Changes the prefix by which the listing of files in a directory special
    files are marked with in browser. By default D is used for directories, p
    for pipes etc.)

    --

    :Parameters:
      `dirmk` : int or char
        marker character for directories
      `fifomk` : int or char
        marker for pipes and FIFOs
      `sockmk` : int or char
        marker for sockets
      `cdevmk` : int or char
        marker for character device files
      `bdevmk` : int or char
        marker character for block device files

    :note: e.g. fl_set_fselector_filetype_marker('d', 'P', 'S', 'V', 'b')

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_fselector_filetype_marker = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_fselector_filetype_marker",
        None, [cty.c_int, cty.c_int, cty.c_int, cty.c_int, cty.c_int],
        """void fl_set_fselector_filetype_marker(int p1, int p2, int p3,
           int p4, int p5)""")
    libr.check_if_initialized()
    if isinstance(dirmk, str):
        # workaround to let a character as int argument
        odirmk = ord(dirmk)
    else:
        odirmk = dirmk
    idirmk = libr.convert_to_int(odirmk)
    if isinstance(fifomk, str):
        # workaround to let a character as int argument
        ofifomk = ord(fifomk)
    else:
        ofifomk = fifomk
    ififomk = libr.convert_to_int(ofifomk)
    if isinstance(sockmk, str):
        # workaround to let a character as int argument
        osockmk = ord(sockmk)
    else:
        osockmk = sockmk
    isockmk = libr.convert_to_int(osockmk)
    if isinstance(cdevmk, str):
        # workaround to let a character as int argument
        ocdevmk = ord(cdevmk)
    else:
        ocdevmk = cdevmk
    icdevmk = libr.convert_to_int(ocdevmk)
    if isinstance(bdevmk, str):
        # workaround to let a character as int argument
        obdevmk = ord(bdevmk)
    else:
        obdevmk = bdevmk
    ibdevmk = libr.convert_to_int(obdevmk)
    libr.keep_elem_refs(dirmk, fifomk, sockmk, cdevmk, bdevmk, idirmk,
        ififomk, isockmk, icdevmk, ibdevmk)
    _fl_set_fselector_filetype_marker(idirmk, ififomk, isockmk, icdevmk,
        ibdevmk)


def fl_set_fselector_title(title):
    """Sets the title of a file selector.

    --

    :Parameters:
      `title` : str
        title to be set

    :note: e.g. fl_set_fselector_title("My own title of F.S.)

    :status: Tested + Doc + NoDemo = OK

    """
    flbasic.fl_set_form_title(fl_get_fselector_form(), title)


def fl_goodies_atclose(pFlForm, vdata):
    """*todo*

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form
      `vdata` : any type (e.g. 'None', int, str, etc..)
        user data to be passed to function; callback has to take care of
        type check

    :return: unused value (xfdata.FL_IGNORE)
    :rtype: int

    :note: e.g. *todo*

    :status: Tested + NoDoc + NoDemo = OK

    """
    _fl_goodies_atclose = libr.cfuncproto(
        libr.load_so_libforms(), "fl_goodies_atclose",
        cty.c_int, [cty.POINTER(xfdata.FL_FORM), cty.c_void_p],
        """int fl_goodies_atclose(FL_FORM * p1, void * p2)""")
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    pvdata = cty.cast(vdata, cty.c_void_p)
    libr.keep_elem_refs(pFlForm, vdata, pvdata)
    retval = _fl_goodies_atclose(pFlForm, pvdata)
    return retval
