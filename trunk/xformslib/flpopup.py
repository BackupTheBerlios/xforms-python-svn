#!/usr/bin/env python
# -*- coding: iso8859-1 -*-

""" xforms-python's functions to manage popups.

    Copyright (C) 2009, 2010  Luca Lazzaroni "LukenShiro"
    e-mail: <lukenshiro@ngi.it>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, version 2.1 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU LGPL along with this
    program. If not, see <http://www.gnu.org/licenses/>.

    See CREDITS file to read acknowledgements and thanks to XForms,
    ctypes and other developers.
"""


# originally generated by 'h2xml+gccxml' and 'xml2py'
# then heavily reordered and reworked

# ############################################# #
# Interface to XForms shared object libraries   #
# ############################################# #


import ctypes as cty
from xformslib import library as libr
from xformslib import flxbasic
from xformslib import xfdata


####################
# forms.h (popupfn.h)
####################

def fl_popup_add(win, title):
    """Defines a new popup. There is no built-in limit to the number
    of popups that can be created.

    --

    :Parameters:
      `win` : long_pos
        window of a parent object; use flxbasic.FL_ObjWin() to find out about
        it. You can also use either 'fl_root' or 'None' for the root window.
      `title` : str
        text of title that gets shown at the top of the popup in a frame. If
        not wanted, pass an empty string or 'None'. It may contain embedded
        newline characters, this allows to create titles that span more than
        one line.

    :return: new popup, or None (on failure)
    :rtype: pointer to xfdata.FL_POPUP

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_add = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_add",
        cty.POINTER(xfdata.FL_POPUP), [xfdata.Window, xfdata.STRING],
        """FL_POPUP * fl_popup_add(Window p1, const char * p2)""")
    libr.check_if_initialized()
    if not win:         # if it's None
        win = flxbasic.fl_root
    ulwin = libr.convert_to_Window(win)
    if not title:       # if it's None
        title = ""
    stitle = libr.convert_to_string(title)
    libr.keep_elem_refs(win, title, ulwin, stitle)
    retval = _fl_popup_add(ulwin, stitle)
    return retval


def fl_popup_add_entries(pPopup, entrytxt):
    """Adds one or more entries to a popup.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `entrytxt` : str
        text of the entry to be added. It may contain newline characters which
        allows to create entries that span more than a single line (among
        special sequences only %S is supported)

    :return: popup entry, or None (on failure)
    :rtype: pointer to xfdata.FL_POPUP

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_add_entries = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_add_entries",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_POPUP),
        xfdata.STRING],
        """FL_POPUP_ENTRY * fl_popup_add_entries(FL_POPUP * p1,
           const char * p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    sentrytxt = libr.convert_to_string(entrytxt)
    libr.keep_elem_refs(pPopup, entrytxt, sentrytxt)
    retval = _fl_popup_add_entries(pPopup, sentrytxt)
    return retval


def fl_popup_insert_entries(pPopup, pPopupEntry, entrytxt):
    """Inserts one or more entries into a popup.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry after which entry is inserted. If it's 'None', it inserts
        items at the very start.
      `entrytxt` : str
        text of the entry to be added. It may contain newline characters which
        allows to create entries that span more than a single line (among
        special sequences only %S is supported)

    :return: popup entry inserted, or None (on failure)
    :rtype: pointer to xfdata.FL_POPUP_ENTRY

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_insert_entries = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_insert_entries",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_POPUP),
        cty.POINTER(xfdata.FL_POPUP_ENTRY), xfdata.STRING],
        """FL_POPUP_ENTRY * fl_popup_insert_entries(FL_POPUP * p1,
           FL_POPUP_ENTRY * p2, const char * p3)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    if not pPopupEntry:         # it's None
        pPopupEntry_alt = cty.cast(pPopupEntry, cty.POINTER(cty.c_void_p))
    else:                       # real FL_POPUP_ENTRY pointer
        pPopupEntry_alt = pPopupEntry
        libr.verify_flpopupentryptr_type(pPopupEntry_alt)
    sentrytxt = libr.convert_to_string(entrytxt)
    libr.keep_elem_refs(pPopup, pPopupEntry, pPopupEntry_alt, entrytxt,
                        sentrytxt)
    retval = _fl_popup_insert_entries(pPopup, pPopupEntry_alt, sentrytxt)
    return retval


def fl_popup_create(win, title, pPopupItem):
    """Creates a popup. It doesn't allow to associate values or pointers to
    user data to individual entries, set titles for sub-popups, have radio
    entries belong to different groups or set enter or leave callback
    functions.

    --

    :Parameters:
      `win` : long_pos
        window of a parent object (use flxbasic.FL_ObjWin() to find out about
        it). You can also use either 'fl_root' or 'None' for the root window.
      `title` : str
        text of title that gets shown at the top of the popup in a frame. If
        not wanted, pass an empty string or 'None'. It may contain embedded
        newline characters, this allows to create titles that span more than
        one line.
      `pPopupItem` : pointer to xfdata.FL_POPUP_ITEM
        popup item

    :return: popup created, or None (on failure)
    :rtype: pointer to xfdata.FL_POPUP

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_create = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_create",
        cty.POINTER(xfdata.FL_POPUP), [xfdata.Window, xfdata.STRING,
        cty.POINTER(xfdata.FL_POPUP_ITEM)],
        """FL_POPUP * fl_popup_create(Window p1, const char * p2,
           FL_POPUP_ITEM * p3)""")
    libr.check_if_initialized()
    if not win:         # if it's None
        win = flxbasic.fl_root
    ulwin = libr.convert_to_Window(win)
    if not title:       # if it's None
        title = ""
    stitle = libr.convert_to_string(title)
    libr.verify_flpopupitemptr_type(pPopupItem)
    libr.keep_elem_refs(win, title, pPopupItem, ulwin, stitle)
    retval = _fl_popup_create(ulwin, stitle, pPopupItem)
    return retval


def fl_popup_add_items(pPopup, pPopupItem):
    """Adds one or more items to a popup.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `pPopupItem` : pointer to xfdata.FL_POPUP_ITEM
        popup item

    :return: popup entry, or None
    :rtype: pointer to xfdata.FL_POPUP_ENTRY

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_add_items = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_add_items",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_POPUP),
        cty.POINTER(xfdata.FL_POPUP_ITEM)],
        """FL_POPUP_ENTRY * fl_popup_add_items(FL_POPUP * p1,
           FL_POPUP_ITEM * p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    libr.verify_flpopupitemptr_type(pPopupItem)
    libr.keep_elem_refs(pPopup, pPopupItem)
    retval = _fl_popup_add_items(pPopup, pPopupItem)
    return retval


def fl_popup_insert_items(pPopup, pPopupEntry, pPopupItem):
    """Inserts entries into a popup.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry after which items are inserted. If it's 'None', items are
        inserted at the very start.
      `pPopupItem` : pointer to xfdata.FL_POPUP_ITEM
        popup item

    :return: popup entry
    :rtype: pointer to xfdata.FL_POPUP_ENTRY

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_insert_items = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_insert_items",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_POPUP),
        cty.POINTER(xfdata.FL_POPUP_ENTRY), cty.POINTER(xfdata.FL_POPUP_ITEM)],
        """FL_POPUP_ENTRY * fl_popup_insert_items(FL_POPUP * p1,
           FL_POPUP_ENTRY * p2, FL_POPUP_ITEM * p3)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    libr.verify_flpopupentryptr_type(pPopupEntry)
    libr.verify_flpopupitemptr_type(pPopupItem)
    libr.keep_elem_refs(pPopup, pPopupEntry, pPopupItem)
    retval = _fl_popup_insert_items(pPopup, pPopupEntry, pPopupItem)
    return retval


def fl_popup_delete(pPopup):
    """Deletes a popup. It?s not possible to call the function while the
    popup is still visible on the screen. Calling it from any callback
    function is problematic unless you know for sure that the popup to be
    deleted (and sub-popups of it) won't be used later and thus normally
    should be avoided.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance

    :return: 0, or -1 (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_delete = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_delete",
        cty.c_int, [cty.POINTER(xfdata.FL_POPUP)],
        """int fl_popup_delete(FL_POPUP * p1)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    libr.keep_elem_refs(pPopup)
    retval = _fl_popup_delete(pPopup)
    return retval


def fl_popup_entry_delete(pPopupEntry):
    """Removes an existing popup entry.

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry to be removed.

    :return: 0, or -1 (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_delete = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_delete",
        cty.c_int, [cty.POINTER(xfdata.FL_POPUP_ENTRY)],
        """int fl_popup_entry_delete(FL_POPUP_ENTRY * p1)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    libr.keep_elem_refs(pPopupEntry)
    retval = _fl_popup_entry_delete(pPopupEntry)
    return retval


def fl_popup_do(pPopup):
    """Shows the created popup and returns when the the user is done with the
    popup and it has been removed from the screen. Only idle callbacks and
    timers etc. are executed in the background while a popup is being shown.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance

    :return: popup return class instance
    :rtype: pointer to xfdata.FL_POPUP_RETURN

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_do = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_do",
        cty.POINTER(xfdata.FL_POPUP_RETURN), [cty.POINTER(xfdata.FL_POPUP)],
        """FL_POPUP_RETURN * fl_popup_do(FL_POPUP * p1)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    libr.keep_elem_refs(pPopup)
    retval = _fl_popup_do(pPopup)
    return retval


def fl_popup_set_position(pPopup, x, y):
    """Sets position where the popup is supposed to appear (if never called,
    the popup appears at the mouse position).

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_set_position = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_set_position",
        None, [cty.POINTER(xfdata.FL_POPUP), cty.c_int, cty.c_int],
        """void fl_popup_set_position(FL_POPUP * p1, int p2, int p3)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    ix = libr.convert_to_int(x)
    iy = libr.convert_to_int(y)
    libr.keep_elem_refs(pPopup, x, y, ix, iy)
    _fl_popup_set_position(pPopup, ix, iy)


def fl_popup_get_policy(pPopup):
    """Obtains current policy setting for handling the popups, or changes
    the default setting for new popup to be created.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance. If it's 'None', gives the default setting for
        the popups created afterwards

    :return: policy for supplied popup, or default policy used in creating
        new popups is returned (if Nono is supplied), or -1 (on errors).
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_get_policy = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_get_policy",
        cty.c_int, [cty.POINTER(xfdata.FL_POPUP)],
        """int fl_popup_get_policy(FL_POPUP * p1)""")
    libr.check_if_initialized()
    if not pPopup:         # it's None
        pPopup_alt = cty.cast(pPopup, cty.POINTER(cty.c_void_p))
    else:                  # real FL_POPUP pointer
        pPopup_alt = pPopup
        libr.verify_flpopupptr_type(pPopup_alt)
    libr.keep_elem_refs(pPopup, pPopup_alt)
    retval = _fl_popup_get_policy(pPopup_alt)
    return retval


def fl_popup_set_policy(pPopup, policy):
    """Sets policy for handling the popup (i.e. does it get closed when the
    user releases the mouse button outside an active entry or not?) or changes
    the default setting of the policy, used in the creation of new popups.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance. If it's 'None', changes the default setting of
        the policy, used in the creation of new popups.
      `policy` : int
        policy to be set. Values (from xfdata.py) FL_POPUP_NORMAL_SELECT,
        FL_POPUP_DRAG_SELECT

    :return: previous policy value, or -1 (on errors).
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_set_policy = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_set_policy",
        cty.c_int, [cty.POINTER(xfdata.FL_POPUP), cty.c_int],
        """int fl_popup_set_policy(FL_POPUP * p1, int p2)""")
    libr.check_if_initialized()
    if not pPopup:         # it's None
        pPopup_alt = cty.cast(pPopup, cty.POINTER(cty.c_void_p))
    else:                  # real FL_POPUP pointer
        pPopup_alt = pPopup
        libr.verify_flpopupptr_type(pPopup_alt)
    libr.checkfatal_allowed_value_in_list(policy, xfdata.POPUPPOLICY_list)
    ipolicy = libr.convert_to_int(policy)
    libr.keep_elem_refs(pPopup, pPopup_alt, policy, ipolicy)
    retval = _fl_popup_set_policy(pPopup_alt, ipolicy)
    return retval


def fl_popup_set_callback(pPopup, py_PopupCb):
    """Associates with a popup or changes a callback function to be invoked
    when an entry (or an entry of a sub-popup) is selected,

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `py_PopupCb` : python function callback, returning value
        callback that is called after entry selection.
        name referring to function(pPopupReturn) -> num.
        parameter pPopopReturn is of type xfdata.FL_POPUP_RETURN

    :return: old popup callback, or None (on errors, or if no callback was
        defined)
    :rtype: pointer ot xfdata.FL_POPUP_CB

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    #FL_POPUP_CB = cty.CFUNCTYPE(cty.c_int, \
    #            cty.POINTER(xfdata.FL_POPUP_RETURN))
    _fl_popup_set_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_set_callback",
        xfdata.FL_POPUP_CB, [cty.POINTER(xfdata.FL_POPUP),
        xfdata.FL_POPUP_CB],
        """FL_POPUP_CB fl_popup_set_callback(FL_POPUP * p1,
           FL_POPUP_CB p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    libr.verify_function_type(py_PopupCb)
    c_PopupCb = xfdata.FL_POPUP_CB(py_PopupCb)
    libr.keep_cfunc_refs(c_PopupCb, py_PopupCb)
    libr.keep_elem_refs(pPopup)
    retval = _fl_popup_set_callback(pPopup, c_PopupCb)
    return retval


def fl_popup_get_title_font(pPopup):
    """Obtains the font style and size of the popup's title.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance

    :return: style, size
    :rtype: int, int

    :note: e.g. *todo*

    :attention: API change from XForms - upstream was
        fl_popup_get_title_font(pPopup, style, size)

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_get_title_font = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_get_title_font",
        None, [cty.POINTER(xfdata.FL_POPUP), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int)],
        """void fl_popup_get_title_font(FL_POPUP * p1, int * p2,
           int * p3)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    style, pstyle = libr.make_int_and_pointer()
    size, psize = libr.make_int_and_pointer()
    libr.keep_elem_refs(pPopup, style, size, pstyle, psize)
    _fl_popup_get_title_font(pPopup, pstyle, psize)
    return style.value, size.value


def fl_popup_set_title_font(pPopup, style, size):
    """Sets the font style and size of the popup's title. This setting also
    applies to sub-popups of the popup, thus setting a title font for
    sub-popups is useless. By default, size and style are (from xfdata)
    FL_NORMAL_SIZE and FL_EMBOSSED_STYLE.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `style` : int
        title style. Values (from xfdata.py) FL_NORMAL_STYLE,
        FL_BOLD_STYLE, FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        title size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE

    :note: e.g. *todo*

    :status: Tested + NoDoc + Demo = OK

    """
    _fl_popup_set_title_font = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_set_title_font",
        None, [cty.POINTER(xfdata.FL_POPUP), cty.c_int, cty.c_int],
        """void fl_popup_set_title_font(FL_POPUP * p1, int p2, int p3)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    libr.checkfatal_allowed_value_in_list(style, xfdata.TEXTSTYLE_list)
    istyle = libr.convert_to_int(style)
    libr.checknonfatal_allowed_value_in_list(size, xfdata.FONTSIZE_list)
    isize = libr.convert_to_int(size)
    libr.keep_elem_refs(pPopup, style, size, istyle, isize)
    _fl_popup_set_title_font(pPopup, istyle, isize)


def fl_popup_entry_get_font(pPopup):
    """Obtains the font style and size of the popup entries.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance

    :return: style, size
    :rtype: int, int

    :note: e.g. *todo*

    :attention: API change from XForms - upstream was
        fl_popup_entry_get_font(pPopup, style, size)

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_get_font = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_get_font",
        None, [cty.POINTER(xfdata.FL_POPUP), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int)],
        """void fl_popup_entry_get_font(FL_POPUP * p1, int * p2, int * p3)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    style, pstyle = libr.make_int_and_pointer()
    size, psize = libr.make_int_and_pointer()
    libr.keep_elem_refs(pPopup, style, size, pstyle, psize)
    _fl_popup_entry_get_font(pPopup, pstyle, psize)
    return style.value, size.value


def fl_popup_entry_set_font(pPopup, style, size):
    """Sets the font style and size of the popup entries.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `style` : int
        style of popup entries. Values (from xfdata.py) FL_NORMAL_STYLE,
        FL_BOLD_STYLE, FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        size of popup entries. Values (from xfdata.py) FL_TINY_SIZE,
        FL_SMALL_SIZE, FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE,
        FL_HUGE_SIZE, FL_DEFAULT_SIZE

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_set_font = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_set_font",
        None, [cty.POINTER(xfdata.FL_POPUP), cty.c_int, cty.c_int],
        """void fl_popup_entry_set_font(FL_POPUP * p1, int p2, int p3)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    libr.checkfatal_allowed_value_in_list(style, xfdata.TEXTSTYLE_list)
    istyle = libr.convert_to_int(style)
    libr.checknonfatal_allowed_value_in_list(size, xfdata.FONTSIZE_list)
    isize = libr.convert_to_int(size)
    libr.keep_elem_refs(pPopup, style, size, istyle, isize)
    _fl_popup_entry_set_font(pPopup, istyle, isize)


def fl_popup_get_bw(pPopup):
    """Obtains the border width of a popup.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance

    :return: borderwidth (bw)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_get_bw = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_get_bw",
        cty.c_int, [cty.POINTER(xfdata.FL_POPUP)],
        """int fl_popup_get_bw(FL_POPUP * p1)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    libr.keep_elem_refs(pPopup)
    retval = _fl_popup_get_bw(pPopup)
    return retval


def fl_popup_set_bw(pPopup, bw):
    """Sets the border width of a popup.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `bw` : int
        border width value to be set

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Tested + NoDoc + Demo = OK

    """
    _fl_popup_set_bw = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_set_bw",
        cty.c_int, [cty.POINTER(xfdata.FL_POPUP), cty.c_int],
        """int fl_popup_set_bw(FL_POPUP * p1, int p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    ibw = libr.convert_to_int(bw)
    libr.keep_elem_refs(pPopup, bw, ibw)
    retval = _fl_popup_set_bw(pPopup, ibw)
    return retval


def fl_popup_get_color(pPopup, colrpos):
    """Obtains several colors used in drawing a popup.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `colrpos` : int
        color type position. Values (from xfdata.py) FL_POPUP_BACKGROUND_COLOR,
        FL_POPUP_HIGHLIGHT_COLOR, FL_POPUP_TITLE_COLOR, FL_POPUP_TEXT_COLOR,
        FL_POPUP_HIGHLIGHT_TEXT_COLOR, FL_POPUP_DISABLED_TEXT_COLOR,
        FL_POPUP_RADIO_COLOR

    :return: color
    :rtype: long_pos

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_get_color = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_get_color",
        xfdata.FL_COLOR, [cty.POINTER(xfdata.FL_POPUP), cty.c_int],
        """FL_COLOR fl_popup_get_color(FL_POPUP * p1, int p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    libr.checkfatal_allowed_value_in_list(colrpos, xfdata.POPUPCOLOR_list)
    icolrpos = libr.convert_to_int(colrpos)
    libr.keep_elem_refs(pPopup, colrpos, icolrpos)
    retval = _fl_popup_get_color(pPopup, icolrpos)
    return retval


def fl_popup_set_color(pPopup, colrpos, colr):
    """Sets several colors used in drawing a popup.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `colrpos` : int
        color type position. Values (from xfdata.py) FL_POPUP_BACKGROUND_COLOR,
        FL_POPUP_HIGHLIGHT_COLOR, FL_POPUP_TITLE_COLOR, FL_POPUP_TEXT_COLOR,
        FL_POPUP_HIGHLIGHT_TEXT_COLOR, FL_POPUP_DISABLED_TEXT_COLOR,
        FL_POPUP_RADIO_COLOR
      `colr` : long_pos
        color value to be set

    :return: color
    :rtype: long_pos

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_set_color = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_set_color",
        xfdata.FL_COLOR, [cty.POINTER(xfdata.FL_POPUP), cty.c_int,
        xfdata.FL_COLOR],
        """FL_COLOR fl_popup_set_color(FL_POPUP * p1, int p2, FL_COLOR p3)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    libr.checkfatal_allowed_value_in_list(colrpos, xfdata.POPUPCOLOR_list)
    libr.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    icolrpos = libr.convert_to_int(colrpos)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(pPopup, colrpos, colr, icolrpos, ulcolr)
    retval = _fl_popup_set_color(pPopup, icolrpos, ulcolr)
    return retval


def fl_popup_set_cursor(pPopup, cursnum):
    """Changes the cursor displayed when a popup is shown.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `cursnum` : int
        id of a symbolic cursor shape's name

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_set_cursor = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_set_cursor",
        None, [cty.POINTER(xfdata.FL_POPUP), cty.c_int],
        """void fl_popup_set_cursor(FL_POPUP * p1, int p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    icursnum = libr.convert_to_int(cursnum)
    libr.keep_elem_refs(pPopup, cursnum, icursnum)
    _fl_popup_set_cursor(pPopup, icursnum)


def fl_popup_get_title(pPopup):
    """Obtains the title of a popup.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance

    :return: title string
    :rtype: str

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_get_title = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_get_title",
        xfdata.STRING, [cty.POINTER(xfdata.FL_POPUP)],
        """const char * fl_popup_get_title(FL_POPUP * p1)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    libr.keep_elem_refs(pPopup)
    retval = _fl_popup_get_title(pPopup)
    return retval


def fl_popup_set_title(pPopup, title):
    """Sets the title of a popup. By default, the popup of a select object
    does not have a title drawn on top of it.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `title` : str
        title of the popup

    :return: popup class instance
    :rtype: pointer to xfdata.FL_POPUP

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_set_title = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_set_title",
        cty.POINTER(xfdata.FL_POPUP), [cty.POINTER(xfdata.FL_POPUP),
        xfdata.STRING],
        """FL_POPUP * fl_popup_set_title(FL_POPUP * p1, const char * p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    stitle = libr.convert_to_string(title)
    libr.keep_elem_refs(pPopup, title, stitle)
    retval = _fl_popup_set_title(pPopup, stitle)
    return retval


def fl_popup_entry_set_callback(pPopupEntry, py_PopupCb):
    """Sets the callback invoked when the entry of a popup is selected.

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry
      `py_PopupCb` : python callback function, returning value
        name referring to function(pPopupReturn) -> num.

    :return: old popup callback, or None (when none was set or an error
        occured).
    :rtype: pointer to xfdata.FL_POPUP_CB

    :note: e.g. *todo*

    :status: Tested + NoDoc + Demo = OK

    """
    # FL_POPUP_CB = cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_POPUP_RETURN))
    _fl_popup_entry_set_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_set_callback",
        xfdata.FL_POPUP_CB, [cty.POINTER(xfdata.FL_POPUP_ENTRY),
        xfdata.FL_POPUP_CB],
        """FL_POPUP_CB fl_popup_entry_set_callback(FL_POPUP_ENTRY * p1,
           FL_POPUP_CB p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    libr.verify_function_type(py_PopupCb)
    c_PopupCb = xfdata.FL_POPUP_CB(py_PopupCb)
    libr.keep_cfunc_refs(c_PopupCb, py_PopupCb)
    libr.keep_elem_refs(pPopupEntry)
    retval = _fl_popup_entry_set_callback(pPopupEntry, c_PopupCb)
    return retval


def fl_popup_entry_set_enter_callback(pPopupEntry, py_PopupCb):
    """Sets the callback invoked when the mouse enters the area of the popup
    entry.

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry
      `py_PopupCb` : python callback function, returning value
        name referring to function(pPopupReturn) -> num.

    :return: old popup callback, or None (when none was set or an error
        occured).
    :rtype: pointer to xfdata.FL_POPUP_CB

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    # FL_POPUP_CB = cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_POPUP_RETURN))
    _fl_popup_entry_set_enter_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_set_enter_callback",
        xfdata.FL_POPUP_CB, [cty.POINTER(xfdata.FL_POPUP_ENTRY),
        xfdata.FL_POPUP_CB],
        """FL_POPUP_CB fl_popup_entry_set_enter_callback(
           FL_POPUP_ENTRY * p1, FL_POPUP_CB p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    libr.verify_function_type(py_PopupCb)
    c_PopupCb = xfdata.FL_POPUP_CB(py_PopupCb)
    libr.keep_cfunc_refs(c_PopupCb, py_PopupCb)
    libr.keep_elem_refs(pPopupEntry)
    retval = _fl_popup_entry_set_enter_callback(pPopupEntry, c_PopupCb)
    return retval


def fl_popup_entry_set_leave_callback(pPopupEntry, py_PopupCb):
    """Sets the callback invoked when leaves the area of the popup entry.

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry
      `py_PopupCb` : python callback function, returning value
        name referring to function(pPopupReturn) -> num.

    :return: old popup callback, or None (when none was set or an error
        occured).
    :rtype: pointer to xfdata.FL_POPUP_CB

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_set_leave_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_set_leave_callback",
        xfdata.FL_POPUP_CB, [cty.POINTER(xfdata.FL_POPUP_ENTRY),
        xfdata.FL_POPUP_CB],
        """FL_POPUP_CB fl_popup_entry_set_leave_callback(
           FL_POPUP_ENTRY * p1, FL_POPUP_CB p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    libr.verify_function_type(py_PopupCb)
    c_PopupCb = xfdata.FL_POPUP_CB(py_PopupCb)
    libr.keep_cfunc_refs(c_PopupCb, py_PopupCb)
    libr.keep_elem_refs(pPopupEntry)
    retval = _fl_popup_entry_set_leave_callback(pPopupEntry, c_PopupCb)
    return retval


def fl_popup_entry_get_state(pPopupEntry):
    """Obtains the state of a popup entry (e.g. from xfdata.py
    FL_POPUP_DISABLED, FL_POPUP_HIDDEN and FL_POPUP_CHECKED).

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry

    :return: current state
    :rtype: int_pos

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_get_state = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_get_state",
        cty.c_uint, [cty.POINTER(xfdata.FL_POPUP_ENTRY)],
        """unsigned int fl_popup_entry_get_state(FL_POPUP_ENTRY * p1)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    libr.keep_elem_refs(pPopupEntry)
    retval = _fl_popup_entry_get_state(pPopupEntry)
    return retval


def fl_popup_entry_set_state(pPopupEntry, state):
    """Sets the state of a popup entry.

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry
      `state` : int_pos
        state to be set. Values (from xfdata.py) FL_POPUP_DISABLED,
        FL_POPUP_HIDDEN or FL_POPUP_CHECKED

    :return: old state, or UINT_MAX? (on errors)
    :rtype: int_pos

    :note: e.g. *todo*

    :status: Tested + NoDoc + Demo = OK

    """
    _fl_popup_entry_set_state = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_set_state",
        cty.c_uint, [cty.POINTER(xfdata.FL_POPUP_ENTRY), cty.c_uint],
        """unsigned int fl_popup_entry_set_state(FL_POPUP_ENTRY * p1,
           unsigned int p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    libr.checkfatal_allowed_value_in_list(state, xfdata.POPUPSTATE_list)
    uistate = libr.convert_to_uint(state)
    libr.keep_elem_refs(pPopupEntry, state, uistate)
    retval = _fl_popup_entry_set_state(pPopupEntry, uistate)
    return retval


def fl_popup_entry_clear_state(pPopupEntry, state):
    """Clears state bits of a popup entry.

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry
      `state` : int_pos
        state to be cleared. Values (from xfdata.py) FL_POPUP_DISABLED,
        FL_POPUP_HIDDEN or FL_POPUP_CHECKED. Or a bitwise OR of them.

    :return: original value of the state
    :rtype: int_pos

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_clear_state = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_clear_state",
        cty.c_uint, [cty.POINTER(xfdata.FL_POPUP_ENTRY), cty.c_uint],
        """unsigned int fl_popup_entry_clear_state(FL_POPUP_ENTRY * p1,
           unsigned int p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    libr.checkfatal_allowed_value_in_list(state, xfdata.POPUPSTATE_list)
    uistate = libr.convert_to_uint(state)
    libr.keep_elem_refs(pPopupEntry, state, uistate)
    retval = _fl_popup_entry_clear_state(pPopupEntry, uistate)
    return retval


def fl_popup_entry_raise_state(pPopupEntry, state):
    """Sets the state bits of a popup entry.

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry
      `state` : int_pos
        state to be set. Values (from xfdata.py) FL_POPUP_DISABLED,
        FL_POPUP_HIDDEN or FL_POPUP_CHECKED. Or a bitwise OR of them.

    :return: original value of the state
    :rtype: int_pos

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_raise_state = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_raise_state",
        cty.c_uint, [cty.POINTER(xfdata.FL_POPUP_ENTRY), cty.c_uint],
        """unsigned int fl_popup_entry_raise_state(FL_POPUP_ENTRY * p1,
           unsigned int p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    libr.checkfatal_allowed_value_in_list(state, xfdata.POPUPSTATE_list)
    uistate = libr.convert_to_uint(state)
    libr.keep_elem_refs(pPopupEntry, state, uistate)
    retval = _fl_popup_entry_raise_state(pPopupEntry, uistate)
    return retval


def fl_popup_entry_toggle_state(pPopupEntry, state):
    """Toggles the state bits of a popup entry.

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry
      `state` : int_pos
        state to be toggled. Values (from xfdata.py) FL_POPUP_DISABLED,
        FL_POPUP_HIDDEN or FL_POPUP_CHECKED. Or a bitwise OR of them.

    :return: original value of the state
    :rtype: int_pos

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_toggle_state = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_toggle_state",
        cty.c_uint, [cty.POINTER(xfdata.FL_POPUP_ENTRY), cty.c_uint],
        """unsigned int fl_popup_entry_toggle_state(FL_POPUP_ENTRY * p1,
           unsigned int p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    libr.checkfatal_allowed_value_in_list(state, xfdata.POPUPSTATE_list)
    uistate = libr.convert_to_uint(state)
    libr.keep_elem_refs(pPopupEntry, state, uistate)
    retval = _fl_popup_entry_toggle_state(pPopupEntry, uistate)
    return retval


def fl_popup_entry_set_text(pPopupEntry, text):
    """Changes the text of a popup entry.

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry
      `text` : str
        text for the entry. No special sequence except "%S" (at which
        place the text is split to make up the left- and right-flushed
        part of the label drawn) is recognized.

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_set_text = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_set_text",
        cty.c_int, [cty.POINTER(xfdata.FL_POPUP_ENTRY), xfdata.STRING],
        """int fl_popup_entry_set_text(FL_POPUP_ENTRY * p1,
           const char * p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    stext = libr.convert_to_string(text)
    libr.keep_elem_refs(pPopupEntry, text, stext)
    retval = _fl_popup_entry_set_text(pPopupEntry, stext)
    return retval


def fl_popup_entry_set_shortcut(pPopupEntry, textsc):
    """Changes the shortcut keys for a popup label.

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry
      `textsc` : str
        text for the shortcut

    :note: e.g. *todo*

    :status: Tested + NoDoc + Demo = OK

    """
    _fl_popup_entry_set_shortcut = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_set_shortcut",
        None, [cty.POINTER(xfdata.FL_POPUP_ENTRY), xfdata.STRING],
        """void fl_popup_entry_set_shortcut(FL_POPUP_ENTRY * p1,
           const char * p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    stextsc = libr.convert_to_string(textsc)
    libr.keep_elem_refs(pPopupEntry, textsc, stextsc)
    _fl_popup_entry_set_shortcut(pPopupEntry, stextsc)


def fl_popup_entry_set_value(pPopupEntry, val):
    """Changes the value assigned to a popup entry.

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry
      `val` : long
        value to be assigned

    :return: previous value
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_set_value = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_set_value",
        cty.c_long, [cty.POINTER(xfdata.FL_POPUP_ENTRY), cty.c_long],
        """long int fl_popup_entry_set_value(FL_POPUP_ENTRY * p1,
           long int p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    lval = libr.convert_to_long(val)
    libr.keep_elem_refs(pPopupEntry, val, lval)
    retval = _fl_popup_entry_set_value(pPopupEntry, lval)
    return retval


def fl_popup_entry_set_user_data(pPopupEntry, vdata):
    """Modifies user data associated with a popup entry.

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry
      `vdata` : any type (e.g. 'None', int, str, etc..)
        user data to be passed to function; callback has to take care of
        type check

    :return: previous user data settings
    :rtype: pointer to void?

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_set_user_data = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_set_user_data",
        cty.c_void_p, [cty.POINTER(xfdata.FL_POPUP_ENTRY), cty.c_void_p],
        """void * fl_popup_entry_set_user_data(FL_POPUP_ENTRY * p1,
           void * p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    pvdata = cty.cast(vdata, cty.c_void_p)
    libr.keep_elem_refs(pPopupEntry, vdata, pvdata)
    retval = _fl_popup_entry_set_user_data(pPopupEntry, pvdata)
    return retval


def fl_popup_entry_get_by_position(pPopup, posnum):
    """Finds an entry by its current position in the popup. Sub-popups aren?t
    taken into consideration.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `posnum` : int
        position number starting with 0 (e.g. when called with 0 the first
        entry will be returned, when called with 1 you get the second entry
        etc. Separator lines aren?t counted but entries currently being hidden
        are.

    :return: popup entry
    :rtype: pointer to xfdata.FL_POPUP_ENTRY

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_get_by_position = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_get_by_position",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_POPUP),
        cty.c_int],
        """FL_POPUP_ENTRY * fl_popup_entry_get_by_position(FL_POPUP * p1,
           int p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    iposnum = libr.convert_to_int(posnum)
    libr.keep_elem_refs(pPopup, posnum, iposnum)
    retval = _fl_popup_entry_get_by_position(pPopup, iposnum)
    return retval


def fl_popup_entry_get_by_value(pPopup, val):
    """Finds a popup entry by its assigned value.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `val` : long
        value assigned to the entry

    :return: popup entry
    :rtype: pointer to xfdata.FL_POPUP_ENTRY

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_get_by_value = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_get_by_value",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_POPUP),
        cty.c_long],
        """FL_POPUP_ENTRY * fl_popup_entry_get_by_value(FL_POPUP * p1,
           long int p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    lval = libr.convert_to_long(val)
    libr.keep_elem_refs(pPopup, val, lval)
    retval = _fl_popup_entry_get_by_value(pPopup, lval)
    return retval


def fl_popup_entry_get_by_user_data(pPopup, vdata):
    """Finds a popup entry by its assigned user data.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `vdata` : any type (e.g. 'None', int, str, etc..)
        user data assigned to the popup entry; callback has to take care of
        type check

    :return: popup entry
    :rtype: pointer to xfdata.FL_POPUP_ENTRY

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_get_by_user_data = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_get_by_user_data",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_POPUP),
        cty.c_void_p],
        """FL_POPUP_ENTRY * fl_popup_entry_get_by_user_data(FL_POPUP * p1,
           void * p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    pvdata = cty.cast(vdata, cty.c_void_p)
    libr.keep_elem_refs(pPopup, vdata, pvdata)
    retval = _fl_popup_entry_get_by_user_data(pPopup, pvdata)
    return retval


def fl_popup_entry_get_by_text(pPopup, text):
    """Finds a popup entry that had been created with a certain text,
    including all the special sequences.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `text` : str
        text of the popup entry to be found.

    :return: popup entry, or None (on failure, because either no entry
        with this text was found or the popup doesn?t exist)
    :rtype: pointer to xfdata.FL_POPUP_ENTRY

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_get_by_text = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_get_by_text",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_POPUP),
        xfdata.STRING],
        """FL_POPUP_ENTRY * fl_popup_entry_get_by_text(FL_POPUP * p1,
           const char * p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    stext = libr.convert_to_string(text)
    libr.keep_elem_refs(pPopup, text, stext)
    retval = _fl_popup_entry_get_by_text(pPopup, stext)
    return retval


def fl_popup_entry_get_by_label(pPopup, label):
    """Finds a popup entry by its left-flushed label parts of the entry as
    shown on the screen (note that tab characters `\\t` originally embedded
    in the text used when creating the label have been replaced by single
    spaces and backspace characters `\\b` were removed as well as all special
    sequences).

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `label` : str
        label of the popup entry.

    :return: popup entry
    :rtype: pointer to xfdata.FL_POPUP_ENTRY

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_get_by_label = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_get_by_label",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_POPUP),
        xfdata.STRING],
        """FL_POPUP_ENTRY * fl_popup_entry_get_by_label(FL_POPUP * p1,
           const char * p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    slabel = libr.convert_to_string(label)
    libr.keep_elem_refs(pPopup, label, slabel)
    retval = _fl_popup_entry_get_by_label(pPopup, slabel)
    return retval


def fl_popup_entry_get_group(pPopupEntry):
    """Obtains which group a radio popup entry belongs. It makes much
    sense when applied to radio entries.

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry

    :return: group number (on success), or xfdata.INT_MAX (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_get_group = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_get_group",
        cty.c_int, [cty.POINTER(xfdata.FL_POPUP_ENTRY)],
        """int fl_popup_entry_get_group(FL_POPUP_ENTRY * p1)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    libr.keep_elem_refs(pPopupEntry)
    retval = _fl_popup_entry_get_group(pPopupEntry)
    return retval


def fl_popup_entry_set_group(pPopupEntry, groupnum):
    """Assigns a radio entry to a different group. It makes much sense when
    applied to radio entries. If one of the entries of the new group was in
    "on" state the entries state will be reset to "off" if necessary.

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry
      `groupnum` : int
        group number to be assigned.

    :return: previous group number, or xfdata.INT_MAX (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_set_group = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_set_group",
        cty.c_int, [cty.POINTER(xfdata.FL_POPUP_ENTRY), cty.c_int],
        """int fl_popup_entry_set_group(FL_POPUP_ENTRY * p1, int p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    igroupnum = libr.convert_to_int(groupnum)
    libr.keep_elem_refs(pPopupEntry, groupnum, igroupnum)
    retval = _fl_popup_entry_set_group(pPopupEntry, igroupnum)
    return retval


def fl_popup_entry_get_subpopup(pPopupEntry):
    """Obtains the sub-popup associated with a sub-popup-entry. It only
    makes sense for sub-popup entries.

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry

    :return: popup class instance
    :rtype: pointer to xfdata.FL_POPUP

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_get_subpopup = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_get_subpopup",
        cty.POINTER(xfdata.FL_POPUP), [cty.POINTER(xfdata.FL_POPUP_ENTRY)],
        """FL_POPUP * fl_popup_entry_get_subpopup(FL_POPUP_ENTRY * p1)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    libr.keep_elem_refs(pPopupEntry)
    retval = _fl_popup_entry_get_subpopup(pPopupEntry)
    return retval


def fl_popup_entry_set_subpopup(pPopupEntry, pPopup):
    """Sets the sub-popup associated with a sub-popup-entry. It only makes
    sense for sub-popup entries.

    --

    :Parameters:
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance

    :return: popup class instance
    :rtype: pointer to xfdata.FL_POPUP

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_entry_set_subpopup = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_entry_set_subpopup",
        cty.POINTER(xfdata.FL_POPUP), [cty.POINTER(xfdata.FL_POPUP_ENTRY),
        cty.POINTER(xfdata.FL_POPUP)],
        """FL_POPUP * fl_popup_entry_set_subpopup(FL_POPUP_ENTRY * p1,
           FL_POPUP * p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupentryptr_type(pPopupEntry)
    libr.verify_flpopupptr_type(pPopup)
    libr.keep_elem_refs(pPopupEntry, pPopup)
    retval = _fl_popup_entry_set_subpopup(pPopupEntry, pPopup)
    return retval


def fl_popup_get_size(pPopup):
    """Obtains the exact sizes of its window. The reported values are
    only valid until the popup is changed, e.g. by adding, deleting or
    changing entries or changing the appearance of the popup.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance

    :return: 0 or -1 on error (in case the supplied popup argument isn?t
        valid), width (w), height (h)
    :rtype: int, int_pos, int_pos

    :note: e.g. *todo*

    :attention: API change from XForms - upstream was
        fl_popup_get_size(pPopup, w, h)

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_get_size = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_get_size",
        cty.c_int, [cty.POINTER(xfdata.FL_POPUP), cty.POINTER(cty.c_uint),
        cty.POINTER(cty.c_uint)],
        """int fl_popup_get_size(FL_POPUP * p1, unsigned int * p2,
           unsigned int * p3)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    w, pw = libr.make_uint_and_pointer()
    h, ph = libr.make_uint_and_pointer()
    libr.keep_elem_refs(pPopup, w, h, pw, ph)
    retval = _fl_popup_get_size(pPopup, pw, ph)
    return retval, w.value, h.value


def fl_popup_get_min_width(pPopup):
    """Obtains the currently set minimum width.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance

    :return: width (w), or negative number (on errors)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_get_min_width = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_get_min_width",
        cty.c_int, [cty.POINTER(xfdata.FL_POPUP)],
        """int fl_popup_get_min_width(FL_POPUP * p1)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    libr.keep_elem_refs(pPopup)
    retval = _fl_popup_get_min_width(pPopup)
    return retval


def fl_popup_set_min_width(pPopup, width):
    """Sets a new minimum width of a popup. By default the width of a popup
    is calculated using the widths of the title and the entries.

    --

    :Parameters:
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance
      `width` : int
        minimum width to be set. If it's 0 or negative switches the use of
        the minimum width off.

    :return: previous width (w), or negative num. (on errors)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_popup_set_min_width = libr.cfuncproto(
        libr.load_so_libforms(), "fl_popup_set_min_width",
        cty.c_int, [cty.POINTER(xfdata.FL_POPUP), cty.c_int],
        """int fl_popup_set_min_width(FL_POPUP * p1, int p2)""")
    libr.check_if_initialized()
    libr.verify_flpopupptr_type(pPopup)
    iwidth = libr.convert_to_int(width)
    libr.keep_elem_refs(pPopup, width, iwidth)
    retval = _fl_popup_set_min_width(pPopup, iwidth)
    return retval
