#!/usr/bin/env python
# -*- coding: iso8859-1 -*-

""" Data, constants and variables to be used with xforms-python.
"""

#    Copyright (C) 2009, 2010, 2011, 2012  Luca Lazzaroni "LukenShiro"
#    e-mail: <lukenshiro@ngi.it>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Lesser General Public License as
#    published by the Free Software Foundation, version 2.1 of the License,
#    or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU Lesser General Public License for more details.
#
#    You should have received a copy of the GNU LGPL along with this
#    program. If not, see <http://www.gnu.org/licenses/>.
#
#    See CREDITS file to read acknowledgements and thanks to XForms,
#    ctypes and other developers.

# originally generated by 'h2xml+gccxml' and 'xml2py'
# then heavily reordered and reworked

# ########################################### #
# Interface to XForms shared-object libraries #
# ########################################### #

# Using a hack (fake class) to allow docstrings for variables,
# to be used with pydoc

import ctypes as cty


# /usr/include/X11/Xdefs.h
XID = cty.c_ulong
Window = XID    # cty.c_ulong
Pixmap = XID    # cty.c_ulong
Cursor = XID    # cty.c_ulong


########################################
# forms.h (Basic.h)
#  Basic definitions and limits.
#  Window system independent prototypes
#  Modify with care
########################################

# Some general constants
FL_ON = 1
FL_OK = 1
FL_VALID = 1
FL_PREEMPT = 1
FL_AUTO = 2
FL_WHEN_NEEDED = FL_AUTO    # 2
FL_OFF = 0
FL_CANCEL = 0
FL_INVALID = 0
# WM_DELETE_WINDOW callback return
FL_IGNORE = -1


# my add - list of possible values --LK
# used by input and browser
SCROLLBARVAL_list = [FL_AUTO, FL_ON, FL_OFF]


# max directory length  FL_PATH_MAX, PATH_MAX
# minimum value to enhance OS compatibility (for linux 4096) --LK
FL_PATH_MAX = 1024


# The screen coordinate unit, FL_Coord, must be of signed type.
FL_Coord = cty.c_int

FL_COLOR = cty.c_ulong

# Coordinates can be in pixels, milli-meters or points (1/72inch)
# values for enumeration 'FL_COORD_UNIT'
FL_COORD_UNIT = cty.c_int  # enum
FL_COORD_PIXEL = 0      # default, Pixel
FL_COORD_MM = 1         # milli-meter
FL_COORD_POINT = 2      # point
FL_COORD_centiMM = 3    # one hundredth of a mm
FL_COORD_centiPOINT = 4    # one hundredth of a point

# my add, list of possible values --LK
COORDUNIT_list = [FL_COORD_PIXEL, FL_COORD_MM, FL_COORD_POINT,
                  FL_COORD_centiMM, FL_COORD_centiPOINT]


# All flobject classes.
# values for enumeration 'FL_CLASS'
FL_CLASS = cty.c_int  # enum
FL_INVALID_CLASS = 0
FL_BUTTON = 1
FL_LIGHTBUTTON = 2
FL_ROUNDBUTTON = 3
FL_ROUND3DBUTTON = 4
FL_CHECKBUTTON = 5
FL_BITMAPBUTTON = 6
FL_PIXMAPBUTTON = 7
FL_BITMAP = 8
FL_PIXMAP = 9
FL_BOX = 10
FL_TEXT = 11
FL_MENU = 12
FL_CHART = 13
FL_CHOICE = 14
FL_COUNTER = 15
FL_SLIDER = 16
FL_VALSLIDER = 17
FL_INPUT = 18
FL_BROWSER = 19
FL_DIAL = 20
FL_TIMER = 21
FL_CLOCK = 22
FL_POSITIONER = 23
FL_FREE = 24
FL_XYPLOT = 25
FL_FRAME = 26
FL_LABELFRAME = 27
FL_CANVAS = 28
FL_GLCANVAS = 29
FL_TABFOLDER = 30
FL_SCROLLBAR = 31
FL_SCROLLBUTTON = 32
FL_MENUBAR = 33
#FL_TEXTBOX placeholder (internal)
FL_LABELBUTTON = 35
FL_COMBOBOX = 36
FL_IMAGECANVAS = 37
FL_THUMBWHEEL = 38
FL_COLORWHEEL = 39
FL_FORMBROWSER = 40
FL_SELECT = 41
FL_NMENU = 42
FL_SPINNER = 43
FL_TBOX = 44
FL_CLASS_END = 45           # sentinel

class admitted_values_for_FL_CLASS(object):
    """Object category

    Admitted values
    ---------------
        FL_BUTTON
            button flobject class
        FL_LIGHTBUTTON
            light button flobject class
        FL_ROUNDBUTTON
            round button flobject class
        FL_ROUND3DBUTTON
            round 3D button flobject class
        FL_CHECKBUTTON
            check button flobject class
        FL_BITMAPBUTTON
            bitmap button flobject class
        FL_PIXMAPBUTTON
            pixmap button flobject class
        FL_BITMAP
            bitmap flobject class
        FL_PIXMAP
            pixmap flobject class
        FL_BOX
            box flobject class
        FL_TEXT
            text flobject class
        FL_MENU
            menu flobject class
        FL_CHART
            chart flobject class
        FL_CHOICE
            choice flobject class
        FL_COUNTER
            counter flobject class
        FL_SLIDER
            slider flobject class
        FL_VALSLIDER
            valslider flobject class
        FL_INPUT
            input flobject class
        FL_BROWSER
            browser flobject class
        FL_DIAL
            dial flobject class
        FL_TIMER
            timer flobject class
        FL_CLOCK
            clock flobject class
        FL_POSITIONER
            positioner flobject class
        FL_FREE
            free flobject class
        FL_XYPLOT
            xyplot flobject class
        FL_FRAME
            frame flobject class
        FL_LABELFRAME
            labelframe flobject class
        FL_CANVAS
            canvas flobject class
        FL_GLCANVAS
            glcanvas flobject class
        FL_TABFOLDER
            tabfolder flobject class
        FL_SCROLLBAR
            scrollbar flobject class
        FL_SCROLLBUTTON
            scrollbutton flobject class
        FL_MENUBAR
            menubar flobject class
        FL_LABELBUTTON
            labelbutton flobject class
        FL_COMBOBOX
            combobox flobject class
        FL_IMAGECANVAS
            imagecanvas flobject class
        FL_THUMBWHEEL
            thumbwheel flobject class
        FL_COLORWHEEL
            colorwheel flobject class
        FL_FORMBROWSER
            formbrowser flobject class
        FL_SELECT
            select flobject class
        FL_NMENU
            nmenu flobject class
        FL_SPINNER
            spinner flobject class
        FL_TBOX
            textbox flobject class
    """
    pass

# my add, list of possible values --LK
OBJCLASS_list = [FL_BUTTON, FL_LIGHTBUTTON, FL_ROUNDBUTTON, FL_ROUND3DBUTTON,
                 FL_CHECKBUTTON, FL_BITMAPBUTTON, FL_PIXMAPBUTTON, FL_BITMAP,
                 FL_PIXMAP, FL_BOX, FL_TEXT, FL_MENU, FL_CHART, FL_CHOICE,
                 FL_COUNTER, FL_SLIDER, FL_VALSLIDER, FL_INPUT, FL_BROWSER,
                 FL_DIAL, FL_TIMER, FL_CLOCK, FL_POSITIONER, FL_FREE,
                 FL_XYPLOT, FL_FRAME, FL_LABELFRAME, FL_CANVAS, FL_GLCANVAS,
                 FL_TABFOLDER, FL_SCROLLBAR, FL_SCROLLBUTTON, FL_MENUBAR,
                 FL_LABELBUTTON, FL_COMBOBOX, FL_IMAGECANVAS,
                 FL_THUMBWHEEL, FL_COLORWHEEL, FL_FORMBROWSER, FL_SELECT,
                 FL_NMENU, FL_SPINNER, FL_TBOX]

FL_BEGIN_GROUP = 10000
FL_END_GROUP = 20000

FL_USER_CLASS_START = 1001      # min. user class value
FL_USER_CLASS_END = 9999        # max. user class value


FL_MAX_BW = 10      # maximum border width (in pixel)

# how to display a form onto screen
# values for enumeration 'FL_PLACE'
FL_PLACE = cty.c_int    # enum
FL_PLACE_FREE = 0       # size remain resizable
FL_PLACE_MOUSE = 1      # mouse centered on form
FL_PLACE_CENTER = 2     # center of the screen
FL_PLACE_POSITION = 4   # specific position
FL_PLACE_SIZE = 8       # specific size
FL_PLACE_GEOMETRY = 16  # specific size and position
FL_PLACE_ASPECT =  32   # keep aspect ratio
FL_PLACE_FULLSCREEN = 64        # scale to fit to screen
FL_PLACE_HOTSPOT = 128          # so mouse fall on (x,y)
FL_PLACE_ICONIC = 256           # start in iconified form
# modifiers
FL_FREE_SIZE = (1<<14)          # 16384
# TODO: verify if it can still be used now
FL_FIX_SIZE  = (1<<15)          # seems to be useless, but some programs
                                # seem to rely on it...

FL_PLACE_FREE_CENTER = (FL_PLACE_CENTER | FL_FREE_SIZE)
FL_PLACE_CENTERFREE = (FL_PLACE_CENTER | FL_FREE_SIZE)

class admitted_values_for_FL_PLACE(object):
    """how to display a form onto screen

    Admitted values
    ---------------
        FL_PLACE_FREE
            Both the position and size are completely free. The
            initial size used is the designed size. Initial position, if
            set via fl_set_form_position(), will be used otherwise
            interactive positioning may be possible if the window manager
            allows it.
        FL_PLACE_MOUSE
            The form is placed centered below the mouse. Interactive resizing
            will not be allowed unless this option is accompanied by
            FL_FREE_SIZE as in FL_PLACE_MOUSE|FL_FREE_SIZE
        FL_PLACE_CENTER
            The form is placed in the center of the screen. If FL_FREE_SIZE
            is also specified, interactive resizing will be allowed.
        FL_PLACE_POSITION
            Initial position used will be the one set via
            fl_set_form_position(). Interactive resizing is possible.
        FL_PLACE_SIZE
            The user can control the position but the size is fixed.
            Interactive resizing is not allowed once the form becomes visible.
        FL_PLACE_GEOMETRY
            Place at the latest position and size (see also below) or the
            geometry set via fl_set_form_geometry() etc. A form so shown will
            have a fixed size and interactive resizing is not allowed.
        FL_PLACE_ASPECT
            Allows interactive resizing but any new size will have the aspect
            ratio as that of the initial size.
        FL_PLACE_FULLSCREEN
            The form is scaled to cover the full screen. If FL_FREE_SIZE is
            also specified, interative resizing will be allowed.
        FL_PLACE_HOTSPOT
            The form is so placed that mouse is on the "hotspot". If
            FL_FREE_SIZE is also specified, interactive resizing will be
            allowed.
        FL_PLACE_ICONIC
            The form is shown initially iconified. The size and location used
            are the window manager's default.
        FL_FREE_SIZE
            Allows resizing (modifier).
        FL_FIX_SIZE
            seems to be useless, but some programs seem to rely on it..
            TODO: verify if it can still be used now
        FL_PLACE_FREE_CENTER
            Same as FL_PLACE_CENTER | FL_FREE_SIZE, i.e., place the form at
            the center of the screen and allow resizing.
        FL_PLACE_CENTERFREE
            Same as FL_PLACE_CENTER | FL_FREE_SIZE, i.e., place the form at
            the center of the screen and allow resizing.
    """
    pass

# my add, list of possible values --LK
# single values, or bitwise OR-ed with FL_FREE_SIZE (only if it makes sense)
PLACE_list = [FL_PLACE_FREE, FL_PLACE_MOUSE, FL_PLACE_CENTER,
        FL_PLACE_POSITION, FL_PLACE_SIZE, FL_PLACE_GEOMETRY,
        FL_PLACE_ASPECT, FL_PLACE_FULLSCREEN, FL_PLACE_HOTSPOT,
        FL_PLACE_ICONIC, FL_FREE_SIZE, FL_PLACE_FREE_CENTER,
        FL_PLACE_CENTERFREE, FL_PLACE_MOUSE | FL_FREE_SIZE,
        FL_PLACE_FULLSCREEN | FL_FREE_SIZE, FL_PLACE_HOTSPOT | FL_FREE_SIZE]


# Window manager decoration request and forms attributes
# values for unnamed enumeration
FL_FULLBORDER = 1       # normal
FL_TRANSIENT = 2        # set TRANSIENT_FOR property
FL_NOBORDER = 3         # use override_redirect to suppress decoration.

# my add, list of possible values --LK
DECORATION_list = [FL_FULLBORDER, FL_TRANSIENT, FL_NOBORDER]


# All box types
# values for enumeration 'FL_BOX_TYPE'
FL_BOX_TYPE = cty.c_int         # enum
FL_NO_BOX = 0
FL_UP_BOX = 1
FL_DOWN_BOX = 2
FL_BORDER_BOX = 3
FL_SHADOW_BOX = 4
FL_FRAME_BOX = 5
FL_ROUNDED_BOX = 6
FL_EMBOSSED_BOX = 7
FL_FLAT_BOX = 8
FL_RFLAT_BOX = 9
FL_RSHADOW_BOX = 10
FL_OVAL_BOX = 11
FL_ROUNDED3D_UPBOX = 12
FL_ROUNDED3D_DOWNBOX = 13
FL_OVAL3D_UPBOX = 14
FL_OVAL3D_DOWNBOX = 15
FL_OVAL3D_FRAMEBOX = 16
FL_OVAL3D_EMBOSSEDBOX = 17
# FL_TOPTAB_UPBOX placeholder (internal)
# FL_SELECTED_TOPTAB_UPBOX placeholder (internal)
# FL_BOTTOMTAB_UPBOX placeholder (internal)
# FL_SELECTED_BOTTOMTAB_UPBOX placeholder (internal)

FL_MAX_BOX_STYLES = 23                # sentinel

# my add, list of possible values --LK
BOXTYPE_list = [FL_NO_BOX, FL_UP_BOX, FL_DOWN_BOX, FL_BORDER_BOX, \
                FL_SHADOW_BOX, FL_FRAME_BOX, FL_ROUNDED_BOX, \
                FL_EMBOSSED_BOX, FL_FLAT_BOX, FL_RFLAT_BOX, FL_RSHADOW_BOX, \
                FL_OVAL_BOX, FL_ROUNDED3D_UPBOX, FL_ROUNDED3D_DOWNBOX, \
                FL_OVAL3D_UPBOX, FL_OVAL3D_DOWNBOX, FL_OVAL3D_FRAMEBOX, \
                FL_OVAL3D_EMBOSSEDBOX]


# How to place text relative to a box
# values for enumeration 'FL_ALIGN'
FL_ALIGN = cty.c_int            # enum
FL_ALIGN_CENTER = 0
FL_ALIGN_TOP = 1
FL_ALIGN_BOTTOM = 2
FL_ALIGN_LEFT = 4
FL_ALIGN_RIGHT = 8
FL_ALIGN_LEFT_TOP = (FL_ALIGN_TOP|FL_ALIGN_LEFT)
FL_ALIGN_RIGHT_TOP = (FL_ALIGN_TOP|FL_ALIGN_RIGHT)
FL_ALIGN_LEFT_BOTTOM = (FL_ALIGN_BOTTOM|FL_ALIGN_LEFT)
FL_ALIGN_RIGHT_BOTTOM = (FL_ALIGN_BOTTOM|FL_ALIGN_RIGHT)
FL_ALIGN_INSIDE = 8192      # (1<<13)
FL_ALIGN_VERT = 16384       # (1<<14)  not functional yet
# FL_ALIGN_TOP_LEFT placeholder (backwards)
# FL_ALIGN_TOP_RIGHT placeholder (backwards)
# FL_ALIGN_BOTTOM_LEFT placeholder (backwards)
# FL_ALIGN_BOTTOM_RIGHT placeholder (backwards)

# my add, list of possible values --LK
# single values, and bitwise OR-ed with FL_ALIGN_INSIDE
ALIGN_list = [FL_ALIGN_CENTER, FL_ALIGN_TOP, FL_ALIGN_BOTTOM, FL_ALIGN_LEFT,
        FL_ALIGN_RIGHT, FL_ALIGN_LEFT_TOP, FL_ALIGN_RIGHT_TOP,
        FL_ALIGN_LEFT_BOTTOM, FL_ALIGN_RIGHT_BOTTOM, FL_ALIGN_INSIDE,
        FL_ALIGN_VERT, FL_ALIGN_TOP|FL_ALIGN_INSIDE,
        FL_ALIGN_BOTTOM|FL_ALIGN_INSIDE, FL_ALIGN_LEFT|FL_ALIGN_INSIDE,
        FL_ALIGN_RIGHT|FL_ALIGN_INSIDE, FL_ALIGN_LEFT_TOP|FL_ALIGN_INSIDE,
        FL_ALIGN_RIGHT_TOP|FL_ALIGN_INSIDE,
        FL_ALIGN_LEFT_BOTTOM|FL_ALIGN_INSIDE,
        FL_ALIGN_RIGHT_BOTTOM|FL_ALIGN_INSIDE]


# Mouse buttons. Do not have to be consecutive
# values for unnamed enumeration
FL_MBUTTON1 = 1
FL_MBUTTON2 = 2
FL_MBUTTON3 = 3
FL_MBUTTON4 = 4
FL_MBUTTON5 = 5

FL_LEFT_MOUSE = FL_MBUTTON1
FL_MIDDLE_MOUSE = FL_MBUTTON2
FL_RIGHT_MOUSE = FL_MBUTTON3
FL_SCROLLUP_MOUSE = FL_MBUTTON4
FL_SCROLLDOWN_MOUSE = FL_MBUTTON5

FL_LEFTMOUSE = FL_LEFT_MOUSE
FL_MIDDLEMOUSE = FL_MIDDLE_MOUSE
FL_RIGHTMOUSE = FL_RIGHT_MOUSE
FL_SCROLLUPMOUSE = FL_SCROLLUP_MOUSE
FL_SCROLLDOWNMOUSE = FL_SCROLLDOWN_MOUSE

# my add, list of possible values --LK
MOUSEBTN_list = [FL_MBUTTON1, FL_MBUTTON2, FL_MBUTTON3, FL_MBUTTON4,
                 FL_MBUTTON5, FL_LEFT_MOUSE, FL_MIDDLE_MOUSE, FL_RIGHT_MOUSE,
                 FL_SCROLLUP_MOUSE, FL_SCROLLDOWN_MOUSE, FL_LEFTMOUSE,
                 FL_MIDDLEMOUSE, FL_RIGHTMOUSE, FL_SCROLLUPMOUSE,
                 FL_SCROLLDOWNMOUSE]


# control when to return input, slider and dial etc. objects.
# Bitwise OR is allowed --LK
FL_RETURN_NONE = 0
FL_RETURN_CHANGED = 1
FL_RETURN_END = 2
FL_RETURN_END_CHANGED = 4
FL_RETURN_SELECTION = 8
FL_RETURN_DESELECTION = 16
FL_RETURN_TRIGGERED = 1024
FL_RETURN_ALWAYS = ~ FL_RETURN_END_CHANGED


# from /usr/include/limits.h or other, my add --LK
INT_MAX = 2147483647        # long upstreams --LK
INT_MIN = (-INT_MAX - 1)
UINT_MAX = 4294967295
DBL_MAX = 1.79769313486231470e+308


# Some special color indices for FL private colormap.
# It does not matter what the value of each enum is,
# but it must start from 0 and be consecutive.
# values for enumeration 'FL_PD_COL'
FL_PD_COL = cty.c_int           # enum
FL_BLACK = 0
FL_RED = 1
FL_GREEN = 2
FL_YELLOW = 3
FL_BLUE = 4
FL_MAGENTA = 5
FL_CYAN = 6
FL_WHITE = 7
FL_TOMATO = 8
FL_INDIANRED = 9
FL_SLATEBLUE = 10
FL_COL1 = 11
FL_RIGHT_BCOL = 12
FL_BOTTOM_BCOL = 13
FL_TOP_BCOL = 14
FL_LEFT_BCOL = 15
FL_MCOL = 16
FL_INACTIVE = 17
FL_PALEGREEN = 18
FL_DARKGOLD = 19
FL_ORCHID = 20
FL_DARKCYAN = 21
FL_DARKTOMATO = 22
FL_WHEAT = 23
FL_DARKORANGE = 24
FL_DEEPPINK = 25
FL_CHARTREUSE = 26
FL_DARKVIOLET = 27
FL_SPRINGGREEN = 28
FL_DODGERBLUE = 29
FL_LIGHTER_COL1 = 30
FL_DARKER_COL1 = 31
FL_ALICEBLUE = 32
FL_ANTIQUEWHITE = 33
FL_AQUA = 34
FL_AQUAMARINE = 35
FL_AZURE = 36
FL_BEIGE = 37
FL_BISQUE = 38
FL_BLANCHEDALMOND = 39
FL_BLUEVIOLET = 40
FL_BROWN = 41
FL_BURLYWOOD = 42
FL_CADETBLUE = 43
FL_CHOCOLATE = 44
FL_CORAL = 45
FL_CORNFLOWERBLUE = 46
FL_CORNSILK = 47
FL_CRIMSON = 48
FL_DARKBLUE = 49
FL_DARKGOLDENROD = 50
FL_DARKGRAY = 51
FL_DARKGREEN = 52
FL_DARKGREY = 53
FL_DARKKHAKI = 54
FL_DARKMAGENTA = 55
FL_DARKOLIVEGREEN = 56
FL_DARKORCHID = 57
FL_DARKRED = 58
FL_DARKSALMON = 59
FL_DARKSEAGREEN = 60
FL_DARKSLATEBLUE = 61
FL_DARKSLATEGRAY = 62
FL_DARKSLATEGREY = 63
FL_DARKTURQUOISE = 64
FL_DEEPSKYBLUE = 65
FL_DIMGRAY = 66
FL_DIMGREY = 67
FL_FIREBRICK = 68
FL_FLORALWHITE = 69
FL_FORESTGREEN = 70
FL_FUCHSIA = 71
FL_GAINSBORO = 72
FL_GHOSTWHITE = 73
FL_GOLD = 74
FL_GOLDENROD = 75
FL_GRAY = 76
FL_GREENYELLOW = 77
FL_GREY = 78
FL_HONEYDEW = 79
FL_HOTPINK = 80
FL_INDIGO = 81
FL_IVORY = 82
FL_KHAKI = 83
FL_LAVENDER = 84
FL_LAVENDERBLUSH = 85
FL_LAWNGREEN = 86
FL_LEMONCHIFFON = 87
FL_LIGHTBLUE = 88
FL_LIGHTCORAL = 89
FL_LIGHTCYAN = 90
FL_LIGHTGOLDENRODYELLOW = 91
FL_LIGHTGRAY = 92
FL_LIGHTGREEN = 93
FL_LIGHTGREY = 94
FL_LIGHTPINK = 95
FL_LIGHTSALMON = 96
FL_LIGHTSEAGREEN = 97
FL_LIGHTSKYBLUE = 98
FL_LIGHTSLATEGRAY = 99
FL_LIGHTSLATEGREY = 100
FL_LIGHTSTEELBLUE = 101
FL_LIGHTYELLOW = 102
FL_LIME = 103
FL_LIMEGREEN = 104
FL_LINEN = 105
FL_MAROON = 106
FL_MEDIUMAQUAMARINE = 107
FL_MEDIUMBLUE = 108
FL_MEDIUMORCHID = 109
FL_MEDIUMPURPLE = 110
FL_MEDIUMSEAGREEN = 111
FL_MEDIUMSLATEBLUE = 112
FL_MEDIUMSPRINGGREEN = 113
FL_MEDIUMTURQUOISE = 114
FL_MEDIUMVIOLETRED = 115
FL_MIDNIGHTBLUE = 116
FL_MINTCREAM = 117
FL_MISTYROSE = 118
FL_MOCCASIN = 119
FL_NAVAJOWHITE = 120
FL_NAVY = 121
FL_OLDLACE = 122
FL_OLIVE = 123
FL_OLIVEDRAB = 124
FL_ORANGE = 125
FL_ORANGERED = 126
FL_PALEGOLDENROD = 127
FL_PALETURQUOISE = 128
FL_PALEVIOLETRED = 129
FL_PAPAYAWHIP = 130
FL_PEACHPUFF = 131
FL_PERU = 132
FL_PINK = 133
FL_PLUM = 134
FL_POWDERBLUE = 135
FL_PURPLE = 136
FL_ROSYBROWN = 137
FL_ROYALBLUE = 138
FL_SADDLEBROWN = 139
FL_SALMON = 140
FL_SANDYBROWN = 141
FL_SEAGREEN = 142
FL_SEASHELL = 143
FL_SIENNA = 144
FL_SILVER = 145
FL_SKYBLUE = 146
FL_SLATEGRAY = 147
FL_SLATEGREY = 148
FL_SNOW = 149
FL_STEELBLUE = 150
FL_TAN = 151
FL_TEAL = 152
FL_THISTLE = 153
FL_TURQUOISE = 154
FL_VIOLET = 155
FL_WHITESMOKE = 156
FL_YELLOWGREEN = 157
FL_FREE_COL1 = 256
FL_FREE_COL2 = 257
FL_FREE_COL3 = 258
FL_FREE_COL4 = 259
FL_FREE_COL5 = 260
FL_FREE_COL6 = 261
FL_FREE_COL7 = 262
FL_FREE_COL8 = 263
FL_FREE_COL9 = 264
FL_FREE_COL10 = 265
FL_FREE_COL11 = 266
FL_FREE_COL12 = 267
FL_FREE_COL13 = 268
FL_FREE_COL14 = 269
FL_FREE_COL15 = 270
FL_FREE_COL16 = 271
FL_NOCOLOR = INT_MAX

FL_BUILT_IN_COLS = FL_YELLOWGREEN + 1
FL_INACTIVE_COL = FL_INACTIVE

# Some aliases for a number of colors.
FL_GRAY16 = FL_RIGHT_BCOL
FL_GRAY35 = FL_BOTTOM_BCOL
FL_GRAY80 = FL_TOP_BCOL
FL_GRAY90 = FL_LEFT_BCOL
FL_GRAY63 = FL_COL1
FL_GRAY75 = FL_MCOL
FL_LCOL = FL_BLACK
FL_NoColor = FL_NOCOLOR

# FL_DOGERBLUE placeholder (backwards)

class admitted_values_for_FL_PD_COL(object):
    """Some special color indices for FL private colormap

    Admitted values
    ---------------
        FL_BLACK or FL_LCOL : RGB triple (0,0,0)
        FL_RED : RGB triple (255,0,0)
        FL_GREEN : RGB triple (0,255,0)
        FL_YELLOW : RGB triple (255,255,0)
        FL_BLUE : RGB triple (0,0,255)
        FL_MAGENTA : RGB triple (255,0,255)
        FL_CYAN : RGB triple (0,255,255)
        FL_WHITE : RGB triple (255,255,255)
        FL_TOMATO : RGB triple (255,99,71)
        FL_INDIANRED : RGB triple (198,113,113)
        FL_SLATEBLUE : RGB triple (113,113,198)
        FL_COL1 or FL_GRAY63 : RGB triple (173,173,173)
        FL_RIGHT_BCOL or FL_GRAY16 : RGB triple (41,41,41)
        FL_BOTTOM_BCOL or FL_GRAY35 : RGB triple (89,89,89)
        FL_TOP_BCOL or FL_GRAY80 : RGB triple (204,204,204)
        FL_LEFT_BCOL or FL_GRAY90 : RGB triple (222,222,222)
        FL_MCOL or FL_GRAY75 : RGB triple (191,191,191)
        FL_INACTIVE or FL_INACTIVE_COL : RGB triple (110,110,110)
        FL_PALEGREEN : RGB triple (113,198,113)
        FL_DARKGOLD : RGB triple (205,149,10)
        FL_ORCHID : RGB triple (205,105,201)
        FL_DARKCYAN : RGB triple (40,170,175)
        FL_DARKTOMATO : RGB triple (139,54,38)
        FL_WHEAT : RGB triple (255,231,155)
        FL_DARKORANGE : RGB triple (255,128,0)
        FL_DEEPPINK : RGB triple (255,0,128)
        FL_CHARTREUSE : RGB triple (128,255,0)
        FL_DARKVIOLET : RGB triple (128,0,255)
        FL_SPRINGGREEN : RGB triple (0,255,128)
        FL_DODGERBLUE : RGB triple (0,128,255)
        FL_LIGHTER_COL1 : RGB triple (204,204,204)
        FL_DARKER_COL1 : RGB triple (161,161,161)
        FL_ALICEBLUE : RGB triple (240,248,255)
        FL_ANTIQUEWHITE : RGB triple (250,235,215)
        FL_AQUA : RGB triple (0,255,255)
        FL_AQUAMARINE : RGB triple (127,255,212)
        FL_AZURE : RGB triple (240,255,255)
        FL_BEIGE : RGB triple (245,245,220)
        FL_BISQUE : RGB triple (255,228,196)
        FL_BLANCHEDALMOND : RGB triple (255,235,205)
        FL_BLUEVIOLET : RGB triple (138,43,226)
        FL_BROWN : RGB triple (165,42,42)
        FL_BURLYWOOD : RGB triple (222,184,135)
        FL_CADETBLUE : RGB triple (95,158,160)
        FL_CHOCOLATE : RGB triple (210,105,30)
        FL_CORAL : RGB triple (255,127,80)
        FL_CORNFLOWERBLUE : RGB triple (100,149,237)
        FL_CORNSILK : RGB triple (255,248,220)
        FL_CRIMSON : RGB triple (220,20,60)
        FL_DARKBLUE : RGB triple (0,0,139)
        FL_DARKGOLDENROD : RGB triple (184,134,11)
        FL_DARKGRAY : RGB triple (169,169,169)
        FL_DARKGREEN : RGB triple (0,100,0)
        FL_DARKGREY : RGB triple (169,169,169)
        FL_DARKKHAKI : RGB triple (189,183,107)
        FL_DARKMAGENTA : RGB triple (139,0,139)
        FL_DARKOLIVEGREEN : RGB triple (85,107,47)
        FL_DARKORCHID : RGB triple (153,50,204)
        FL_DARKRED : RGB triple (139,0,0)
        FL_DARKSALMON : RGB triple (233,150,122)
        FL_DARKSEAGREEN : RGB triple (143,188,143)
        FL_DARKSLATEBLUE : RGB triple (72,61,139)
        FL_DARKSLATEGRAY or FL_DARKSLATEGREY : RGB triple (47,79,79)
        FL_DARKTURQUOISE : RGB triple (0,206,209)
        FL_DEEPSKYBLUE : RGB triple (0,191,255)
        FL_DIMGRAY or FL_DIMGREY : RGB triple (105,105,105)
        FL_FIREBRICK : RGB triple (178,34,34)
        FL_FLORALWHITE : RGB triple (255,250,240)
        FL_FORESTGREEN : RGB triple (34,139,34)
        FL_FUCHSIA : RGB triple (255,0,255)
        FL_GAINSBORO : RGB triple (220,220,220)
        FL_GHOSTWHITE : RGB triple (248,248,255)
        FL_GOLD : RGB triple (255,215,0)
        FL_GOLDENROD : RGB triple (218,165,32)
        FL_GRAY or FL_GREY : RGB triple (128,128,128)
        FL_GREENYELLOW : RGB triple (173,255,47)
        FL_HONEYDEW : RGB triple (240,255,240)
        FL_HOTPINK : RGB triple (255,105,180)
        FL_INDIGO : RGB triple (75,0,130)
        FL_IVORY : RGB triple (255,255,240)
        FL_KHAKI : RGB triple (240,230,140)
        FL_LAVENDER : RGB triple (230,230,250)
        FL_LAVENDERBLUSH : RGB triple (255,240,245)
        FL_LAWNGREEN : RGB triple (124,252,0)
        FL_LEMONCHIFFON : RGB triple (255,250,205)
        FL_LIGHTBLUE : RGB triple (173,216,230)
        FL_LIGHTCORAL : RGB triple (240,128,128)
        FL_LIGHTCYAN : RGB triple (224,255,255)
        FL_LIGHTGOLDENRODYELLOW : RGB triple (250,250,210)
        FL_LIGHTGRAY : RGB triple (211,211,211)
        FL_LIGHTGREEN : RGB triple (144,238,144)
        FL_LIGHTGREY : RGB triple (211,211,211)
        FL_LIGHTPINK : RGB triple (255,182,193)
        FL_LIGHTSALMON : RGB triple (255,160,122)
        FL_LIGHTSEAGREEN : RGB triple (32,178,170)
        FL_LIGHTSKYBLUE : RGB triple (135,206,250)
        FL_LIGHTSLATEGRAY or FL_LIGHTSLATEGREY : RGB triple (119,136,153)
        FL_LIGHTSTEELBLUE : RGB triple (176,196,222)
        FL_LIGHTYELLOW : RGB triple (255,255,224)
        FL_LIME : RGB triple (0,255,0)
        FL_LIMEGREEN : RGB triple (50,205,50)
        FL_LINEN : RGB triple (250,240,230)
        FL_MAROON : RGB triple (128,0,0)
        FL_MEDIUMAQUAMARINE : RGB triple (102,205,170)
        FL_MEDIUMBLUE : RGB triple (0,0,205)
        FL_MEDIUMORCHID : RGB triple (186,85,211)
        FL_MEDIUMPURPLE : RGB triple (147,112,219)
        FL_MEDIUMSEAGREEN : RGB triple (60,179,113)
        FL_MEDIUMSLATEBLUE : RGB triple (123,104,238)
        FL_MEDIUMSPRINGGREEN : RGB triple (0,250,154)
        FL_MEDIUMTURQUOISE : RGB triple (72,209,204)
        FL_MEDIUMVIOLETRED : RGB triple (199,21,133)
        FL_MIDNIGHTBLUE : RGB triple (25,25,112)
        FL_MINTCREAM : RGB triple (245,255,250)
        FL_MISTYROSE : RGB triple (255,228,225)
        FL_MOCCASIN : RGB triple (255,228,181)
        FL_NAVAJOWHITE : RGB triple (255,222,173)
        FL_NAVY : RGB triple (0,0,128)
        FL_OLDLACE : RGB triple (253,245,230)
        FL_OLIVE : RGB triple (128,128,0)
        FL_OLIVEDRAB : RGB triple (107,142,35)
        FL_ORANGE : RGB triple (255,165,0)
        FL_ORANGERED : RGB triple (255,69,0)
        FL_PALEGOLDENROD : RGB triple (238,232,170)
        FL_PALETURQUOISE : RGB triple (175,238,238)
        FL_PALEVIOLETRED : RGB triple (219,112,147)
        FL_PAPAYAWHIP : RGB triple (255,239,213)
        FL_PEACHPUFF : RGB triple (255,218,185)
        FL_PERU : RGB triple (205,133,63)
        FL_PINK : RGB triple (255,192,203)
        FL_PLUM : RGB triple (221,160,221)
        FL_POWDERBLUE : RGB triple (176,224,230)
        FL_PURPLE : RGB triple (128,0,128)
        FL_ROSYBROWN : RGB triple (188,143,143)
        FL_ROYALBLUE : RGB triple (65,105,225)
        FL_SADDLEBROWN : RGB triple (139,69,19)
        FL_SALMON : RGB triple (250,128,114)
        FL_SANDYBROWN : RGB triple (244,164,96)
        FL_SEAGREEN : RGB triple (46,139,87)
        FL_SEASHELL : RGB triple (255,245,238)
        FL_SIENNA : RGB triple (160,82,45)
        FL_SILVER : RGB triple (192,192,192)
        FL_SKYBLUE : RGB triple (135,206,235)
        FL_SLATEGRAY or FL_SLATEGREY : RGB triple (112,128,144)
        FL_SNOW : RGB triple (255,250,250)
        FL_STEELBLUE : RGB triple (70,130,180)
        FL_TAN : RGB triple (210,180,140)
        FL_TEAL : RGB triple (0,128,128)
        FL_THISTLE : RGB triple (216,191,216)
        FL_TURQUOISE : RGB triple (64,224,208)
        FL_VIOLET : RGB triple (238,130,238)
        FL_WHITESMOKE : RGB triple (245,245,245)
        FL_YELLOWGREEN : RGB triple (154,205,50)
        FL_FREE_COL1 : RGB triple (0,0,0)
        FL_FREE_COL2 : RGB triple (0,0,0)
        FL_FREE_COL3 : RGB triple (0,0,0)
        FL_FREE_COL4 : RGB triple (0,0,0)
        FL_FREE_COL5 : RGB triple (0,0,0)
        FL_FREE_COL6 : RGB triple (0,0,0)
        FL_FREE_COL7 : RGB triple (0,0,0)
        FL_FREE_COL8 : RGB triple (0,0,0)
        FL_FREE_COL9 : RGB triple (0,0,0)
        FL_FREE_COL10 : RGB triple (0,0,0)
        FL_FREE_COL11 : RGB triple (0,0,0)
        FL_FREE_COL12 : RGB triple (0,0,0)
        FL_FREE_COL13 : RGB triple (0,0,0)
        FL_FREE_COL14 : RGB triple (0,0,0)
        FL_FREE_COL15 : RGB triple (0,0,0)
        FL_FREE_COL16 : RGB triple (0,0,0)
        FL_NOCOLOR or FL_NoColor : No color
    """

# my add, list of (some of) possible values --LK
COLOR_list = [FL_BLACK, FL_RED, FL_GREEN, FL_YELLOW, FL_BLUE, FL_MAGENTA,
        FL_CYAN, FL_WHITE, FL_TOMATO, FL_INDIANRED, FL_SLATEBLUE, FL_COL1,
        FL_RIGHT_BCOL, FL_BOTTOM_BCOL, FL_TOP_BCOL, FL_LEFT_BCOL, FL_MCOL,
        FL_INACTIVE, FL_PALEGREEN, FL_DARKGOLD, FL_ORCHID, FL_DARKCYAN,
        FL_DARKTOMATO, FL_WHEAT, FL_DARKORANGE, FL_DEEPPINK, FL_CHARTREUSE,
        FL_DARKVIOLET, FL_SPRINGGREEN, FL_DODGERBLUE, FL_LIGHTER_COL1,
        FL_DARKER_COL1, FL_ALICEBLUE, FL_ANTIQUEWHITE, FL_AQUA, FL_AQUAMARINE,
        FL_AZURE, FL_BEIGE, FL_BISQUE, FL_BLANCHEDALMOND, FL_BLUEVIOLET,
        FL_BROWN, FL_BURLYWOOD, FL_CADETBLUE, FL_CHOCOLATE, FL_CORAL,
        FL_CORNFLOWERBLUE, FL_CORNSILK, FL_CRIMSON, FL_DARKBLUE,
        FL_DARKGOLDENROD, FL_DARKGRAY, FL_DARKGREEN, FL_DARKGREY,
        FL_DARKKHAKI, FL_DARKMAGENTA, FL_DARKOLIVEGREEN, FL_DARKORCHID,
        FL_DARKRED, FL_DARKSALMON, FL_DARKSEAGREEN, FL_DARKSLATEBLUE,
        FL_DARKSLATEGRAY, FL_DARKSLATEGREY, FL_DARKTURQUOISE, FL_DEEPSKYBLUE,
        FL_DIMGRAY, FL_DIMGREY, FL_FIREBRICK, FL_FLORALWHITE, FL_FORESTGREEN,
        FL_FUCHSIA, FL_GAINSBORO, FL_GHOSTWHITE, FL_GOLD, FL_GOLDENROD,
        FL_GRAY, FL_GREENYELLOW, FL_GREY, FL_HONEYDEW, FL_HOTPINK, FL_INDIGO,
        FL_IVORY, FL_KHAKI, FL_LAVENDER, FL_LAVENDERBLUSH, FL_LAWNGREEN,
        FL_LEMONCHIFFON, FL_LIGHTBLUE, FL_LIGHTCORAL, FL_LIGHTCYAN,
        FL_LIGHTGOLDENRODYELLOW, FL_LIGHTGRAY, FL_LIGHTGREEN, FL_LIGHTGREY,
        FL_LIGHTPINK, FL_LIGHTSALMON, FL_LIGHTSEAGREEN, FL_LIGHTSKYBLUE,
        FL_LIGHTSLATEGRAY, FL_LIGHTSLATEGREY, FL_LIGHTSTEELBLUE,
        FL_LIGHTYELLOW, FL_LIME, FL_LIMEGREEN, FL_LINEN, FL_MAROON,
        FL_MEDIUMAQUAMARINE, FL_MEDIUMBLUE, FL_MEDIUMORCHID, FL_MEDIUMPURPLE,
        FL_MEDIUMSEAGREEN, FL_MEDIUMSLATEBLUE, FL_MEDIUMSPRINGGREEN,
        FL_MEDIUMTURQUOISE, FL_MEDIUMVIOLETRED, FL_MIDNIGHTBLUE, FL_MINTCREAM,
        FL_MISTYROSE, FL_MOCCASIN, FL_NAVAJOWHITE, FL_NAVY, FL_OLDLACE,
        FL_OLIVE, FL_OLIVEDRAB, FL_ORANGE, FL_ORANGERED, FL_PALEGOLDENROD,
        FL_PALETURQUOISE, FL_PALEVIOLETRED, FL_PAPAYAWHIP, FL_PEACHPUFF,
        FL_PERU, FL_PINK, FL_PLUM, FL_POWDERBLUE, FL_PURPLE, FL_ROSYBROWN,
        FL_ROYALBLUE, FL_SADDLEBROWN, FL_SALMON, FL_SANDYBROWN, FL_SEAGREEN,
        FL_SEASHELL, FL_SIENNA, FL_SILVER, FL_SKYBLUE, FL_SLATEGRAY,
        FL_SLATEGREY, FL_SNOW, FL_STEELBLUE, FL_TAN, FL_TEAL, FL_THISTLE,
        FL_TURQUOISE, FL_VIOLET, FL_WHITESMOKE, FL_YELLOWGREEN, FL_FREE_COL1,
        FL_FREE_COL2, FL_FREE_COL3, FL_FREE_COL4, FL_FREE_COL5, FL_FREE_COL6,
        FL_FREE_COL7, FL_FREE_COL8, FL_FREE_COL9, FL_FREE_COL10,
        FL_FREE_COL11, FL_FREE_COL12, FL_FREE_COL13, FL_FREE_COL14,
        FL_FREE_COL15, FL_FREE_COL16, FL_NOCOLOR, FL_INACTIVE_COL]


# Events that a form reacts to.
# values for enumeration 'FL_EVENTS'
FL_EVENTS = cty.c_int           # enum
FL_NOEVENT = 0
FL_DRAW = 1
FL_PUSH = 2
FL_RELEASE = 3
FL_ENTER = 4
FL_LEAVE = 5
FL_MOTION = 6
FL_FOCUS = 7
FL_UNFOCUS = 8
FL_KEYPRESS = 9
FL_UPDATE = 10
FL_STEP = 11
FL_SHORTCUT = 12
FL_FREEMEM = 13
FL_OTHER = 14
FL_DRAWLABEL = 15
FL_DBLCLICK = 16
FL_TRPLCLICK = 17
FL_ATTRIB = 18
FL_KEYRELEASE = 19
FL_PS = 20
FL_MOVEORIGIN = 21
FL_RESIZED = 22
# FL_MOVE placeholder (backwards)
# FL_KEYBOARD placeholder (backwards)
# FL_MOUSE placeholder (backwards)

class admitted_values_for_FL_EVENTS(object):
    """Events that a form reacts to.

    Admitted values
    ---------------
        FL_NOEVENT
            *todo*
        FL_DRAW
            The flobject has to be (re)drawn. To figure out the actual size
            of the flobject you can use the fields ptr_flobject.contents.x,
            ptr_flobject.contents.y, ptr_flobject.contents.w and
            ptr_flobject.contents.h. Many Xlib drawing routines require a
            window ID, which you can obtain from the flobject pointer using
            FL_ObjWin(ptr_flobject). Some other aspects might also influence
            the way the flobject has to be drawn. E.g., you might want to
            draw the flobject differently when the mouse is on top of it or
            when the mouse is pressed on it. This can be figured out the
            following way, the field ptr_flobject.contents.belowmouse tells
            you whether the flobject is below the mouse. The field
            ptr_flobject.contents.pushed indicates whether the flobject is
            currently being pushed with the mouse. Finally,
            ptr_flobject.contents.focus indicate whether input focus is
            directed towards this object. Note that drawing of the flobject
            is the full responsibility of the flobject class, including the
            bounding box and the label, which can be found in the field
            ptr_flobject.contents.label. The Forms Library provides a large
            number of routines to help you draw object. One important caution
            about your draw event handling code, none of the high level
            routines (fl_freeze_form(), fl_deactivate_form()) etc. can be
            used. The only routines allowed to be used are (direct) drawing
            functions and flobject internal book keeping routines. Attributes
            modifying routines, such as fl_set_object_color() etc. are not
            allowed (using them can lead to infinite recursions). In addition,
            (re)drawing of other flobjects using fl_redraw_object() while
            handling FL_DRAW will also not work. Due to the way double
            buffering is handled, at the time the FL_DRAW event is passed
            to the handling function (and only then) FL_ObjWin(ptr_flobject)
            might return a pixmap used as the backbuffer (at least if the
            flobject is double buffered). What that means is that
            FL_ObjWin(ptr_flobject) should not be used when a real window is
            needed. For a real window you can change the window's cursor or
            query the mouse position within it. You cannot do either of these
            with the backbuffer pixmap. If there is a need to obtain the real
            window ID the following routine can be used
            fl_get_real_object_window(). To summarize, use
            FL_ObjWin(ptr_flobject) when drawing and use
            fl_get_real_object_window() for cursor or pointer routines.
            This distinction is important only while handling FL_DRAW events,
            FL_ObjWin(obj) should be used anywhere else.
        FL_PUSH
            The user has pushed a mouse button on the flobject. Normally this
            requires some actual action. The number of the mouse button pushed
            is given in the 'key' parameter, having one of FL_*_MOUSE values.
        FL_RELEASE
            The user has released the mouse button. This event is only sent if
            a FL_PUSH event was sent before.
        FL_ENTER
            This event is sent when the mouse has entered the bounding box
            and might require some action. Note also that the field
            ptr_flobject.content.belowmouse in the flobject is being set. If
            entering an flobjects area only changes its appearance, redrawing
            it normally suffices. Do not do this directly! Always redraw the
            flobject by calling fl_redraw_object(). It will send a FL_DRAW
            event to the flobject but also does some other things (like
            setting window IDs and taking care of double buffering etc.).
        FL_LEAVE
            The mouse has left the bounding box. Again, normally a redraw is
            enough (or nothing at all).
        FL_MOTION
            Motion events get sent between FL_ENTER and FL_LEAVE events when
            the mouse position changes on the flobject. The mouse position is
            given as an argument to the handle routine.
        FL_FOCUS
            Input got focussed to this object. This type of event and the
            next two are only sent to flobjects for which the field
            ptr_flobject.contents.input is set to 1 (see below).
        FL_UNFOCUS
            Input is no longer focussed on the flobject.
        FL_KEYPRESS
            A key was pressed. The ASCII value (or KeySym if non-ASCII) is
            passed to the routine via the 'key' argument, modifier keys can
            be retrieved from the state member of the XEvent also passed to
            the function via 'xev'. This event only happens between FL_FOCUS
            and FL_UNFOCUS events. Not all flobjects sent keyboard events,
            only those that have non-zero value in field
            ptr_flobject.contents.input or ptr_flobject.contents.wantkey.
        FL_UPDATE
            for flobjects that need to update something from time to time.
            Such an event, like the FL_STEP event, also gets send about every
            50 msec (but less often under high load) to flobjects while they
            are "pushed", i.e. between receiving a FL_PUSH and a FL_RELEASE
            event if the ptr_flobject.contents.want_update field is set for
            the flobject. Like for the FL_STEP event the handling routine
            receives a synthetic MotionNotify event as the XEvent. This is
            typically used by flobjects that have to perform tasks at regular
            time intervals while they are "pushed" (e.g. counters that need
            to count up or down while the mouse is pushed on one of its
            buttons).
        FL_STEP
            A FL_STEP event is sent all the time (typically about 20 times
            a second but possibly less often because of system delays and
            other time-consuming tasks) to flobjects for which the field
            ptr_flobject.contents.automatic has been set to a non-zero value.
            The handling routine receives a synthetic MotionNotify event as
            the XEvent. This can be used to make a flobject change appearance
            without user action. Clock and timer flobjects use this type of
            event.
        FL_SHORTCUT
            The user used a keyboard shortcut. The shortcut used is given
            in the parameter key. See below for more on shortcuts.
        FL_FREEMEM
            This event is sent when the flobject is to be freed. All memory
            allocated for the flobject must be freed when this event is
            received.
        FL_OTHER
            property, selection etc. Events other than the above. These
            events currently include ClientMessage, Selection and possibly
            other window manager events. All information about the event
            is contained in 'xev' parameter and 'mx', 'my' may or may not
            reflect the actual position of the mouse.
        FL_DRAWLABEL
            This event typically follows FL_DRAW and indicates that the
            flobject label needs to be (re)drawn. If the flobject in question
            always draws its label inside the bounding box and this is
            taken care of by handing FL_DRAW, you can ignore this event.
        FL_DBLCLICK
            double click. The user has pushed a mouse button twice within
            a certain time limit (FL_CLICK_TIMEOUT), which by default is
            400 msec. This event is sent after two FL_PUSH, FL_RELEASE
            sequence. Note that FL_DBLCLICK is only generated for flobjects
            that have non-zero ptr_flobject.contents.click timeout fields and
            it will not be generated for events from the scroll wheel.
        FL_TRPLCLICK
            triple click. The user has pushed a mouse button three times
            within a certain time window. This event is sent after a
            FL_DBLCLICK, FL_PUSH, FL_RELEASE sequence. Set click timeout
            to none-zero to activate FL_TRPLCLICK.
        FL_ATTRIB
            attribute change *todo*
        FL_KEYRELEASE
            A pressed key is released.
        FL_PS
            dumps a form into EPS
        FL_MOVEORIGIN
            dragging the form across the screen changes its absolute x,y
            coords. Objects that themselves contain forms should ensure
            that they are up to date.
        FL_RESIZED
            the flobject has been resized by scale_form the flobject has been
            resized by scale_form. Tell it that this has happened so that
            it can resize any FL_FORMs that it contains.
    """

# TODO: verify if bitwise OR-ed makes sense here.
# my add, list of possible values --LK
# single values, or ?
EVENTS_list = [FL_DRAW, FL_PUSH, FL_RELEASE, FL_ENTER, FL_LEAVE,
               FL_MOTION, FL_FOCUS, FL_UNFOCUS, FL_KEYPRESS, FL_UPDATE,
               FL_STEP, FL_SHORTCUT, FL_FREEMEM, FL_OTHER, FL_DRAWLABEL,
               FL_DBLCLICK, FL_TRPLCLICK, FL_ATTRIB, FL_KEYRELEASE,
               FL_PS, FL_MOVEORIGIN, FL_RESIZED]


# Resize policies
# values for enumeration 'FL_RESIZE_T'
FL_RESIZE_T = cty.c_int         # enum
FL_RESIZE_NONE = 0
FL_RESIZE_X = 1
FL_RESIZE_Y = 2
FL_RESIZE_ALL = (FL_RESIZE_X | FL_RESIZE_Y)

# my add, list of possible values --LK
RESIZE_list = [FL_RESIZE_NONE, FL_RESIZE_X, FL_RESIZE_Y, FL_RESIZE_ALL]


# Keyboard focus control
# values for enumeration 'FL_KEY'
FL_KEY = cty.c_int      # enum
FL_KEY_NORMAL  = 1     # normal keys(0-255) - tab +left/right
FL_KEY_TAB     = 2     # normal keys + 4 direction cursor
FL_KEY_SPECIAL = 4     # only needs special keys(>255)
FL_KEY_ALL     = 7     # all keys

# all long upstreams --LK
FL_ALT_MASK = (1<<25)      # alt + Key --> FL_ALT_MASK + key
FL_CONTROL_MASK = (1<<26)
FL_SHIFT_MASK = (1<<27)

# FL_ALT_VAL placeholder (backwards)

MAX_SHORTCUTS = 8

class admitted_values_for_FL_KEY(object):
    """Keyboard focus control

    Admitted values
    ---------------
        FL_KEY_NORMAL
            The flobject receives left and right cursor, <Home> and <End>
            keys plus all normal keys (0-255) except <Tab> <Return>
            (default).
        FL_KEY_TAB
            Object receives the <Tab>, <Return> as well as the <Up> and
            <Down> cursor keys.
        FL_KEY_SPECIAL
            The flobject receives all keys with a KeySym above 255 which
            are not already covered by FL_KEY_NORMAL and FL_KEY_TAB
            (e.g. function keys etc.)
        FL_KEY_ALL
            Object receives all keys.
        FL_ALT_MASK
            ALT combination with a key (value added to a KeySym)
        FL_CONTROL_MASK
            CONTROL combination with a key (value added to a KeySym)
        FL_SHIFT_MASK
            SHIFT combination with a key (value added to a KeySym)
    """

# TODO: verify if bitwise OR-ed makes sense here.
# my add, list of possible values --LK
KEY_list = [FL_KEY_NORMAL, FL_KEY_TAB, FL_KEY_SPECIAL, FL_KEY_ALL,
            FL_ALT_MASK, FL_CONTROL_MASK, FL_SHIFT_MASK]


# FL_PUP_NONE placeholder (deprecated)
# FL_PUP_GREY placeholder (deprecated)
# FL_PUP_BOX placeholder (deprecated)
# FL_PUP_CHECK placeholder (deprecated)
# FL_PUP_RADIO placeholder (deprecated)
# FL_PUP_GRAY placeholder (deprecated)
# FL_PUP_TOGGLE placeholder (backwards and deprecated)
# FL_PUP_INACTIVE placeholder (deprecated)
# my add, list of possible values --LK
# PUP_list placeholder (deprecated)

# FL_PUP_CB placeholder (deprecated)

STRING = cty.c_char_p
WSTRING = cty.c_wchar_p

# class FL_PUP_ENTRY placeholder (deprecated)
# FL_MENU_ENTRY placeholder (deprecated)


# ***** FONTS *****

FL_MAXFONTS = 48        # max number of fonts

# values for enumeration 'FL_TEXT_STYLE'
FL_TEXT_STYLE = cty.c_int       # enum
FL_INVALID_STYLE = -1
FL_NORMAL_STYLE = 0
FL_BOLD_STYLE = 1
FL_ITALIC_STYLE = 2
FL_BOLDITALIC_STYLE = 3
FL_FIXED_STYLE = 4
FL_FIXEDBOLD_STYLE = 5
FL_FIXEDITALIC_STYLE = 6
FL_FIXEDBOLDITALIC_STYLE = 7
FL_TIMES_STYLE = 8
FL_TIMESBOLD_STYLE = 9
FL_TIMESITALIC_STYLE = 10
FL_TIMESBOLDITALIC_STYLE = 11
FL_MISC_STYLE = 12
FL_MISCBOLD_STYLE = 13
FL_MISCITALIC_STYLE = 14
FL_SYMBOL_STYLE = 15
# modifier masks. Need to fit a short
FL_SHADOW_STYLE = 512           #(1<<9)
FL_ENGRAVED_STYLE = 1024        #(1<<10)
FL_EMBOSSED_STYLE = 2048        #(1<<11)

FL_FONT_STYLE = FL_TEXT_STYLE

# my add, list of possible values --LK
# FL_INVALID_STYLE not to be chosen from
TEXTSTYLE_list = [FL_NORMAL_STYLE, FL_BOLD_STYLE, FL_ITALIC_STYLE,
    FL_BOLDITALIC_STYLE, FL_FIXED_STYLE, FL_FIXEDBOLD_STYLE,
    FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE, FL_TIMES_STYLE,
    FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE, FL_TIMESBOLDITALIC_STYLE,
    FL_MISC_STYLE, FL_MISCBOLD_STYLE, FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE,
    FL_NORMAL_STYLE|FL_SHADOW_STYLE, FL_BOLD_STYLE|FL_SHADOW_STYLE,
    FL_ITALIC_STYLE|FL_SHADOW_STYLE, FL_BOLDITALIC_STYLE|FL_SHADOW_STYLE,
    FL_FIXED_STYLE|FL_SHADOW_STYLE, FL_FIXEDBOLD_STYLE|FL_SHADOW_STYLE,
    FL_FIXEDITALIC_STYLE|FL_SHADOW_STYLE,
    FL_FIXEDBOLDITALIC_STYLE|FL_SHADOW_STYLE, FL_TIMES_STYLE|FL_SHADOW_STYLE,
    FL_TIMESBOLD_STYLE|FL_SHADOW_STYLE, FL_TIMESITALIC_STYLE|FL_SHADOW_STYLE,
    FL_TIMESBOLDITALIC_STYLE|FL_SHADOW_STYLE, FL_MISC_STYLE|FL_SHADOW_STYLE,
    FL_MISCBOLD_STYLE|FL_SHADOW_STYLE, FL_MISCITALIC_STYLE|FL_SHADOW_STYLE,
    FL_SYMBOL_STYLE|FL_SHADOW_STYLE, FL_NORMAL_STYLE|FL_ENGRAVED_STYLE,
    FL_BOLD_STYLE|FL_ENGRAVED_STYLE, FL_ITALIC_STYLE|FL_ENGRAVED_STYLE,
    FL_BOLDITALIC_STYLE|FL_ENGRAVED_STYLE, FL_FIXED_STYLE|FL_ENGRAVED_STYLE,
    FL_FIXEDBOLD_STYLE|FL_ENGRAVED_STYLE,
    FL_FIXEDITALIC_STYLE|FL_ENGRAVED_STYLE,
    FL_FIXEDBOLDITALIC_STYLE|FL_ENGRAVED_STYLE,
    FL_TIMES_STYLE|FL_ENGRAVED_STYLE, FL_TIMESBOLD_STYLE|FL_ENGRAVED_STYLE,
    FL_TIMESITALIC_STYLE|FL_ENGRAVED_STYLE,
    FL_TIMESBOLDITALIC_STYLE|FL_ENGRAVED_STYLE,
    FL_MISC_STYLE|FL_ENGRAVED_STYLE, FL_MISCBOLD_STYLE|FL_ENGRAVED_STYLE,
    FL_MISCITALIC_STYLE|FL_ENGRAVED_STYLE, FL_SYMBOL_STYLE|FL_ENGRAVED_STYLE,
    FL_NORMAL_STYLE|FL_EMBOSSED_STYLE, FL_BOLD_STYLE|FL_EMBOSSED_STYLE,
    FL_ITALIC_STYLE|FL_EMBOSSED_STYLE, FL_BOLDITALIC_STYLE|FL_EMBOSSED_STYLE,
    FL_FIXED_STYLE|FL_EMBOSSED_STYLE, FL_FIXEDBOLD_STYLE|FL_EMBOSSED_STYLE,
    FL_FIXEDITALIC_STYLE|FL_EMBOSSED_STYLE,
    FL_FIXEDBOLDITALIC_STYLE|FL_EMBOSSED_STYLE,
    FL_TIMES_STYLE|FL_EMBOSSED_STYLE, FL_TIMESBOLD_STYLE|FL_EMBOSSED_STYLE,
    FL_TIMESITALIC_STYLE|FL_EMBOSSED_STYLE,
    FL_TIMESBOLDITALIC_STYLE|FL_EMBOSSED_STYLE,
    FL_MISC_STYLE|FL_EMBOSSED_STYLE,
    FL_MISCBOLD_STYLE|FL_EMBOSSED_STYLE, FL_MISCITALIC_STYLE|FL_EMBOSSED_STYLE,
    FL_SYMBOL_STYLE|FL_EMBOSSED_STYLE, FL_SHADOW_STYLE, FL_ENGRAVED_STYLE,
    FL_EMBOSSED_STYLE]


# Standard sizes in XForms
FL_TINY_SIZE = 8
FL_SMALL_SIZE = 10
FL_NORMAL_SIZE = 12
FL_MEDIUM_SIZE = 14
FL_LARGE_SIZE = 18
FL_HUGE_SIZE = 24
FL_DEFAULT_SIZE = FL_SMALL_SIZE

# FL_TINY_FONT placeholder (backwards)
# FL_SMALL_FONT placeholder (backwards)
# FL_NORMAL_FONT placeholder (backwards)
# FL_MEDIUM_FONT placeholder (backwards)
# FL_LARGE_FONT placeholder (backwards)
# FL_HUGE_FONT placeholder (backwards)
# FL_NORMAL_FONT1 placeholder (backwards)
# FL_NORMAL_FONT2 placeholder (backwards)
# FL_DEFAULT_FONT placeholder (backwards)


FL_BOUND_WIDTH = 1     # Border width of boxes, FL_Coord(1)

FL_CLICK_TIMEOUT = 400      # double click interval


# Definition of basic struct that holds a flobject

class FL_FORM_(cty.Structure):
    """FL_FORM class

    To access to the data referenced by a pointer to FL_FORM (ptr_flform) you
    need to use "ptr_flform.contents", then one of its attributes' name.
    Nonetheless, whenever possible it is better to use appropriate functions.

    Attributes
    ----------
        fdui : pointer to any type
            for fdesign
        u_vdata : pointer to any type
            anything the user likes as user data for application program.
            The main module does not reference or modify this field in any
            way and neither should the class routines.
        u_cdata : str
            anything the user likes as user data for application program.
            The main module does not reference or modify this field in any
            way and neither should the class routines.
        u_ldata : long
            anything the user likes as user data for application program.
            The main module does not reference or modify this field in any
            way and neither should the class routines.
        label : str
            window title
        window : Window
            X resource ID for form window
        x : int
            horizontal position of flobject
        y : int
            vertical position of flobject
        w : int
            width of flobject in unit coords
        h : int
            height of flobject in unit coords
        handle_dec_x : int
            *todo*
        handle_dec_y : int
            *todo*
        hotx : int
            horizontal hot-spot of the form
        hoty : int
            vertical hot-spot of the form
        w_hr : float
            high resolution width (for precise scaling)
        h_hr : float
            high resolution height (for precise scaling)
        first : pointer to FL_OBJECT
            points to the first flobject on the form (list)
        last : pointer to FL_OBJECT
            points to the last flobject on the form (list)
        focusobj : pointer to FL_OBJECT
            points to the flobject on the form that has the input focus
        form_callback : function
            FL_FORMCALLBACKPTR type function
        activate_callback : function
            FL_FORM_ATACTIVATE type function
        deactivate_callback : function
            FL_FORM_ATDEACTIVATE type function
        form_cb_data : pointer to any type
            user data for callback
        activate_data : pointer to any type
            user data for activate callback
        deactivate_data : pointer to any type
            user data for deactivate callback
        key_callback : function
            FL_RAW_CALLBACK type function
        push_callback : function
            FL_RAW_CALLBACK type function
        crossing_callback : function
            FL_RAW_CALLBACK type function
        motion_callback : function
            FL_RAW_CALLBACK type function
        all_callback : function
            FL_RAW_CALLBACK type function
        compress_mask : long_pos
            *todo*
        evmask : long_pos
            event mask *todo*
        close_callback : function
            FL_FORM_ATCLOSE type function
        close_data : pointer to any type
            user data for close callback
        flpixmap : pointer to FL_pixmap
            back buffer
        icon_pixmap : long_pos
            *todo*
        icon_mask : long_pos
            *todo*
        deactivated : int
            non-zero if deactivated., It can be changed using
            fl_activated_form() and fl_deactivated_form().
        use_pixmap : int
            true if dbl buffering
        frozen : int
            true if sync change
        visible : int
            true if visible on screen (mapped). It can be changed using
            fl_show_form() and fl_hide_form()
        wm_border : int
            window manager info
        prop : int_pos
            other attributes
        num_auto_objects : int
            *todo*
        top : int
            *todo*
        sort_of_modal : int
            internal use
        parent : pointer to FL_FORM
            *todo*
        child : pointer to FL_FORM
            *todo*
        parent_obj : pointer to FL_OBJECT
            *todo*
        attached : int
            not independent flobject anymore
        pre_attach : function, no return
            function(ptr_flform) type
        attach_data : pointer to any type
            *todo*
        no_tooltip : int
            *todo*
    """
    pass

FL_FORM = FL_FORM_


class FL_OBJECT_(cty.Structure):
    """FL_OBJECT class

    Each XForms flobject has a number of attributes. Some of them are used by
    the main routine, some have a fixed meaning and should never be altered
    by the class routines and some are free for the class routines to use.
    Please always use accessor methods when available instead of using or
    changing the flobject's properties directly.

    To access directly to the data referenced by a pointer to FL_OBJECT
    (ptr_flobject) you need to use "ptr_flobject.contents", then one of its
    attributes' name. Nonetheless, whenever possible it is always better to
    use appropriate functions.

    Attributes
    ----------
        form : pointer to FL_FORM
            the form this flobject belongs to. It is used by the main
            routines. The class routines should not change it.
        u_vdata : pointer to any type
            anything the user likes as user data for application program. The
            main module does not reference or modify this field in any way
            and neither should the class routines.
        u_cdata : str
            anything the user likes for application program. The main module
            does not reference or modify this field in any way and neither
            should the class routines.
        u_ldata : long
            anything the user likes for application program. The main module
            does not reference or modify this field in any way and neither
            should the class routines.
        objclass : int
            XForms class of flobject (button, slider, etc). It can be queried
            using fl_get_object_class()
        type : int
            type of flobject within the class. At least one type should exist
            and should be provided. They should be numbered from 0 upwards.
            It can be queried using fl_get_object_type()
        boxtype : int
            what kind of bounding box type. The handling routine for the
            flobject must take care that is actually drawn (with a specific
            routine). It can be changed or queried using
            fl_set_object_boxtype() and fl_get_object_boxtype()
        x : int
            current horizontal position of bounding box of the flobject. This
            value will change when the user resizes the form window. To
            determine position use fl_get_object_position() or
            fl_get_object_geometry() (for size too). To change position use
            fl_set_object_position(), or fl_set_object_geometry() (for size
            too)
        y : int
            current vertical position of bounding box of the flobject. This
            value will change when the user resizes the form window. To
            determine position use fl_get_object_position() or
            fl_get_object_geometry() (for size too). To change position use
            fl_set_object_position(), or fl_set_object_geometry() (for size
            too)
        w : int
            current width of bounding box of the flobject. This value
            value will change when the user resizes the form window. To
            determine size use fl_get_object_size() or
            fl_get_object_geometry() (for position too). To change size use
            fl_get_object_size() or fl_get_object_geometry() (for position
            too).
        h : int
            current height of bounding box of the flobject. This
            value will change when the user resizes the form window. To
            determine size use fl_get_object_size() or
            fl_get_object_geometry() (for position too). To change size use
            fl_get_object_size() or fl_get_object_geometry() (for position
            too).
        fl1 : float
            distance of upper left hand corner to left of enclosing form
        fr1 : float
            distance of upper left hand corner to right of enclosing form
        ft1 : float
            distance of upper left hand corner to top of enclosing form
        fb1 : float
            distance of upper left hand corner to bottom of enclosing form
        fl2 : float
            distance of lower right hand corner to left of enclosing form
        fr2 : float
            distance of lower right hand corner to right of enclosing form
        ft2 : float
            distance of lower right hand corner to top of enclosing form
        fb2 : float
            distance of lower right hand corner to bottom of enclosing form
        bw : int
            border width of flobject. Negative values indicate the up box
            should look "softer" (in which case no black line of 1 pixel
            width is drawn around the flobjects box). It can be queried using
            fl_get_object_bw(). A different border width can be set using
            fl_set_object_bw()
        col1 : long_pos
            first color index of flobject in the internal color lookup table
            Colors can be changed using fl_set_object_color() and queried
            using fl_get_object_color()
        col2 : long_pos
            second color index of flobject in the internal color lookup table
            Colors can be changed using fl_set_object_color() and queried
            using fl_get_object_color()
        label : str
            textual label of flobject. It can be changed using
            fl_set_object_label() and queried using fl_get_object_label()
            It must be drawn by the routine handling the flobject when it
            receives a FL_DRAWLABEL event (or it could be part of the code
            for FL_DRAW event). For non-offsetted labels, i.e. the alignment
            is relative to the entire bounding box, simply calling
            fl_draw_object_label() should be enough.
        lcol : long_pos
            color of the label. It can be set using fl_set_object_lcol()
            and queried using fl_get_object_lcol()
        align : int
            alignment of label with respect to the flobject. It can be set
            using fl_set_object_lalign() and queried using
            fl_get_object_lalign()
        lsize : int
            size of font to draw the label. It can be set using
            fl_set_object_lsize() and queried using fl_get_object_lsize()
        lstyle : int
            style of font to draw the label. It can be set using
            fl_set_object_lstyle() and queried using fl_get_object_lstyle()
        shortcut : pointer to long
            A pointer to long containing all shortcuts (as keysyms) defined
            for the flobject. You should never need them because they are
            fully handled by the main routines.
        handle : function, returning value
            function(ptr_flobject, int, crd, crd, int, pvdata) -> int
            This is a pointer to the interaction handling routine for the
            object. fl_add_NEW() sets this by providing the correct handling
            routine. Normally it is never used (except by the main routine)
            or changed although there might be situations in which you want
            to change the interaction handling routine for a flobject, due to
            some user action.
        object_callback : function, no return
            function(ptr_flobject, long)
            callback routine that the application program assigned to the
            flobject and that the system invokes when the user does something
            with the flobject.
        argument : long
            The argument to be passed to the callback routine when invoked.
        spec : pointer to any type
            Instantiation. This is a pointer that points to any class specific
            information. For example, for sliders it stores the minimum,
            maximum and current value of the slider. Most classes (except the
            most simple ones like boxes and texts) will need this. Whenever
            the flobject receives the event FL_FREEMEM it should free this
            memory.
        prehandle : function, returning value
            function(ptr_flobject, int, crd, crd, int, pvdata)
        posthandle : function, returning value
            function(ptr_flobject, int, crd, crd, int, pvdata)
        set_return : function, no return
            function(ptr_flobject, int_pos)
        resize : int_pos
            what to do if WM resizes the form. It can be set using
            fl_set_object_resize() and queried using fl_get_object_resize()
        nwgravity : int_pos
            how to re-position top-left corner relative to its position
            prior to resizing. It can be set using fl_set_object_gravity()
            and queried using fl_get_object_gravity()
        segravity : int_pos
            how to re-position lower-right corner relative to its position
            prior to resizing. It can be set using fl_set_object_gravity()
            and queried using fl_get_object_gravity()
        prev : pointer to FL_OBJECT
            previous flobject in form. It is used by the main routines. The
            class routines should not change it.
        next : pointer to FL_OBJECT
            next flobject in form. It is used by the main routines. The class
            routines should not change it.
        parent : pointer to FL_OBJECT
            parent of flobject
        child : pointer to FL_OBJECT
            child of flobject
        nc : pointer to FL_OBJECT
            next child of flobject
        flpixmap : pointer to FL_pixmap
            pixmap doublebuffering stateinfo
        use_pixmap : int
            true to use pixmap double buffering
        returned : int
            what last interaction returned (by flobject handling function).
            Values: FL_RETURN_NONE (Handling function did FL_RETURN_NONE,
            i.e. 0), FL_RETURN_CHANGED (Handling function detected a change
            of the flobjects state), FL_RETURN_END (Handling function detected
            end of interaction with object). FL_RETURN_CHANGED and
            FL_RETURN_END are bits that can be bitwise OR-ed. If both are
            set this indicates that the flobjects state was changed and the
            interaction ended.
        how_return : int_pos
            under what circumstances the flobject is returned by e.g.
            fl_do_forms() or the callback function for the flobject is
            invoked. It can be changed using fl_set_object_return().
            Especially in the case of flobjects having child flobjects also
            the corresponding settings for child flobjects may need changes
            and which automatically get adjusted when the above function is
            used. Values are: FL_RETURN_NONE (flobject gets never returned or
            its callback invoked), FL_RETURN_CHANGED (returns flobject or
            invokes callback when state of object changed), FL_RETURN_END
            (returns flobject or invokes callback at end of interaction,
            normally when the mouse key is released or, in the case of input
            flobjects, the object has lost focus), FL_RETURN_END_CHANGED
            (returns flobject or invokes callback only when interaction has
            ended and the state of the flobject has changed),
            FL_RETURN_SELECTION (returns flobject or invokes callback if e.g.
            in a browser a line was selected), FL_RETURN_SELECTION (returns
            flobject or invokes callback if e.g. in a browser a line was
            deselected), FL_RETURN_ALWAYS (returns flobject or invokes
            callback whenever interaction has ended or the state of the
            flobject has changed).
        double_buffer : int
            only used by mesa/gl canvas
        pushed : int
            flag if the mouse is pushed within the bounding box of the
            flobject. It is set and reset by the main routine. Class routines
            should never change it but can use it to draw or handle flobjects
            differently.
        focus : int
            flag if keyboard input is sent to this object. It is set and reset
            by the main routine. Never change it but you can use its value.
        belowmouse : int
            flag if the mouse is on this object. It is set and reset by the
            main routine. The class routines should never change it but can
            use it to draw or handle the flobject differently.
        active : int
            flag if flobject is active, accepting event other than FL_DRAW.
            Static flobjects (e.g. text and boxes) are inactive. By default
            flobjects are active; it can be changed by using
            fl_deactivate_object() and fl_activate_object(). It can be queried
            using fl_object_is_active()
        input : int
            flag if this flobject can receive keyboard input. If not, events
            related to keyboard input are not sent to the flobject. The
            default value of input is false. Note that not all keys are sent
            (see wantkey).
        wantkey : int
            An input flobject normally does not receive <Tab> or <Return>
            keystrokes or any other keys except those that have values between
            0-255, the <Left> and <Right> arrow keys and <Home> and <End>
            (<Tab> and <Return> are normally used to switch between input
            flobjects). By setting this field to FL_KEY_TAB enforces that the
            flobject receives also these two keys as well as the <Up> and
            <Down> arrow keys and <PgUp> and <PgDn> when it has the focus. To
            receive other special keys (e.g. function keys) FL_KEY_SPECIAL
            must be set here. By setting wantkey to FL_KEY_ALL all keys are
            sent to the object.
        radio : int
            *todo*
        automatic : int
            An flobject is automatic if it automatically (without user actions)
            has to change its contents. Automatic flobjects get a FL_STEP event
            about every 50 msec. E.g. the flobject class FL_CLOCK is automatic.
            It is false, by default. It can be set using
            fl_set_object_automatic() (do not set the flobject member directly
            except from within a function like fl_add_NEW(), in other contexts
            some extra work is required) and to test the flobject for it use
            fl_object_is_automatic().
        redraw : int
            *todo*
        visible : int
            flag if the flobject is visible. When the flobject is not visible
            the main routine will never try to draw it or send events to it.
            By default flobjects are visible. It can be hidden using
            fl_hide_object() and queried using fl_object_is_visible(). Note
            that this does not guarantee that the flobject is visible on the
            screen, you need to verify if the form the flobject belongs to is
            visible using fl_form_is_visible() (when returning true).
        is_under : int
            if (partially) hidden by other flobject
        clip : int
            *todo*
        click_timeout : long_pos
            If non-zero this indicates the the maximum elapsed time (in msec)
            between two mouse clicks to be considered a double click. A zero
            value disables double/triple click detection. It can be set using
            fl_set_object_dblclick() and queried using fl_get_object_dblclick()
        c_vdata : pointer to any type
            for flobject class use. The main module does not reference or
            modify this field in any way. The flobject classes, including the
            built-in ones, may use this field.
        c_cdata : str
            for flobject class use. The main module does not reference or
            modify this field in any way. The flobject classes, including the
            built-in ones, may use this field.
        c_ldata : long
            for flobject class use. The main module does not reference or
            modify this field in any way. The flobject classes, including the
            built-in ones, may use this field.
        dbl_background : long_pos
            double buffer background color
        tooltip : str
            tooltip helper for flobject
        tipID : int
            tooltip id
        group_id : int
            group number the flobject belongs to
        want_motion : int
            *todo*
        want_update : int
            *todo*
    """
    pass

FL_OBJECT = FL_OBJECT_


# from /usr/include/X11/Xlib.h ***
XPointer = STRING       # cty.c_char_p


# /usr/include/X11/Xlib.h 159
class _XExtData(cty.Structure):
    """X11 _XExtData class

    Attributes
    ----------
        number : int
            number returned by XRegisterExtension
        next : pointer to _XExtData
            next item on list of data for structure
        free_private : function, returning value
            function(pointer to _XExtData) -> int
            next item on list of data for structure
        private_data : str
            data private to this extension
    """
    pass
_XExtData.__slots__ = ['number', 'next', 'free_private', 'private_data']
_XExtData._fields_ = [
        ('number', cty.c_int),
        ('next', cty.POINTER(_XExtData)),
        ('free_private', cty.CFUNCTYPE(cty.c_int, cty.POINTER(_XExtData))),
        ('private_data', XPointer), ]

XExtData = _XExtData

VisualID = cty.c_ulong


# /usr/include/X11/Xlib.h 249
class Visual(cty.Structure):
    """Visual class. It contains information about possible colormapping.

    Attributes
    ----------
        ext_data : pointer to XExtData
            hook for extension to hang data
        visualid : long_pos
            visual id of this visual
        c_class : int
            (C++ compatible name) class of screen (monochrome, etc.)
        red_mask : long_pos
            mask value for red
        green_mask : long_pos
            mask value for green
        blue_mask : long_pos
            mask value for blue
        bits_per_rgb : int
            log base 2 of distinct color values
        map_entries : int
            color map entries
    """
    pass
Visual.__slots__ = ['ext_data', 'visualid', 'c_class', 'red_mask', \
        'green_mask', 'blue_mask', 'bits_per_rgb', 'map_entries',]
Visual._fields_ = [
        ('ext_data', cty.POINTER(XExtData)),
        ('visualid', VisualID),
        ('c_class', cty.c_int),
        ('red_mask', cty.c_ulong),
        ('green_mask', cty.c_ulong),
        ('blue_mask', cty.c_ulong),
        ('bits_per_rgb', cty.c_int),
        ('map_entries', cty.c_int), ]


# All pixmaps used by FL_OBJECT to simulate double buffering have the
# following entries in the structure. FL_Coord x,y are used to shift the
# origin of the drawing routines
class FL_pixmap_(cty.Structure):
    """Fl_pixmap class

    Attributes
    ----------
        pixmap : long_pos
            Pixmap resource id
        win : long_pos
            window
        visual : pointer to Visual
            Visual class
        xpos : int
            horizontal position
        ypos : int
            vertical position
        width : int
            width
        height : int
            height
        depth : int
            depth of visual
        dbl_background : long_pos
            color value
        pixel : long_pos
            color value
    """
    pass
FL_pixmap_.__slots__ = ['pixmap', 'win', 'visual', 'x', 'y', 'w', \
        'h', 'depth', 'dbl_background', 'pixel',]
FL_pixmap_._fields_ = [
        ('pixmap', Pixmap),
        ('win', Window),
        ('visual', cty.POINTER(Visual)),
        ('x', FL_Coord),
        ('y', FL_Coord),
        ('w', FL_Coord),
        ('h', FL_Coord),
        ('depth', cty.c_int),
        ('dbl_background', FL_COLOR),
        ('pixel', FL_COLOR), ]
FL_pixmap = FL_pixmap_


FL_IO_CALLBACK = cty.CFUNCTYPE(None, cty.c_int, cty.c_void_p)

FL_SIGNAL_HANDLER = cty.CFUNCTYPE(None, cty.c_int, cty.c_void_p)

FL_TIMEOUT_CALLBACK = cty.CFUNCTYPE(None, cty.c_int, cty.c_void_p)

# at close (WM menu delete/close etc.)
FL_FORM_ATCLOSE = cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_FORM), \
        cty.c_void_p)

# deactivate/activate callbacks
FL_FORM_ATACTIVATE = cty.CFUNCTYPE(None, cty.POINTER(FL_FORM), cty.c_void_p)
FL_FORM_ATDEACTIVATE = cty.CFUNCTYPE(None, cty.POINTER(FL_FORM), cty.c_void_p)

# callback function for an entire form
FL_FORMCALLBACKPTR = cty.CFUNCTYPE(None, cty.POINTER(FL_OBJECT), cty.c_void_p)

FL_HANDLEPTR = cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_OBJECT), cty.c_int, \
                FL_Coord, FL_Coord, cty.c_int, cty.c_void_p)


# /usr/include/X11/Xlib.h 984
class _XEvent(cty.Union):
    """_XEvent class

    Attributes
    ----------
        type : int
            event type
        xany : XAnyEvent
            *todo*
        xkey : XKeyEvent
            *todo*
        xbutton : XButtonEvent
            *todo*
        xmotion : XMotionEvent
            *todo*
        xcrossing : XCrossingEvent
            *todo*
        xfocus : XFocusChangeEvent
            *todo*
        xexpose : XExposeEvent
            *todo*
        xgraphicsexpose : XGraphicsExposeEvent
            *todo*
        xnoexpose : XNoExposeEvent
            *todo*
        xvisibility : XVisibilityEvent
            *todo*
        xcreatewindow : XCreateWindowEvent
            *todo*
        xdestroywindow : XDestroyWindowEvent
            *todo*
        xunmap : XUnmapEvent
            *todo*
        xmap : XMapEvent
            *todo*
        xmaprequest : XMapRequestEvent
            *todo*
        xreparent : XReparentEvent
            *todo*
        xconfigure : XConfigureEvent
            *todo*
        xgravity : XGravityEvent
            *todo*
        xresizerequest : XResizeRequestEvent
            *todo*
        xconfigurerequest : XConfigureRequestEvent
            *todo*
        xcirculate : XCirculateEvent
            *todo*
        xcirculaterequest : XCirculateRequestEvent
            *todo*
        xproperty : XPropertyEvent
            *todo*
        xselectionclear : XSelectionClearEvent
            *todo*
        xselectionrequest : XSelectionRequestEvent
            *todo*
        xselection : XSelectionEvent
            *todo*
        xcolormap : XColormapEvent
            *todo*
        xclient : XClientMessageEvent
            *todo*
        xmapping : XMappingEvent
            *todo*
        xerror : XErrorEvent
            *todo*
        xkeymap : XKeymapEvent
            *todo*
        xgeneric : XGenericEvent
            *todo*
        xcookie : XGenericEventCookie
            *todo*
        pad : array of 24 long
            *todo*
    """
    pass
XEvent = _XEvent



# preemptive callback function - ptr_XEvent is necessary as type cast is not
# handled here in xforms-python
# FL_RAW_CALLBACK = cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_FORM), \
#                       cty.c_void_p)
FL_RAW_CALLBACK = cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_FORM), \
                                cty.POINTER(XEvent))

# flobject callback function
FL_CALLBACKPTR = cty.CFUNCTYPE(None, cty.POINTER(FL_OBJECT), cty.c_long)


FL_DRAWPTR = cty.CFUNCTYPE(None, FL_Coord, FL_Coord, FL_Coord, FL_Coord,
                           cty.c_int, FL_COLOR)

# error callback
FL_ERROR_FUNC = cty.CFUNCTYPE(None, STRING, STRING)


FL_FORM_._pack_ = 4
FL_FORM_.__slots__ = ['fdui', 'u_vdata', 'u_cdata', 'u_ldata', 'label', \
        'window', 'x', 'y', 'w', 'h', 'handle_dec_x', 'handle_dec_y', \
        'hotx', 'hoty', 'w_hr', 'h_hr', 'first', 'last', 'focusobj', \
        'form_callback', 'activate_callback', 'deactivate_callback', \
        'form_cb_data', 'activate_data', 'deactivate_data', 'key_callback', \
        'push_callback', 'crossing_callback', 'motion_callback', \
        'all_callback', 'compress_mask', 'evmask', 'close_callback', \
        'close_data', 'flpixmap', 'icon_pixmap', 'icon_mask', 'deactivated', \
        'use_pixmap', 'frozen', 'visible', 'wm_border', 'prop', \
        'num_auto_objects', 'top', 'sort_of_modal', 'parent', 'child', \
        'parent_obj', 'attached', 'pre_attach', 'attach_data', 'no_tooltip',]
FL_FORM_._fields_ = [
    ('fdui', cty.c_void_p),             # for fdesign
    ('u_vdata', cty.c_void_p),          # for application
    ('u_cdata', STRING),                # for application
    ('u_ldata', cty.c_long),            # for application
    ('label', STRING),                  # window title
    ('window', Window),                 # X resource ID for window
    ('x', FL_Coord),                    # current geometry info
    ('y', FL_Coord),
    ('w', FL_Coord),
    ('h', FL_Coord),
    ('handle_dec_x', cty.c_int),
    ('handle_dec_y', cty.c_int),
    ('hotx', FL_Coord),                 # horizontal hot-spot of the form
    ('hoty', FL_Coord),                 # vertical hot-spot of the form
    ('w_hr', cty.c_double),   # high resolution width (for precise scaling)
    ('h_hr', cty.c_double),   # high resolution height (for precise scaling)
    ('first', cty.POINTER(FL_OBJECT)),
    ('last', cty.POINTER(FL_OBJECT)),
    ('focusobj', cty.POINTER(FL_OBJECT)),
    ('form_callback', FL_FORMCALLBACKPTR),
    ('activate_callback', FL_FORM_ATACTIVATE),
    ('deactivate_callback', FL_FORM_ATDEACTIVATE),
    ('form_cb_data', cty.c_void_p),
    ('activate_data', cty.c_void_p),
    ('deactivate_data', cty.c_void_p),
    ('key_callback', FL_RAW_CALLBACK),
    ('push_callback', FL_RAW_CALLBACK),
    ('crossing_callback', FL_RAW_CALLBACK),
    ('motion_callback', FL_RAW_CALLBACK),
    ('all_callback', FL_RAW_CALLBACK),
    ('compress_mask', cty.c_ulong),
    ('evmask', cty.c_ulong),
    # WM_DELETE_WINDOW message handler
    ('close_callback', FL_FORM_ATCLOSE),
    ('close_data', cty.c_void_p),
    ('flpixmap', cty.POINTER(FL_pixmap)),     # back buffer
    ('icon_pixmap', Pixmap),
    ('icon_mask', Pixmap),
    # interaction and other flags
    ('deactivated', cty.c_int),               # non-zero if deactivated
    ('use_pixmap', cty.c_int),                # true if dbl buffering
    ('frozen', cty.c_int),                    # true if sync change
    ('visible', cty.c_int),                   # true if mapped
    ('wm_border', cty.c_int),                 # window manager info
    ('prop', cty.c_uint),                     # other attributes
    ('num_auto_objects', cty.c_int),
    ('top', cty.c_int),
    ('sort_of_modal', cty.c_int),             # internal use
    ('parent', cty.POINTER(FL_FORM)),
    ('child', cty.POINTER(FL_FORM)),
    ('parent_obj', cty.POINTER(FL_OBJECT)),
    ('attached', cty.c_int),                  # not independent anymore
    ('pre_attach', cty.CFUNCTYPE(None, cty.POINTER(FL_FORM))),
    ('attach_data', cty.c_void_p),
    ('no_tooltip', cty.c_int), ]

FL_OBJECT_._pack_ = 4
FL_OBJECT_.__slots__ = ['form', 'u_vdata', 'u_cdata', 'u_ldata', \
        'objclass', 'type', 'boxtype', 'x', 'y', 'w', 'h', 'fl1', 'fr1', \
        'ft1', 'fb1', 'fl2', 'fr2', 'ft2', 'fb2', 'bw', 'col1', 'col2', \
        'label', 'lcol', 'align', 'lsize', 'lstyle', 'shortcut', 'handle', \
        'object_callback', 'argument', 'spec', 'prehandle', 'posthandle', \
        'set_return', 'resize', 'nwgravity', 'segravity', 'prev', 'next', \
        'parent', 'child', 'nc', 'flpixmap', 'use_pixmap', 'returned', \
        'how_return', 'double_buffer', 'pushed', 'focus', 'belowmouse', \
        'active', 'input', 'wantkey', 'radio', 'automatic', 'redraw', \
        'visible', 'is_under', 'clip', 'click_timeout', 'c_vdata', \
        'c_cdata','c_ldata', 'dbl_background', 'tooltip', 'tipID', \
        'group_id', 'want_motion', 'want_update',]
FL_OBJECT_._fields_ = [
    ('form', cty.POINTER(FL_FORM)),   # the form this flobject belongs to
    ('u_vdata', cty.c_void_p),        # anything the user likes
    ('u_cdata', STRING),              # anything the user likes
    ('u_ldata', cty.c_long),          # anything the user likes
    ('objclass', cty.c_int),          # class of flobject, button, slider etc
    ('type', cty.c_int),              # type within the class
    ('boxtype', cty.c_int),           # what kind of box type
    ('x', FL_Coord),                  # current obj. location and size
    ('y', FL_Coord),
    ('w', FL_Coord),
    ('h', FL_Coord),
    ('fl1', cty.c_double),            # distances of upper left hand (1) and
    ('fr1', cty.c_double),            # lower right hand corner (2) to left,
    ('ft1', cty.c_double),            # right, top and bottom of enclosing
    ('fb1', cty.c_double),            # form
    ('fl2', cty.c_double),
    ('fr2', cty.c_double),
    ('ft2', cty.c_double),
    ('fb2', cty.c_double),
    ('bw', FL_Coord),
    ('col1', FL_COLOR),                 # colors of obj
    ('col2', FL_COLOR),
    ('label', STRING),                  # flobject label
    ('lcol', FL_COLOR),                 # label color
    ('align', cty.c_int),               # alignment
    ('lsize', cty.c_int),               # label size
    ('lstyle', cty.c_int),              # label style
    ('shortcut', cty.POINTER(cty.c_long)),
    ('handle', cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_OBJECT), cty.c_int, \
            FL_Coord, FL_Coord, cty.c_int, cty.c_void_p)),
    ('object_callback', cty.CFUNCTYPE(None, cty.POINTER(FL_OBJECT), \
            cty.c_long)),
    ('argument', cty.c_long),
    ('spec', cty.c_void_p),             # instantiation
    ('prehandle', cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_OBJECT), \
            cty.c_int, FL_Coord, FL_Coord, cty.c_int, cty.c_void_p)),
    ('posthandle', cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_OBJECT), \
            cty.c_int, FL_Coord, FL_Coord, cty.c_int, cty.c_void_p)),
    ('set_return', cty.CFUNCTYPE(None, cty.POINTER(FL_OBJECT), cty.c_uint)),
    # re-configure preference
    ('resize', cty.c_uint),           # what to do if WM resizes the FORM
    ('nwgravity', cty.c_uint),        # how to re-position top-left corner
    ('segravity', cty.c_uint),       # how to re-position lower-right corner
    ('prev', cty.POINTER(FL_OBJECT)),     # prev. obj in form
    ('next', cty.POINTER(FL_OBJECT)),     # next obj in form
    ('parent', cty.POINTER(FL_OBJECT)),
    ('child', cty.POINTER(FL_OBJECT)),
    ('nc', cty.POINTER(FL_OBJECT)),        # next child
    ('flpixmap', cty.POINTER(FL_pixmap)),  # pixmap doublebuffering stateinfo
    ('use_pixmap', cty.c_int),        # true to use pixmap double buffering
    # some interaction flags
    ('returned', cty.c_int),            # what last interaction returned
    ('how_return', cty.c_uint),          # under which conditions to return
    ('double_buffer', cty.c_int),         # only used by mesa/gl canvas
    ('pushed', cty.c_int),
    ('focus', cty.c_int),
    ('belowmouse', cty.c_int),
    ('active', cty.c_int),                # if accepting event
    ('input', cty.c_int),
    ('wantkey', cty.c_int),
    ('radio', cty.c_int),
    ('automatic', cty.c_int),
    ('redraw', cty.c_int),
    ('visible', cty.c_int),
    ('is_under', cty.c_int),        # if (partially) hidden by other flobject
    ('clip', cty.c_int),
    ('click_timeout', cty.c_ulong),
    ('c_vdata', cty.c_void_p),          # for class use
    ('c_cdata', STRING),                # for class use
    ('c_ldata', cty.c_long),            # for class use
    ('dbl_background', FL_COLOR),       # double buffer background
    ('tooltip', STRING),
    ('tipID', cty.c_int),
    ('group_id', cty.c_int),
    ('want_motion', cty.c_int),
    ('want_update', cty.c_int), ]


FL_EVENT = cty.POINTER(FL_OBJECT)


# form visibility state, form .visible
# values for unnamed enumeration
FL_BEING_HIDDEN = -1
FL_HIDDEN = 0
FL_INVISIBLE = FL_HIDDEN
FL_VISIBLE = 1

# my add, list of possible values --LK
VISIBLE_list = [FL_BEING_HIDDEN, FL_HIDDEN, FL_INVISIBLE, FL_VISIBLE]


# All FD_xxx structure emitted by fdesign contains at least the
# following
class FD_Any(cty.Structure):
    """FD_Any class

    Attributes
    ----------
        form : pointer to FL_FORM
            *todo*
        vdata : pointer to any type
            *todo*
        cdata : str
            *todo*
        ldata : long
            *todo*
    """
    pass
FD_Any.__slots__ = ['form', 'vdata', 'cdata', 'ldata',]
FD_Any._fields_ = [
        ('form', cty.POINTER(FL_FORM)),
        ('vdata', cty.c_void_p),
        ('cdata', STRING),
        ('ldata', cty.c_long), ]


# Async IO stuff
FL_READ   = 1
FL_WRITE  = 2
FL_EXCEPT = 4

# my add, list of possible values --LK
ASYNCIO_list = [FL_READ, FL_WRITE, FL_EXCEPT]


# values for unnamed enumeration
FL_INPUT_END_EVENT_CLASSIC = 0
FL_INPUT_END_EVENT_ALWAYS  = 1

# my add, list of possible values --LK
INPUTENDRETNEVENT_list = [FL_INPUT_END_EVENT_CLASSIC, \
        FL_INPUT_END_EVENT_ALWAYS]


FL_MAX_MENU_CHOICE_ITEMS = 128


# *** start - from /usr/include/X11/keysymdef.h ***
# TTY function keys, cleverly chosen to map to ASCII, for convenience of
# programming, but could have been arbitrary (at the cost of lookup
# tables in client code).
XK_BackSpace = 0xff08           # Back space, back char
XK_Tab = 0xff09
XK_Linefeed = 0xff0a            # Linefeed, LF
XK_Clear = 0xff0b
XK_Return = 0xff0d              # Return, enter
XK_Pause = 0xff13               # Pause, hold
XK_Scroll_Lock = 0xff14
XK_Sys_Req = 0xff15
XK_Escape = 0xff1b
XK_Delete = 0xffff              # Delete, rubout

# Cursor control & motion
XK_Home = 0xff50
XK_Left = 0xff51               # Move left, left arrow
XK_Up = 0xff52                 # Move up, up arrow
XK_Right = 0xff53              # Move right, right arrow
XK_Down = 0xff54               # Move down, down arrow
XK_Prior = 0xff55              # Prior, previous
XK_Page_Up = 0xff55
XK_Next = 0xff56               # Next
XK_Page_Down = 0xff56
XK_End = 0xff57                # EOL
XK_Begin = 0xff58              # BOL

# Misc functions
XK_Select = 0xff60             # Select, mark
XK_Print = 0xff61
XK_Execute = 0xff62            # Execute, run, do
XK_Insert = 0xff63             # Insert, insert here
XK_Undo = 0xff65
XK_Redo = 0xff66               # Redo, again
XK_Menu = 0xff67
XK_Find = 0xff68               # Find, search
XK_Cancel = 0xff69             # Cancel, stop, abort, exit
XK_Help = 0xff6a               # Help
XK_Break = 0xff6b
XK_Mode_switch = 0xff7e        # Character set switch
XK_script_switch = 0xff7e      # Alias for mode_switch
XK_Num_Lock = 0xff7f

# Keypad functions, keypad numbers cleverly chosen to map to ASCII
XK_KP_Space = 0xff80           # Space
XK_KP_Tab = 0xff89
XK_KP_Enter = 0xff8d           # Enter
XK_KP_F1 = 0xff91              # PF1, KP_A, ...
XK_KP_F2 = 0xff92
XK_KP_F3 = 0xff93
XK_KP_F4 = 0xff94
XK_KP_Home = 0xff95
XK_KP_Left = 0xff96
XK_KP_Up = 0xff97
XK_KP_Right = 0xff98
XK_KP_Down = 0xff99
XK_KP_Prior = 0xff9a
XK_KP_Page_Up = 0xff9a
XK_KP_Next = 0xff9b
XK_KP_Page_Down = 0xff9b
XK_KP_End = 0xff9c
XK_KP_Begin = 0xff9d
XK_KP_Insert = 0xff9e
XK_KP_Delete = 0xff9f
XK_KP_Equal = 0xffbd           # Equals
XK_KP_Multiply = 0xffaa
XK_KP_Add = 0xffab
XK_KP_Separator = 0xffac       # Separator, often comma
XK_KP_Subtract = 0xffad
XK_KP_Decimal = 0xffae
XK_KP_Divide = 0xffaf

XK_KP_0 = 0xffb0
XK_KP_1 = 0xffb1
XK_KP_2 = 0xffb2
XK_KP_3 = 0xffb3
XK_KP_4 = 0xffb4
XK_KP_5 = 0xffb5
XK_KP_6 = 0xffb6
XK_KP_7 = 0xffb7
XK_KP_8 = 0xffb8
XK_KP_9 = 0xffb9

# Auxiliary functions; note the duplicate definitions for left and right
# function keys;  Sun keyboards and a few other manufacturers have such
# function key groups on the left and/or right sides of the keyboard.
# We've not found a keyboard with more than 35 function keys total.
XK_F1 = 0xffbe
XK_F2 = 0xffbf
XK_F3 = 0xffc0
XK_F4 = 0xffc1
XK_F5 = 0xffc2
XK_F6 = 0xffc3
XK_F7 = 0xffc4
XK_F8 = 0xffc5
XK_F9 = 0xffc6
XK_F10 = 0xffc7
XK_F11 = 0xffc8
XK_L1 = 0xffc8
XK_F12 = 0xffc9
XK_L2 = 0xffc9
XK_F13 = 0xffca
XK_L3 = 0xffca
XK_F14 = 0xffcb
XK_L4 = 0xffcb
XK_F15 = 0xffcc
XK_L5 = 0xffcc
XK_F16 = 0xffcd
XK_L6 = 0xffcd
XK_F17 = 0xffce
XK_L7 = 0xffce
XK_F18 = 0xffcf
XK_L8 = 0xffcf
XK_F19 = 0xffd0
XK_L9 = 0xffd0
XK_F20 = 0xffd1
XK_L10 = 0xffd1
XK_F21 = 0xffd2
XK_R1 = 0xffd2
XK_F22 = 0xffd3
XK_R2 = 0xffd3
XK_F23 = 0xffd4
XK_R3 = 0xffd4
XK_F24 = 0xffd5
XK_R4 = 0xffd5
XK_F25 = 0xffd6
XK_R5 = 0xffd6
XK_F26 = 0xffd7
XK_R6 = 0xffd7
XK_F27 = 0xffd8
XK_R7 = 0xffd8
XK_F28 = 0xffd9
XK_R8 = 0xffd9
XK_F29 = 0xffda
XK_R9 = 0xffda
XK_F30 = 0xffdb
XK_R10 = 0xffdb
XK_F31 = 0xffdc
XK_R11 = 0xffdc
XK_F32 = 0xffdd
XK_R12 = 0xffdd
XK_F33 = 0xffde
XK_R13 = 0xffde
XK_F34 = 0xffdf
XK_R14 = 0xffdf
XK_F35 = 0xffe0
XK_R15 = 0xffe0

# Modifiers
XK_Shift_L = 0xffe1             # Left shift
XK_Shift_R = 0xffe2             # Right shift
XK_Control_L = 0xffe3           # Left control
XK_Control_R = 0xffe4           # Right control
XK_Caps_Lock = 0xffe5           # Caps lock
XK_Shift_Lock = 0xffe6          # Shift lock

XK_Meta_L = 0xffe7              # Left meta
XK_Meta_R = 0xffe8              # Right meta
XK_Alt_L = 0xffe9               # Left alt
XK_Alt_R = 0xffe                # Right alt
XK_Super_L = 0xffeb             # Left super
XK_Super_R = 0xffec             # Right super
XK_Hyper_L = 0xffed             # Left hyper
XK_Hyper_R = 0xffee             # Right hyper
# *** end - from /usr/include/X11/keysymdef.h ***

class admitted_values_for_KEYSYM(object):
    """KeySym keyboard symbols

    Admitted values
    ---------------
        XK_BackSpace (Back space/char key)
        XK_Tab (Tab key)
        XK_Linefeed (Linefeed, LF key)
        XK_Clear *todo*
        XK_Return (Return, enter key)
        XK_Pause (Pause, hold key)
        XK_Scroll_Lock (Scroll Lock key)
        XK_Sys_Req (Print Sys Req key)
        XK_Escape (Esc key)
        XK_Delete (Delete, rubout key)
        XK_Home (Home key)
        XK_Left (Move left, left arrow cursor key)
        XK_Up (Move up, up arrow cursor key)
        XK_Right (Move right, right arrow cursor key)
        XK_Down (Move down, down arrow cursor key)
        XK_Prior (Prior, previous key) ?
        XK_Page_Up (Page up key)
        XK_Next (Next key) ?
        XK_Page_Down (Page down key)
        XK_End (EOL End key)
        XK_Begin (BOL Begin key) ?
        XK_Select (Select, mark key) ?
        XK_Print (Print key) ?
        XK_Execute (Execute, run, do key) ?
        XK_Insert (Insert, insert here key) ?
        XK_Undo (Undo key) ?
        XK_Redo (Redo, again key) ?
        XK_Menu (Menu key) ?
        XK_Find (Find, search key) ?
        XK_Cancel (Cancel, stop, abort, exit key) ?
        XK_Help (Help key) ?
        XK_Break (Break key) ?
        XK_Mode_switch (Character set switch key) ?
        XK_script_switch (Alias for mode_switch key) ?
        XK_Num_Lock (Num Lock key)
        XK_KP_Space (Space Keypad key)
        XK_KP_Tab (Tab Keypad key)
        XK_KP_Enter (Enter Keypad key)
        XK_KP_F1 (PF1, KP_A, ... Keypad Fn 1)
        XK_KP_F2 (Keypad Fn 2 key)
        XK_KP_F3 (Keypad Fn 3 key)
        XK_KP_F4 (Keypad Fn 4 key)
        XK_KP_Home (Keypad Home key)
        XK_KP_Left (Keypad left key)
        XK_KP_Up (Keypad up key)
        XK_KP_Right (Keypad right key)
        XK_KP_Down (Keypad down key)
        XK_KP_Prior (Keypad prior key)
        XK_KP_Page_Up (Keypad page up key)
        XK_KP_Next (Keypad next key)
        XK_KP_Page_Down (Keypad page down key)
        XK_KP_End (Keypad End key)
        XK_KP_Begin (Keypad begin key) ?
        XK_KP_Insert (Keypad insert key)
        XK_KP_Delete (Keypad Delete key)
        XK_KP_Equal (Equals Keypad key)
        XK_KP_Multiply (Keypad multiply key) ?
        XK_KP_Add (Keypad add key)
        XK_KP_Separator (Separator, often comma, Keypad key)
        XK_KP_Subtract (Keypad subtract key)
        XK_KP_Decimal (Keypad decimal key)
        XK_KP_Divide (Keypad divide key)
        XK_KP_0 (Keypad 0 key)
        XK_KP_1 (Keypad 1 key)
        XK_KP_2 (Keypad 2 key)
        XK_KP_3 (Keypad 3 key)
        XK_KP_4 (Keypad 4 key)
        XK_KP_5 (Keypad 5 key)
        XK_KP_6 (Keypad 6 key)
        XK_KP_7 (Keypad 7 key)
        XK_KP_8 (Keypad 8 key)
        XK_KP_9 (Keypad 9 key)
        XK_F1 (Fn 1 key)
        XK_F2 (Fn 2 key)
        XK_F3 (Fn 3 key)
        XK_F4 (Fn 4 key)
        XK_F5 (Fn 5 key)
        XK_F6 (Fn 6 key)
        XK_F7 (Fn 7 key)
        XK_F8 (Fn 8 key)
        XK_F9 (Fn 9 key)
        XK_F10 (Fn 10 key)
        XK_F11 (Fn 11 key)
        XK_L1 *todo*
        XK_F12 (Fn 12 key)
        XK_L2 *todo*
        XK_F13 (Fn 13 key)
        XK_L3 *todo*
        XK_F14 (Fn 14 key)
        XK_L4 *todo*
        XK_F15 (Fn 15 key)
        XK_L5 *todo*
        XK_F16 (Fn 16 key)
        XK_L6 *todo*
        XK_F17 (Fn 17 key)
        XK_L7 *todo*
        XK_F18 (Fn 18 key)
        XK_L8 *todo*
        XK_F19 (Fn 19 key)
        XK_L9 *todo*
        XK_F20 (Fn 20 key)
        XK_L10 *todo*
        XK_F21 (Fn 21 key)
        XK_R1 *todo*
        XK_F22 (Fn 22 key)
        XK_R2 *todo*
        XK_F23 (Fn 23 key)
        XK_R3 *todo*
        XK_F24 (Fn 24 key)
        XK_R4 *todo*
        XK_F25 (Fn 25 key)
        XK_R5 *todo*
        XK_F26 (Fn 26 key)
        XK_R6 *todo*
        XK_F27 (Fn 27 key)
        XK_R7 *todo*
        XK_F28 (Fn 28 key)
        XK_R8 *todo*
        XK_F29 (Fn 29 key)
        XK_R9 *todo*
        XK_F30 (Fn 30 key)
        XK_R10 *todo*
        XK_F31 (Fn 31 key)
        XK_R11 *todo*
        XK_F32 (Fn 32 key)
        XK_R12 *todo*
        XK_F33 (Fn 33 key)
        XK_R13 *todo*
        XK_F34 (Fn 34 key)
        XK_R14 *todo*
        XK_F35 (Fn 35 key)
        XK_R15 *todo*
        XK_Shift_L (Modifier Left shift)
        XK_Shift_R (Modifier Right shift)
        XK_Control_L (Modifier Left control)
        XK_Control_R (Modifier Right control)
        XK_Caps_Lock (Modifier Caps lock)
        XK_Shift_Lock (Modifier Shift lock) ?
        XK_Meta_L (Modifier Left meta) ?
        XK_Meta_R (Modifier Right meta) ?
        XK_Alt_L (Modifier Left alt)
        XK_Alt_R (Modifier Right alt)
        XK_Super_L (Modifier Left super) ?
        XK_Super_R (Modifier Right super) ?
        XK_Hyper_L (Modifier Left hyper) ?
        XK_Hyper_R (Modifier Right hyper) ?
    """
    pass


class _IO_FILE(cty.Structure):
    pass
FILE = _IO_FILE


########################
# forms.h (xbasic.h)
########################


# /usr/include/X11/Xutil.h 296
class XVisualInfo(cty.Structure):
    """XVisualInfo class. Information is used by the visual utility routines
    to find desired visual type from the many visuals a display may support.

    Attributes
    ----------
        visual : pointer to Visual
            Visual class
        visualid : long_pos
            visual id of this visual
        screen : int
            *todo*
        depth : int
            depth of the visual
        c_class : int
            (C++ compatible name) class of screen (monochrome, etc.)
        red_mask : long_pos
            mask value for red
        green_mask : long_pos
            mask value for green
        blue_mask : long_pos
            mask value for blue
        colormap_size : int
            *todo*
        bits_per_rgb : int
            log base 2 of distinct color values
    """
    pass
XVisualInfo.__slots__ = ['visual', 'visualid', 'screen', 'depth', \
        'c_class', 'red_mask', 'green_mask', 'blue_mask', 'colormap_size', \
        'bits_per_rgb',]
XVisualInfo._fields_ = [
        ('visual', cty.POINTER(Visual)),
        ('visualid', VisualID),
        ('screen', cty.c_int),
        ('depth', cty.c_int),
        ('c_class', cty.c_int),
        ('red_mask', cty.c_ulong),
        ('green_mask', cty.c_ulong),
        ('blue_mask', cty.c_ulong),
        ('colormap_size', cty.c_int),
        ('bits_per_rgb', cty.c_int), ]


# /usr/include/X11/Xdefs.h
XID = cty.c_ulong
Window = XID    # cty.c_ulong
Pixmap = XID    # cty.c_ulong


FL_APPEVENT_CB = cty.CFUNCTYPE(cty.c_int, cty.POINTER(XEvent), cty.c_void_p)


# Draw mode
# values for unnamed enumeration
FL_XOR = 6              # GXxor
FL_COPY = 3             # GXcopy
FL_AND = 1              # GXand

# my add, list of possible values --LK
DRAWMODE_list = [FL_XOR, FL_COPY, FL_AND]


FL_MINDEPTH = 1


# FL_IllegalVisual placeholder (backwards)
# FL_StaticGray placeholder (backwards)
# FL_GrayScale placeholder (backwards)
# FL_StaticColor placeholder (backwards)
# FL_PseudoColor placeholder (backwards)
# FL_TrueColor placeholder (backwards)
# FL_DirectColor placeholder (backwards)
# FL_DefaultVisual placeholder (backwards)

# values for unnamed enumeration
IllegalVisual = -1
StaticGray = 0
GrayScale = 1
StaticColor = 2
PseudoColor = 3
TrueColor = 4
DirectColor = 5
DefaultVisual = 10       # special request
GreyScale = GrayScale
StaticGrey = StaticGray

# my add - list of possible values --LK
VISUALMODE_list = [StaticGray, GrayScale, StaticColor, PseudoColor, TrueColor,
        DirectColor, DefaultVisual, GreyScale, StaticGrey]

# values for unnamed enumeration
FL_North = 2                            #NorthGravity
FL_NorthEast = 3                        #NorthEastGravity
FL_NorthWest = 1                        #NorthWestGravity
FL_South = 8                            #SouthGravity
FL_SouthEast = 9                        #SouthEastGravity
FL_SouthWest = 7                        #SouthWestGravity
FL_East = 6                             #EastGravity
FL_West = 4                             #WestGravity
FL_NoGravity = 0                        #ForgetGravity
FL_ForgetGravity = FL_NoGravity         #ForgetGravity

# my add, list of possible values --LK
GRAVITY_list = [FL_North, FL_NorthEast, FL_NorthWest, FL_South, FL_SouthEast,
        FL_SouthWest, FL_East, FL_West, FL_NoGravity, FL_ForgetGravity]


# Internal colormap size. Not really very meaningful as fl_mapcolor
# and company allow color "leakage", that is, although only FL_MAX_COLS
# are kept in the internal colormap, the server might have substantially
# more colors allocated
FL_MAX_COLORS = 1024
FL_MAX_COLS = FL_MAX_COLORS


# FL graphics state information. Some are redundant.

Font = XID    # cty.c_ulong
Atom = cty.c_ulong

# /usr/include/X11/Xlib.h 1044
class XFontProp(cty.Structure):
    """XFontProp class. There are additional properties returned, to allow
    arbitrary information with fonts, .

    Attributes
    ----------
        name : long_pos
            Atom
        card32 : long_pos
            *todo*
    """
    pass
XFontProp.__slots__ = ['name', 'card32',]
XFontProp._fields_ = [
        ('name', Atom),
        ('card32', cty.c_ulong), ]

# /usr/include/X11/Xlib.h 1035
class XCharStruct(cty.Structure):
    """XCharStruct class. Per character font metric information.

    Attributes
    ----------
        lbearing : short
            origin to left edge of raster
        rbearing : short
            origin to right edge of raster
        width : short
            advance to next char's origin
        ascent : short
            baseline to top edge of raster
        descent : short
            baseline to bottom edge of raster
        attributes : ushort
            per char flags (not predefined)
    """
XCharStruct.__slots__ = ['lbearing', 'rbearing', 'width', 'ascent', \
        'descent', 'attributes',]
XCharStruct._fields_ = [
        ('lbearing', cty.c_short),
        ('rbearing', cty.c_short),
        ('width', cty.c_short),
        ('ascent', cty.c_short),
        ('descent', cty.c_short),
        ('attributes',  cty.c_ushort), ]

# /usr/include/X11/Xlib.h 1050
class XFontStruct(cty.Structure):
    """XFontStruct class

    Attributes
    ----------
        ext_data : pointer to XExtData
            hook for extension to hang data
        fid : long_pos
            Font id for this font
        direction : int_pos
            hint about direction the font is painted
        min_char_or_byte2 : int_pos
            first character
        max_char_or_byte2 : int_pos
            last character
        min_byte1 : int_pos
            first row that exists
        max_byte1 : int_pos
            first row that exists
        all_chars_exist : int
            (bool) flag if all characters have non-zero size
        default_char : int_pos
            char to print for undefined character
        n_properties : int
            how many properties there are
        properties : pointer to XFontProp
            pointer to array of additional properties
        min_bounds : XCharStruct instance
            minimum bounds over all existing char
        max_bounds : XCharStruct instance
            maximum bounds over all existing char
        per_char : pointer to XCharStruct
            first_char to last_char information
        ascent : int
            log. extent above baseline for spacing
        descent : int
            log. descent below baseline for spacing
    """
XFontStruct.__slots__ = ['ext_data', 'fid', 'direction', \
        'min_char_or_byte2', 'max_char_or_byte2', 'min_byte1', \
        'max_byte1', 'all_chars_exist', 'default_char', 'n_properties', \
        'properties', 'min_bounds', 'max_bounds', 'per_char', \
        'ascent', 'descent',]
XFontStruct._fields_ = [
        ('ext_data', cty.POINTER(XExtData)),
        ('fid', Font),
        ('direction', cty.c_uint),
        ('min_char_or_byte2', cty.c_uint),
        ('max_char_or_byte2', cty.c_uint),
        ('min_byte1', cty.c_uint),
        ('max_byte1', cty.c_uint),
        ('all_chars_exist', cty.c_int),
        ('default_char', cty.c_uint),
        ('n_properties', cty.c_int),
        ('properties', cty.POINTER(XFontProp)),
        ('min_bounds', XCharStruct),
        ('max_bounds', XCharStruct),
        ('per_char', cty.POINTER(XCharStruct)),
        ('ascent', cty.c_int),
        ('descent', cty.c_int), ]


Colormap = XID    # cty.c_ulong


# /usr/include/X11/Xlib.h 225
class _XGC(cty.Structure):
    pass
GC = cty.POINTER(_XGC)

class FL_State(cty.Structure):
    """FL_State class

    Attributes
    ----------
        xvinfo : pointer to XVisualInfo
            *todo*
        cur_fnt : pointer to XFontStruct
            *todo*
        colormap : long_pos
            Colormap
        trailblazer : long_pos
            Window
        vclass : int
            visual class
        depth : int
            depth of visual
        rgb_bits : int
            *todo*
        dithered : int
            *todo*
        pcm : int
            *todo*
        gc : array of 16 GC
            *todo*
        textgc : array of 16 GC
            *todo*
        dimmedGC', GC
            *todo*
        lut : array of 1024 long_pos
            *todo*
        rshift : int_pos
            *todo*
        rmask : int_pos
            *todo*
        rbits : int_pos
            *todo*
        gshift : int_pos
            *todo*
        gmask : int_pos
            *todo*
        gbits : int_pos
            *todo*
        bshift : int_pos
            *todo*
        bmask : int_pos
            *todo*
        bbits : int_pos
            *todo*
    """
FL_State.__slots__ = ['xvinfo', 'cur_fnt', 'colormap', 'trailblazer', \
        'vclass', 'depth', 'rgb_bits', 'dithered', 'pcm', 'gc', \
        'textgc', 'dimmedGC', 'lut', 'rshift', 'rmask', 'rbits', \
        'gshift', 'gmask', 'gbits', 'bshift', 'bmask', 'bbits',]
FL_State._fields_ = [
        ('xvinfo', cty.POINTER(XVisualInfo)),
        ('cur_fnt', cty.POINTER(XFontStruct)),
        ('colormap', Colormap),
        ('trailblazer', Window),
        ('vclass', cty.c_int),
        ('depth', cty.c_int),
        ('rgb_bits', cty.c_int),
        ('dithered', cty.c_int),
        ('pcm', cty.c_int),
        ('gc', GC * 16),
        ('textgc', GC * 16),
        ('dimmedGC', GC),
        ('lut', cty.c_ulong * 1024),
        ('rshift', cty.c_uint),
        ('rmask', cty.c_uint),
        ('rbits', cty.c_uint),
        ('gshift', cty.c_uint),
        ('gmask', cty.c_uint),
        ('gbits', cty.c_uint),
        ('bshift', cty.c_uint),
        ('bmask', cty.c_uint),
        ('bbits', cty.c_uint), ]

# FL_STATE placeholder (backwards)


# Global variables
# /usr/include/X11/Xlib.h 266
class _XDisplay(cty.Structure):
    _fields_ = []

Display = _XDisplay


# Fonts related

FL_MAX_FONTSIZES = 10
FL_MAX_FONTNAME_LENGTH = 80

class FL_FONT(cty.Structure):
    """Font class

    Attributes
    ----------
        fs : array of pointer to XFontStruct
            cached fontstruct
        size : array of short
            cached sizes
        nsize : short
            cached so far
        fname : str
            filename without size info
    """
    pass
FL_FONT.__slots__ = ['fs', 'size', 'nsize', 'fname',]
FL_FONT._fields_ = [
        ('fs', cty.POINTER(XFontStruct) * FL_MAX_FONTSIZES),
        ('size', cty.c_short * FL_MAX_FONTSIZES),
        ('nsize', cty.c_short),
        ('fname', cty.c_char * (FL_MAX_FONTNAME_LENGTH + 1)), ]


# /usr/include/X11/Xlib.h 439
class XPoint(cty.Structure):
    """XPoint class

    Attributes
    ----------
        x : short
            horizontal position of a point
        y : short
            vertical position of a point
    """
    pass
FL_POINT = XPoint

# /usr/include/X11/Xlib.h 444
class XRectangle(cty.Structure):
    """XRectangle class

    Attributes
    ----------
        x : short
            horizontal position of rectangle
        y : short
            vertical position of rectangle
        width : ushort
            width of rectangle
        height : ushort
            height of rectangle
    """
    pass
FL_RECT = XRectangle


# Line attributes

# values for unnamed enumeration
FL_SOLID = 0                 #LineSolid
FL_USERDASH = 1               #LineOnOffDash
FL_USERDOUBLEDASH = 2        #LineDoubleDash
FL_DOT = 3
FL_DOTDASH = 4
FL_DASH = 5
FL_LONGDASH = 6

# my add, list of possible values --LK
LINESTYLE_list = [FL_SOLID, FL_USERDASH, FL_USERDOUBLEDASH, FL_DOT,
                  FL_DOTDASH, FL_DASH, FL_LONGDASH]


# *** start - from /usr/include/X11/X.h ***
# Input Event Masks. Used as event-mask window attribute and as arguments
# to Grab requests.  Not to be confused with event names.
NoEventMask = 0
KeyPressMask = (1 << 0)                  # 1
KeyReleaseMask = (1 << 1)                # 2
ButtonPressMask = (1 << 2)               # 4
ButtonReleaseMask = (1 << 3)             # 8
EnterWindowMask = (1 << 4)               # 16
LeaveWindowMask = (1 << 5)               # 32
PointerMotionMask = (1 << 6)             # 64
PointerMotionHintMask = (1 << 7)         # 128
Button1MotionMask = (1 << 8)             # 256
Button2MotionMask = (1 << 9)             # 512
Button3MotionMask = (1 << 10)            # 1024
Button4MotionMask = (1 << 11)            # 2048
Button5MotionMask = (1 << 12)            # 4096
ButtonMotionMask = (1 << 13)             # 8192
KeymapStateMask = (1 << 14)              # 16384
ExposureMask = (1 << 15)                 # 32768
VisibilityChangeMask = (1 << 16)         # 65536
StructureNotifyMask = (1 << 17)          # 131072
ResizeRedirectMask = (1 << 18)           # 262144
SubstructureNotifyMask = (1 << 19)       # 524288
SubstructureRedirectMask = (1 << 20)     # 1048576
FocusChangeMask = (1 << 21)              # 2097152
ColormapChangeMask = (1 << 23)           # 4194304
OwnerGrabButtonMask = (1 << 24)          # 8388608
# Key masks. Used as modifiers to GrabButton and GrabKey, results of
# QueryPointer, state in various key-, mouse-, and button-related events.
ShiftMask = (1 << 0)
LockMask = (1 << 1)
ControlMask = (1 << 2)
Mod1Mask = (1 << 3)
Mod2Mask = (1 << 4)
Mod3Mask = (1 << 5)
Mod4Mask = (1 << 6)
Mod5Mask = (1 << 7)
# button masks.  Used in same manner as Key masks above. Not to be confused
# with button names below.
Button1Mask = (1 << 8)
Button2Mask = (1 << 9)
Button3Mask = (1 << 10)
Button4Mask = (1 << 11)
Button5Mask = (1 << 12)
AnyModifier = (1 << 15)       # used in GrabButton, GrabKey
# *** end - from /usr/include/X11/X.h ***


# All registerable events, including Client Message
FL_ALL_EVENT = (KeyPressMask | KeyReleaseMask | \
        ButtonPressMask | ButtonReleaseMask | EnterWindowMask | \
        LeaveWindowMask | ButtonMotionMask | PointerMotionMask)

# my add, list of possible values --LK
INPUTEVENTMASK_list = [NoEventMask, KeyPressMask, KeyReleaseMask, \
        ButtonPressMask, ButtonReleaseMask, EnterWindowMask, \
        LeaveWindowMask, PointerMotionMask, PointerMotionHintMask, \
        Button1MotionMask, Button2MotionMask, Button3MotionMask, \
        Button4MotionMask, Button5MotionMask, ButtonMotionMask, \
        KeymapStateMask, ExposureMask, VisibilityChangeMask,
        StructureNotifyMask, ResizeRedirectMask, SubstructureNotifyMask,\
        SubstructureRedirectMask, FocusChangeMask, ColormapChangeMask,
        OwnerGrabButtonMask]


# Resources

# values for enumeration 'FL_RTYPE'
FL_RTYPE = cty.c_int  # enum
FL_NONE = 0
FL_SHORT = 10
FL_BOOL = 11
FL_INT = 12
FL_LONG = 13
FL_FLOAT = 14
FL_STRING = 15

# my add, list of possible values --LK
RTYPE_list = [FL_NONE, FL_SHORT, FL_BOOL, FL_INT, FL_LONG, FL_FLOAT,
              FL_STRING]

class FL_RESOURCE(cty.Structure):
    """XForms built-in resource.

    Attributes
    ----------
        res_name : str
            resource name
        res_class : str
            resource class
        type : int
            variable type, e.g. FL_INT, FL_FLOAT, FL_BOOL, FL_STRING, etc..
        var : pointer to any type
            address for the variable value
        defval : str
            default setting in string form
        nbytes : int
            size in bytes+1 used only if var has 'str' type

    List of resources
    -----------------
        rgamma
            class Gamma, type FL_FLOAT, default value 1.0
        ggamma
            class Gamma, type FL_FLOAT, default value 1.0
        bgamma
            class Gamma, type FL_FLOAT, default value 1.0
        visual
            class Visual, type FL_STRING, default value best
        depth
            class Depth, type FL_INT, default value best
        doubleBuffer
            class DoubleBuffer, type FL_BOOL, default value true
        privateColormap
            class PrivateColormap, type FL_BOOL, default value false
        standardColormap
            class StandardColormap, type FL_BOOL, default value false
        sharedColormap
            class SharedColormap, type FL_BOOL, default value false
        pupFontSize
            class PupFontSize, type FL_INT, default value 12pt
        buttonFontSize
            class FontSize, type FL_INT, default value 10pt
        sliderFontSize
            class FontSize, type FL_INT, default value 10pt
        inputFontSize
            class FontSize, type FL_INT, default value 10pt
        browserFontSize
            class FontSize, type FL_INT, default value 10pt
        menuFontSize
            class FontSize, type FL_INT, default value 10pt
        choiceFontSize
            class FontSize, type FL_INT, default value 10pt
        ulPropWidth
            class ULPropWidth, type FL_BOOL, default value true
        ulThickness
            class ULThickness, type FL_INT, default value 1
        scrollbarType
            class ScrollbarType, type FL_STRING, default value thin
        coordUnit
            class CoordUnit, type FL_STRING, default value pixel
        borderWidth
            class BorderWidth, type FL_INT, default value 1

        "best" means that the XForms Library by default selects a
        visual that has the most depth.
    """
FL_RESOURCE.__slots__ = ['res_name', 'res_class', 'type', 'var', \
        'defval', 'nbytes',]
FL_RESOURCE._fields_ = [
        ('res_name', STRING),       # resource name
        ('res_class', STRING),      # resource class
        ('type', FL_RTYPE),         # FL_INT, FL_FLOAT, FL_BOOL, FL_STRING ..
        ('var', cty.c_void_p),      # address for the variable
        ('defval', STRING),         # default setting in string form
        ('nbytes', cty.c_int), ]    # size used only for strings


# values for enumeration 'XrmOptionKind'
XrmOptionKind = cty.c_int       # enum
XrmoptionNoArg = 0      # Value is specified in OptionDescRec.value
XrmoptionIsArg = 1      # Value is the option string itself
XrmoptionStickyArg = 2  # Value is characters immediately following option
XrmoptionSepArg = 3     # Value is next argument in argv
XrmoptionResArg = 4     # Resource and value in next argument in argv
XrmoptionSkipArg = 5    # Ignore this option and the next argument in argv
XrmoptionSkipLine = 6   # Ignore this option and the rest of argv
XrmoptionSkipNArgs = 7

# /usr/include/X11/Xresource.h 345
class XrmOptionDescRec(cty.Structure):
    """XrmOptionDescRec class

    Attributes
    ----------
        option : str
            Option abbreviation in sys.argv (prefixed with '-')
        specifier : str
            resource specifier (starting with '*' or '.')
        argKind : int
            Which style of option it is. Values: XrmoptionNoArg (Value is
            specified in OptionDescRec.value), XrmoptionIsArg (Value is the
            option string itself), XrmoptionStickyArg (Value is characters
            immediately following option), XrmoptionSepArg (Value is next
            argument in argv), XrmoptionResArg (Resource and value in next
            argument in argv), XrmoptionSkipArg (Ignore this option and the
            next argument in argv), XrmoptionSkipLine (Ignore this option and
            the rest of argv), XrmoptionSkipNArgs (Ignore this option and the
            next OptionDescRes.value arguments in argv)
        value : str
            Value to provide if argKind is XrmoptionNoArg
    """
XrmOptionDescRec.__slots__ = ['option', 'specifier', 'argKind', 'value',]
XrmOptionDescRec._fields_ = [
        ('option', STRING),
        ('specifier', STRING),
        ('argKind', XrmOptionKind),
        ('value', XPointer), ]

XrmOptionDescList = cty.POINTER(XrmOptionDescRec)

FL_CMD_OPT = XrmOptionDescRec

FL_resource = FL_RESOURCE


KeySym = XID    # cty.c_ulong


# All Form control variables. Named closely as its resource name

class FL_IOPT(cty.Structure):
    """Form control variables.

    Attributes
    ----------
        rgamma : float
            gamma for red?
        ggamma : float
            gamma for green?
        bgamma : float
            gamma for blue?
        debug : int
            debug level (0-5)
        sync : int
            *todo*
        depth : int
            preferred visual depth
        vclass : int
            preferred visual class (TrueColor, etc..)
        doubleBuffer : int
            Simulates double-buffer
        ulPropWidth : int
            underline stuff
        ulThickness : int
            underline thickness
        buttonFontSize : int
            default button label font size
        sliderFontSize : int
            *todo*
        inputFontSize : int
            Input label and text font size
        browserFontSize : int
            Browser label and text font size
        menuFontSize : int
            Menu label font size
        choiceFontSize : int
            Choice label and choice text font size
        labelFontSize : int
            Label font size for all other flobjects (box, pixmap etc.)
        pupFontSize : int
            font size for pop-up menus
        pupFontStyle : int
            font style for pop-up menus
        privateColormap : int
            Selects private colormap if appropriate
        sharedColormap : int
            Forces use of shared colormap
        standardColormap : int
            Forces use of standard colormap
        scrollbarType : int
            Scrollbar type to use for browser and input
        backingStore : int
            Turn BackingStore on or off
        coordUnit : int
            Unit of measure, e.g. pixel, mm, point
        borderWidth : int
            default border width
        safe : int
            *todo*
        rgbfile : str
            where RGB file is
        vname : str (24 chars)
            name of visual class
    """
FL_IOPT.__slots__ = ['rgamma', 'ggamma', 'bgamma', 'debug', 'sync', \
        'depth', 'vclass', 'doubleBuffer', 'ulPropWidth', 'ulThickness', \
        'buttonFontSize', 'sliderFontSize', 'inputFontSize', \
        'browserFontSize', 'menuFontSize', 'choiceFontSize', \
        'labelFontSize', 'pupFontSize', 'pupFontStyle', 'privateColormap', \
        'sharedColormap', 'standardColormap', 'scrollbarType', \
        'backingStore', 'coordUnit', 'borderWidth', 'safe', 'rgbfile', \
        'vname',]
FL_IOPT._fields_ = [
        ('rgamma', cty.c_float),
        ('ggamma', cty.c_float),
        ('bgamma', cty.c_float),
        ('debug', cty.c_int),
        ('sync', cty.c_int),
        ('depth', cty.c_int),
        ('vclass', cty.c_int),
        ('doubleBuffer', cty.c_int),
        ('ulPropWidth', cty.c_int),          # underline stuff
        ('ulThickness', cty.c_int),
        ('buttonFontSize', cty.c_int),
        ('sliderFontSize', cty.c_int),
        ('inputFontSize', cty.c_int),
        ('browserFontSize', cty.c_int),
        ('menuFontSize', cty.c_int),
        ('choiceFontSize', cty.c_int),
        ('labelFontSize', cty.c_int),        # all other labels fonts
        ('pupFontSize', cty.c_int),          # font for pop-up menus
        ('pupFontStyle', cty.c_int),
        ('privateColormap', cty.c_int),
        ('sharedColormap', cty.c_int),
        ('standardColormap', cty.c_int),
        ('scrollbarType', cty.c_int),
        ('backingStore', cty.c_int),
        ('coordUnit', cty.c_int),
        ('borderWidth', cty.c_int),
        ('safe', cty.c_int),
        ('rgbfile', STRING),                # where RGB file is
        ('vname', cty.c_char * 24), ]

buttonLabelSize = FL_IOPT().buttonFontSize
sliderLabelSize = FL_IOPT().sliderFontSize
inputLabelSize = FL_IOPT().inputFontSize


# Program default masks

# values for unnamed enumeration
FL_PDDepth = 2                      # (1<<1)
FL_PDClass = 4                      # (1<<2)
FL_PDDouble = 8                     # (1<<3)
FL_PDSync = 16                      # (1<<4)
FL_PDPrivateMap = 32                # (1<<5)
FL_PDScrollbarType = 64             # (1<<6)
FL_PDPupFontSize = 128              # (1<<7)
FL_PDButtonFontSize = 256           # (1<<8)
FL_PDInputFontSize = 512            # (1<<9)
FL_PDSliderFontSize  = 1024         # (1<<10)
FL_PDVisual = 2048                  # (1<<11)
FL_PDULThickness = 4096             # (1<<12)
FL_PDULPropWidth = 8192             # (1<<13)
FL_PDBS = 16384                     # (1<<14)
FL_PDCoordUnit = 32768              # (1<<15)
FL_PDDebug = 65536                  # (1<<16)
FL_PDSharedMap = 131072             # (1<<17)
FL_PDStandardMap = 262144           # (1<<18)
FL_PDBorderWidth = 524288           # (1<<19)
FL_PDSafe = 1048576                 # (1<<20)
FL_PDMenuFontSize = 2097152         # (1<<21)
FL_PDBrowserFontSize = 4194304      # (1<<22)
FL_PDChoiceFontSize = 8388608       # (1<<23)
FL_PDLabelFontSize = 16777216       # (1<<24)

FL_PDButtonLabelSize = FL_PDButtonFontSize
FL_PDSliderLabelSize = FL_PDSliderFontSize
FL_PDInputLabelSize = FL_PDInputFontSize
FL_PDButtonLabel = FL_PDButtonLabelSize

# my add, list of possible values --LK
PRGDEFAULTS_list = [FL_PDDepth, FL_PDClass, FL_PDDouble, FL_PDSync,
                    FL_PDPrivateMap, FL_PDScrollbarType, FL_PDPupFontSize,
                    FL_PDButtonFontSize, FL_PDInputFontSize,
                    FL_PDSliderFontSize, FL_PDVisual, FL_PDULThickness,
                    FL_PDULPropWidth, FL_PDBS, FL_PDCoordUnit, FL_PDDebug,
                    FL_PDSharedMap, FL_PDStandardMap, FL_PDBorderWidth,
                    FL_PDSafe, FL_PDMenuFontSize, FL_PDBrowserFontSize,
                    FL_PDChoiceFontSize, FL_PDLabelFontSize,
                    FL_PDButtonLabelSize, FL_PDSliderLabelSize,
                    FL_PDInputLabelSize, FL_PDButtonLabel]


# How we pack and unpack colors
FL_PCTYPE = cty.c_ubyte         # primary color type
FL_PCBITS = 8
FL_PCMAX = (1 << FL_PCBITS) - 1

FL_PACKED4 = cty.c_uint
FL_PACKED = FL_PACKED4

FL_RMASK = 0x000000ff
FL_RSHIFT = 0
FL_GMASK = 0x0000ff00
FL_GSHIFT = 8
FL_BMASK = 0x00ff0000
FL_BSHIFT = 16
FL_AMASK = 0xff000000
FL_ASHIFT = 24


# upstreams' internal structure? --LK
class FL_RGB2PIXEL_(cty.Structure):
    """FL_RGB2PIXEL_ class

    Attributes
    ----------
        rshift : int_pos
            red *todo*
        rmask' : int_pos
            mask value for red
        rbits : int_pos
            red *todo*
        gshift : int_pos
            green *todo*
        gmask' : int_pos
            mask value for green
        gbits : int_pos
            green *todo*
        bshift : int_pos
            blue *todo*
        bmask : int_pos
            mask value for blue
        bbits : int_pos
            blue *todo*
        bits_per_rgb : int
            *todo*
        colormap_size : int
            *todo*
    """
    pass
FL_RGB2PIXEL_.__slots__ = ['rshift', 'rmask', 'rbits', 'gshift', 'gmask', \
        'gbits', 'bshift', 'bmask', 'bbits', 'bits_per_rgb', 'colormap_size',]
FL_RGB2PIXEL_._fields_ = [
        ('rshift', cty.c_uint),
        ('rmask', cty.c_uint),
        ('rbits', cty.c_uint),
        ('gshift', cty.c_uint),
        ('gmask', cty.c_uint),
        ('gbits', cty.c_uint),
        ('bshift', cty.c_uint),
        ('bmask', cty.c_uint),
        ('bbits', cty.c_uint),
        ('bits_per_rgb', cty.c_int),
        ('colormap_size', cty.c_int), ]

FL_RGB2PIXEL = FL_RGB2PIXEL_


Mask = cty.c_ulong
Time = cty.c_ulong
GContext = XID          # cty.c_ulong
KeyCode = cty.c_ubyte


# /usr/include/X11/Xlib.h 416
class XWindowChanges(cty.Structure):
    """X11 XWindowChanges class. Data structure for XReconfigureWindow.

    Attributes
    ----------
        x : int
            horizontal position of window
        y : int
            vertical position of window
        width : int
            width of window
        height : int
            height of window
        border_width : int
            width of the window border
        sibling : long_pos
            Window
        stack_mode : int
            *todo*
    """
    pass
XWindowChanges.__slots__ = ['x', 'y', 'width', 'height', 'border_width', \
        'sibling', 'stack_mode',]
XWindowChanges._fields_ = [
        ('x', cty.c_int),
        ('y', cty.c_int),
        ('width', cty.c_int),
        ('height', cty.c_int),
        ('border_width', cty.c_int),
        ('sibling', Window),
        ('stack_mode', cty.c_int), ]


# /usr/include/X11/Xlib.h 426
class XColor(cty.Structure):
    """X11 XColor class. Data structure used by color operations.

    Attributes
    ----------
        pixel : long_pos
            *todo*
        red : ushort
            *todo*
        green : ushort
            *todo*
        blue :  ushort
            *todo*
        flags : char
            *todo*
        pad : char
            *todo*
    """
    pass
XColor.__slots__ = ['pixel', 'red', 'green', 'blue', 'flags', 'pad',]
XColor._fields_ = [
        ('pixel', cty.c_ulong),
        ('red',  cty.c_ushort),
        ('green',  cty.c_ushort),
        ('blue',  cty.c_ushort),
        ('flags', cty.c_char),
        ('pad', cty.c_char), ]


# /usr/include/X11/Xlib.h 435
class XSegment(cty.Structure):
    """X11 XSegment class

    Attributes
    ----------
        x1 : short
            horizontal position of start point
        y1 : short
            vertical position of start point
        x2 : short
            horizontal position of end point
        y2 : short
            vertical position of end point
    """
    pass
XSegment.__slots__ = ['x1', 'y1', 'x2', 'y2',]
XSegment._fields_ = [
        ('x1', cty.c_short),
        ('y1', cty.c_short),
        ('x2', cty.c_short),
        ('y2', cty.c_short), ]


XPoint.__slots__ = ['x', 'y',]
XPoint._fields_ = [
    ('x', cty.c_short),
    ('y', cty.c_short), ]


# /usr/include/X11/Xlib.h 444
XRectangle.__slots__ = ['x', 'y', 'width', 'height',]
XRectangle._fields_ = [
    ('x', cty.c_short),
    ('y', cty.c_short),
    ('width',  cty.c_ushort),
    ('height',  cty.c_ushort),
]


# /usr/include/X11/Xlib.h 450
class XArc(cty.Structure):
    """X11 XArc class

    Attributes
    ----------
        x : short
            horizontal position
        y : short
            vertical position
        width : ushort
            width of arc
        height : ushort
            height of arc
        angle1 : short
            *todo*
        angle2 : short
            *todo*
    """
    pass
XArc.__slots__ = ['x', 'y', 'width', 'height', 'angle1', 'angle2',]
XArc._fields_ = [
        ('x', cty.c_short),
        ('y', cty.c_short),
        ('width',  cty.c_ushort),
        ('height',  cty.c_ushort),
        ('angle1', cty.c_short),
        ('angle2', cty.c_short), ]


# /usr/include/X11/Xlib.h 464
class XKeyboardControl(cty.Structure):
    """X11 XKeyboardControl class. Data structure for XChangeKeyboardControl.

    Attributes
    ----------
        key_click_percent : int
            *todo*
        bell_percent : int
            *todo*
        bell_pitch : int
            *todo*
        bell_duration : int
            *todo*
        led : int
            *todo*
        led_mode : int
            *todo*
        key : int
            *todo*
        auto_repeat_mode : int
            On, Off, Default
    """
    pass
XKeyboardControl.__slots__ = ['key_click_percent', 'bell_percent', \
        'bell_pitch', 'bell_duration', 'led', 'led_mode', 'key', \
        'auto_repeat_mode',]
XKeyboardControl._fields_ = [
        ('key_click_percent', cty.c_int),
        ('bell_percent', cty.c_int),
        ('bell_pitch', cty.c_int),
        ('bell_duration', cty.c_int),
        ('led', cty.c_int),
        ('led_mode', cty.c_int),
        ('key', cty.c_int),
        ('auto_repeat_mode', cty.c_int), ]


# /usr/include/X11/Xlib.h 475
class XKeyboardState(cty.Structure):
    """X11 XKeyboardState class. Data structure for XGetKeyboardControl.

    Attributes
    ----------
        key_click_percent : int
            *todo*
        bell_percent : int
            *todo*
        bell_pitch : int_pos,
            *todo*
        bell_duration : int_pos
            *todo*
        led_mask : long_pos
            *todo*
        global_auto_repeat : int
            *todo*
        auto_repeats : array of 32 char
            *todo*
    """
    pass
XKeyboardState.__slots__ = ['key_click_percent', 'bell_percent', \
        'bell_pitch', 'bell_duration', 'led_mask', 'global_auto_repeat', \
        'auto_repeats',]
XKeyboardState._fields_ = [
        ('key_click_percent', cty.c_int),
        ('bell_percent', cty.c_int),
        ('bell_pitch', cty.c_uint),
        ('bell_duration', cty.c_uint),
        ('led_mask', cty.c_ulong),
        ('global_auto_repeat', cty.c_int),
        ('auto_repeats', cty.c_char * 32), ]


# /usr/include/X11/Xlib.h 482
class XTimeCoord(cty.Structure):
    """X11 XTimeCoord class. Data structure for XGetMotionEvents.

    Attributes
    ----------
        time : long_pos
            time in milliseconds
        x : short
            *todo*
        y : short
            *todo*
    """
    pass
XTimeCoord.__slots__ = ['time', 'x', 'y',]
XTimeCoord._fields_ = [
        ('time', Time),
        ('x', cty.c_short),
        ('y', cty.c_short), ]


# /usr/include/X11/Xlib.h 489
class XModifierKeymap(cty.Structure):
    """X11 XModifierKeymap class. Data structure for X{Set,Get}ModifierMapping.

    Attributes
    ----------
        max_keypermod : int
            The server's max # of keys per modifier
        modifiermap : pointer to KeyCode
            An 8 by max_keypermod array of modifiers
    """
    pass
XModifierKeymap.__slots__ = ['max_keypermod', 'modifiermap',]
XModifierKeymap._fields_ = [
        ('max_keypermod', cty.c_int),
        ('modifiermap', cty.POINTER(KeyCode)), ]


Display = _XDisplay


# /usr/include/X11/Xlib.h 501
class _XPrivate(cty.Structure):
    _fields_ = []


# /usr/include/X11/Xlib.h 502
class _XrmHashBucketRec(cty.Structure):
    _fields_ = []


# /usr/include/X11/Xlib.h 582
class XKeyEvent(cty.Structure):
    """X11 XKeyEvent class. Definitions of specific events.

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
            # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        window : long_pos
            "event" window it is reported relative to
        root : long_pos
            root window that the event occurred on
        subwindow : long_pos
            child window
        time : long_pos
            time in milliseconds
        x : int
            horizontal coordinates of pointer in event window
        y : int
            vertical coordinates of pointer in event window
        x_root : int
            horizontal coordinates relative to root
        y_root : int
            vertical coordinates relative to root
        state : int_pos
            key or button mask
        keycode : int_pos
            detail
        same_screen : int
            (bool) same screen flag
    """
    pass
XKeyEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'window', 'root', 'subwindow', 'time', 'x', 'y', 'x_root', \
        'y_root', 'state', 'keycode', 'same_screen',]
XKeyEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('window', Window),
        ('root', Window),
        ('subwindow', Window),
        ('time', Time),
        ('x', cty.c_int),
        ('y', cty.c_int),
        ('x_root', cty.c_int),
        ('y_root', cty.c_int),
        ('state', cty.c_uint),
        ('keycode', cty.c_uint),
        ('same_screen', cty.c_int), ]
XKeyPressedEvent = XKeyEvent
XKeyReleasedEvent = XKeyEvent


# /usr/include/X11/Xlib.h 600
class XButtonEvent(cty.Structure):
    """X11 XButtonEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
            # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        window : long_pos
            "event" window it is reported relative to
        root : long_pos
            root window that the event occurred on
        subwindow : long_pos
            child window
        time : long_pos
            time in milliseconds
        x : int
            horizontal coordinates of pointer in event window
        y : int
            vertical coordinates of pointer in event window
        x_root : int
            horizontal coordinates relative to root
        y_root : int
            vertical coordinates relative to root
        state : int_pos
            key or button mask
        button : int_pos
            detail
        same_screen : int
            (bool) same screen flag
    """
    pass
XButtonEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'window', 'root', 'subwindow', 'time', 'x', 'y', 'x_root', \
        'y_root', 'state', 'button', 'same_screen',]
XButtonEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('window', Window),
        ('root', Window),
        ('subwindow', Window),
        ('time', Time),
        ('x', cty.c_int),
        ('y', cty.c_int),
        ('x_root', cty.c_int),
        ('y_root', cty.c_int),
        ('state', cty.c_uint),
        ('button', cty.c_uint),
        ('same_screen', cty.c_int), ]
XButtonPressedEvent = XButtonEvent
XButtonReleasedEvent = XButtonEvent


# /usr/include/X11/Xlib.h 618
class XMotionEvent(cty.Structure):
    """X11 XMotionEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
            # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        window : long_pos
            "event" window it is reported relative to
        root : long_pos
            root window that the event occurred on
        subwindow : long_pos
            child window
        time : long_pos
            time in milliseconds
        x : int
            horizontal coordinates of pointer in event window
        y : int
            vertical coordinates of pointer in event window
        x_root : int
            horizontal coordinates relative to root
        y_root : int
            vertical coordinates relative to root
        state : int_pos
            key or button mask
        is_hint : char
            detail
        same_screen : int
            (bool) same screen flag
    """
    pass
XMotionEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'window', 'root', 'subwindow', 'time', 'x', 'y', 'x_root', \
        'y_root', 'state', 'is_hint', 'same_screen',]
XMotionEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('window', Window),
        ('root', Window),
        ('subwindow', Window),
        ('time', Time),
        ('x', cty.c_int),
        ('y', cty.c_int),
        ('x_root', cty.c_int),
        ('y_root', cty.c_int),
        ('state', cty.c_uint),
        ('is_hint', cty.c_char),
        ('same_screen', cty.c_int), ]
XPointerMovedEvent = XMotionEvent


# /usr/include/X11/Xlib.h 641
class XCrossingEvent(cty.Structure):
    """X11 XCrossingEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
            # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        window : long_pos
            "event" window it is reported relative to
        root : long_pos
            root window that the event occurred on
        subwindow : long_pos
            child window
        time : long_pos
            time in milliseconds
        x : int
            horizontal coordinates of pointer in event window
        y : int
            vertical coordinates of pointer in event window
        x_root : int
            horizontal coordinates relative to root
        y_root : int
            vertical coordinates relative to root
        mode : int
            NotifyNormal, NotifyGrab, NotifyUngrab
        detail : int
            NotifyAncestor, NotifyVirtual, NotifyInferior,
            NotifyNonlinear, NotifyNonlinearVirtual
        same_screen : int
            (bool) same screen flag
        focus : int
            boolean focus
        state : int_pos
            key or button mask
    """
    pass
XCrossingEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'window', 'root', 'subwindow', 'time', 'x', 'y', 'x_root', \
        'y_root', 'mode', 'detail', 'same_screen', 'focus', 'state',]
XCrossingEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('window', Window),
        ('root', Window),
        ('subwindow', Window),
        ('time', Time),
        ('x', cty.c_int),
        ('y', cty.c_int),
        ('x_root', cty.c_int),
        ('y_root', cty.c_int),
        ('mode', cty.c_int),
        ('detail', cty.c_int),
        ('same_screen', cty.c_int),
        ('focus', cty.c_int),
        ('state', cty.c_uint), ]
XEnterWindowEvent = XCrossingEvent
XLeaveWindowEvent = XCrossingEvent


# /usr/include/X11/Xlib.h 659
class XFocusChangeEvent(cty.Structure):
    """X11 XFocusChangeEvent class

    Attributes
    ----------
        type : int
            FocusIn or FocusOut
        serial : long_pos
            # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        window : long_pos
            window of event
        mode : int
            NotifyNormal, NotifyWhileGrabbed,
            NotifyGrab, NotifyUngrab
        detail : int
            NotifyAncestor, NotifyVirtual, NotifyInferior,
            NotifyNonlinear,NotifyNonlinearVirtual, NotifyPointer,
            NotifyPointerRoot, NotifyDetailNone
    """
    pass
XFocusChangeEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'window', 'mode', 'detail',]
XFocusChangeEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('window', Window),
        ('mode', cty.c_int),
        ('detail', cty.c_int), ]

XFocusInEvent = XFocusChangeEvent
XFocusOutEvent = XFocusChangeEvent


# /usr/include/X11/Xlib.h 671
class XKeymapEvent(cty.Structure):
    """X11 XKeymapEvent class. It is generated on EnterWindow
    and FocusIn when KeyMapState selected.

    Attributes
    ----------
        type : int
            # of last request processed by server
        serial : long_pos
            # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        window : long_pos
            window of event
        key_vector : array of 32 char
            *todo*
    """
    pass
XKeymapEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'window', 'key_vector',]
XKeymapEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('window', Window),
        ('key_vector', cty.c_char * 32), ]


# /usr/include/X11/Xlib.h 682
class XExposeEvent(cty.Structure):
    """X11 XExposeEvent class. The expose event is one of the most basic events
    an application may receive. It will be sent in one of several cases:
    - A window that covered part of our window has moved away, exposing part
    (or all) of our window;
    - Our window was raised above other windows;
    - Our window mapped for the first time;
    - Our window was de-iconified.

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
            # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        window : long_pos
            The id of the window this expose event was sent for
        x : int
            horizontal position (in pixels) from the top-left of the window,
            of the window's region that needs to be redrawn
        y : int
            vertical position (in pixels) from the top-left of the window, of
            the window's region that needs to be redrawn
        width : int
            width (in pixels) of the window's region that needs to be redraw
        height : int
            height (in pixels) of the window's region that needs to be redraw
        count : int
            number of other expose events waiting in the server's events queue.
            This may be useful if we got several expose events in a row, we
            will usually avoid redrawing the window until we get the last of
            them (i.e. until count is 0)
    """
    pass
XExposeEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'window', 'x', 'y', 'width', 'height', 'count',]
XExposeEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('window', Window),
        ('x', cty.c_int),
        ('y', cty.c_int),
        ('width', cty.c_int),
        ('height', cty.c_int),
        ('count', cty.c_int), ]


Drawable = XID    # cty.c_ulong


# /usr/include/X11/Xlib.h 695
class XGraphicsExposeEvent(cty.Structure):
    """X11 XGraphicsExposeEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
            # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        drawable : long_pos
            Drawable *todo*
        x : int
            *todo*
        y : int
            *todo*
        width : int
            *todo*
        height : int
            *todo*
        count : int
            if non-zero, at least this many more?
        major_code : int
            core is CopyArea or CopyPlane
        minor_code : int
            not defined in the core
    """
    pass
XGraphicsExposeEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'drawable', 'x', 'y', 'width', 'height', 'count', 'major_code', \
        'minor_code',]
XGraphicsExposeEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('drawable', Drawable),
        ('x', cty.c_int),
        ('y', cty.c_int),
        ('width', cty.c_int),
        ('height', cty.c_int),
        ('count', cty.c_int),
        ('major_code', cty.c_int),
        ('minor_code', cty.c_int), ]


# /usr/include/X11/Xlib.h 705
class XNoExposeEvent(cty.Structure):
    """X11 XNoExposeEvent class

    Attributes
    ----------
        type : int
            typeof event
        serial : long_pos
            # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        drawable : long_pos
            Drawable
        major_code : int
            core is CopyArea or CopyPlane
        minor_code : int
            not defined in the core
    """
    pass
XNoExposeEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'drawable', 'major_code', 'minor_code',]
XNoExposeEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('drawable', Drawable),
        ('major_code', cty.c_int),
        ('minor_code', cty.c_int), ]


# /usr/include/X11/Xlib.h 714
class XVisibilityEvent(cty.Structure):
    """X11 XVisibilityEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
            # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        window : long_pos
            Window of event
        state : int
            Visibility state
    """
    pass
XVisibilityEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'window', 'state',]
XVisibilityEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('window', Window),
        ('state', cty.c_int), ]


# /usr/include/X11/Xlib.h 727
class XCreateWindowEvent(cty.Structure):
    """X11 XCreateWindowEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        parent : long_pos
            parent of the window
        window : long_pos
            Window id of window created
        x : int
            window horizontal location
        y : int
            window vertical location
        width : int
            width of the window
        height : int
            height of the window
        border_width : int
            width of border
        override_redirect : int
            (bool) creation should be overridden
    """
    pass
XCreateWindowEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'parent', 'window', 'x', 'y', 'width', 'height', 'border_width', \
        'override_redirect',]
XCreateWindowEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('parent', Window),
        ('window', Window),
        ('x', cty.c_int),
        ('y', cty.c_int),
        ('width', cty.c_int),
        ('height', cty.c_int),
        ('border_width', cty.c_int),
        ('override_redirect', cty.c_int), ]


# /usr/include/X11/Xlib.h 736
class XDestroyWindowEvent(cty.Structure):
    """X11 XDestroyWindowEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        event : long_pos
            Window
        window : long_pos
            Window
    """
    pass
XDestroyWindowEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'event', 'window',]
XDestroyWindowEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('event', Window),
        ('window', Window), ]


# /usr/include/X11/Xlib.h 746
class XUnmapEvent(cty.Structure):
    """X11 XUnmapEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        event : long_pos
            Window
        window : long_pos
            Window
        from_configure : int
            (bool) *todo*
    """
    pass
XUnmapEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'event', 'window', 'from_configure',]
XUnmapEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('event', Window),
        ('window', Window),
        ('from_configure', cty.c_int), ]


# /usr/include/X11/Xlib.h 756
class XMapEvent(cty.Structure):
    """X11 XMapEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        event : long_pos
            Window
        window : long_pos
            Window
        override_redirect : int
            boolean, is override set...
    """
    pass
XMapEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'event', 'window', 'override_redirect',]
XMapEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('event', Window),
        ('window', Window),
        ('override_redirect', cty.c_int), ]


# /usr/include/X11/Xlib.h 765
class XMapRequestEvent(cty.Structure):
    """X11 XMapRequestEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        parent : long_pos
            Window
        window : long_pos
            Window
    """
    pass
XMapRequestEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'parent', 'window',]
XMapRequestEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('parent', Window),
        ('window', Window), ]


# /usr/include/X11/Xlib.h 777
class XReparentEvent(cty.Structure):
    """X11 XReparentEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        event : long_pos
            Window
        window : long_pos
            Window
        parent : long_pos
            Window
        x : int
            *todo*
        y : int
            *todo*
        override_redirect : int
            *todo*
    """
    pass
XReparentEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'event', 'window', 'parent', 'x', 'y', 'override_redirect',]
XReparentEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('event', Window),
        ('window', Window),
        ('parent', Window),
        ('x', cty.c_int),
        ('y', cty.c_int),
        ('override_redirect', cty.c_int), ]


# /usr/include/X11/Xlib.h 791
class XConfigureEvent(cty.Structure):
    """X11 XConfigureEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        event : long_pos
            Window
        window : long_pos
            Window
        x : int
            *todo*
        y : int
            *todo*
        width : int
            *todo*
        height : int
            *todo*
        border_width : int
            *todo*
        above : long_pos
            Window
        override_redirect : int
            *todo*
    """
    pass
XConfigureEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'event', 'window', 'x', 'y', 'width', 'height', 'border_width', \
        'above', 'override_redirect',]
XConfigureEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('event', Window),
        ('window', Window),
        ('x', cty.c_int),
        ('y', cty.c_int),
        ('width', cty.c_int),
        ('height', cty.c_int),
        ('border_width', cty.c_int),
        ('above', Window),
        ('override_redirect', cty.c_int), ]


# /usr/include/X11/Xlib.h 801
class XGravityEvent(cty.Structure):
    """X11 XGravityEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        event : long_pos
            Window
        window : long_pos
            Window
        x : int
            *todo*
        y : int
            *todo*
    """
    pass
XGravityEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'event', 'window', 'x', 'y',]
XGravityEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('event', Window),
        ('window', Window),
        ('x', cty.c_int),
        ('y', cty.c_int), ]


# /usr/include/X11/Xlib.h 810
class XResizeRequestEvent(cty.Structure):
    """X11 XResizeRequestEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        window : long_pos
            Window
        width : int
            *todo*
        height : int
            *todo*
    """
    pass
XResizeRequestEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'window', 'width', 'height',]
XResizeRequestEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('window', Window),
        ('width', cty.c_int),
        ('height', cty.c_int), ]


# /usr/include/X11/Xlib.h 825
class XConfigureRequestEvent(cty.Structure):
    """X11 XConfigureRequestEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        parent : long_pos
            Window
        window : long_pos
            Window
        x : int
            *todo*
        y : int
            *todo*
        width : int
            *todo*
        height : int
            *todo*
        border_width : int
            *todo*
        above : long_pos
            Window
        detail : int
            Above, Below, TopIf, BottomIf, Opposite
        value_mask : long_pos
            *todo*
    """
    pass
XConfigureRequestEvent.__slots__ = ['type', 'serial', 'send_event', \
    'display', 'parent', 'window', 'x', 'y', 'width', 'height', \
    'border_width', 'above', 'detail', 'value_mask',]
XConfigureRequestEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('parent', Window),
        ('window', Window),
        ('x', cty.c_int),
        ('y', cty.c_int),
        ('width', cty.c_int),
        ('height', cty.c_int),
        ('border_width', cty.c_int),
        ('above', Window),
        ('detail', cty.c_int),
        ('value_mask', cty.c_ulong), ]


# /usr/include/X11/Xlib.h 835
class XCirculateEvent(cty.Structure):
    """X11 XCirculateEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        event : long_pos
            Window
        window : long_pos
            Window
        place : int
            PlaceOnTop, PlaceOnBottom
    """
    pass
XCirculateEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'event', 'window', 'place',]
XCirculateEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('event', Window),
        ('window', Window),
        ('place', cty.c_int), ]


# /usr/include/X11/Xlib.h 845
class XCirculateRequestEvent(cty.Structure):
    """X11 XCirculateRequestEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        parent : long_pos
            Window
        window :  long_pos
            Window
        place : int
            PlaceOnTop, PlaceOnBottom
    """
    pass
XCirculateRequestEvent.__slots__ = ['type', 'serial', 'send_event', \
        'display', 'parent', 'window', 'place',]
XCirculateRequestEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('parent', Window),
        ('window', Window),
        ('place', cty.c_int), ]


# /usr/include/X11/Xlib.h 856
class XPropertyEvent(cty.Structure):
    """X11 XPropertyEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        window : long_pos
            Window
        atom : long_pos
            Atom
        time : long_pos
            Time
        state : int
            NewValue, Deleted
    """
    pass
XPropertyEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'window', 'atom', 'time', 'state',]
XPropertyEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('window', Window),
        ('atom', Atom),
        ('time', Time),
        ('state', cty.c_int), ]


# /usr/include/X11/Xlib.h 866
class XSelectionClearEvent(cty.Structure):
    """X11 XSelectionClearEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        window : long_pos
            Window
        selection : long_pos
            Atom
        time : long_pos
            Time
    """
    pass
XSelectionClearEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'window', 'selection', 'time',]
XSelectionClearEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('window', Window),
        ('selection', Atom),
        ('time', Time), ]


# /usr/include/X11/Xlib.h 879
class XSelectionRequestEvent(cty.Structure):
    """X11 XSelectionRequestEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        owner : long_pos
            Window
        requestor : long_pos
            Window
        selection : long_pos
            Atom
        target : long_pos
            Atom
        property : long_pos
            Atom
        time : long_pos
            Time
    """
    pass
XSelectionRequestEvent.__slots__ = ['type', 'serial', 'send_event', \
        'display', 'owner', 'requestor', 'selection', 'target', 'property', \
        'time',]
XSelectionRequestEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('owner', Window),
        ('requestor', Window),
        ('selection', Atom),
        ('target', Atom),
        ('property', Atom),
        ('time', Time), ]


# /usr/include/X11/Xlib.h 891
class XSelectionEvent(cty.Structure):
    """X11 XSelectionEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        requestor : long_pos
            Window
        selection : long_pos
            Atom
        target : long_pos
            Atom
        property : long_pos
            ATOM or None
        time : long_pos
            Time
    """
    pass
XSelectionEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'requestor', 'selection', 'target', 'property', 'time',]
XSelectionEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('requestor', Window),
        ('selection', Atom),
        ('target', Atom),
        ('property', Atom),
        ('time', Time), ]


# /usr/include/X11/Xlib.h 906
class XColormapEvent(cty.Structure):
    """X11 XColormapEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        window : long_pos
            Window
        colormap : long_pos
            COLORMAP or None
        c_new : int
            *todo*
        state : int
            ColormapInstalled, ColormapUninstalled
    """
    pass
XColormapEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'window', 'colormap', 'c_new', 'state',]
XColormapEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('window', Window),
        ('colormap', Colormap),
        ('c_new', cty.c_int),
        ('state', cty.c_int), ]


# /usr/include/X11/Xlib.h 916
class N19XClientMessageEvent4DOT_71E(cty.Union):
    """X11 N19XClientMessageEvent4DOT_71E class

    Attributes
    ----------
        b : array of 20 char
            *todo*
        s : array of 10 short
            *todo*
        l : array of 5 long
            *todo*
    """
    pass
N19XClientMessageEvent4DOT_71E.__slots__ = ['b', 's', 'l',]
N19XClientMessageEvent4DOT_71E._fields_ = [
        ('b', cty.c_char * 20),
        ('s', cty.c_short * 10),
        ('l', cty.c_long * 5), ]


# /usr/include/X11/Xlib.h 921
class XClientMessageEvent(cty.Structure):
    """X11 XClientMessageEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        window : long_pos
            Window
        message_type : long_pos
            Atom
        format : int
            *todo*
        data : N19XClientMessageEvent4DOT_71E
            a Union structure *todo*
    """
    pass
XClientMessageEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'window', 'message_type', 'format', 'data',]
XClientMessageEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('window', Window),
        ('message_type', Atom),
        ('format', cty.c_int),
        ('data', N19XClientMessageEvent4DOT_71E), ]


# /usr/include/X11/Xlib.h 933
class XMappingEvent(cty.Structure):
    """X11 XMappingEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        window : long_pos
            unused
        request : int
            one of MappingModifier, MappingKeyboard,
            MappingPointer
        first_keycode : int
            first keycode
        count : int
            defines range of change w. first_keycode
    """
    pass
XMappingEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'window', 'request', 'first_keycode', 'count',]
XMappingEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('window', Window),
        ('request', cty.c_int),
        ('first_keycode', cty.c_int),
        ('count', cty.c_int), ]


# /usr/include/X11/Xlib.h 943
class XErrorEvent(cty.Structure):
    """XErrorEvent class

    Attributes
    ----------
        type : int
            type of event
        display : pointer to Display
            Display the event was read from
        resourceid : long_pos
            resource id
        serial : long_pos
            serial number of failed request
        error_code : ubyte
            error code of failed request
        request_code : ubyte
            Major op-code of failed request
        minor_code : ubyte
            Minor op-code of failed request
    """
    pass
XErrorEvent.__slots__ = ['type', 'display', 'resourceid', 'serial', \
        'error_code', 'request_code', 'minor_code',]
XErrorEvent._fields_ = [
        ('type', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('resourceid', XID),
        ('serial', cty.c_ulong),
        ('error_code', cty.c_ubyte),
        ('request_code', cty.c_ubyte),
        ('minor_code', cty.c_ubyte), ]


# /usr/include/X11/Xlib.h 951
class XAnyEvent(cty.Structure):
    """X11 XAnyEvent class

    Attributes
    ----------
        type : int
            type of event
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        window : long_pos
            window on which event was requested in event mask
    """
    pass
XAnyEvent.__slots__ = ['type', 'serial', 'send_event', 'display', 'window',]
XAnyEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('window', Window), ]


# /usr/include/X11/Xlib.h 967
class XGenericEvent(cty.Structure):
    """X11 XGenericEvent class. This event is the standard event for
    all newer extensions.

    Attributes
    ----------
        type : int
            type of event. Always GenericEvent
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        extension : int
            major opcode of extension that caused the event
        evtype : int
            actual event type
    """
    pass
XGenericEvent.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'extension', 'evtype',]
XGenericEvent._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('extension', cty.c_int),
        ('evtype', cty.c_int), ]


# /usr/include/X11/Xlib.h 978
class XGenericEventCookie(cty.Structure):
    """X11 XGenericEventCookie class

    Attributes
    ----------
        type : int
            type of event. Always GenericEvent
        serial : long_pos
             # of last request processed by server
        send_event : int
            (bool) true if this came from a SendEvent request
        display : pointer to Display
            Display the event was read from
        extension : int
            major opcode of extension that caused the event
        evtype : int
            actual event type
        cookie : int_pos
            *todo*
        data : pointer to void
            *todo*
    """
    pass
XGenericEventCookie.__slots__ = ['type', 'serial', 'send_event', 'display', \
        'extension', 'evtype', 'cookie', 'data',]
XGenericEventCookie._fields_ = [
        ('type', cty.c_int),
        ('serial', cty.c_ulong),
        ('send_event', cty.c_int),
        ('display', cty.POINTER(Display)),
        ('extension', cty.c_int),
        ('evtype', cty.c_int),
        ('cookie', cty.c_uint),
        ('data', cty.c_void_p), ]


# /usr/include/X11/Xlib.h 984
_XEvent.__slots__ = ['type', 'xany', 'xkey', 'xbutton', 'xmotion', \
        'xcrossing', 'xfocus', 'xexpose', 'xgraphicsexpose', 'xnoexpose', \
        'xvisibility', 'xcreatewindow', 'xdestroywindow', 'xunmap', \
        'xmap', 'xmaprequest', 'xreparent', 'xconfigure', 'xgravity', \
        'xresizerequest', 'xconfigurerequest', 'xcirculate', \
        'xcirculaterequest', 'xproperty', 'xselectionclear', \
        'xselectionrequest', 'xselection', 'xcolormap', 'xclient', \
        'xmapping', 'xerror', 'xkeymap', 'xgeneric', 'xcookie', 'pad',]
_XEvent._fields_ = [
    ('type', cty.c_int),
    ('xany', XAnyEvent),
    ('xkey', XKeyEvent),
    ('xbutton', XButtonEvent),
    ('xmotion', XMotionEvent),
    ('xcrossing', XCrossingEvent),
    ('xfocus', XFocusChangeEvent),
    ('xexpose', XExposeEvent),
    ('xgraphicsexpose', XGraphicsExposeEvent),
    ('xnoexpose', XNoExposeEvent),
    ('xvisibility', XVisibilityEvent),
    ('xcreatewindow', XCreateWindowEvent),
    ('xdestroywindow', XDestroyWindowEvent),
    ('xunmap', XUnmapEvent),
    ('xmap', XMapEvent),
    ('xmaprequest', XMapRequestEvent),
    ('xreparent', XReparentEvent),
    ('xconfigure', XConfigureEvent),
    ('xgravity', XGravityEvent),
    ('xresizerequest', XResizeRequestEvent),
    ('xconfigurerequest', XConfigureRequestEvent),
    ('xcirculate', XCirculateEvent),
    ('xcirculaterequest', XCirculateRequestEvent),
    ('xproperty', XPropertyEvent),
    ('xselectionclear', XSelectionClearEvent),
    ('xselectionrequest', XSelectionRequestEvent),
    ('xselection', XSelectionEvent),
    ('xcolormap', XColormapEvent),
    ('xclient', XClientMessageEvent),
    ('xmapping', XMappingEvent),
    ('xerror', XErrorEvent),
    ('xkeymap', XKeymapEvent),
    ('xgeneric', XGenericEvent),
    ('xcookie', XGenericEventCookie),
    ('pad', cty.c_long * 24), ]


# *** start - from /usr/include/X11/X.h ***
# Event names.  Used in "type" field in XEvent structures.  Not to be
# confused with event masks above.  They start from 2 because 0 and 1
# are reserved in the protocol for errors and replies.
KeyPress = 2
KeyRelease = 3
ButtonPress = 4
ButtonRelease = 5
MotionNotify = 6
EnterNotify = 7
LeaveNotify = 8
FocusIn = 9
FocusOut = 10
KeymapNotify = 11
Expose = 12
GraphicsExpose = 13
NoExpose = 14
VisibilityNotify = 15
CreateNotify = 16
DestroyNotify = 17
UnmapNotify = 18
MapNotify = 19
MapRequest = 20
ReparentNotify = 21
ConfigureNotify = 22
ConfigureRequest = 23
GravityNotify = 24
ResizeRequest = 25
CirculateNotify = 26
CirculateRequest = 27
PropertyNotify = 28
SelectionClear = 29
SelectionRequest = 30
SelectionNotify = 31
# *** end - from /usr/include/X11/X.h ***

class admitted_values_for_EventNames(object):
    """Event type names.

    Admitted values
    ---------------
        KeyPress
            *todo*
        KeyRelease
            *todo*
        ButtonPress
            *todo*
        ButtonRelease
            *todo*
        MotionNotify
            *todo*
        EnterNotify
            *todo*
        LeaveNotify
            *todo*
        FocusIn
            *todo*
        FocusOut
            *todo*
        KeymapNotify
            *todo*
        Expose
            *todo*
        GraphicsExpose
            *todo*
        NoExpose
            *todo*
        VisibilityNotify
            *todo*
        CreateNotify
            *todo*
        DestroyNotify
            *todo*
        UnmapNotify
            *todo*
        MapNotify
            *todo*
        MapRequest
            *todo*
        ReparentNotify
            *todo*
        ConfigureNotify
            *todo*
        ConfigureRequest
            *todo*
        GravityNotify
            *todo*
        ResizeRequest
            *todo*
        CirculateNotify
            *todo*
        CirculateRequest
            *todo*
        PropertyNotify
            *todo*
        SelectionClear
            *todo*
        SelectionRequest
            *todo*
        SelectionNotify
            *todo*
    """
    pass

# my add, list of possible values --LK
# added 0, for all event types --LK
XEVENTNAMES_list = [0, KeyPress, KeyRelease, ButtonPress, ButtonRelease,
            MotionNotify, EnterNotify, LeaveNotify, FocusIn, FocusOut,
            KeymapNotify, Expose, GraphicsExpose, NoExpose, VisibilityNotify,
            CreateNotify, DestroyNotify, UnmapNotify, MapNotify, MapRequest,
            ReparentNotify, ConfigureNotify, ConfigureRequest, GravityNotify,
            ResizeRequest, CirculateNotify, CirculateRequest, PropertyNotify,
            SelectionClear, SelectionRequest, SelectionNotify]


# *** start - from /usr/include/X11/Xutil.h 139 ***
# definitions for initial window state
#WithdrawnState = 0      # for windows that are not mapped
NormalState = 1         # most applications want to start this way
IconicState = 3         # application wants to start as an icon
# *** end - from /usr/include/X11/Xutil.h ***

# my add, list of possible values --LK
WINSTATE_list = [NormalState, IconicState]



#######################
# forms.h (bitmap.h)
# Bitmap flobject class
#######################

FL_NORMAL_BITMAP = 0

# my add, list of possible values --LK
BITMAPTYPE_list = [FL_NORMAL_BITMAP, ]


# Defaults
FL_BITMAP_BOXTYPE = FL_NO_BOX
FL_BITMAP_COL1 = FL_COL1            # background of bitmap
FL_BITMAP_COL2 = FL_COL1            # not used currently
FL_BITMAP_LCOL = FL_LCOL            # foreground of bitmap
FL_BITMAP_ALIGN = FL_ALIGN_BOTTOM


# PIXMAP stuff

FL_NORMAL_PIXMAP = 0

# my add - list of possible values --LK
PIXMAPTYPE_list = [FL_NORMAL_PIXMAP, ]


#######################
# forms.h (browser.h)
# Object class Browser
#######################

# values for enumeration 'FL_BROWSER_TYPE'
FL_BROWSER_TYPE = cty.c_int     # enum
FL_NORMAL_BROWSER = 0
FL_SELECT_BROWSER = 1
FL_HOLD_BROWSER = 2
FL_MULTI_BROWSER = 3

# my add - list of possible values --LK
BROWSERTYPE_list = [FL_NORMAL_BROWSER, FL_SELECT_BROWSER,
                    FL_HOLD_BROWSER, FL_MULTI_BROWSER]


# Defaults
FL_BROWSER_BOXTYPE = FL_DOWN_BOX
FL_BROWSER_COL1 = FL_COL1
FL_BROWSER_COL2 = FL_YELLOW
FL_BROWSER_LCOL = FL_LCOL
FL_BROWSER_ALIGN = FL_ALIGN_BOTTOM

# Others
FL_BROWSER_SLCOL = FL_COL1
FL_BROWSER_FONTSIZE = FL_SMALL_SIZE


#FL_BROWSER_LINELENGTH placeholder (backwards)

FL_BROWSER_SCROLL_CALLBACK = cty.CFUNCTYPE(None, cty.POINTER(FL_OBJECT),
                cty.c_int, cty.c_void_p)


# my add --LK
class admitted_value_for_BROWSERLINES_APPEARANCE(object):
    """Values to be used for changing appearance of individual lines in the
    browser.

    Whenever a line starts with the symbol '@' the next letter indicates
    the special characteristics associated with this line. The following
    possibilities exist at the moment:
        f    Fixed width font.
        n    Normal (Helvetica) font.
        t    Times-Roman like font.
        b    Boldface modifier.
        i    Italics modifier.
        l    Large (new size is FL_LARGE_SIZE).
        m    Medium (new size is FL_MEDIUM_SIZE).
        s    Small (new size is FL_SMALL_SIZE).
        L    Large (new size = current size + 6).
        M    Medium (new size = current size + 4).
        S    Small (new size = current size - 2).
        c    Centered.
        r    Right aligned.
        _    Draw underlined text.
        -    An engraved separator. Text following '-' is ignored.
        C    The next number indicates the color index for this line.
        N    Non-selectable line (in selectable browsers).
        @@    Regular '@' character.
    The modifiers (bold and itatic) work by adding FL_BOLD_STYLE and
    FL_ITALIC_STYLE to the current active font index to look up the font in
    the font table; you can modify the table using flbasic.fl_set_font_name()
    function.
    More than one option can be used by putting them next to each other. E.g.,
    "@C1@l@f@b@cTitle" will give you the red, large, bold fixed font, centered
    word "Title". As you can see the font change requests accumulate and the
    order is important, i.e., "@f@b@i" gives you a fixed bold italic font
    while "@b@i@f" gives you a (plain) fixed font.
    Depending on the font size and style lines may have different heights.
    In some cases the character '@' might need to be placed at the beginning
    of the lines without introducing the special meaning mentioned above. In
    this case you can use "@@" or change the special character to something
    other than '@' using flbrowser.fl_set_browser_specialkey() function.
    """
    pass



#############################################################
# forms.h (button.h)
# All Buttons, regular button, light button and round button
#############################################################

# values for enumeration 'FL_BUTTON_TYPE'
FL_BUTTON_TYPE = cty.c_int      # enum
FL_NORMAL_BUTTON = 0
FL_PUSH_BUTTON = 1
FL_RADIO_BUTTON = 2
FL_HIDDEN_BUTTON = 3
FL_TOUCH_BUTTON = 4
FL_INOUT_BUTTON = 5
FL_RETURN_BUTTON = 6
FL_HIDDEN_RET_BUTTON = 7
FL_MENU_BUTTON = 8
FL_TOGGLE_BUTTON = FL_PUSH_BUTTON

# my add, list of possible values --LK
BUTTONTYPE_list = [FL_NORMAL_BUTTON, FL_PUSH_BUTTON, FL_RADIO_BUTTON, \
                FL_HIDDEN_BUTTON, FL_TOUCH_BUTTON, FL_INOUT_BUTTON, \
                FL_RETURN_BUTTON, FL_HIDDEN_RET_BUTTON, FL_MENU_BUTTON, \
                FL_TOGGLE_BUTTON]


class FL_BUTTON_SPEC(cty.Structure):
    """FL_BUTTON_SPEC class. It is used for all button or button-like
    flobjects.

    Attributes
    ----------
        pixmap : long_pos
            pixmap resource id, for bitmap/pixmap button only
        mask : long_pos
            mask resource id, for bitmap/pixmap button only
        bits_w : int_pos
            for bitmap/pixmap button only *todo*
        bits_h : int_pos
            for bitmap/pixmap button only *todo*
        val : int
            state of button, whether if it is pushed or not
        mousebut : int
            mouse button that caused the push
        timdel : int
            time since last touch (only TOUCH buttons)
        event : int
            what event triggers redraw
        is_pushed : int
            set while drawn as pushed down
        react_to : int array of 5 elements
            mouse buttons button reacts to
        cspecl : long
            reserved for non-generic flobject class specific data
        cspecv : pointer to any type
            reserved for non-generic flobject class specific data
        filename : str
            name of pixmap/bitmap file to be used
        focus_pixmap : long_pos
            *todo*
        focus_mask : long_pos
            *todo*
        focus_filename : str
            name of pixmap/bitmap file to be used if focused
    """
    pass
FL_BUTTON_SPEC.__slots__ = ['pixmap', 'mask', 'bits_w', 'bits_h', 'val', \
        'mousebut', 'timdel', 'event', 'is_pushed', 'react_to', 'cspecl', \
        'cspecv', 'filename', 'focus_pixmap', 'focus_mask', 'focus_filename',]
FL_BUTTON_SPEC._fields_ = [
        ('pixmap', Pixmap),
        ('mask', Pixmap),
        ('bits_w', cty.c_uint),
        ('bits_h', cty.c_uint),
        ('val', cty.c_int),            # state of button, whether on/off
        ('mousebut', cty.c_int),       # mouse button that caused the push
        ('timdel', cty.c_int),         # time since last touch (TOUCH buttons)
        ('event', cty.c_int),          # what event triggers redraw
        ('is_pushed', cty.c_int),      # set while drawn as pushed down
        ('react_to', cty.c_int * 5),   # mouse buttons button reacts to
        ('cspecl', cty.c_long),        # reserved for class specific stuff
        ('cspecv', cty.c_void_p),      # misc. things
        ('filename', STRING),
        ('focus_pixmap', Pixmap),
        ('focus_mask', Pixmap),
        ('focus_filename', STRING), ]

FL_BUTTON_STRUCT = FL_BUTTON_SPEC


# normal button default
FL_BUTTON_BOXTYPE = FL_UP_BOX
FL_BUTTON_COL1 = FL_COL1
FL_BUTTON_COL2 = FL_COL1
FL_BUTTON_LCOL = FL_LCOL
FL_BUTTON_ALIGN = (FL_ALIGN_CENTER | FL_ALIGN_INSIDE)
FL_BUTTON_MCOL1 = FL_MCOL
FL_BUTTON_MCOL2 = FL_MCOL
FL_BUTTON_BW = FL_BOUND_WIDTH

# light button defaults
FL_LIGHTBUTTON_BOXTYPE = FL_UP_BOX
FL_LIGHTBUTTON_COL1 = FL_COL1
FL_LIGHTBUTTON_COL2 = FL_YELLOW
FL_LIGHTBUTTON_LCOL = FL_LCOL
FL_LIGHTBUTTON_ALIGN = (FL_ALIGN_CENTER | FL_ALIGN_INSIDE)
FL_LIGHTBUTTON_TOPCOL = FL_COL1
FL_LIGHTBUTTON_MCOL = FL_MCOL
FL_LIGHTBUTTON_MINSIZE = 12

# round button defaults
FL_ROUNDBUTTON_BOXTYPE = FL_NO_BOX
FL_ROUNDBUTTON_COL1 = FL_MCOL
FL_ROUNDBUTTON_COL2 = FL_YELLOW
FL_ROUNDBUTTON_LCOL = FL_LCOL
FL_ROUNDBUTTON_ALIGN = FL_ALIGN_CENTER
FL_ROUNDBUTTON_TOPCOL = FL_COL1
FL_ROUNDBUTTON_MCOL = FL_MCOL

# round3d button defaults
FL_ROUND3DBUTTON_BOXTYPE = FL_NO_BOX
FL_ROUND3DBUTTON_COL1 = FL_COL1
FL_ROUND3DBUTTON_COL2 = FL_BLACK
FL_ROUND3DBUTTON_LCOL = FL_LCOL
FL_ROUND3DBUTTON_ALIGN = FL_ALIGN_CENTER
FL_ROUND3DBUTTON_TOPCOL = FL_COL1
FL_ROUND3DBUTTON_MCOL = FL_MCOL

# check button defaults
FL_CHECKBUTTON_BOXTYPE = FL_NO_BOX
FL_CHECKBUTTON_COL1 = FL_COL1
FL_CHECKBUTTON_COL2 = FL_YELLOW
FL_CHECKBUTTON_LCOL = FL_LCOL
FL_CHECKBUTTON_ALIGN = FL_ALIGN_CENTER

FL_CHECKBUTTON_TOPCOL = FL_COL1
FL_CHECKBUTTON_MCOL = FL_MCOL

# bitmap button defaults
FL_BITMAPBUTTON_BOXTYPE = FL_UP_BOX
FL_BITMAPBUTTON_COL1 = FL_COL1         # bitmap background
FL_BITMAPBUTTON_COL2 = FL_BLUE         # "focus" color
FL_BITMAPBUTTON_LCOL = FL_LCOL         # bitmap foreground
FL_BITMAPBUTTON_ALIGN = FL_ALIGN_BOTTOM

# bitmap button defaults
FL_PIXMAPBUTTON_BOXTYPE = FL_UP_BOX
FL_PIXMAPBUTTON_COL1 = FL_BUTTON_COL1
FL_PIXMAPBUTTON_COL2 = FL_BUTTON_COL2
FL_PIXMAPBUTTON_LCOL = FL_BUTTON_LCOL
FL_PIXMAPBUTTON_MCOL1 = FL_BUTTON_MCOL1
FL_PIXMAPBUTTON_MCOL2 = FL_BUTTON_MCOL2
FL_PIXMAPBUTTON_ALIGN = FL_ALIGN_BOTTOM


FL_DrawButton = cty.CFUNCTYPE(None, cty.POINTER(FL_OBJECT))
FL_CleanupButton = cty.CFUNCTYPE(None, cty.POINTER(FL_BUTTON_SPEC))

FL_DRAWBUTTON = FL_DrawButton
FL_CLEANUPBUTTON = FL_CleanupButton



#######################
# forms.h (canvas.h)
# Header for FL_CANVAS
#######################

# values for enumeration 'FL_CANVAS_TYPE'
FL_CANVAS_TYPE = cty.c_int      # enum
FL_NORMAL_CANVAS = 0
FL_SCROLLED_CANVAS = 1

# list of possible values - my add --LK
CANVASTYPE_list = [FL_NORMAL_CANVAS, FL_SCROLLED_CANVAS]


# Default
FL_CANVAS_BOXTYPE = FL_DOWN_BOX     # really the decoration frame
FL_CANVAS_ALIGN = FL_ALIGN_TOP


# /usr/include/X11/Xlib.h 317
class XSetWindowAttributes(cty.Structure):
    """XSetWindowAttributes class. Data structure for setting window
    attributes.

    Attributes
    ----------
        background_pixmap : long_pos
            background or None or ParentRelative
        background_pixel : long_pos
            background pixel
        border_pixmap : long_pos
            background or None or ParentRelative
        border_pixel : long_pos
            border pixel value
        bit_gravity : int
            one of bit gravity values
        win_gravity : int
            one of the window gravity values
        backing_store : int
            NotUseful, WhenMapped, Always
        backing_planes : long_pos
            planes to be preseved if possible
        backing_pixel : long_pos
            value to use in restoring planes
        save_under : int
            (bool) should bits under be saved? (popups)
        event_mask : long
            set of events that should be saved
        do_not_propagate_mask : long
            set of events that should not propagate
        override_redirect : int
            boolean value for override-redirect
        colormap : long_pos
            color map to be associated with window
        cursor : long_pos
            cursor to be displayed (or None)
    """
    pass
XSetWindowAttributes.__slots__ = ['background_pixmap', 'background_pixel', \
        'border_pixmap', 'border_pixel', 'bit_gravity', 'win_gravity', \
        'backing_store', 'backing_planes', 'backing_pixel', 'save_under', \
        'event_mask', 'do_not_propagate_mask', 'override_redirect', \
        'colormap', 'cursor',]
XSetWindowAttributes._fields_ = [
        ('background_pixmap', Pixmap),
        ('background_pixel', cty.c_ulong),
        ('border_pixmap', Pixmap),
        ('border_pixel', cty.c_ulong),
        ('bit_gravity', cty.c_int),
        ('win_gravity', cty.c_int),
        ('backing_store', cty.c_int),
        ('backing_planes', cty.c_ulong),
        ('backing_pixel', cty.c_ulong),
        ('save_under', cty.c_int),
        ('event_mask', cty.c_long),
        ('do_not_propagate_mask', cty.c_long),
        ('override_redirect', cty.c_int),
        ('colormap', Colormap),
        ('cursor', Cursor), ]


FL_HANDLE_CANVAS = cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_OBJECT),
        Window, cty.c_int, cty.c_int, cty.POINTER(XEvent), cty.c_void_p)


FL_MODIFY_CANVAS_PROP = cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_OBJECT))


#############################
# forms.h (chart.h)
# Chart flobject class
#############################

# values for enumeration 'FL_CHART_TYPE'
FL_CHART_TYPE = cty.c_int       # enum
FL_BAR_CHART = 0
FL_HORBAR_CHART = 1
FL_LINE_CHART = 2
FL_FILL_CHART = 3
FL_SPIKE_CHART = 4
FL_PIE_CHART = 5
FL_SPECIALPIE_CHART = 6
# FL_FILLED_CHART placeholder (backwards)

# list of possible values - my add --LK
CHARTTYPE_list = [FL_BAR_CHART, FL_HORBAR_CHART, FL_LINE_CHART, \
                  FL_FILL_CHART, FL_SPIKE_CHART, FL_PIE_CHART, \
                  FL_SPECIALPIE_CHART]


# Defaults
FL_CHART_BOXTYPE = FL_BORDER_BOX
FL_CHART_COL1 = FL_COL1
FL_CHART_LCOL = FL_LCOL
FL_CHART_ALIGN = FL_ALIGN_BOTTOM

# Others
FL_CHART_MAX = 2048


#################################
# forms.h (clock.h)
#################################

# values for unnamed enumeration
FL_ANALOG_CLOCK = 0
FL_DIGITAL_CLOCK = 1

# my add, list of possible values --LK
CLOCKTYPE_list = [FL_ANALOG_CLOCK, FL_DIGITAL_CLOCK]


FL_CLOCK_BOXTYPE = FL_UP_BOX
FL_CLOCK_COL1 = FL_INACTIVE_COL
FL_CLOCK_COL2 = FL_BOTTOM_BCOL
FL_CLOCK_LCOL = FL_BLACK
FL_CLOCK_ALIGN = FL_ALIGN_BOTTOM

FL_CLOCK_TOPCOL = FL_COL1



##########################
# forms.h (counter_var.h)
##########################

# values for enumeration 'FL_COUNTER_TYPE'
FL_COUNTER_TYPE = cty.c_int     # enum
FL_NORMAL_COUNTER = 0
FL_SIMPLE_COUNTER = 1

# list of possible values - my add --LK
COUNTERTYPE_list = [FL_NORMAL_COUNTER, FL_SIMPLE_COUNTER]


# Defaults
FL_COUNTER_BOXTYPE = FL_UP_BOX
FL_COUNTER_COL1 = FL_COL1
FL_COUNTER_COL2 = FL_BLUE           # counter label
FL_COUNTER_LCOL = FL_LCOL           # counter reporting
FL_COUNTER_ALIGN = FL_ALIGN_BOTTOM

# Others
FL_COUNTER_BW = FL_BOUND_WIDTH - 1


FL_VAL_FILTER = cty.CFUNCTYPE(STRING, cty.POINTER(FL_OBJECT),
                              cty.c_double, cty.c_int)


#############################
# forms.h (cursor.h)
# Cursor defs and prototypes
#############################

# *** start - from /usr/include/X11/cursorfont.h ***
XC_num_glyphs = 154             # in linux 255
XC_X_cursor = 0
XC_arrow = 2
XC_based_arrow_down = 4
XC_based_arrow_up = 6
XC_boat = 8
XC_bogosity = 10
XC_bottom_left_corner = 12
XC_bottom_right_corner = 14
XC_bottom_side = 16
XC_bottom_tee = 18
XC_box_spiral = 20
XC_center_ptr = 22
XC_circle = 24
XC_clock = 26
XC_coffee_mug = 28
XC_cross = 30
XC_cross_reverse = 32
XC_crosshair = 34
XC_diamond_cross = 36
XC_dot = 38
XC_dotbox = 40
XC_double_arrow = 42
XC_draft_large = 44
XC_draft_small = 46
XC_draped_box = 48
XC_fleur = 52
XC_gobbler = 54
XC_gumby = 56
XC_hand1 = 58
XC_hand2 = 60
XC_heart = 62
XC_icon = 64
XC_iron_cross = 66
XC_left_ptr = 68
XC_left_side = 70
XC_left_tee = 72
XC_leftbutton = 74
XC_ll_angle = 76
XC_lr_angle = 78
XC_man = 80
XC_middlebutton = 82
XC_mouse = 84
XC_pencil = 86
XC_pirate = 88
XC_plus = 90
XC_question_arrow = 92
XC_right_ptr = 94
XC_right_side = 96
XC_right_tee = 98
XC_rightbutton = 100
XC_rtl_logo = 102
XC_sailboat = 104
XC_sb_down_arrow = 106
XC_sb_h_double_arrow = 108
XC_sb_left_arrow = 110
XC_sb_right_arrow = 112
XC_sb_up_arrow = 114
XC_sb_v_double_arrow = 116
XC_shuttle = 118
XC_sizing = 120
XC_spider = 122
XC_spraycan = 124
XC_star = 126
XC_target = 128
XC_tcross = 130
XC_top_left_arrow = 132
XC_top_left_corner = 134
XC_top_right_corner = 136
XC_top_side = 138
XC_top_tee = 140
XC_trek = 142
XC_ul_angle = 144
XC_umbrella = 146
XC_ur_angle = 148
XC_watch = 150
XC_xterm = 152
# *** end - from /usr/include/X11/cursorfont.h ***

# my add  --LK
XCursors_list = [XC_arrow, XC_based_arrow_down, XC_based_arrow_up, \
        XC_boat, XC_bogosity, XC_bottom_left_corner, XC_bottom_right_corner, \
        XC_bottom_side, XC_bottom_tee, XC_box_spiral, XC_center_ptr, \
        XC_circle, XC_clock, XC_coffee_mug, XC_cross, XC_cross_reverse, \
        XC_crosshair, XC_diamond_cross, XC_dot, XC_dotbox, XC_double_arrow, \
        XC_draft_large, XC_draft_small, XC_draped_box, XC_fleur, \
        XC_gobbler, XC_gumby, XC_hand1, XC_hand2, XC_heart, XC_icon, \
        XC_iron_cross, XC_left_ptr, XC_left_side, XC_left_tee, \
        XC_leftbutton, XC_ll_angle, XC_lr_angle, XC_man, XC_middlebutton, \
        XC_mouse, XC_pencil, XC_pirate, XC_plus, XC_question_arrow, \
        XC_right_ptr, XC_right_side, XC_right_tee, XC_rightbutton, \
        XC_rtl_logo, XC_sailboat, XC_sb_down_arrow, XC_sb_h_double_arrow, \
        XC_sb_left_arrow, XC_sb_right_arrow, XC_sb_up_arrow, \
        XC_sb_v_double_arrow, XC_shuttle, XC_sizing, XC_spider, XC_spraycan, \
        XC_star, XC_target, XC_tcross, XC_top_left_arrow, \
        XC_top_left_corner, XC_top_right_corner, XC_top_side, XC_top_tee, \
        XC_trek, XC_ul_angle, XC_umbrella, XC_ur_angle, XC_watch, XC_xterm]


# values for unnamed enumeration
FL_INVISIBLE_CURSOR = -2
FL_DEFAULT_CURSOR = -1
FL_BUSY_CURSOR = XC_watch               # 150
FL_CROSSHAIR_CURSOR = XC_tcross         # 130
FL_KILL_CURSOR = XC_pirate              # 88
FL_NWARROW_CURSOR = XC_top_left_arrow   # 132
FL_NEARROW_CURSOR = XC_arrow            # 2

XC_invisible = FL_INVISIBLE_CURSOR

class admitted_values_for_CURSORS(object):
    """Type of cursor

    Admitted values
    ---------------
        FL_INVISIBLE_CURSOR
            cursor not visible
        FL_DEFAULT_CURSOR
            default cursor
        FL_BUSY_CURSOR
            watch cursor (when system is busy)
        FL_CROSSHAIR_CURSOR
            *todo*
        FL_KILL_CURSOR
            *todo*
        FL_NWARROW_CURSOR
            top left arrow cursor
        FL_NEARROW_CURSOR
            top right arrow cursor
    """
    pass

# my add, list of possible values --LK
CURSORS_list = [FL_INVISIBLE_CURSOR, FL_DEFAULT_CURSOR, FL_BUSY_CURSOR,
        FL_CROSSHAIR_CURSOR, FL_KILL_CURSOR, FL_NWARROW_CURSOR,
        FL_NEARROW_CURSOR]


###################
# forms.h (dial.h)
###################

# values for enumeration 'FL_DIAL_TYPE'
FL_DIAL_TYPE = cty.c_int        # enum
FL_NORMAL_DIAL = 0
FL_LINE_DIAL = 1
FL_FILL_DIAL = 2

# list of possible values - my add --LK
DIALTYPE_list = [FL_NORMAL_DIAL, FL_LINE_DIAL, FL_FILL_DIAL]


# values for unnamed enumeration
FL_DIAL_CW = 0
FL_DIAL_CCW = 1

# list of possible values - my add --LK
DIALROTN_list = [FL_DIAL_CW, FL_DIAL_CCW]


# Defaults
FL_DIAL_BOXTYPE = FL_FLAT_BOX
FL_DIAL_COL1 = FL_COL1
FL_DIAL_COL2 = FL_RIGHT_BCOL
FL_DIAL_LCOL = FL_LCOL
FL_DIAL_ALIGN = FL_ALIGN_BOTTOM

# Others
FL_DIAL_TOPCOL = FL_COL1


############################################
# forms.h (filesys.h)
# Convenience functions to read a directory
############################################

# File types
# values for unnamed enumeration
FT_FILE = 0
FT_DIR = 1
FT_LINK = 2
FT_SOCK = 3
FT_FIFO = 4
FT_BLK = 5
FT_CHR = 6
FT_OTHER = 7

class admitted_values_for_FILETYPE(object):
    """Types of file

    Admitted values
    ---------------
        FT_FILE
            a regular file type
        FT_DIR
            a directory file type
        FT_LINK
            a symbolic link file type
        FT_SOCK
            a socket file type
        FT_FIFO
            a pipe or FIFO file type
        FT_BLK = 5
            a block device file type
        FT_CHR
            a character device file type
        FT_OTHER
            other(?) file type
    """
    pass


class FL_Dirlist(cty.Structure):
    """FL_DirList class

    Attributes
    ----------
        name : str
            entry name
        type : int
            file type
        dl_mtime : long
            file modification time
        dl_size : long_pos
            file size in bytes
    """
    pass
FL_Dirlist.__slots__ = ['name', 'type', 'dl_mtime', 'dl_size',]
FL_Dirlist._fields_ = [
        ('name', STRING),                # entry name
        ('type', cty.c_int),             # FILE_TYPE
        ('dl_mtime', cty.c_long),        # file modification time
        ('dl_size', cty.c_ulong), ]      # file size in bytes


# values for unnamed enumeration
#FL_NONE                    # Do not sort the entries (defined elsewhere)
FL_ALPHASORT = 1            # sort in alphabetic order
FL_RALPHASORT = 2           # sort in reverse alphabetic order
FL_MTIMESORT = 3            # sort according to modification time
FL_RMTIMESORT = 4           # sort in reverse modification time
FL_SIZESORT = 5             # sort in increasing size order
FL_RSIZESORT = 6            # sort in decreasing size order
FL_CASEALPHASORT = 7        # sort case insensitive
FL_RCASEALPHASORT = 8       # sort case insensitive


FL_DIRLIST_FILTER = cty.CFUNCTYPE(cty.c_int, STRING, cty.c_int)


#########################
# forms. (formbrowser.h)
#########################

# values for unnamed enumeration
FL_NORMAL_FORMBROWSER = 0

# my add, list of possible values --LK
FORMBRWSTYPE_list = [FL_NORMAL_FORMBROWSER, ]


# values for unnamed enumeration
FL_SMOOTH_SCROLL = 0
FL_JUMP_SCROLL = 1

# list of possible values - my add --LK
FORMBRWSSCROLL_list = [FL_SMOOTH_SCROLL, FL_JUMP_SCROLL]

# defaults?
FL_FORMBROWSER_BOXTYPE = FL_DOWN_BOX
FL_FORMBROWSER_COL1 = FL_COL1
FL_FORMBROWSER_ALIGN = FL_ALIGN_TOP


#############
# glcanvas.h
#############

# my add --LK
# *** start - from /usr/include/GL/*.h
GLboolean = cty.c_ubyte
GLXDrawable = XID

class __GLXcontextRec(cty.Structure):
    """GLXContext class.

    Attributes
    ----------
        currentDpy : pointer to Display
            *todo*
        isDirect : ubyte?
            todo*
        currentDrawable : long_pos
            *todo*
        currentReadable : long_pos
            *todo*
        xid : long_pos
            *todo*
    """
    pass
__GLXcontextRec.__slot__ = ['currentDpy', 'isDirect', 'currentDrawable',
        'currentReadable', 'xid']
__GLXcontextRec._fields_ = [
        ('currentDpy', cty.POINTER(Display)),
        ('isDirect', GLboolean),
        ('currentDrawable', GLXDrawable),
        ('currentReadable', GLXDrawable),
        ('xid', XID),]
__GLXcontext = __GLXcontextRec
GLXContext = cty.POINTER(__GLXcontext)
# *** end - from /usr/include/GL/*.h


# values for GL configuration attributes - my add --LK
# *** start - from /usr/include/GL/glx.h:70
GLX_USE_GL = 1
GLX_BUFFER_SIZE = 2
GLX_LEVEL = 3
GLX_RGBA = 4
GLX_DOUBLEBUFFER = 5
GLX_STEREO = 6
GLX_AUX_BUFFERS = 7
GLX_RED_SIZE = 8
GLX_GREEN_SIZE = 9
GLX_BLUE_SIZE = 10
GLX_ALPHA_SIZE = 11
GLX_DEPTH_SIZE = 12
GLX_STENCIL_SIZE = 13
GLX_ACCUM_RED_SIZE = 14
GLX_ACCUM_GREEN_SIZE = 15
GLX_ACCUM_BLUE_SIZE = 16
GLX_ACCUM_ALPHA_SIZE = 17
# *** end - from /usr/include/GL/glx.h

class admitted_values_for_GLCONFIGATTR(object):
    """GL configuration attributes

    Admitted values
    ---------------
        GLX_USE_GL
            Ignored. Only visuals that can be rendered with GLX are
            considered.
        GLX_BUFFER_SIZE, int_pos
            Must be followed by a non-negative integer that indicates the
            desired color index buffer size. The smallest index buffer of at
            least the specified size is preferred. Ignored if GLX_RGBA is
            asserted.
        GLX_LEVEL, int
            Must be followed by an integer buffer-level specification. This
            specification is honored exactly. Buffer level zero corresponds
            to the main frame buffer of the display. Buffer level one is the
            first overlay frame buffer, level two the second overlay frame
            buffer, and so on. Negative buffer levels correspond to underlay
            frame buffers.
        GLX_RGBA
            If present, only TrueColor and DirectColor visuals are considered.
            Otherwise, only PseudoColor and StaticColor visuals are considered.
        GLX_DOUBLEBUFFER
            If present, only double-buffered visuals are considered.
            Otherwise, only single-buffered visuals are considered.
        GLX_STEREO
            If present, only stereo visuals are considered. Otherwise, only
            monoscopic visuals are considered.
        GLX_AUX_BUFFERS, int_pos
            Must be followed by a non-negative integer that indicates the
            desired number of auxiliary buffers. Visuals with the smallest
            number of auxiliary buffers that meets or exceeds the specified
            number are preferred.
        GLX_RED_SIZE, int_pos
            Must be followed by a non-negative minimum size specification. If
            this value is zero, the smallest available red buffer is preferred.
            Otherwise, the largest available red buffer of at least the
            minimum size is preferred.
        GLX_GREEN_SIZE, int_pos
            Must be followed by a non-negative minimum size specification. If
            this value is zero, the smallest available green buffer is
            preferred. Otherwise, the largest available green buffer of at
            least the minimum size is preferred.
        GLX_BLUE_SIZE, int_pos
            Must be followed by a nonnegative minimum size specification. If
            this value is zero, the smallest available blue buffer is
            preferred. Otherwise, the largest available blue buffer of at
            least the minimum size is preferred.
        GLX_ALPHA_SIZE, int_pos
            Must be followed by a nonnegative minimum size specification. If
            this value is zero, the smallest available alpha buffer is
            preferred. Otherwise, the largest available alpha buffer of at
            least the minimum size is preferred.
        GLX_DEPTH_SIZE, int_pos
            Must be followed by a nonnegative minimum size specification.
            If this value is zero, visuals with no depth buffer are
            preferred. Otherwise, the largest available depth buffer of at
            least the minimum size is preferred.
        GLX_STENCIL_SIZE, int_pos
            Must be followed by a nonnegative integer that indicates the
            desired number of stencil bitplanes. The smallest stencil buffer
            of at least the specified size is preferred. If the desired
            value is zero, visuals with no stencil buffer are preferred.
        GLX_ACCUM_RED_SIZE, int_pos
            Must be followed by a nonnegative minimum size specification. If
            this value is zero, visuals with no red accumulation buffer
            are preferred. Otherwise, the largest possible red accumulation
            buffer of at least the minimum size is preferred.
        GLX_ACCUM_GREEN_SIZE, int_pos
            Must be followed by a non-negative minimum size specification. If
            this value is zero, visuals with no green accumulation buffer
            are preferred. Otherwise, the largest possible green accumulation
            buffer of at least the minimum size is preferred.
        GLX_ACCUM_BLUE_SIZE, int_pos
            Must be followed by a non-negative minimum size specification. If
            this value is zero, visuals with no blue accumulation buffer are
            preferred. Otherwise, the largest possible blue accumulation
            buffer of at least the minimum size is preferred.
        GLX_ACCUM_ALPHA_SIZE, int_pos
            Must be followed by a non-negative minimum size specification. If
            this value is zero, visuals with no alpha accumulation buffer are
            preferred. Otherwise, the largest possible alpha accumulation
            buffer of at least the minimum size is preferred.
    """
    pass


######################
# forms.h (goodies.h)
######################

# Resources and misc. goodie routines
FLAlertDismissLabel = "flAlert.dismiss.label"
FLAlertTitle = "flAlert.title"

FLQuestionYesLabel = "flQuestion.yes.label"
FLQuestionNoLabel = "flQuestion.no.label"
FLQuestionTitle = "flQuestion.title"

FLOKLabel = "flInput.ok.label"
FLInputClearLabel = "flInput.clear.label"
FLInputCancelLabel = "flInput.cancel.label"
FLInputTitle = "flInput.title"

FLChoiceTitle = "flChoice.title"

class admitted_values_for_GoodiesLabel(object):
    """Label for goodies

    Admitted values
    ---------------
        FLAlertDismissLabel
            label for dismiss in an alert goodie
        FLAlertTitle
            title in an alert goodie
        FLQuestionYesLabel
            label for yes in a question goodie
        FLQuestionNoLabel
            label for no in a question goodie
        FLQuestionTitle = "flQuestion.title"
            title in a question goodie
        FLOKLabel = "flInput.ok.label"
            label for ok in an input goodie
        FLInputClearLabel = "flInput.clear.label"
            label for clear in an input goodie
        FLInputCancelLabel = "flInput.cancel.label"
            label for cancel in an input goodie
        FLInputTitle = "flInput.title"
            title in an input goodie
        FLChoiceTitle = "flChoice.title"
            title in a choice goodie
    """
    pass

# command log

class FD_CMDLOG(cty.Structure):
    """FD_CMDLOG class

    Attributes
    ----------
        form : pointer to FL_FORM
            the form
        vdata : pointer to void
            unused
        cdata : str
            unused
        ldata : long
            unused
        browser : pointer to FL_OBJECT
            the browser flobject
        close_browser : pointer to FL_OBJECT
            the close button
        clear_browser : pointer to FL_OBJECT
            the clear button
    """
    pass
FD_CMDLOG.__slots__ = ['form', 'vdata', 'cdata', 'ldata', 'browser', \
        'close_browser', 'clear_browser',]
FD_CMDLOG._fields_ = [
        ('form', cty.POINTER(FL_FORM)),
        ('vdata', cty.c_void_p),
        ('cdata', STRING),
        ('ldata', cty.c_long),
        ('browser', cty.POINTER(FL_OBJECT)),
        ('close_browser', cty.POINTER(FL_OBJECT)),
        ('clear_browser', cty.POINTER(FL_OBJECT)), ]

# file selector

FL_MAX_FSELECTOR = 6

class FD_FSELECTOR(cty.Structure):
    """FD_FSELECTOR class

    Attribute
    ---------
        fselect : pointer to FL_FORM
            file selector's form
        vdata : pointer to void
            *todo*
        cdata : pointer to void
            *todo*
        ldata : long
            *todo*
        browser : pointer to FL_OBJECT
            browser flobject in file selector
        input : pointer to FL_OBJECT
            input flobject in file selector
        prompt : pointer to FL_OBJECT
            *todo*
        resbutt : pointer to FL_OBJECT
            rescan button flobject in file selector
        patbutt : pointer to FL_OBJECT
            pattern button flobject in file selector
        dirbutt : pointer to FL_OBJECT
            directory button flobject in file selector
        cancel : pointer to FL_OBJECT
            cancel button flobject in file selector
        ready : pointer to FL_OBJECT
            ready button flobject in file selector
        dirlabel : pointer to FL_OBJECT
            label for directory in file selector
        patlabel : pointer to FL_OBJECT
            label for pattern in file selector
        appbutt : pointer to an array of 3 FL_OBJECT
            *todo*
    """
    pass
FD_FSELECTOR.__slots__ = ['fselect', 'vdata', 'cdata', 'ldata', \
        'browser', 'input', 'prompt', 'resbutt', 'patbutt', 'dirbutt', \
        'cancel', 'ready', 'dirlabel', 'patlabel', 'appbutt',]
FD_FSELECTOR._fields_ = [
        ('fselect', cty.POINTER(FL_FORM)),
        ('vdata', cty.c_void_p),
        ('cdata', cty.c_void_p),
        ('ldata', cty.c_long),
        ('browser', cty.POINTER(FL_OBJECT)),
        ('input', cty.POINTER(FL_OBJECT)),
        ('prompt', cty.POINTER(FL_OBJECT)),
        ('resbutt', cty.POINTER(FL_OBJECT)),
        ('patbutt', cty.POINTER(FL_OBJECT)),
        ('dirbutt', cty.POINTER(FL_OBJECT)),
        ('cancel', cty.POINTER(FL_OBJECT)),
        ('ready', cty.POINTER(FL_OBJECT)),
        ('dirlabel', cty.POINTER(FL_OBJECT)),
        ('patlabel', cty.POINTER(FL_OBJECT)),
        ('appbutt', cty.POINTER(FL_OBJECT) * 3), ]


FL_FSCB = cty.CFUNCTYPE(cty.c_int, STRING, cty.c_void_p)



####################
# forms.h (input.h)
####################

# Types
# values for enumeration 'FL_INPUT_TYPE'
FL_INPUT_TYPE = cty.c_int # enum
FL_NORMAL_INPUT = 0
FL_FLOAT_INPUT = 1
FL_INT_INPUT = 2
FL_DATE_INPUT = 3
FL_MULTILINE_INPUT = 4
FL_HIDDEN_INPUT = 5
FL_SECRET_INPUT = 6

# my add - list of possible values --LK
INPUTTYPE_list = [FL_NORMAL_INPUT, FL_FLOAT_INPUT, FL_INT_INPUT,
                  FL_DATE_INPUT, FL_MULTILINE_INPUT, FL_HIDDEN_INPUT,
                  FL_SECRET_INPUT]


# for date input
# values for unnamed enumeration
FL_INPUT_MMDD = 0
FL_INPUT_DDMM = 1

# my add - list of possible values --LK
DATEFMT_list = [FL_INPUT_MMDD, FL_INPUT_DDMM]


# Defaults
FL_INPUT_BOXTYPE = FL_DOWN_BOX
FL_INPUT_COL1 = FL_COL1
FL_INPUT_COL2 = FL_MCOL
FL_INPUT_LCOL = FL_LCOL
FL_INPUT_ALIGN = FL_ALIGN_LEFT

# Others
FL_INPUT_TCOL = FL_LCOL
FL_INPUT_CCOL = FL_BLUE

FL_RINGBELL = (1 << 4)


# edit keys

class FL_EditKeymap(cty.Structure):
    """FL_EditKeymap class

    Attributes
    ----------
        del_prev_char : long
            delete previous char
        del_next_char : long
            delete next char
        del_prev_word : long
            delete previous word
        del_next_word : long
            delete next word
        moveto_prev_line : long
            one line up
        moveto_next_line : long
            one line down
        moveto_prev_char : long
            one char left
        moveto_next_char : long
            one char right
        moveto_prev_word : long
            one word left
        moveto_next_word : long
            one word right
        moveto_prev_page : long
            one page up
        moveto_next_page : long
            one page down
        moveto_bol : long
            move to begining of line
        moveto_eol : long
            move to end of line
        moveto_bof : long
            move to begin of file
        moveto_eof : long
            move to end of file
        transpose : long
            switch two char positions
        paste : long
            paste the edit buffer
        backspace : long
            another del_prev_char
        del_to_bol : long
            cut to begining of line
        del_to_eol : long
            cut to end of line
        clear_field : long
            delete everything
        del_to_eos : long
            not implemented
    """
    pass
FL_EditKeymap.__slots__ = ['del_prev_char', 'del_next_char', \
        'del_prev_word', 'del_next_word', 'moveto_prev_line', \
        'moveto_next_line', 'moveto_prev_char', 'moveto_next_char', \
        'moveto_prev_word', 'moveto_next_word', 'moveto_prev_page', \
        'moveto_next_page', 'moveto_bol', 'moveto_eol', 'moveto_bof', \
        'moveto_eof', 'transpose', 'paste', 'backspace', 'del_to_bol', \
        'del_to_eol', 'clear_field', 'del_to_eos',]
FL_EditKeymap._fields_ = [
        ('del_prev_char', cty.c_long),        # delete previous char
        ('del_next_char', cty.c_long),        # delete next char
        ('del_prev_word', cty.c_long),        # delete previous word
        ('del_next_word', cty.c_long),        # delete next word
        # movement
        ('moveto_prev_line', cty.c_long),     # one line up
        ('moveto_next_line', cty.c_long),     # one line down
        ('moveto_prev_char', cty.c_long),     # one char left
        ('moveto_next_char', cty.c_long),     # one char right
        ('moveto_prev_word', cty.c_long),     # one word left
        ('moveto_next_word', cty.c_long),     # one word right
        ('moveto_prev_page', cty.c_long),     # one page up
        ('moveto_next_page', cty.c_long),     # one page down
        ('moveto_bol', cty.c_long),           # move to begining of line
        ('moveto_eol', cty.c_long),           # move to end of line
        ('moveto_bof', cty.c_long),           # move to begin of file
        ('moveto_eof', cty.c_long),           # move to end of file
        # misc. stuff
        ('transpose', cty.c_long),            # switch two char positions
        ('paste', cty.c_long),                # paste the edit buffer
        ('backspace', cty.c_long),            # another  del_prev_char
        ('del_to_bol', cty.c_long),           # cut to begining of line
        ('del_to_eol', cty.c_long),           # cut to end of line
        ('clear_field', cty.c_long),          # delete everything
        ('del_to_eos', cty.c_long), ]         # not implemented


FL_INPUTVALIDATOR = cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_OBJECT),
                                  STRING, STRING, cty.c_int)


#####################
# forms.h (nmenu.h)
#####################

# Nmenu flobject types
# values for unnamed enumeration
FL_NORMAL_NMENU = 0
FL_NORMAL_TOUCH_NMENU = 1
FL_BUTTON_NMENU = 2
FL_BUTTON_TOUCH_NMENU = 3

# list of possible values - my add --LK
NMENUTYPE_list = [FL_NORMAL_NMENU, FL_NORMAL_TOUCH_NMENU, FL_BUTTON_NMENU, \
                  FL_BUTTON_TOUCH_NMENU]


# pointless as per library.py's get_xforms_version() --LK
# major, minor, fixlevel version
#FL_VERSION = 1 FL_REVISION = 0  FL_FIXLEVEL = "93pre10"
#FL_INCLUDE_VERSION = (FL_VERSION * 1000 + FL_REVISION)


FL_FALSE = 0
FL_TRUE = (not FL_FALSE)



#####################
# forms.h (choice.h)
#####################

# FL_CHOICE_TYPE placeholder (deprecated)
# FL_NORMAL_CHOICE placeholder (deprecated)
# FL_NORMAL_CHOICE2 placeholder (deprecated)
# FL_DROPLIST_CHOICE placeholder (deprecated)
# FL_BROWSER_CHOICE placeholder (deprecated)
# FL_SIMPLE_CHOICE placeholder (deprecated)
# list of possible values - my add --LK
# CHOICETYPE_list placeholder (deprecated)
# FL_CHOICE_BOXTYPE placeholder (deprecated)
# FL_CHOICE_COL1 placeholder (deprecated)
# FL_CHOICE_COL2 placeholder (deprecated)
# FL_CHOICE_LCOL placeholder (deprecated)
# FL_CHOICE_ALIGN placeholder (deprecated)
# FL_CHOICE_MCOL placeholder (deprecated)
# FL_CHOICE_MAXITEMS placeholder (deprecated)


#################################
# forms.h (clipbd.h)
# prototypes for clipboard stuff
#################################

FL_CPTYPE = Atom        # c_ulong


###################
# forms.h (flps.h)
###################

# postscript stuff
# values for unnamed enumeration
FLPS_AUTO = 0
FLPS_LANDSCAPE = 1
FLPS_PORTRAIT = 2
FLPS_BESTFIT = 3

class admitted_values_for_PS_ORIENTATION(object):
    """Postscript orientation

    Admitted values
    ---------------
        FLPS_AUTO
            Automatic orientation, switch to landscape if does
            not fit
        FLPS_LANDSCAPE
            Landscape  orientation always (horizontal)
        FLPS_PORTRAIT
            Portrait orientation always (vertical)
        FLPS_BESTFIT
            Best fit orientation with even margin
    """
    pass

# values for unnamed enumeration
FLPS_BW = -1
FLPS_GRAYSCALE = 0
FLPS_COLOR = 1

class admitted_values_for_PSCOLORS(object):
    """Colors for Postscript

    Admitted values
    ---------------
        FLPS_BW
            All drawings are black with white background
        FLPS_GRAYSCALE
            Grayscale color
        FLPS_COLOR
            Used full color
    """
    pass


class FLPS_CONTROL(cty.Structure):
    """FLPS_CONTROL class

    Attributes
    ----------
        ps_color : int
            The choices are full color (FLPS_COLOR), grayscale
            (FLPS_GRAYSCALE) and black&white (FLPS_BW). The
            default for xyplot is black and white. In this mode,
            all drawings are black, on a white background. If
            drawbox (see below) is true, the drawing color can be
            either white or black depending on the specified color.
        orientation : int
            Valid choices are FLPS_AUTO, FLPS_PORTRAIT and
            FLPS_LANDSCAPE. The default is FLPS_AUTO.
        auto_fit : int
            By default, this is true so the object always fits the
            printed page. Set it to false (0) to turn off auto-scaling.
        drawbox : int
            Set this to 1 if the box of the object is to be drawn.
        eps : int
            Set this to 1 if output in EPS format is required.
            *todo*
        xdpi : float
            Horizontal screen resolution. The default is to use the
            actual resolution of the display. Note by setting a dpi
            number smaller or larger than the actual resolution, the
            output object is in effect being enlarged or shrunken.
        ydpi : float
            Vertical screen resolution. The default is to use the
            actual resolution of the display. Note by setting a dpi
            number smaller or larger than the actual resolution, the
            output object is in effect being enlarged or shrunken.
        paper_w : float
            The paper width in inches. The default is 8.5 in.
        paper_h : float
            The paper height in inches. The default is 11 in.
        gamma : float
            *todo*
        tmpdir : str
            *todo*
        printer_dpi : int
            *todo*
        hm : float
            *todo*
        vm : float
            *todo*
        xscale : float
            *todo*
        yscale : float
            *todo*
        scale_text : int
            *todo*
        first_page_only : int
            *todo*
        clip : int
            *todo*
    """
    pass
FLPS_CONTROL.__slots__ = ['ps_color', 'orientation', 'auto_fit', \
        'drawbox', 'eps', 'xdpi', 'ydpi', 'paper_w', 'paper_h', \
        'gamma', 'tmpdir', 'printer_dpi', 'hm', 'vm', 'xscale', \
        'yscale', 'scale_text', 'first_page_only', 'clip',]
FLPS_CONTROL._fields_ = [
        ('ps_color', cty.c_int),
        ('orientation', cty.c_int),
        ('auto_fit', cty.c_int),
        ('drawbox', cty.c_int),
        ('eps', cty.c_int),
        ('xdpi', cty.c_float),
        ('ydpi', cty.c_float),
        ('paper_w', cty.c_float),
        ('paper_h', cty.c_float),
        ('gamma', cty.c_float),
        ('tmpdir', STRING),
        ('printer_dpi', cty.c_int),
        ('hm', cty.c_float),
        ('vm', cty.c_float),
        ('xscale', cty.c_float),
        ('yscale', cty.c_float),
        ('scale_text', cty.c_int),
        ('first_page_only', cty.c_int),
        ('clip', cty.c_int), ]


####################
# forms.h (frame.h)
####################

# types of frames
# values for unnamed enumeration
FL_NO_FRAME = 0
FL_UP_FRAME = 1
FL_DOWN_FRAME = 2
FL_BORDER_FRAME = 3
FL_SHADOW_FRAME = 4
FL_ENGRAVED_FRAME = 5
FL_ROUNDED_FRAME = 6
FL_EMBOSSED_FRAME = 7
FL_OVAL_FRAME = 8

# my add, list of possible values --LK
FRAMETYPE_list = [FL_NO_FRAME, FL_UP_FRAME, FL_DOWN_FRAME, FL_BORDER_FRAME,
        FL_SHADOW_FRAME, FL_ENGRAVED_FRAME, FL_ROUNDED_FRAME,
        FL_EMBOSSED_FRAME, FL_OVAL_FRAME]


# defaults?
FL_FRAME_COL1 = FL_BLACK        # border color
FL_FRAME_COL2 = FL_COL1         # label background
FL_FRAME_LCOL = FL_BLACK        # label color


#####################
# forms.h (free.h)
# Free flobject class
#####################

# values for enumeration 'FL_FREE_TYPE'
FL_FREE_TYPE = cty.c_int        # enum
FL_NORMAL_FREE = 0
FL_INACTIVE_FREE = 1
FL_INPUT_FREE = 2
FL_CONTINUOUS_FREE = 3
FL_ALL_FREE = 4

FL_SLEEPING_FREE = FL_INACTIVE_FREE

# list of possible values - my add --LK
FREETYPE_list = [FL_NORMAL_FREE, FL_INACTIVE_FREE, FL_INPUT_FREE,
                 FL_CONTINUOUS_FREE, FL_ALL_FREE, FL_SLEEPING_FREE]


#####################
# forms.h (menu.h)
#  Menu flobject class
#####################

# FL_MENU_TYPE placeholder (deprecated)
# FL_TOUCH_MENU placeholder (deprecated)
# FL_PUSH_MENU placeholder (deprecated)
# FL_PULLDOWN_MENU placeholder (deprecated)
# my add - list of possbile values --LK
# MENUTYPE_list placeholder (deprecated)
# FL_MENU_BOXTYPE placeholder (deprecated)
# FL_MENU_COL1 placeholder (deprecated)
# FL_MENU_COL2 placeholder (deprecated)
# FL_MENU_LCOL placeholder (deprecated)
# FL_MENU_ALIGN placeholder (deprecated)
# FL_MENU_MAXITEMS placeholder (deprecated)


###################
# forms.h (text.h)
###################

# values for unnamed enumeration
FL_NORMAL_TEXT = 0

# list of possible values - my add --LK
TEXTTYPE_list = [FL_NORMAL_TEXT, ]


FL_TEXT_BOXTYPE = FL_FLAT_BOX
FL_TEXT_COL1 = FL_COL1
FL_TEXT_COL2 = FL_MCOL
FL_TEXT_LCOL = FL_LCOL
FL_TEXT_ALIGN = FL_ALIGN_LEFT


###############################
# forms.h (xpopup.h)
# Prototypes for xpop-up menus
###############################

# FL_MAXPUPI placeholder (deprecated)
# FL_PUP_PADH placeholder (deprecated)


#################################
# forms.h (clipbd.h)
# prototypes for clipboard stuff
#################################

FL_LOSE_SELECTION_CB = cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_OBJECT),
                                     cty.c_long)
FL_LOSE_SELECTION_CALLBACK = FL_LOSE_SELECTION_CB


FL_SELECTION_CB = cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_OBJECT),
                                cty.c_long, cty.c_void_p, cty.c_long)
FL_SELECTION_CALLBACK = FL_SELECTION_CB


#############################
# forms.h (popup.h)
#############################


class FL_POPUP_(cty.Structure):
    """FL_POPUP class

    Attributes
    ----------
        next : pointer to FL_POPUP
            next in linked list
        prev : pointer to FL_POPUP
            previous in linked list
        parent : pointer to FL_POPUP
            for sub-popups, direct parent
        top_parent : pointer to FL_POPUP
            for sub-popups, top-most parent
        entries : pointer to FL_POPUP_ENTRY
            pointer to list of entries
        title : str
            popup title
        win : long_pos
            popup window
        parent_win : long_pos
            parent window of popup window
        cursor : long_pos
            cursor for the popup
        callback : function
            FL_POPUP_CB function type
        use_req_pos : int
            if set use req_x, req_y
        req_x : int
            *todo*
        req_y : int
            *todo*
        x : int
            horizontal position of popup window
        y : int
            vertical position of popup window
        w : int_pos
            width of popup window
        h : int_pos
            height of popup window
        min_width : int
            minimum width of popup
        title_box_x : int
            horizontal position of title box
        title_box_y : int
            vertical position of title box
        title_box_w : int_pos
            width of title box
        title_box_h : int_pos
            height of title box
        has_subs : int
            *todo*
        has_boxes : int
            *todo*
        counter : int
            *todo*
        title_font_style : int
            *todo*
        title_font_size : int
            *todo*
        entry_font_style : int
            *todo*
        entry_font_size : int
            *todo*
        event_mask : long_pos
            *todo*
        bw : int
            border width
        bg_color : long_pos
            background color of popup
        on_color : long_pos
            color of entry under mouse
        title_color : long_pos
            color of title text
        text_color : long_pos
            normal text color of entry
        text_on_color : long_pos
            text color when mouse on entry
        text_off_color : long_pos
            text color of disabled entry
        radio_color : long_pos
            color of radio buttons
        policy : int
            popup policy
        need_recalc : int
            do we need to recalc position?
        ret : FL_POPUP_RETURN instance
            structure passed to callbacks and returned on
            selection
    """
    pass

FL_POPUP = FL_POPUP_

class FL_POPUP_ENTRY_(cty.Structure):
    """FL_POPUP_ENTRY class

    Attributes
    ----------
        prev : pointer to FL_POPUP_ENTRY
            next in linked list
        next : pointer to FL_POPUP_ENTRY
            previous in linked list
        popup : pointer to FL_POPUP
            popup it belongs to
        is_act : int
            set while mouse is over it
        text : str
            complete text of entry
        label : str
            cleaned-up label text
        accel : str
            cleaned-up accelerator key text
        val : long
            value associated with entry
        user_data : pointer to any type
            pointer to user data
        type : int
            normal, toggle, radio, sub-popup
        state : int_pos
            disabled, hidden, checked
        group : int
            group (for radio entries only)
        sub : pointer to FL_POPUP
            sub-popup bound to entry
        shortcut : pointer to long
            keyboard shortcuts
        ulpos : int
            underline position in text
        callback : FL_POPUP_CB function type
            callback for selected entry
        enter_callback : FL_POPUP_CB function type
            callback for entering entry
        leave_callback : FL_POPUP_CB function type
            callback for leaving entry
        x : int
            horizontal position of entry text
        y : int
            vertical position of entry text
        w : int_pos
            width of entry text
        h : int_pos
            height of entry text
        box_x : int
            *todo*
        box_y : int
            *todo*
        box_w : int_pos
            *todo*
        box_h : int_pos
            *todo*
        sl_h : int_pos
            *todo*
        ul_x : int
            *todo*
        ul_y : int
            *todo*
        ul_w : int_pos
            *todo*
        ul_h : int_pos
            *todo*
    """
    pass

FL_POPUP_ENTRY = FL_POPUP_ENTRY_

class FL_POPUP_RETURN_(cty.Structure):
    """FL_POPUP_RETURN class

    Attributes
    ----------
        val : long
            value assigned to popup entry
        user_data : pointer to any type
            pointer to user data
        text : str
            text of the selected popup entry
        label : str
            left-flushed label part
        accel : str
            right-flushed label part
        entry : pointer to FL_POPUP_ENTRY
            pointer to selected popup entry
        popup : pointer to FL_POPUP
            popup or sub-popup it belongs to
    """
    pass
FL_POPUP_RETURN_.__slots__ = ['val', 'user_data', 'text', 'label', \
        'accel', 'entry', 'popup',]
FL_POPUP_RETURN_._fields_ = [
        ('val', cty.c_long),              # value assigned to popup entry
        ('user_data', cty.c_void_p),      # pointer to user data
        ('text', STRING),               # text of the selected popup entry
        ('label', STRING),              # left-flushed label part
        ('accel', STRING),              # right-flushed label part
        ('entry', cty.POINTER(FL_POPUP_ENTRY)),  # ptr to selected popup entry
        ('popup', cty.POINTER(FL_POPUP)), ]     # popup we're called for

FL_POPUP_RETURN = FL_POPUP_RETURN_


FL_POPUP_CB = cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_POPUP_RETURN))


FL_POPUP_.__slots__ = ['next', 'prev', 'parent', 'top_parent', 'entries', \
        'title', 'win', 'parent_win', 'cursor', 'callback', 'use_req_pos', \
        'req_x', 'req_y', 'x', 'y', 'w', 'h', 'min_width', 'title_box_x', \
        'title_box_y', 'title_box_w', 'title_box_h', 'has_subs', \
        'has_boxes', 'counter', 'title_font_style', 'title_font_size', \
        'entry_font_style', 'entry_font_size', 'event_mask', 'bw', \
        'bg_color', 'on_color', 'title_color', 'text_color', \
        'text_on_color', 'text_off_color', 'radio_color', 'policy', \
        'need_recalc', 'ret',]
FL_POPUP_._fields_ = [
    ('next', cty.POINTER(FL_POPUP)),      # next in linked list
    ('prev', cty.POINTER(FL_POPUP)),      # previous in linked list
    ('parent', cty.POINTER(FL_POPUP)),      # for sub-popups, direct parent
    ('top_parent', cty.POINTER(FL_POPUP)),  # and top-most parent
    ('entries', cty.POINTER(FL_POPUP_ENTRY)),   # pointer to list of entries
    ('title', STRING),
    ('win', Window),                    # popup window
    ('parent_win', Window),             # parent window of popup window
    ('cursor', Cursor),                 # cursor for the popup
    ('callback', FL_POPUP_CB),
    ('use_req_pos', cty.c_int),         # if set use req_x, req_y
    ('req_x', cty.c_int),
    ('req_y', cty.c_int),
    ('x', cty.c_int),                   # position of popup window
    ('y', cty.c_int),
    ('w', cty.c_uint),                  # dimensions of popup window
    ('h', cty.c_uint),
    ('min_width', cty.c_int),           # minimum width of popup
    ('title_box_x', cty.c_int),         # position of title box
    ('title_box_y', cty.c_int),
    ('title_box_w', cty.c_uint),        # dimensions of title box
    ('title_box_h', cty.c_uint),
    ('has_subs', cty.c_int),
    ('has_boxes', cty.c_int),
    ('counter', cty.c_int),
    ('title_font_style', cty.c_int),
    ('title_font_size', cty.c_int),
    ('entry_font_style', cty.c_int),
    ('entry_font_size', cty.c_int),
    ('event_mask', cty.c_ulong),
    ('bw', cty.c_int),                  # border width
    ('bg_color', FL_COLOR),             # background color of popup
    ('on_color', FL_COLOR),             # color of entry under mouse
    ('title_color', FL_COLOR),          # color of title text
    ('text_color', FL_COLOR),           # normal text color of entry
    ('text_on_color', FL_COLOR),        # text color when mouse on entry
    ('text_off_color', FL_COLOR),       # text color of disabled entry
    ('radio_color', FL_COLOR),          # color of radio buttons
    ('policy', cty.c_int),
    ('need_recalc', cty.c_int),         # do we need to recalc position?
    ('ret', FL_POPUP_RETURN), ]  # structure passed to callbacks and returned
                                 # on selection

FL_POPUP_ENTRY_.__slots__ = ['prev', 'next', 'popup', 'is_act', 'text', \
        'label', 'accel', 'val', 'user_data', 'type', 'state', 'group', \
        'sub', 'shortcut', 'ulpos', 'callback', 'enter_callback', \
        'leave_callback', 'x', 'y', 'w', 'h', 'box_x', 'box_y', 'box_w', \
        'box_h', 'sl_h', 'ul_x', 'ul_y', 'ul_w', 'ul_h', ]
FL_POPUP_ENTRY_._fields_ = [
    ('prev', cty.POINTER(FL_POPUP_ENTRY)),  # next in linked list
    ('next', cty.POINTER(FL_POPUP_ENTRY)),  # previous in linked list
    ('popup', cty.POINTER(FL_POPUP)),       # popup it belongs to
    ('is_act', cty.c_int),                  # set while mouse is over it
    ('text', STRING),                       # complete text of entry
    ('label', STRING),                      # cleaned-up label text
    ('accel', STRING),                      # cleaned-up accelerator key text
    ('val', cty.c_long),                    # value associated with entry
    ('user_data', cty.c_void_p),            # pointer to user data
    ('type', cty.c_int),                   # normal, toggle, radio, sub-popup
    ('state', cty.c_uint),                  # disabled, hidden, checked
    ('group', cty.c_int),                   # group (for radio entries only)
    ('sub', cty.POINTER(FL_POPUP)),         # sub-popup bound to entry
    ('shortcut', cty.POINTER(cty.c_long)),    # keyboard shortcuts
    ('ulpos', cty.c_int),                     # underline position in text
    ('callback', FL_POPUP_CB),              # callback for entry
    ('enter_callback', FL_POPUP_CB),        # callback for entering entry
    ('leave_callback', FL_POPUP_CB),        # callback for leaving entry
    ('x', cty.c_int),                   # horizontal position of entry text
    ('y', cty.c_int),                   # vertical position of entry text
    ('w', cty.c_uint),                      # width of entry text
    ('h', cty.c_uint),                      # height of entry text
    ('box_x', cty.c_int),
    ('box_y', cty.c_int),
    ('box_w', cty.c_uint),
    ('box_h', cty.c_uint),
    ('sl_h', cty.c_uint),
    ('ul_x', cty.c_int),
    ('ul_y', cty.c_int),
    ('ul_w', cty.c_uint),
    ('ul_h', cty.c_uint), ]


class FL_POPUP_ITEM(cty.Structure):
    """FL_POPUP_ITEM class

    Attributes
    ----------
        text : str
            text of entry
        callback : FL_POPUP_CB function type
            (selection) callback
        shortcut : str
            keyboard shortcut description
        type : int
            type of entry
        state : int
            disabled, hidden, checked
    """
    pass
FL_POPUP_ITEM.__slots__ = ['text', 'callback', 'shortcut', 'type', 'state',]
FL_POPUP_ITEM._fields_ = [
        ('text', STRING),               # text of entry
        ('callback', FL_POPUP_CB),      # (selection) callback
        ('shortcut', STRING),           # keyboard shortcut description
        ('type', cty.c_int),            # type of entry
        ('state', cty.c_int), ]         # disabled, hidden, checked


# Popup policies
# values for unnamed enumeration
FL_POPUP_NORMAL_SELECT = 0
FL_POPUP_DRAG_SELECT = 1

# my add, list of possible values --LK
POPUPPOLICY_list = [FL_POPUP_NORMAL_SELECT, FL_POPUP_DRAG_SELECT]


# Popup states
# values for unnamed enumeration
FL_POPUP_NONE = 0       # No special flags are set for the state of the popup
FL_POPUP_DISABLED = 1       # entry is disabled
FL_POPUP_HIDDEN   = 2       # entry is temporarily hidden
FL_POPUP_CHECKED  = 4       # toggle/radio item is in on state

class admitted_values_for_POPUPSTATE(object):
    """States of popup

    Admitted values
    ---------------
        FL_POPUP_NONE
            No special flags are set for the state of the popup
        FL_POPUP_DISABLED
            The popup is disabled and cannot be selected
        FL_POPUP_HIDDEN
            The popup is hidden, i.e. does not get shown, and thus cannot
            be selected
        FL_POPUP_CHECKED
            Only relevant for toggle or radio popups, marks it as in
            "on" state).
    """
    pass

# my add, list of possible values --LK
# single values and bitwise OR-ed of them
POPUPSTATE_list = [FL_POPUP_NONE, FL_POPUP_DISABLED, FL_POPUP_HIDDEN,
                FL_POPUP_CHECKED, FL_POPUP_DISABLED|FL_POPUP_HIDDEN,
                FL_POPUP_DISABLED|FL_POPUP_CHECKED,
                FL_POPUP_HIDDEN|FL_POPUP_CHECKED]


# Popup entry types
# values for unnamed enumeration
FL_POPUP_NORMAL = 0         # normal popup entry
FL_POPUP_TOGGLE = 1         # toggle ("binary") popup entry
FL_POPUP_RADIO = 2          # radio popup entry
FL_POPUP_SUB = 3            # sub-popup popup entry
FL_POPUP_LINE = 4           # line popup entry

class admitted_values_for_POPUPTYPE(object):
    """Types of popup

    Admitted values
    ---------------
        FL_POPUP_NORMAL
            Normal popup entry with no special properties.
        FL_POPUP_TOGGLE
            Toggle or binary popup entry, drawn with a check-mark
            to its left if in 'on' state
        FL_POPUP_RADIO
            Radio popup entry, drawn with a circle to its left
            (color-filled when 'on'. The group member of the FL_POPUP_ENTRY
            structure determines to which group the entry belongs
        FL_POPUP_SUB
            Entry for a sub-popup. The sub member of its FL_POPUP_ENTRY
            structure is a pointer to the sub-popup that gets shown when
            the mouse enters the entry.
        FL_POPUP_LINE
            Not a real entry, just indicates that a separator line is to be
            drawn between the previous and the next entry.
    """
    pass

# list of possible values, my add --LK
POPUPTYPE_list = [FL_POPUP_NORMAL, FL_POPUP_TOGGLE, FL_POPUP_RADIO,
                  FL_POPUP_SUB, FL_POPUP_LINE]


# Popup color types
# values for unnamed enumeration
FL_POPUP_BACKGROUND_COLOR = 0
FL_POPUP_HIGHLIGHT_COLOR = 1
FL_POPUP_TITLE_COLOR = 2
FL_POPUP_TEXT_COLOR = 3
FL_POPUP_HIGHLIGHT_TEXT_COLOR = 4
FL_POPUP_DISABLED_TEXT_COLOR = 5
FL_POPUP_RADIO_COLOR = 6

# list of possible values, my add --LK
POPUPCOLOR_list = [FL_POPUP_BACKGROUND_COLOR, FL_POPUP_HIGHLIGHT_COLOR,
                   FL_POPUP_TITLE_COLOR, FL_POPUP_TEXT_COLOR,
                   FL_POPUP_HIGHLIGHT_TEXT_COLOR,
                   FL_POPUP_DISABLED_TEXT_COLOR, FL_POPUP_RADIO_COLOR]


#########################
# forms.h (positioner.h)
#########################

FL_NORMAL_POSITIONER = 0
FL_OVERLAY_POSITIONER = 1
FL_INVISIBLE_POSITIONER = 2

# my add, list of possible values --LK
POSITIONERTYPE_list = [FL_NORMAL_POSITIONER, FL_OVERLAY_POSITIONER,
                       FL_INVISIBLE_POSITIONER]


# Defaults
FL_POSITIONER_BOXTYPE = FL_DOWN_BOX
FL_POSITIONER_COL1 = FL_COL1
FL_POSITIONER_COL2 = FL_RED
FL_POSITIONER_LCOL = FL_LCOL
FL_POSITIONER_ALIGN = FL_ALIGN_BOTTOM


#############################
# forms.h (scrollbar.h)
#############################

# values for unnamed enumeration
FL_VERT_SCROLLBAR = 0
FL_HOR_SCROLLBAR = 1
FL_VERT_THIN_SCROLLBAR = 2
FL_HOR_THIN_SCROLLBAR = 3
FL_VERT_NICE_SCROLLBAR = 4
FL_HOR_NICE_SCROLLBAR = 5
FL_VERT_PLAIN_SCROLLBAR = 6
FL_HOR_PLAIN_SCROLLBAR = 7
FL_HOR_BASIC_SCROLLBAR = FL_HOR_PLAIN_SCROLLBAR
FL_VERT_BASIC_SCROLLBAR = FL_VERT_PLAIN_SCROLLBAR

# values for unnamed enumeration
FL_NORMAL_SCROLLBAR = 0
FL_THIN_SCROLLBAR = 1
FL_NICE_SCROLLBAR = 2
FL_PLAIN_SCROLLBAR = 3

# my add, list of possible values --LK
SCROLLTYPE_list = [FL_VERT_SCROLLBAR, FL_HOR_SCROLLBAR, \
                  FL_VERT_THIN_SCROLLBAR, FL_HOR_THIN_SCROLLBAR, \
                  FL_VERT_NICE_SCROLLBAR, FL_HOR_NICE_SCROLLBAR, \
                  FL_VERT_PLAIN_SCROLLBAR, FL_HOR_PLAIN_SCROLLBAR, \
                  FL_HOR_BASIC_SCROLLBAR, FL_VERT_BASIC_SCROLLBAR, \
                  FL_NORMAL_SCROLLBAR, FL_THIN_SCROLLBAR, \
                  FL_NICE_SCROLLBAR, FL_PLAIN_SCROLLBAR]


#####################
# forms.h (select.h)
#####################

# Select flobject types
# values for unnamed enumeration
FL_NORMAL_SELECT = 0
FL_MENU_SELECT = 1
FL_DROPLIST_SELECT = 2

# list of possible values - my add --LK
SELECTTYPE_list = [FL_NORMAL_SELECT, FL_MENU_SELECT, FL_DROPLIST_SELECT]


# Defaults
FL_SELECT_COL1 = FL_COL1
FL_SELECT_COL2 = FL_MCOL
FL_SELECT_LCOL = FL_LCOL
FL_SELECT_ALIGN = FL_ALIGN_LEFT


#######################
# forms.h (slider.h)
# Slider flobject class
#######################

FL_HOR_FLAG = 1
FL_SCROLL_FLAG = 8

class admitted_values_for_SLIDERFLAG(object):
    """Flags of slider, to be used with another slider type.

    Admitted values
    ---------------
        FL_HOR_FLAG
            flag for horizontal slider
        FL_SCROLL_FLAG
            flag for scrollbar slider
    """
    pass

# values for enumeration 'FL_SLIDER_TYPE'
FL_SLIDER_TYPE = cty.c_int # enum
FL_VERT_SLIDER = 0
FL_HOR_SLIDER = FL_VERT_SLIDER | FL_HOR_FLAG
FL_VERT_FILL_SLIDER = 2
FL_HOR_FILL_SLIDER = FL_VERT_FILL_SLIDER | FL_HOR_FLAG
FL_VERT_NICE_SLIDER = 4
FL_HOR_NICE_SLIDER = FL_VERT_NICE_SLIDER | FL_HOR_FLAG
FL_VERT_BROWSER_SLIDER = 6
FL_HOR_BROWSER_SLIDER = FL_VERT_BROWSER_SLIDER | FL_HOR_FLAG

# The following are for use with scrollbars only!
# for FL_VERT_SCROLLBAR and FL_HOR_SCROLLBAR
FL_VERT_BROWSER_SLIDER2 = FL_VERT_SLIDER | FL_SCROLL_FLAG
FL_HOR_BROWSER_SLIDER2 = FL_HOR_SLIDER | FL_SCROLL_FLAG
# for FL_VERT_THIN_SCROLLBAR and FL_VERT_THIN_SCROLLBAR
FL_VERT_THIN_SLIDER = FL_VERT_FILL_SLIDER | FL_SCROLL_FLAG
FL_HOR_THIN_SLIDER = FL_HOR_FILL_SLIDER | FL_SCROLL_FLAG
# for FL_VERT_NICE_SCROLLBAR and FL_HOR_NICE_SCROLLBAR
FL_VERT_NICE_SLIDER2 = FL_VERT_NICE_SLIDER | FL_SCROLL_FLAG
FL_HOR_NICE_SLIDER2 = FL_HOR_NICE_SLIDER | FL_SCROLL_FLAG
# for use as FL_VERT_PLAIN_SCROLLBAR and FL_VERT_PLAIN_SCROLLBAR
FL_VERT_BASIC_SLIDER = FL_VERT_BROWSER_SLIDER | FL_SCROLL_FLAG
FL_HOR_BASIC_SLIDER = FL_HOR_BROWSER_SLIDER | FL_SCROLL_FLAG

# my add, list of possible values --LK
SLIDERTYPE_list = [FL_VERT_SLIDER, FL_HOR_SLIDER, FL_VERT_FILL_SLIDER, \
        FL_HOR_FILL_SLIDER, FL_VERT_NICE_SLIDER, FL_HOR_NICE_SLIDER, \
        FL_VERT_BROWSER_SLIDER, FL_HOR_BROWSER_SLIDER, \
        FL_VERT_BROWSER_SLIDER2, FL_HOR_BROWSER_SLIDER2, \
        FL_VERT_THIN_SLIDER, FL_HOR_THIN_SLIDER, FL_VERT_NICE_SLIDER2, \
        FL_HOR_NICE_SLIDER2, FL_VERT_BASIC_SLIDER, FL_HOR_BASIC_SLIDER]


# Defaults
FL_SLIDER_BW1 = FL_BOUND_WIDTH
FL_SLIDER_BW2 = 0             #FL_abs(FL_BOUND_WIDTH) - 1
FL_SLIDER_BOXTYPE = FL_DOWN_BOX
FL_SLIDER_COL1 = FL_COL1
FL_SLIDER_COL2 = FL_COL1
FL_SLIDER_LCOL = FL_LCOL
FL_SLIDER_ALIGN = FL_ALIGN_BOTTOM

# Others
FL_SLIDER_FINE = 0.25
FL_SLIDER_WIDTH = 0.10


##########################
# forms.h (spinner.h)
##########################

# values for enumeration 'FL_SPINNER_TYPE'
FL_SPINNER_TYPE = cty.c_int     # enum
FL_INT_SPINNER = 0
FL_FLOAT_SPINNER = 1

# my add, list of possible values --LK
SPINNERTYPE_list = [FL_INT_SPINNER, FL_FLOAT_SPINNER]


########################
# forms.h (tabfolder.h)
########################

# values for unnamed enumeration
FL_TOP_TABFOLDER = 0        # tab on top
FL_BOTTOM_TABFOLDER = 1
FL_LEFT_TABFOLDER = 2
FL_RIGHT_TABFOLDER = 3
FL_NORMAL_TABFOLDER = FL_TOP_TABFOLDER

# my add, list of possible values --LK
TABFOLDERTYPE_list = [FL_TOP_TABFOLDER, FL_BOTTOM_TABFOLDER,
        FL_LEFT_TABFOLDER, FL_RIGHT_TABFOLDER, FL_NORMAL_TABFOLDER]


# values for unnamed enumeration
FL_NO = 0
FL_FIT = 1
FL_ENLARGE_ONLY = 2

# my add, list of possible values --LK
FOLDERSIZESFIT_list = [FL_NO, FL_FIT, FL_ENLARGE_ONLY]



#########################
# forms.h (thumbwheel.h)
#########################

# values for unnamed enumeration
FL_VERT_THUMBWHEEL = 0
FL_HOR_THUMBWHEEL = 1

# my add, list of possible values --LK
THUMBWHEELTYPE_list = [FL_VERT_THUMBWHEEL, FL_HOR_THUMBWHEEL]


# defaults
FL_THUMBWHEEL_COL1 = FL_COL1
FL_THUMBWHEEL_COL2 = FL_COL1
FL_THUMBWHEEL_LCOL = FL_BLACK
FL_THUMBWHEEL_BOXTYPE = FL_BORDER_BOX
FL_THUMBWHEEL_ALIGN = FL_ALIGN_BOTTOM


######################
# forms.h (timer.h)
# Timer flobject class
######################

# values for enumeration 'FL_TIMER_TYPE'
FL_TIMER_TYPE = cty.c_int # enum
FL_NORMAL_TIMER = 0
FL_VALUE_TIMER = 1
FL_HIDDEN_TIMER = 2

# my add, list of possible values --LK
TIMERTYPE_list = [FL_NORMAL_TIMER, FL_VALUE_TIMER, FL_HIDDEN_TIMER]


# Defaults
FL_TIMER_BOXTYPE = FL_DOWN_BOX
FL_TIMER_COL1 = FL_COL1
FL_TIMER_COL2 = FL_RED
FL_TIMER_LCOL = FL_LCOL
FL_TIMER_ALIGN = FL_ALIGN_CENTER

# Others
FL_TIMER_BLINKRATE = 0.2


FL_TIMER_FILTER = cty.CFUNCTYPE(STRING, cty.POINTER(FL_OBJECT),
                                cty.c_double)


###############################
# forms.h (xyplot.h)
###############################

# values for enumeration 'FL_XYPLOT_TYPE'
FL_XYPLOT_TYPE = cty.c_int      # enum
FL_NORMAL_XYPLOT = 0    # solid line
FL_SQUARE_XYPLOT = 1
FL_CIRCLE_XYPLOT = 2
FL_FILL_XYPLOT = 3
FL_POINTS_XYPLOT = 4
FL_DASHED_XYPLOT = 5
FL_IMPULSE_XYPLOT = 6
FL_ACTIVE_XYPLOT = 7
FL_EMPTY_XYPLOT = 8
FL_DOTTED_XYPLOT = 9
FL_DOTDASHED_XYPLOT = 10
FL_LONGDASHED_XYPLOT = 11
FL_LINEPOINTS_XYPLOT = 12

# list of possible values - my add --LK
XYPLOTTYPE_list = [FL_NORMAL_XYPLOT, FL_SQUARE_XYPLOT, FL_CIRCLE_XYPLOT, \
        FL_FILL_XYPLOT, FL_POINTS_XYPLOT, FL_DASHED_XYPLOT, \
        FL_IMPULSE_XYPLOT, FL_ACTIVE_XYPLOT, FL_EMPTY_XYPLOT, \
        FL_DOTTED_XYPLOT, FL_DOTDASHED_XYPLOT, FL_LONGDASHED_XYPLOT, \
        FL_LINEPOINTS_XYPLOT]


# values for unnamed enumeration
FL_LINEAR = 0
FL_LOG = 1

# list of possible values - my add --LK
XYPLOTSCALE_list = [FL_LINEAR, FL_LOG]


# values for unnamed enumeration
FL_GRID_NONE  = 0
FL_GRID_MAJOR = 1
FL_GRID_MINOR = 2

# list of possible values - my add --LK
XYPLOTGRID_list = [FL_GRID_NONE, FL_GRID_MAJOR, FL_GRID_MINOR]


# Defaults
FL_XYPLOT_BOXTYPE = FL_FLAT_BOX
FL_XYPLOT_COL1 = FL_COL1
FL_XYPLOT_LCOL = FL_LCOL
FL_XYPLOT_ALIGN = FL_ALIGN_BOTTOM
FL_MAX_XYPLOTOVERLAY = 32


FL_XYPLOT_SYMBOL = cty.CFUNCTYPE(None, cty.POINTER(FL_OBJECT), cty.c_int,
            cty.POINTER(FL_POINT), cty.c_int, cty.c_int, cty.c_int)


#########################
# flimage.h
# Image related routines
#########################

# values for unnamed enumeration
FL_IMAGE_NONE = 0       # not supported image file format
FL_IMAGE_MONO = 1
FL_IMAGE_GRAY = 2
FL_IMAGE_CI = 4
FL_IMAGE_RGB = 8
FL_IMAGE_PACKED = 16
FL_IMAGE_GRAY16 = 32
FL_IMAGE_RGB16 = 64
FL_IMAGE_FLEX = 1023        # all formats

# aliases
FLIMAGE_NONE = FL_IMAGE_NONE
FLIMAGE_MONO = FL_IMAGE_MONO
FLIMAGE_GRAY = FL_IMAGE_GRAY
FLIMAGE_CI = FL_IMAGE_CI
FLIMAGE_RGB = FL_IMAGE_RGB
FLIMAGE_PACKED = FL_IMAGE_PACKED
FLIMAGE_GRAY16 = FL_IMAGE_GRAY16
FLIMAGE_RGB16 = FL_IMAGE_RGB16
FLIMAGE_FLEX = FL_IMAGE_FLEX

# my add, list of possible values --LK
FLIMAGETYPE_list = [FL_IMAGE_NONE, FL_IMAGE_MONO, FL_IMAGE_GRAY, \
        FL_IMAGE_CI, FL_IMAGE_RGB, FL_IMAGE_PACKED, FL_IMAGE_GRAY16, \
        FL_IMAGE_RGB16, FL_IMAGE_FLEX, FLIMAGE_NONE, FLIMAGE_MONO, \
        FLIMAGE_GRAY, FLIMAGE_CI, FLIMAGE_RGB, FLIMAGE_PACKED, \
        FLIMAGE_GRAY16, FLIMAGE_RGB16, FLIMAGE_FLEX]


FL_LUTBITS = 12         # max colormap bits. 4096 entries

# values for unnamed enumeration
FLIMAGE_AUTOCOLOR = 0x7fffffff
FLIMAGE_BADCOLOR = FLIMAGE_AUTOCOLOR

FL_WINDOW = Window    # cty.c_ulong


class flimage_text_(cty.Structure):
    """flimage_text class

    Attributes
    ----------
        str : str
            the text string itself
        len : int
            string length
        x : int
            starting horizontal position of text (wrt image)
        y : int
            starting vertical position of text (wrt image)
        color : int_pos
            color of the text
        bcolor : int_pos
            background color of the text
        nobk : int
            no background
        size : int
            font size
        style : int
            font style
        angle : int
            in 1/10th of a degrees
        align : int
            alignment with regards to (x,y)
    """
    pass
flimage_text_.__slots__ = ['str', 'len', 'x', 'y', 'color', 'bcolor', \
        'nobk', 'size', 'style', 'angle', 'align',]
flimage_text_._fields_ = [
        ('str', STRING),              # the string itself
        ('len', cty.c_int),           # string length
        ('x', cty.c_int),             # starting location of text (wrt image)
        ('y', cty.c_int),
        ('color', cty.c_uint),        # color of the text
        ('bcolor', cty.c_uint),       # background color of the text
        ('nobk', cty.c_int),          # no background
        ('size', cty.c_int),          # font size & style
        ('style', cty.c_int),
        ('angle', cty.c_int),         # in 1/10th of a degrees
        ('align', cty.c_int), ]       # alignment with regards to (x,y)
FLIMAGE_TEXT = flimage_text_


class flimage_marker_(cty.Structure):
    """ FLIMAGE_MARKER class

    Attributes
    ----------
        name : str
            marker name
        w : int
            width
        h : int
            height
        x : int
            horizontal location
        y :  int
            vertical location
        color : int_pos
            color of the marker
        bcolor : int_pos
            aux. color of the marker
        angle : int
            angle in 1/10th of a degree
        fill : int
            *todo*
        thickness : int
            line thickness
        style : int
            line style
        display : pointer to void
            display, filled by XForms
        gc : pointer to void
            graphics context, filled by XForms
        win : long_pos
            window, filled by XForms
        psdraw : str
            filled by XForms *todo*
    """
    pass
flimage_marker_.__slots__ = ['name', 'w', 'h', 'x', 'y', 'color', \
        'bcolor', 'angle', 'fill', 'thickness', 'style', 'display', \
        'gc', 'win', 'psdraw',]
flimage_marker_._fields_ = [
        ('name', STRING),               # marker name
        ('w', cty.c_int),               # width
        ('h', cty.c_int),               # height
        ('x', cty.c_int),               # horizontal location
        ('y', cty.c_int),               # vertical location
        ('color', cty.c_uint),          # color of the marker
        ('bcolor', cty.c_uint),         # aux. color of the marker
        ('angle', cty.c_int),           # in 1/10th of a degree
        ('fill', cty.c_int),
        ('thickness', cty.c_int),       # line thickness
        ('style', cty.c_int),           # line style
        # the following are filled by the library
        ('display', cty.c_void_p),
        ('gc', cty.c_void_p),
        ('win', FL_WINDOW),
        ('psdraw', STRING), ]
FLIMAGE_MARKER = flimage_marker_

FLIMAGE_REPFREQ = 0x1f   # report every 32 lines


class flimage_setup_(cty.Structure):
    """flimage_setup_ class

    Attributes
    ----------
        app_data : pointer to void
            The application can use it to set a value so
            ptr_flimage.contents.app_data in all image structures returned
            by XForms will have this value. It is most useful to set this
            field to something that is persistent during the application
            run, such as the fdui structure of the main control panel.
            ptr_flimage.contents.app_data is different from
            ptr_flimage.contents.u_vdata because all image structures returned
            by XForms have the same value of ptr_flimage.contents.app_data set
            by XForms, and ptr_flimage.contents.u_vdata is set by the
            application on an image-by-image basis.
        visual_cue : function, returned value
            name referring to function(ptr_flimage, [str]message) -> int
            function that will be called by all image reading, writing and
            processing routines. It is meant to give the user some visual
            feedback about what is happening. For lengthy tasks, this
            function is called repeatedly and periodically to indicate what
            percentage of the task is completed and to give the application
            program a chance to check and process GUI activities (for example,
            via fl_check_forms()). The 1st parameter to the function is the
            image (pointer to FL_IMAGE) currently being worked on and the
            second parameter is a short message, indicating the name of the
            task, such as "Reading JPG" etc. Two fields in the image structure
            can be used to obtain progress information.
            ptr_flimage.contents.total indicates the total amount of work to
            be done in some arbitrary units (usually number of rows in the
            image). ptr_flimage.contents.completed indicates how much of the
            task has been completed. The percentage of how much is completed is
            then simply the ratio of ptr_flimage.contents.completed and
            ptr_flimage.contents.total, multiplied by 100. At the begin of a
            task ptr_flimage.contents.completed is set to a value less or equal
            1, and at the end of the task, ptr_flimage.contents.completed is
            set to ptr_flimage.contents.total. A special value of -1 for
            ptr_flimage.contents.completed may be used to indicate a task of
            unknown length.
        error_message : function, no return
            name referring to function(ptr_flimage, [str]message)
            It is a function that is called when an error (of all severities)
            has occurred inside the library. It is recommanded that the
            application provide a means to show the messages to the user by
            supplying this function. The 1st parameter is a pointer to the
            image that is being worked on, and the second parameter is a brief
            message, such as "memory allocation failed" etc. A convenience
            function, flflimage.flimage_error(), is provided to call the error
            message handler.
        display : function, returned value
            function(ptr_flimage, long_pos) -> int
        rgbfile : str
            It should be set to the full path to the color name database
            ('rgb.txt') if your system has it in non-standard locations. On
            some systems this file is /usr/share/X11/rgb.txt, in other ones
            is '/usr/lib/X11/rgb.txt' (which is the default if it is not set).
        do_not_clear : int
            By default, flflimage.flimage_display() clears the window before
            displaying the image. Set this member to 1 to disable window
            clearing.
        xdisplay : pointer to void
            *todo*
        max_frames : int
            It specifies the maximum number of frames to read by
            flflimage.flimage_load(). The default maximum is 30 frames.
        delay : int
            It specifies the delay (in milliseconds) between successive
            frames. It is used by the flflimage.flimage_display() routine.
        no_auto_extension : int
            By default, flflimage.flimage_dump() changes the filename
            extension to reflect the format. Set this member to 1 to
            disable extension substitution.
        report_frequency : int
            *todo*
        double_buffer : int
            If set, all image display will by default double-buffered.
            Double-buffering an image is very expensive (in terms of both
            resource and speed) as the backbuffer is simulated using a pixmap.
            If there are no annotations, double-buffering an image does not
            really improve anything. It is far better to turn double-buffering
            on and off on a image-by-image basis using
            ptr_flimage.contents.double_buffer
        trailblazer : long_pos
            internal use
        header_info : int
            *todo*
    """
    pass

FLIMAGESETUP = cty.POINTER(flimage_setup_)


# possible errors from the library. Not currently (v0.89) used
# values for unnamed enumeration
FLIMAGE_ERR_NONE = 0
FLIMAGE_ERR_ALLOC = -50
FLIMAGE_ERR_INVALID = -49
FLIMAGE_ERR_ARGUMENT = -48
FLIMAGE_ERR_FILE = -47
FLIMAGE_ERR_INTERNAL = -46
FLIMAGE_ERR_UNKNOWN = -45

class admitted_values_for_FLIMAGEERRTYPE(object):
    """Error types for flimage

    Admitted values
    ---------------
        FLIMAGE_ERR_NONE
            no error
        FLIMAGE_ERR_ALLOC
            memory? allocation error
        FLIMAGE_ERR_INVALID
            invalid image
        FLIMAGE_ERR_ARGUMENT
            bad argument/request
        FLIMAGE_ERR_FILE
            i/o error
        FLIMAGE_ERR_INTERNAL
            bugs
        FLIMAGE_ERR_UNKNOWN
            unknown error
    """
    pass


class flimage_(cty.Structure):
    """FL_IMAGE class

    Attributes
    ----------
        type : int
            image type. It specifies the current image type and storage
            (1bit, 24bit etc. See next section for details). The image
            type also indicates implicitly which of the pixel fields
            should be used.
        w : int
            image width
        h : int
            image height
        app_data : pointer to void
            for application at setup time. It is initialized at image
            creation. Its value can be set by the application prior to
            any existence of image. Once set, all images created thereafter
            will have the same value for this field. See Section later.
            XForms does not modify or reference it once it is initialized.
        u_vdata : pointer to void
            can be used for application. It is always initialize to None.
            XForms does not reference or modify it.
        u_ldata : long
            can be used for application. It is always initialize to None.
            XForms does not reference or modify it.
        red : pointer to pointer to ubyte?
            This is one of the 3 color components of a 24 bit image, each
            of which is a 2-dimensional array. The 2D array is arranged so
            the image runs from left to right and top to bottom. E.g., the
            3rd pixel on the 10th row is composed of the following RGB
            elements: (red[9][2],green[9][2],blue[9][2]). These fields are
            meaningful only if the image type is FL_IMAGE_RGB.
        green : pointer to pointer to ubyte?
            This is one of the 3 color components of a 24 bit image, each
            of which is a 2-dimensional array. The 2D array is arranged so
            the image runs from left to right and top to bottom. E.g., the
            3rd pixel on the 10th row is composed of the following RGB
            elements: (red[9][2],green[9][2],blue[9][2]). These fields are
            meaningful only if the image type is FL_IMAGE_RGB.
        blue : pointer to pointer to ubyte?
            This is one of the 3 color components of a 24 bit image, each
            of which is a 2-dimensional array. The 2D array is arranged so
            the image runs from left to right and top to bottom. E.g., the
            3rd pixel on the 10th row is composed of the following RGB
            elements: (red[9][2],green[9][2],blue[9][2]). These fields are
            meaningful only if the image type is FL_IMAGE_RGB.
        alpha : pointer to pointer to ubyte?
            Although it is always allocated for a 24bit image, alpha is
            currently not used by XForms.
        rgba : pointer to pointer to ubyte? (array of 4 members)
            alias *todo*
        ci : pointer to pointer to ushort?
            pixel values for a color index image (image type FL_IMAGE_CI).
            It is also a 2-dimensional array arranged in the same way as
            the fields red, green and blue, i.e., the image runs from left
            to right, top to bottom. E.g., ci[3][9] should be used to obtain
            the 10th pixel on the 4th row. To obtain the RGB elements of a
            pixel, the pixel value should be used as an index into a lookup
            table specified by the fields red_lut, green_lut and blue_lut.
            Although ci can hold an unsigned short, only the lower
            FL_LUTBITS (12) bits are supported, i.e., the color index should
            not be bigger than 4095.
        gray : pointer to pointer to ushort?
            A 2-dimensional array that holds the pixels of a gray image.
            The pixel values are interpreted as intensities in a linear
            fashion. Two types of gray images are supported, 8 bit
            (FL_IMAGE_GRAY) and 16 bit (FL_IMAGE_GRAY16). For 16 bit gray
            image, the actual depths of the image is indicated by member
            gray_maxval. E.g., if gray_maxval is 4095, it is assumed that
            the actual pixel value ranges from 0 to 4095, i.e., the gray
            scale image is 12 bit. For 8 bit grayscale image, gray_maxval
            is not used. This means that the type FL_IMAGE_GRAY is always
            assumed to be 8 bit, the loading and creating routine should
            take care to properly scale data that are less than 8 bit.
        packed : pointer to pointer to FL_PACKED4
            A 2-dimensional array that holds a 24 bit/32 bit image in a
            packed format. Each element of the 2D array is an int_pos (for
            now) that holds the RGB, one byte each, in the lower 24 bits of
            the integer. The topmost byte is not used. The function FL_PACK(r,
            g, b) should be used to pack the triplet (r, g, b) into a pixel
            and FL_UNPACK(p, r, g, b) should be used to unpack a pixel. To
            obtain individual primary colors, the macros FL_GETR(p),
            FL_GETG(p) and FL_GETB(p) are available. Use of said functions
            to pack and unpack are strongly recommended. It will isolate the
            application program from future changes of the primary color
            type (for example, 16-bit resolution for R,G and B).
        red16 : pointer to pointer to ushort?
            not currently supported
        green16 : pointer to pointer to ushort?
            not currently supported
        blue16 : pointer to pointer to ushort?
            not currently supported
        alpha16 : pointer to pointer to ushort?
            not currently supported
        ci8 : pointer to pointer to ubyte?
            not currently supported
        red_lut : pointer to int
            red lookup tables for a color index image. Each of the table
            is a 1D array of length image->map len.
        green_lut : pointer to int
            green lookup tables for a color index image. Each of the table
            is a 1D array of length image->map len.
        blue_lut : pointer to int
            blue lookup tables for a color index image. Each of the table
            is a 1D array of length image->map len.
        alpha_lut : pointer to int
            alpha lookup tables. Although alpha lut is always allocated for
            a color index image, it is currently not used by XForms.
        lut : pointer to int (array 4 members)
            alias
        map_len : int
            The length of the colormap (lookup table).
        colors : int
            actual colors used in displaying
        gray_maxval : int
            indicates the range of gray16. It is meaningful only if the image
            type is FL_IMAGE_GRAY16. It specifies the actual dynamic range of
            the gray intensities. Its value should be set by the image loading
            routines if the gray image depth is more than 8 bits.
        ci_maxval : int
            max value of ci. not used, use map_len. It is by default 256,
            indicating the maximum value of the color index.
        rgb_maxval : int
            max value for rgb16 image
        level : int
            *todo*
        wwidth : int
            *todo*
        wlut : pointer to ushort
            lut for window levelling
        wlut_len : int
            *todo*
        app_background : int
            A packed RGB value indicating the preferred color to use for the
            background of an image (also known as transparent color). It is
            initialized to an illegal value. Since there is no portable way
            to obtain the window background the application has to set this
            field if transparency is to be achieved. In future versions of
            image support, other means of doing transparency will be explored
            and implemented.
        comments : str
            it is typically set by the loading routines to convey some
            information about the image. The application is free to choose how
            to display the comment, which may have embedded newlines in it.
        comments_len : int
            length of comments
        available_type : int
            *todo*
        next : pointer to flimage_
            This is a link to the next image. This is how flimage_load()
            chains multiple image together.
        sx : int
             display subimage horizontal position
        sy : int
            display subimage vertical position
        sw : int
            display subimage width
        sh : int),
            display subimage height
        wx : int
            display location relative to win (horizontal position)
        wy : int
            display location relative to win (vertical position)
        modified : int
            If true , informs XForms to invalidate the buffered image.
            It is to be used if you need to modify the image, either the
             pixels or the lookup tables.
        display : function, returned value
            function(pointer to flimage_, FL_WINDOW) -> int
            A function you can use to display an image. The image
            loading routine sets this function.
        double_buffer : int
            If true, the display function will double-buffer the image
            by using a pixmap. For typical image display it is not necessary
            to enable double-buffering as it is very expensive (memory and
            speed). Double-buffering may be useful in image editing.
        sxd : int
            *todo*
        syd : int
            *todo*
        swd : int
            *todo*
        shd : int
            *todo*
        wxd : int
            *todo*
        wyd : int
            *todo*
        fmt_name : str
            format name (ppm,jpg etc)
        text : pointer to FLIMAGE_TEXT
            annotation text
        ntext : int
            *todo*
        max_text : int
            *todo*
        dont_display_text : int
            *todo*
        display_text : function, no return
            function(pointer to flimage_)
        free_text : function, no return
            function(pointer to flimage_)
        marker : pointer to FLIMAGE_MARKER
            *todo*
        nmarkers : int
            number of markers
        max_markers : int
            *todo*
        dont_display_marker : int
            *todo*
        display_markers : function, no return
            function(pointer to flimage_)
        free_markers : function, no return
            function(pointer to flimage_)
        pmin : double
            minimum value physical data range
        pmax : double
            maximum value physical data range
        poffset : double
            *todo*
        pscale : double
            *todo*
        xdist_offset : double),
            pixel grid horizontal distance
        xdist_scale : double
            *todo*
        ydist_offset : double
            pixel grid vertical distance
        ydist_scale : double
            *todo*
        infile : str
            *todo*
        outfile : str
            *todo*
        foffset : long),
            *todo*
        original_type : int
            *todo*
        pre_write : function, returned value
            function(pointer to flimage_) -> int
            hooks for application to have a chance to set some options.
            If pre_write returns -1, the output will be canceled
        post_write : function, returned value
            function(pointer to flimage_) -> int
            hooks for application to have a chance to set some options.
        subx : int
            image processing stuff. Subimage horizontal origin
        suby : int
            subimage vertical origin
        subw : int
            subimage width
        subh : int
            subimage height
        sub_shape : int
            shape of the subimage
        fill_color : int_pos
            fill color
        force_convert : int
            *todo*
        llut : pointer to int (array 3 members)
            linear lut
        llut_len : int
            *todo*
        hist : pointer to int_pos (array 4 members)
            *todo*
        total : int
            application handlers *todo*
        completed : int
            application handlers *todo*
        visual_cue : function, returned value
            function(pointer to flimage_, str) -> int
        error_message : function, no return
            function(pointer to flimage_, str)
        error_code : int
            not currently used
        display_type : int
            just before handing it to X
        pixels : pointer to pointer to ushort
            *todo*
        image_spec : pointer to void
            additional image info
        xdisplay : pointer to void
            the X connection
        tran_rgb : int
            RGB color that should be transparent
        tran_index : int
            index that should be transparent
        matr : int
            *todo*
        matc : int
            *todo*
        more : int
            multi-frame images *todo*
        current_frame : int
            *todo*
        total_frames : int
            *todo*
        next_frame : function, returned value
            function(pointer to flimage_) -> int
        prev_frame : function, returned value
            function(pointer to flimage_) -> int
        random_frame : function, returned value
            function(pointer to flimage_, int) -> int
        rewind_frame : function, returned value
            function(pointer to flimage_) -> int
        cleanup : function, no return
            function(pointer to flimage_)
        stop_looping : int
            *todo*
        fpin : pointer to FILE
            for internal use
        fpout : pointer to FILE
            for internal use
        image_io : pointer to void
            *todo*
        io_spec : pointer to void
            io operation helper. It is meant for the reading/writing
            routine to place format specific state information that
            otherwise needs to be static or global.
        spec_size : int
            It should be set to the number of bytes io_spec contains.
        depth : int
            the depth we actually use
        vclass : int
            visual class
        visual : pointer to void
            *todo*
        xcolormap : long_pos,
            *todo*
        rgb2p : FL_RGB2PIXEL_
            *todo*
        ximage : pointer to void
            *todo*
        win : long_pos
            window *todo*
        gc : pointer to void
            *todo*
        sdepth : int
            depth the server says
        textgc : pointer to void
            *todo*
        markergc : pointer to void
            *todo*
        extra_io_info : pointer to void
            *todo*
        pixmap : long_pos
            The backbuffer pixmap if double-buffered.
        pixmap_w : int
            *todo*
        pixmap_h : int
            *todo*
        pixmap_depth : int
            *todo*
        isPixmap : int
            *todo*
        setup : FLIMAGESETUP
            *todo*
        info : str
            *todo*
    """
    pass
flimage_.__slots__ = ['type', 'w', 'h', 'app_data', 'u_vdata', 'u_ldata', \
        'red', 'green', 'blue', 'alpha', 'rgba', 'ci', 'gray', 'packed', \
        'red16', 'green16', 'blue16', 'alpha16', 'ci8', 'red_lut', \
        'green_lut', 'blue_lut', 'alpha_lut', 'lut', 'map_len', 'colors', \
        'gray_maxval', 'ci_maxval', 'rgb_maxval', 'level', 'wwidth', \
        'wlut', 'wlut_len', 'app_background', 'comments', 'comments_len', \
        'available_type', 'next', 'sx', 'sy', 'sw', 'sh', 'wx', 'wy', \
        'modified', 'display', 'double_buffer', 'sxd', 'syd', 'swd', \
        'shd', 'wxd', 'wyd', 'fmt_name', 'text', 'ntext', 'max_text', \
        'dont_display_text', 'display_text', 'free_text', 'marker', \
        'nmarkers', 'max_markers', 'dont_display_marker', 'display_markers', \
        'free_markers', 'pmin', 'pmax', 'poffset', 'pscale', 'xdist_offset', \
        'xdist_scale', 'ydist_offset', 'ydist_scale', 'infile', 'outfile', \
        'foffset', 'original_type', 'pre_write', 'post_write', 'subx', \
        'suby', 'subw', 'subh', 'sub_shape', 'fill_color', 'force_convert', \
        'llut', 'llut_len', 'hist', 'total', 'completed', 'visual_cue', \
        'error_message', 'error_code', 'display_type', 'pixels', \
        'image_spec', 'xdisplay', 'tran_rgb', 'tran_index', 'matr', 'matc', \
        'more', 'current_frame', 'total_frames', 'next_frame', 'prev_frame', \
        'random_frame', 'rewind_frame', 'cleanup', 'stop_looping', 'fpin', \
        'fpout', 'image_io', 'io_spec', 'spec_size', 'depth', 'vclass', \
        'visual', 'xcolormap', 'rgb2p', 'ximage', 'win', 'gc', 'sdepth', \
        'textgc', 'markergc', 'extra_io_info', 'pixmap', 'pixmap_w', \
        'pixmap_h', 'pixmap_depth', 'isPixmap', 'setup', 'info',]
flimage_._fields_ = [
        ('type', cty.c_int),            # image type
        ('w', cty.c_int),               # image width
        ('h', cty.c_int),               # image height
        ('app_data', cty.c_void_p),     # for application at setup time
        ('u_vdata', cty.c_void_p),      # for application
        ('u_ldata', cty.c_long),        # for application
        ('red', cty.POINTER(cty.POINTER(cty.c_ubyte))),
        ('green', cty.POINTER(cty.POINTER(cty.c_ubyte))),
        ('blue', cty.POINTER(cty.POINTER(cty.c_ubyte))),
        ('alpha', cty.POINTER(cty.POINTER(cty.c_ubyte))),
        ('rgba', cty.POINTER(cty.POINTER(cty.c_ubyte)) * 4),    # alias
        ('ci', cty.POINTER(cty.POINTER(cty.c_ushort))),
        ('gray', cty.POINTER(cty.POINTER(cty.c_ushort))),
        ('packed', cty.POINTER(cty.POINTER(FL_PACKED4))),
        # red16, green16, blue16, alpha16 and ci8 not currently supported
        ('red16', cty.POINTER(cty.POINTER(cty.c_ushort))),
        ('green16', cty.POINTER(cty.POINTER(cty.c_ushort))),
        ('blue16', cty.POINTER(cty.POINTER(cty.c_ushort))),
        ('alpha16', cty.POINTER(cty.POINTER(cty.c_ushort))),
        ('ci8', cty.POINTER(cty.POINTER(cty.c_ubyte))),
        ('red_lut', cty.POINTER(cty.c_int)),        # red lookup tables
        ('green_lut', cty.POINTER(cty.c_int)),      # green lookup tables
        ('blue_lut', cty.POINTER(cty.c_int)),       # blue lookup tables
        ('alpha_lut', cty.POINTER(cty.c_int)),      # alpha lookup tables
        ('lut', cty.POINTER(cty.c_int) * 4),        # alias
        ('map_len', cty.c_int),                 # lut length
        ('colors', cty.c_int),          # actual colors used in displaying
        ('gray_maxval', cty.c_int),         # indicate the range of gray16
        ('ci_maxval', cty.c_int),   # max value of ci. not used, use map_len
        ('rgb_maxval', cty.c_int),              # max value for rgb16 image
        ('level', cty.c_int),
        ('wwidth', cty.c_int),
        ('wlut', cty.POINTER(cty.c_ushort)),        # lut for window levelling
        ('wlut_len', cty.c_int),
        ('app_background', cty.c_int),          # transparent color, in RGB
        ('comments', STRING),
        ('comments_len', cty.c_int),
        ('available_type', cty.c_int),
        ('next', cty.POINTER(flimage_)),
        ('sx', cty.c_int),                      # display subimage origin
        ('sy', cty.c_int),
        ('sw', cty.c_int),                      # display subimage width
        ('sh', cty.c_int),
        ('wx', cty.c_int),              # display location relative to win
        ('wy', cty.c_int),
        ('modified', cty.c_int),
        ('display', cty.CFUNCTYPE(cty.c_int, cty.POINTER(flimage_), \
                FL_WINDOW)),
        ('double_buffer', cty.c_int),
        ('sxd', cty.c_int),
        ('syd', cty.c_int),
        ('swd', cty.c_int),
        ('shd', cty.c_int),
        ('wxd', cty.c_int),
        ('wyd', cty.c_int),
        ('fmt_name', STRING),       # format name (ppm,jpg etc)
        # annotation stuff
        ('text', cty.POINTER(FLIMAGE_TEXT)),
        ('ntext', cty.c_int),
        ('max_text', cty.c_int),
        ('dont_display_text', cty.c_int),
        ('display_text', cty.CFUNCTYPE(None, cty.POINTER(flimage_))),
        ('free_text', cty.CFUNCTYPE(None, cty.POINTER(flimage_))),
        ('marker', cty.POINTER(FLIMAGE_MARKER)),
        ('nmarkers', cty.c_int),
        ('max_markers', cty.c_int),
        ('dont_display_marker', cty.c_int),
        ('display_markers', cty.CFUNCTYPE(None, cty.POINTER(flimage_))),
        ('free_markers', cty.CFUNCTYPE(None, cty.POINTER(flimage_))),
        # physicalValue = poffset + pixelValue * pscale
        ('pmin', cty.c_double),         # minimum value physical data range
        ('pmax', cty.c_double),         # maximum value physical data range
        ('poffset', cty.c_double),
        ('pscale', cty.c_double),
        #  pixel grid distance
        ('xdist_offset', cty.c_double),
        ('xdist_scale', cty.c_double),
        ('ydist_offset', cty.c_double),
        ('ydist_scale', cty.c_double),
        ('infile', STRING),
        ('outfile', STRING),
        ('foffset', cty.c_long),
        ('original_type', cty.c_int),
        # hooks for application to have a chance to set some options.
        # if pre_write returns -1, the output will be canceled
        ('pre_write', cty.CFUNCTYPE(cty.c_int, cty.POINTER(flimage_))),
        ('post_write', cty.CFUNCTYPE(cty.c_int, cty.POINTER(flimage_))),
        # image processing stuff
        ('subx', cty.c_int),        # subimage horizontal origin
        ('suby', cty.c_int),        # subimage vertical origin
        ('subw', cty.c_int),        # subimage width
        ('subh', cty.c_int),        # subimage height
        ('sub_shape', cty.c_int),   # shape of the subimage
        ('fill_color', cty.c_uint),     # fill color
        ('force_convert', cty.c_int),
        ('llut', cty.POINTER(cty.c_int) * 3),   # linear lut
        ('llut_len', cty.c_int),
        ('hist', cty.POINTER(cty.c_uint) * 4),
        # application handlers
        ('total', cty.c_int),
        ('completed', cty.c_int),
        ('visual_cue', cty.CFUNCTYPE(cty.c_int, cty.POINTER(flimage_), \
            STRING)),
        ('error_message', cty.CFUNCTYPE(None, cty.POINTER(flimage_), \
            STRING)),
        ('error_code', cty.c_int),      # not currently used
        ('display_type', cty.c_int),    # just before handing it to X
        ('pixels', cty.POINTER(cty.POINTER(cty.c_ushort))),
        ('image_spec', cty.c_void_p),   # additional image info
        ('xdisplay', cty.c_void_p),     # the X connection
        ('tran_rgb', cty.c_int),        # RGB color that should be transparent
        ('tran_index', cty.c_int),      # index that should be transparent
        ('matr', cty.c_int),
        ('matc', cty.c_int),
        # multi-frame images
        ('more', cty.c_int),
        ('current_frame', cty.c_int),
        ('total_frames', cty.c_int),
        ('next_frame', cty.CFUNCTYPE(cty.c_int, cty.POINTER(flimage_))),
        ('prev_frame', cty.CFUNCTYPE(cty.c_int, cty.POINTER(flimage_))),
        ('random_frame', cty.CFUNCTYPE(cty.c_int, cty.POINTER(flimage_), \
                cty.c_int)),
        ('rewind_frame', cty.CFUNCTYPE(cty.c_int, cty.POINTER(flimage_))),
        ('cleanup', cty.CFUNCTYPE(None, cty.POINTER(flimage_))),
        ('stop_looping', cty.c_int),
        # the following are for internal use
        ('fpin', cty.POINTER(FILE)),
        ('fpout', cty.POINTER(FILE)),
        ('image_io', cty.c_void_p),
        ('io_spec', cty.c_void_p),      # io operation helper
        ('spec_size', cty.c_int),
        ('depth', cty.c_int),           # the depth we actually use
        ('vclass', cty.c_int),
        ('visual', cty.c_void_p),
        ('xcolormap', cty.c_ulong),
        ('rgb2p', FL_RGB2PIXEL_),
        ('ximage', cty.c_void_p),
        ('win', FL_WINDOW),
        ('gc', cty.c_void_p),
        ('sdepth', cty.c_int),          # depth the server says
        ('textgc', cty.c_void_p),
        ('markergc', cty.c_void_p),
        ('extra_io_info', cty.c_void_p),
        ('pixmap', cty.c_ulong),
        ('pixmap_w', cty.c_int),
        ('pixmap_h', cty.c_int),
        ('pixmap_depth', cty.c_int),
        ('isPixmap', cty.c_int),
        ('setup', FLIMAGESETUP),
        ('info', STRING), ]

FL_IMAGE = flimage_


# some configuration stuff

flimage_setup_.__slots__ = ['app_data', 'visual_cue', 'error_message', \
        'display', 'rgbfile', 'do_not_clear', 'xdisplay', 'max_frames', \
        'delay', 'no_auto_extension', 'report_frequency', 'double_buffer', \
        'trailblazer', 'header_info']
flimage_setup_._fields_ = [
    ('app_data', cty.c_void_p),
    ('visual_cue', cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_IMAGE), STRING)),
    ('error_message', cty.CFUNCTYPE(None, cty.POINTER(FL_IMAGE), STRING)),
    ('display', cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_IMAGE), cty.c_ulong)),
    ('rgbfile', STRING),
    ('do_not_clear', cty.c_int),
    ('xdisplay', cty.c_void_p),
    ('max_frames', cty.c_int),
    ('delay', cty.c_int),
    ('no_auto_extension', cty.c_int),
    ('report_frequency', cty.c_int),
    ('double_buffer', cty.c_int),
    # internal use
    ('trailblazer', cty.c_ulong),
    ('header_info', cty.c_int), ]

FLIMAGE_SETUP = flimage_setup_

# prototype for flimage_setup_'s visual_cue function
cfunc_int_ptrflimage_str = cty.CFUNCTYPE(cty.c_int, \
        cty.POINTER(FL_IMAGE), STRING)


# output options

class FLIMAGE_JPEG_OPTION(cty.Structure):
    """FLIMAGE_JPEG_OPTION class

    Attributes
    ----------
      quality : int
        quality for jpeg to be set
      smoothing : int
        smoothing for jpeg to be set
    """
    pass
FLIMAGE_JPEG_OPTION.__slots__ = ['quality', 'smoothing',]
FLIMAGE_JPEG_OPTION._fields_ = [
        ('quality', cty.c_int),
        ('smoothing', cty.c_int), ]


# values for unnamed enumeration
FLIMAGE_WRITABLE = FL_WRITE
FLIMAGE_READABLE = FL_READ

class admitted_values_for_READWRITEFLIMAGE(object):
    """Flimage read/write state

    Admitted values
    ---------------
        FLIMAGE_WRITABLE
            flag if image can be written
        FLIMAGE_READABLE
            flag if image can be read
        FLIMAGE_WRITABLE|FLIMAGE_READABLE
            flag if image can be read and written
    """
    pass


class FLIMAGE_FORMAT_INFO(cty.Structure):
    """FLIMAGE_FORMAT_INFO class

    Attributes
    ----------
      formal_name : str
        the formal name of image format, e.g.
        "Tag Image File Format"
      short_name : str
        an abbreviated name for the image format,
        e.g. "tiff"
      extension : str
        file extension, e.g. "tif"
      type : int
        the image type, generally one of the supported image
        types (e.g. FL_IMAGE_RGB), but it does not have to.
        For image file formats that are capable of holding more
        than one type of images, this field can be set to indicate
        this by OR-ing the supported types together (e.g.,
        FL_IMAGE_RGB|FL_IMAGE_GRAY).
      read_write : int
        if image can be written or read. Values: FLIMAGE_WRITABLE,
        FLIMAGE_READABLE or FLIMAGE_WRITABLE|FLIMAGE_READABLE
      annotation : int
        *todo*
    """
    pass
FLIMAGE_FORMAT_INFO.__slots__ = ['formal_name', 'short_name', 'extension', \
        'type', 'read_write', 'annotation',]
FLIMAGE_FORMAT_INFO._fields_ = [
        ('formal_name', STRING),
        ('short_name', STRING),
        ('extension', STRING),
        ('type', cty.c_int),
        ('read_write', cty.c_int),
        ('annotation', cty.c_int), ]


# simple image processing routines
# TODO: to be verified.
#FLIMAGE_SHARPEN = cty.pointer(cty.pointer(cty.c_int(-1)))
FLIMAGE_SHARPEN = -1
#FLIMAGE_SMOOTH = cty.pointer(cty.pointer(cty.c_int(-2)))
FLIMAGE_SMOOTH = -2
FL_SMOOTH = FLIMAGE_SMOOTH
FL_SHARPEN = FLIMAGE_SHARPEN

class admitted_values_for_SHARPENSMOOTHFLIMAGE(object):
    """Flimage sharpen/smooth image

    Admitted values
    ---------------
        FL_SMOOTH
            *todo*
        FL_SHARPEN
            *todo*
    """
    pass


# values for unnamed enumeration
FLIMAGE_NOSUBPIXEL = 0
FLIMAGE_SUBPIXEL = 1
FLIMAGE_CENTER = 2
FLIMAGE_RIGHT = 8
FLIMAGE_ASPECT = 32
FLIMAGE_NOCENTER = FL_ALIGN_LEFT_TOP

class admitted_values_for_FLIMAGEPOSITION(object):
    """Flimage position/rotation

    Admitted values
    ---------------
        FLIMAGE_NOSUBPIXEL
            scale with no subpixel sampling
        FLIMAGE_SUBPIXEL
            scale with subpixel sampling
        FLIMAGE_CENTER
            center warped image (default)
        FLIMAGE_RIGHT
            flush right the warped image
        FLIMAGE_ASPECT
            fit the size
        FLIMAGE_NOCENTER
            *todo*
    """
    pass

# my add, list of possible values for subpixel in
# flflimage.flimage_rotate() --LK
FLIMAGESUBPIXROT_list = [FLIMAGE_NOSUBPIXEL, FLIMAGE_SUBPIXEL]


# /usr/include/X11/Xlib.h 345
class XWindowAttributes(cty.Structure):
    """X11 XWindowAttributes class

    Attributes
    ----------
        x : int
            horizontal location of window
        y : int
            vertical location of window
        width : int
            width of window
        height : int
            height of window
        border_width : int
            border width of window
        depth : int
            depth of window
        visual : pointer to Visual
            the associated visual structure
        root : long_pos
            root of screen containing window
        c_class : int
            (C++ compatible name) InputOutput, InputOnly
        bit_gravity : int
            one of bit gravity values
        win_gravity : int
            one of the window gravity values
        backing_store : int
            one of the window gravity values
        backing_planes : long_pos
            planes to be preserved if possible
        backing_pixel : long_pos
            value to be used when restoring planes
        save_under : int
            boolean, should bits under be saved?
        colormap : long_pos
            color map to be associated with window
        map_installed : int
            boolean, is color map currently installed
        map_state : int
            IsUnmapped, IsUnviewable, IsViewable
        all_event_masks : long
            set of events all people have interest in
        your_event_mask : long
            my event mask
        do_not_propagate_mask : long
            set of events that should not propagate
        override_redirect : int
            boolean value for override-redirect
        screen : pointer to Screen
            back pointer to correct screen
    """
    pass


# /usr/include/X11/Xlib.h 176
class XExtCodes(cty.Structure):
    """X11 XExtCodes class. It contains structures used by the
    extension mechanism.

    Attributes
    ----------
        extension : int
            extension number
        major_opcode : int
            major op-code assigned by server
        first_event : int
            first event number for the extension
        first_error : int
            first error number for the extension
    """
    pass
XExtCodes.__slots__ = ['extension', 'major_opcode', 'first_event', \
        'first_error',]
XExtCodes._fields_ = [
        ('extension', cty.c_int),
        ('major_opcode', cty.c_int),
        ('first_event', cty.c_int),
        ('first_error', cty.c_int), ]


# /usr/include/X11/Xlib.h 186
class XPixmapFormatValues(cty.Structure):
    """X11 XPixmapFormatValues class

    Attributes
    ----------
        depth : int
            *todo*
        bits_per_pixel : int
            *todo*
        scanline_pad : int
            *todo*
    """
    pass
XPixmapFormatValues.__slots__ = ['depth', 'bits_per_pixel', 'scanline_pad',]
XPixmapFormatValues._fields_ = [
        ('depth', cty.c_int),
        ('bits_per_pixel', cty.c_int),
        ('scanline_pad', cty.c_int), ]

# /usr/include/X11/Xlib.h 218
class XGCValues(cty.Structure):
    """X11 XGCValues class. It is a Data structure for
    setting graphics context.

    Attributes
    ----------
        function : int
            logical operation
       plane_mask : long_pos
            plane mask
        foreground : long_pos
            foreground pixel
        background : long_pos
            background pixel
        line_width : int
            line width
        line_style : int
            LineSolid, LineOnOffDash, LineDoubleDash
        cap_style : int
            CapNotLast, CapButt, CapRound, CapProjecting
        join_style : int
            JoinMiter, JoinRound, JoinBevel
        fill_style : int
            FillSolid, FillTiled, FillStippled, FillOpaeueStippled
        fill_rule : int
            EvenOddRule, WindingRule
        arc_mode : int
            ArcChord, ArcPieSlice
        tile : long_pos
            tile pixmap for tiling operations
        stipple : long_pos
            stipple 1 plane pixmap for stipping
        ts_x_origin : int
            horizontal offset for tile or stipple operations
        ts_y_origin : int
            vertical offset for tile or stipple operations
        font : long_pos
            default text font for text operations
        subwindow_mode : int
            ClipByChildren, IncludeInferiors
        graphics_exposures : int
            boolean, should exposures be generated
        clip_x_origin : int
            horizontal origin for clipping
        clip_y_origin : int
            vertical origin for clipping
        clip_mask : long_pos
            bitmap clipping; other calls for rects
        dash_offset : int
            patterned/dashed line information
        dashes : char
            *todo*
    """
    pass
XGCValues.__slots__ = ['function', 'plane_mask', 'foreground', \
        'background', 'line_width', 'line_style', 'cap_style', 'join_style', \
        'fill_style', 'fill_rule', 'arc_mode', 'tile', 'stipple', \
        'ts_x_origin', 'ts_y_origin', 'font', 'subwindow_mode', \
        'graphics_exposures', 'clip_x_origin', 'clip_y_origin', 'clip_mask', \
        'dash_offset', 'dashes',]
XGCValues._fields_ = [
        ('function', cty.c_int),
        ('plane_mask', cty.c_ulong),
        ('foreground', cty.c_ulong),
        ('background', cty.c_ulong),
        ('line_width', cty.c_int),
        ('line_style', cty.c_int),
        ('cap_style', cty.c_int),
        ('join_style', cty.c_int),
        ('fill_style', cty.c_int),
        ('fill_rule', cty.c_int),
        ('arc_mode', cty.c_int),
        ('tile', Pixmap),
        ('stipple', Pixmap),
        ('ts_x_origin', cty.c_int),
        ('ts_y_origin', cty.c_int),
        ('font', Font),
        ('subwindow_mode', cty.c_int),
        ('graphics_exposures', cty.c_int),
        ('clip_x_origin', cty.c_int),
        ('clip_y_origin', cty.c_int),
        ('clip_mask', Pixmap),
        ('dash_offset', cty.c_int),
        ('dashes', cty.c_char), ]


# /usr/include/X11/Xlib.h 258
class Depth(cty.Structure):
    """X11 Depth class. It contains information for each possible depth.

    Attributes
    ----------
        depth : int
            this depth (Z) of the depth
        nvisuals : int
            number of Visual types at this depth
        visuals : pointer to Visual
            list of visuals possible at this depth
    """
    pass
Depth.__slots__ = ['depth', 'nvisuals', 'visuals',]
Depth._fields_ = [
        ('depth', cty.c_int),
        ('nvisuals', cty.c_int),
        ('visuals', cty.POINTER(Visual)), ]

# /usr/include/X11/Xlib.h 286
class Screen(cty.Structure):
    """X11 Screen class

    Attributes
    ----------
        ext_data : pointer to XExtData
            hook for extension to hang data
        display : pointer to _XDisplay
            back pointer to display structure
        root : long_pos
            Root window id.
        width : int
            width of screen
        height : int
            height of screen
        mwidth : int
            width of screen in millimeters
        mheight : int
            height of screen in millimeters
        ndepths : int
            number of depths possible
        depths : pointer to Depth
            list of allowable depths on the screen
        root_depth : int
            bits per pixel
        root_visual : pointer to Visual
            root visual
        default_gc : GC
            GC for the root visual
        cmap : long_pos
            default color map
        white_pixel : long_pos
            White pixel values
        black_pixel : long_pos
            Black pixel values
        max_maps : int
            max color maps
        min_maps : int
            min color maps
        backing_store : int
            Never, WhenMapped, Always
        save_unders : int
            *todo*
        root_input_mask : long
            initial root input mask
    """
    pass
Screen.__slots__ = ['ext_data', 'display', 'root', 'width', 'height', \
        'mwidth', 'mheight', 'ndepths', 'depths', 'root_depth', \
        'root_visual', 'default_gc', 'cmap', 'white_pixel', 'black_pixel', \
        'max_maps', 'min_maps', 'backing_store', 'save_unders', \
        'root_input_mask',]
Screen._fields_ = [
        ('ext_data', cty.POINTER(XExtData)),
        ('display', cty.POINTER(_XDisplay)),
        ('root', Window),
        ('width', cty.c_int),
        ('height', cty.c_int),
        ('mwidth', cty.c_int),
        ('mheight', cty.c_int),
        ('ndepths', cty.c_int),
        ('depths', cty.POINTER(Depth)),
        ('root_depth', cty.c_int),
        ('root_visual', cty.POINTER(Visual)),
        ('default_gc', GC),
        ('cmap', Colormap),
        ('white_pixel', cty.c_ulong),
        ('black_pixel', cty.c_ulong),
        ('max_maps', cty.c_int),
        ('min_maps', cty.c_int),
        ('backing_store', cty.c_int),
        ('save_unders', cty.c_int),
        ('root_input_mask', cty.c_long), ]


# /usr/include/X11/Xlib.h 296
class ScreenFormat(cty.Structure):
    """X11 ScreenFormat class. it describes ZFormat data the screen
    will understand.

    Attributes
    ----------
        ext_data : pointer to XExtData
            hook for extension to hang data
        depth : int
            depth of this image format
        bits_per_pixel : int
            bits/pixel at this depth
        scanline_pad : int
            scanline must padded to this multiple
    """
ScreenFormat.__slots__ = ['ext_data', 'depth', 'bits_per_pixel', \
        'scanline_pad',]
ScreenFormat._fields_ = [
        ('ext_data', cty.POINTER(XExtData)),
        ('depth', cty.c_int),
        ('bits_per_pixel', cty.c_int),
        ('scanline_pad', cty.c_int), ]

XWindowAttributes.__slots__ = ['x', 'y', 'width', 'height', 'border_width', \
        'depth', 'visual', 'root', 'c_class', 'bit_gravity', 'win_gravity', \
        'backing_store', 'backing_planes', 'backing_pixel', 'save_under', \
        'colormap', 'map_installed', 'map_state', 'all_event_masks', \
        'your_event_mask', 'do_not_propagate_mask', 'override_redirect', \
        'screen',]
XWindowAttributes._fields_ = [
    ('x', cty.c_int),
    ('y', cty.c_int),
    ('width', cty.c_int),
    ('height', cty.c_int),
    ('border_width', cty.c_int),
    ('depth', cty.c_int),
    ('visual', cty.POINTER(Visual)),
    ('root', Window),
    ('c_class', cty.c_int),
    ('bit_gravity', cty.c_int),
    ('win_gravity', cty.c_int),
    ('backing_store', cty.c_int),
    ('backing_planes', cty.c_ulong),
    ('backing_pixel', cty.c_ulong),
    ('save_under', cty.c_int),
    ('colormap', Colormap),
    ('map_installed', cty.c_int),
    ('map_state', cty.c_int),
    ('all_event_masks', cty.c_long),
    ('your_event_mask', cty.c_long),
    ('do_not_propagate_mask', cty.c_long),
    ('override_redirect', cty.c_int),
    ('screen', cty.POINTER(Screen)),
]


# /usr/include/X11/Xlib.h 356
class XHostAddress(cty.Structure):
    """X11 XHostAddress class. it is data structure for host setting.

    Attributes
    ----------
        family : int
            for example FamilyInternet
        length : int
            length of address, in bytes
        address : str
            pointer to where to find the bytes
    """
    pass
XHostAddress.__slots__ = ['family', 'length', 'address',]
XHostAddress._fields_ = [
        ('family', cty.c_int),
        ('length', cty.c_int),
        ('address', STRING), ]


# /usr/include/X11/Xlib.h 366
class XServerInterpretedAddress(cty.Structure):
    """X11 XServerInterpretedAddress class. It is data structure for
    ServerFamilyInterpreted addresses in host routines.

    Attributes
    ----------
        typelength : int
            length of type string, in bytes
        valuelength : int
            length of value string, in bytes
        type : str
            pointer to where to find the type string
        value : str
            pointer to where to find the address
    """
    pass
XServerInterpretedAddress.__slots__ = ['typelength', 'valuelength', 'type', \
        'value',]
XServerInterpretedAddress._fields_ = [
        ('typelength', cty.c_int),
        ('valuelength', cty.c_int),
        ('type', STRING),
        ('value', STRING), ]


# /usr/include/X11/Xlib.h 371
class _XImage(cty.Structure):
    """X11 XImage class. it is data structure for "image" data,
    used by image manipulation routines.

    Attributes
    ----------
        width : int
            width of the image
        height : int
            height of the image
        xoffset : int
            number of pixels offset in X direction
        format : int
            XYBitmap, XYPixmap, ZPixmap
        data : str
            pointer to image data
        byte_order : int
            data byte order, LSBFirst, MSBFirst
        bitmap_unit : int
            quant. of scanline 8, 16, 32
        bitmap_bit_order : int
            LSBFirst, MSBFirst
        bitmap_pad : int
            8, 16, 32 either XY or ZPixmap
        depth : int
            depth of image
        bytes_per_line : int
            accelerator to next line
        bits_per_pixel : int
            bits per pixel (ZPixmap)
        red_mask : long_pos
            red bits in z arrangement
        green_mask : long_pos
            green bits in z arrangement
        blue_mask : long_pos
            blue bits in z arrangement
        obdata : str
            hook for the object routines to hang on
        f : funcs class instance
            image manipulation routines
    """
    pass


# /usr/include/X11/Xlib.h 387
class funcs(cty.Structure):
    """X11 funcs class

    Attributes
    ----------
        create_image : function, returned value
            function(pointer to _XDisplay, pointer to Visual,
            [int_pos]depth, [int]format, [int]offset, [str]data,
            [int_pos]width, [int_pos]height, [int]bitmap_pad,
            [int]bytes_per_line) -> pointer to _XImage
        destroy_image : function, returned value
            function(pointer to _XImage) -> int
        get_pixel : function, returned value
            function(pointer to _XImage, int, int) -> long_pos
        put_pixel : function, returned value
            function(pointer to _XImage, int, int, long_pos) -> int
        sub_image : function, returned value
            function(pointer to _XImage, int, int, int_pos,
            int_pos) -> pointer to _XImage
        add_pixel : function, returned value
            function(pointer to _XImage, long) -> int
    """
    pass
funcs.__slots__ = ['create_image', 'destroy_image', 'get_pixel', \
        'put_pixel', 'sub_image', 'add_pixel',]
funcs._fields_ = [
        ('create_image', cty.CFUNCTYPE(cty.POINTER(_XImage),
            cty.POINTER(_XDisplay), cty.POINTER(Visual), cty.c_uint,
            cty.c_int, cty.c_int, STRING, cty.c_uint, cty.c_uint, cty.c_int,
            cty.c_int)),
        ('destroy_image', cty.CFUNCTYPE(cty.c_int, cty.POINTER(_XImage))),
        ('get_pixel', cty.CFUNCTYPE(cty.c_ulong, cty.POINTER(_XImage),
            cty.c_int, cty.c_int)),
        ('put_pixel', cty.CFUNCTYPE(cty.c_int, cty.POINTER(_XImage),
            cty.c_int, cty.c_int, cty.c_ulong)),
        ('sub_image', cty.CFUNCTYPE(cty.POINTER(_XImage),
            cty.POINTER(_XImage), cty.c_int, cty.c_int, cty.c_uint,
            cty.c_uint)),
        ('add_pixel', cty.CFUNCTYPE(cty.c_int, cty.POINTER(_XImage),
            cty.c_long)), ]


_XImage.__slots__ = ['width', 'height', 'xoffset', 'format', 'data', \
        'byte_order', 'bitmap_unit', 'bitmap_bit_order', 'bitmap_pad', \
        'depth', 'bytes_per_line', 'bits_per_pixel', 'red_mask', \
        'green_mask', 'blue_mask', 'obdata', 'f',]
_XImage._fields_ = [
    ('width', cty.c_int),
    ('height', cty.c_int),
    ('xoffset', cty.c_int),
    ('format', cty.c_int),
    ('data', STRING),
    ('byte_order', cty.c_int),
    ('bitmap_unit', cty.c_int),
    ('bitmap_bit_order', cty.c_int),
    ('bitmap_pad', cty.c_int),
    ('depth', cty.c_int),
    ('bytes_per_line', cty.c_int),
    ('bits_per_pixel', cty.c_int),
    ('red_mask', cty.c_ulong),
    ('green_mask', cty.c_ulong),
    ('blue_mask', cty.c_ulong),
    ('obdata', XPointer),
    ('f', funcs), ]
XImage = _XImage


FLIMAGE_Identify = cty.CFUNCTYPE(cty.c_int, cty.POINTER(FILE))
FLIMAGE_Description = cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_IMAGE))
FLIMAGE_Read_Pixels = cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_IMAGE))
FLIMAGE_Write_Image = cty.CFUNCTYPE(cty.c_int, cty.POINTER(FL_IMAGE))


#fl_ul_magic_char = (xfdata.STRING).in_dll(library.load_so_libforms(),
#                    'fl_state')
fl_ul_magic_char = STRING



# here it is some documentation for some general concepts who do not belong
# particularly to a single function or data constant or variable.

# hacks to allow docstrings for non-functions and non-constants, since as a
# Values are meant to be ignored.
special_sequences_for_entry_text = """
    Special sequences for extry text
    --------------------------------

    A special sequences is represented by a case-sensitive alphabetic character
    placed into the entry text, prepended by a '%' character.

    There are 3 types of special sequences:
      - some do not need any additional arguments afterhand (%t, %T, %l, %d,
      %h);
      - some need an additional value directly inserted in text after it (%S);
      - some need an additional but separated argument/parameter (%x, %u, %f,
      %E, %L, %r, %R, %s).

    Some of them are mutually exclusive (%t, %T, %r, %R, %l, %m).

    Use %% to put a % character within the text of an entry.
"""
special_sequences_for_entry_text_x = """ \
    %x (with additional separate argument as a type long value)
    sets a value that is passed to all callback routines for the entry."""
special_sequences_for_entry_text_u = """ \
    %u (with additional separate argument as data of any type)
    sets user data that is passed to all callbacks of the entry. Warning:
    currently in xforms-python it does not fully work as expected."""
special_sequences_for_entry_text_f = """ \
    %f (with additional separate argument as function name)
    sets a callback function that gets called when the entry is selected. The
     function is of type FL_POPUP_CB, returning an int. Information about the
     entry etc. gets passed to the callback function via the FL_POPUP_RETURN
     class instance and the return value of the function can be used to keep
     the selection being reported back to the caller of fl_popup_do() by
     returning a value of FL_IGNORE (-1)."""
special_sequences_for_entry_text_E = """ \
    %E (with additional separate argument as function name)
    sets a callback routine that gets called each time the mouse enters the
    entry (as long as the entry is not disabled or hidden). The function type
    is the same as %f's callback function but its return value is never used."""
special_sequences_for_entry_text_L = """ \
    %L (with additional separate argument as function name)
    sets a callback routine that gets called each time the mouse leaves the
    entry. The function type is the same as %f's callback function but its
    return value is never used."""
special_sequences_for_entry_text_m = """ \
    %m (with additional separate argument as popup class instance)
    a sub-popup gets opened when the mouse enters the entry (the entry itself
    thus cannot be selected). The sub-popup to be opened must be an already
    existing FL_POPUP. A triangle will be drawn on the right of the entry to
    indicate that it is an entry for a sub-popup."""
special_sequences_for_entry_text_t = """ \
    %t (no argument)
    makes the entry a "toggle" entry, an entry that represents binary states
    and gets a check-mark drawn on its left if in "on" state. It is in "off"
    state at the start. Switching states happens automatically when the entry
    is selected."""
special_sequences_for_entry_text_T = """ \
    %T (no argument)
    makes the entry a "toggle" entry, an entry that represents binary states
    and gets a check-mark drawn on its left if in "on" state. If is in "on"
    state at the start. Switching states happens automatically when the entry
    is selected."""
special_sequences_for_entry_text_r = """ \
    %r (with additional separate argument as a type int group value)
    makes the entry a "radio" entry, i.e. it becomes part of a group of
    entries of which only one can be "on" at a time. The group value cannot
    be INT_MIN or INT_MAX. Radio entries are drawn with a small circle to the
    left, with the one for the entry in "on" state filled with a color (blue
    by default). When a radio entry is selected by the user that was in "off"
    state the entry of the group that was is "on" state before is automatically
    switched to "off" state. The entry is in "off" state at start (only one
    can be 'on' at the same time)."""
special_sequences_for_entry_text_R = """ \
    %R (with additional separate argument as a type int group value)
    makes the entry a "radio" entry, i.e. it becomes part of a group of entries
    of which only one can be "on" at a time. The group value cannot be INT_MIN
    or INT_MAX. Radio entries are drawn with a small circle to the left, with
    the one for the entry in "on" state filled with a color (blue per default).
    When a radio entry is selected by the user that was in "off" state the
    entry of the group that was is "on" state before is automatically switched
    to "off" state. The entry is in "on" state (in that case all entries
    created before in "on" state are reset to "off" state, i.e. the one
    created last "wins")."""
special_sequences_for_entry_text_l = """ \
    %l (no argument)
    creates not a real entry but indicates that a line is to be drawn to
    visually group other entries. While other properties can be set for such
    an "entry" only the "hidden" property is taken into account."""
special_sequences_for_entry_text_d = """ \
    %d (no argument)
    marks the entry as disabled, i.e. it cannot be selected and its text is
    by default drawn in a different color."""
special_sequences_for_entry_text_h = """ \
    %h (no argument)
    marks the entry as hidden, i.e. it is not shown while in this state."""
special_sequences_for_entry_text_s = """ \
    %s (with additional separate argument as a str)
    sets one or more shortcut keys for an entry. The character in the label
    identical to the shortcut character is only shown as underlined if %S is
    not used."""
special_sequences_for_entry_text_S = """ \
    %S (with an in-text value after)
    For entries with shortcut keys it is quite common to have them shown on
    the right hand side. Using %S you can split the entry's text into two
    parts, the first one (before %S) being drawn flushed left and the second
    part flushed right. Note that using this special sequence does not
    automatically sets a shortcut key, this still has to be done using %s."""


