#!/usr/bin/env python
# -*- coding: iso8859-1 -*-

""" xforms-python's functions to manage basic generic flobjects.
"""

#    Copyright (C) 2009, 2010, 2011  Luca Lazzaroni "LukenShiro"
#    e-mail: <lukenshiro@ngi.it>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Lesser General Public License as
#    published by the Free Software Foundation, version 2.1 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU Lesser General Public License for more details.
#
#    You should have received a copy of the GNU LGPL along with this
#    program. If not, see <http://www.gnu.org/licenses/>.
#
#    See CREDITS file to read acknowledgements and thanks to XForms,
#    ctypes and other developers.


# originally generated by 'h2xml+gccxml' and 'xml2py'
# then heavily reordered and reworked

# ############################################# #
# Interface to XForms shared flobject libraries   #
# ############################################# #

import ctypes as cty
from xformslib import library
from xformslib import xfdata


########################################
# forms.h (Basic.h)
# Basic definitions and limits.
# Window system independent prototypes
# Modify with care
########################################


def FL_IS_UPBOX(boxtype):
    if (boxtype == xfdata.FL_UP_BOX) or \
            (boxtype == xfdata.FL_OVAL3D_UPBOX) or \
            (boxtype == xfdata.FL_ROUNDED3D_UPBOX):
        return True
    else:
        return False


def FL_IS_DOWNBOX(boxtype):
    if (boxtype == xfdata.FL_DOWN_BOX) or \
            (boxtype == xfdata.FL_OVAL3D_DOWNBOX) or \
            (boxtype == xfdata.FL_ROUNDED3D_DOWNBOX):
        return True
    else:
        return False


def FL_TO_DOWNBOX(boxtype):
    if boxtype == xfdata.FL_UP_BOX:
        t1 = xfdata.FL_DOWN_BOX
    elif boxtype == xfdata.FL_ROUNDED3D_UPBOX:
        t1 = xfdata.FL_ROUNDED3D_DOWNBOX
    elif boxtype == xfdata.FL_OVAL3D_UPBOX:
        t1 = xfdata.FL_OVAL3D_DOWNBOX
    else:
        t1 = boxtype
    return t1


def special_style(style):
    if (style >= xfdata.FL_SHADOW_STYLE) and \
            (style <= (xfdata.FL_EMBOSSED_STYLE + xfdata.FL_MAXFONTS)):
        return True
    else:
        return False


# IO other than XEvent Q

def fl_add_io_callback(fd, fmask, pyfn_IoCallback, userdata):
    """fl_add_io_callback(fd, fmask, pyfn_IoCallback, userdata)

    Registers an input callback function when input is available from fd.

    Parameters
    ----------
        fd : int
            a valid file descriptor in a unix system from an opened file
        fmask : int
            under what circumstance the input callback should be invoked.
            Values (from xfdata.py) are:
            - FL_READ (file descriptor has data available),
            - FL_WRITE (file descriptor is available for writing),
            - FL_EXCEPT (an I/O error has occurred)
        pyfn_IoCallback : python function, no return
            name referring to function([int]num, [pointer to void]vdata)
            function to be invoked on said circumstances
        userdata : any type (e.g. None, int, str, etc..)
            user data to be passed to function; invoked callback has to take
            care of type check and re-cast from ptr_void to chosen type using
            appropriate xfstruct.convert_ptrvoid_to_*() function

    Examples
    --------
        >>> def iocb(num, vdata):
        >>> ... <something>
        >>> fdesc = os.open(myfile, os.RD_ONLY)
        >>> fl_add_io_callback(fdesc, xfdata.FL_READ, iocb, None)

    Notes
    -----
        Status: UnitTest + Doc + NoDemo = OK

    """
    #FL_IO_CALLBACK = cty.CFUNCTYPE(None, cty.c_int, cty.c_void_p)
    _fl_add_io_callback = library.cfuncproto(
        library.load_so_libforms(), "fl_add_io_callback", \
        None, [cty.c_int, cty.c_uint, xfdata.FL_IO_CALLBACK, cty.c_void_p],
        """void fl_add_io_callback(int fd, unsigned int mask,
           FL_IO_CALLBACK callback, void * data) """)
    library.check_if_flinitialized()
    i_fd = library.convert_to_intc(fd)
    library.checkfatal_allowed_value_in_list(fmask, xfdata.ASYNCIO_list)
    ui_fmask = library.convert_to_uintc(fmask)
    library.verify_function_type(pyfn_IoCallback)
    cfn_IoCallback = xfdata.FL_IO_CALLBACK(pyfn_IoCallback)
    ptr_vdata = library.convert_userdata_to_ptrvoid(userdata)
    library.keep_cfunc_refs(cfn_IoCallback, pyfn_IoCallback)
    library.keep_elem_refs(fd, i_fd, fmask, ui_fmask, userdata, ptr_vdata)
    _fl_add_io_callback(i_fd, ui_fmask, cfn_IoCallback, ptr_vdata)


def fl_remove_io_callback(fd, fmask, pyfn_IoCallback):
    """fl_remove_io_callback(fd, fmask, pyfn_IoCallback)

    Removes the registered callback function when input is available from fd.

    Parameters
    ----------
        fd : int
            a valid file descriptor in a unix system
        fmask : int
            under what circumstance the input callback should be removed.
            Values (from xfdata.py) are:
            - FL_READ (file descriptor has data available),
            - FL_WRITE (file descriptor is available for writing),
            - FL_EXCEPT (an I/O error has occurred)
        pyfn_IoCallback : python function, no return
            name referring to function([int]num, [pointer to void]pvdata)
            function to be removed on said circumstances

    Examples
    --------
        >>> def iocb(num, pvdata):
        >>> ... <something>
        >>> fdesc = os.open(myfile, os.RD_ONLY)
        >>> fl_remove_io_callback(fdesc, xfdata.FL_READ, iocb)

    Notes
    -----
        Status: UnitTest + Doc + NoDemo = OK

    """
    #FL_IO_CALLBACK = cty.CFUNCTYPE(None, cty.c_int, cty.c_void_p)
    _fl_remove_io_callback = library.cfuncproto(
        library.load_so_libforms(), "fl_remove_io_callback", \
        None, [cty.c_int, cty.c_uint, xfdata.FL_IO_CALLBACK], \
        """void fl_remove_io_callback(int fd, unsigned int mask,
           FL_IO_CALLBACK cb) """)
    library.check_if_flinitialized()
    i_fd = library.convert_to_intc(fd)
    library.checkfatal_allowed_value_in_list(fmask, xfdata.ASYNCIO_list)
    ui_fmask = library.convert_to_uintc(fmask)
    library.verify_function_type(pyfn_IoCallback)
    cfn_IoCallback = xfdata.FL_IO_CALLBACK(pyfn_IoCallback)
    library.keep_cfunc_refs(cfn_IoCallback, pyfn_IoCallback)
    library.keep_elem_refs(fd, i_fd, fmask, ui_fmask)
    _fl_remove_io_callback(i_fd, ui_fmask, cfn_IoCallback)


# signals

def fl_add_signal_callback(sglnum, pyfn_SignalHandler, userdata):
    """fl_add_signal_callback(sglnum, pyfn_SignalHandler, userdata)

    Handles the receipt of a signal by registering a callback function
    that gets called when a signal is caught (only one function per
    signal).

    Parameters
    ----------
        sglnum : int
            signal number. Values (from external signal module)
            SIGALRM, SIGINT, ...
        pyfn_SignalHandler : python function callback, no return
            name referring to function([int]num, [pointer to void]pvdata)
            callback invoked after catching signal
        userdata : any type (e.g. None, int, str, etc..)
            user data to be passed to function; invoked callback has to take
            care of type check and re-cast from ptr_void to chosen type using
            appropriate xfstruct.convert_ptrvoid_to_*() function

    Examples
    --------
        >>> def sglhandl(numsgl, pvdata):
        >>> ... <something>
        >>> fl_add_signal_callback(signal.SIGALRM, sglhandl, None)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    #FL_SIGNAL_HANDLER = cty.CFUNCTYPE(None, cty.c_int, cty.c_void_p)
    _fl_add_signal_callback = library.cfuncproto(
        library.load_so_libforms(), "fl_add_signal_callback", \
        None, [cty.c_int, xfdata.FL_SIGNAL_HANDLER, cty.c_void_p], \
        """void fl_add_signal_callback(int s, FL_SIGNAL_HANDLER cb,
           void * data) """)
    library.check_if_flinitialized()
    i_sglnum = library.convert_to_intc(sglnum)
    library.verify_function_type(pyfn_SignalHandler)
    cfn_SignalHandler = xfdata.FL_SIGNAL_HANDLER(pyfn_SignalHandler)
    ptr_vdata = library.convert_userdata_to_ptrvoid(userdata)
    library.keep_cfunc_refs(cfn_SignalHandler, pyfn_SignalHandler)
    library.keep_elem_refs(sglnum, i_sglnum, userdata, ptr_vdata)
    _fl_add_signal_callback(i_sglnum, cfn_SignalHandler, ptr_vdata)


def fl_remove_signal_callback(sglnum):
    """fl_remove_signal_callback(sglnum)

    Removes a previously registered callback function related to a signal.

    Parameters
    ----------
        sglnum : int
            signal number. Values (from external signal module)
            SIGALRM, SIGINT, ...

    Examples
    --------
        >>> fl_remove_signal_callback(signal.SIGALRM)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_remove_signal_callback = library.cfuncproto(
        library.load_so_libforms(), "fl_remove_signal_callback", \
        None, [cty.c_int], \
        """void fl_remove_signal_callback(int s) """)
    library.check_if_flinitialized()
    i_sglnum = library.convert_to_intc(sglnum)
    library.keep_elem_refs(sglnum, i_sglnum)
    _fl_remove_signal_callback(i_sglnum)


def fl_signal_caught(sglnum):
    """fl_signal_caught(sglnum)

    Informs the main loop of the delivery of the particular signal.
    The signal is received by the application program.

    Parameters
    ----------
        sglnum : int
            signal number. Values (from external signal module)
            SIGALRM, SIGINT, ...

    Examples
    --------
        >>> fl_signal_caught(signal.SIGALRM)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_signal_caught = library.cfuncproto(
        library.load_so_libforms(), "fl_signal_caught", \
        None, [cty.c_int], \
        """void fl_signal_caught(int s) """)
    library.check_if_flinitialized()
    i_sglnum = library.convert_to_intc(sglnum)
    library.keep_elem_refs(sglnum, i_sglnum)
    _fl_signal_caught(i_sglnum)


def fl_app_signal_direct(yesno):
    """fl_app_signal_direct(yesno)

    Changes the default behavior of the built-in signal facilities. It
    is to be called with a true value for flag prior to any use of
    fl_add_signal_callback().

    Parameters
    ----------
        yesno : int
            flag to disable/enable signal. Values 0 (disabled) or
            1 (enabled)

    Examples
    --------
        >>> fl_app_signal_direct(1)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_app_signal_direct = library.cfuncproto(
        library.load_so_libforms(), "fl_app_signal_direct", \
        None, [cty.c_int], \
        """void fl_app_signal_direct(int y) """)
    library.check_if_flinitialized()
    i_yesno = library.convert_to_intc(yesno)
    library.keep_elem_refs(yesno, i_yesno)
    _fl_app_signal_direct(i_yesno)


def fl_input_end_return_handling(endtype):
    """fl_input_end_return_handling(endtype) -> endtype

    Defines type of handling return of end events for input flobjects.

    Parameters
    ----------
        endtype : int
            how end return event for input is handled. Values (from xfdata.py):
            - FL_INPUT_END_EVENT_CLASSIC (old behavior) Uses old behavior in
              handling return of end event for input. An "end of edit" event
              was not reported back to the program when the user clicked
              on a non-input flobject, i.e. changed to a different input
              flobject. This let to some problems when the interaction with
              the clicked-on non-input flobject depended on the new content
              of the input flobject, just having been edited, but which had
              not been been reported back to the caller.
            - FL_INPUT_END_EVENT_ALWAYS (default) Uses new behavior in handling
              return of end event for input. It means that the user either hits
              the <Tab> or the <Return> key (except for multi-line inputs) or
              that he/she clicks onto some other flobject that in principle
              allows user interaction. These events are interpreted as an
              indication the user is done editing the input field and thus are
              reported back to the program, either by returning the input
              flobject or invoking its callback. But unless the user goes to a
              different input flobject, the input field edited retains focus.

    Returns
    -------
        endtype : int
            previous setting

    Examples
    --------
        >>> fl_input_end_return_handling(xfdata.FL_INPUT_END_EVENT_CLASSIC)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_input_end_return_handling = library.cfuncproto(
        library.load_so_libforms(), "fl_input_end_return_handling", \
        cty.c_int, [cty.c_int], \
        """int fl_input_end_return_handling(int type)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(endtype, \
            xfdata.INPUTENDRETNEVENT_list)
    i_endtype = library.convert_to_intc(endtype)
    library.keep_elem_refs(endtype, i_endtype)
    retval = _fl_input_end_return_handling(i_endtype)
    return retval


# timeouts

def fl_add_timeout(msec, pyfn_TimeoutCallback, userdata):
    """fl_add_timeout(msec, pyfn_TimeoutCallback, userdata) -> timeoutid

    Adds a timeout callback to be called after a specified elapsed time.

    Parameters
    ----------
        msec : long
            time elapsed in milliseconds
        pyfn_TimeoutCallback : python function, no return
            name referring to function([int]timeoutid, [pointer to void]pvdata)
            Function to be invoked when time is elapsed. Timeout id is passed
            to callback.
        userdata : any type (e.g. None, int, str, etc..)
            user data to be passed to function; invoked callback has to take
            care of type check and re-cast from ptr_void to chosen type using
            appropriate xfstruct.convert_ptrvoid_to_*() function

    Returns
    -------
        timeoutid : int
            timeout id to be added

    Examples
    --------
        >>> def timeoutcb(num, pvdata):
        >>> ... <something>
        >>> timnum = fl_add_timeout(100, timeoutcb, None)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    #FL_TIMEOUT_CALLBACK = cty.CFUNCTYPE(None, cty.c_int, cty.c_void_p)
    _fl_add_timeout = library.cfuncproto(
        library.load_so_libforms(), "fl_add_timeout", \
        cty.c_int, [cty.c_long, xfdata.FL_TIMEOUT_CALLBACK, cty.c_void_p],
        """int fl_add_timeout(long int msec, FL_TIMEOUT_CALLBACK callback,
           void * data) """)
    library.check_if_flinitialized()
    l_msec = library.convert_to_longc(msec)
    library.verify_function_type(pyfn_TimeoutCallback)
    cfn_TimeoutCallback = xfdata.FL_TIMEOUT_CALLBACK(pyfn_TimeoutCallback)
    ptr_vdata = library.convert_userdata_to_ptrvoid(userdata)
    library.keep_cfunc_refs(cfn_TimeoutCallback, pyfn_TimeoutCallback)
    library.keep_elem_refs(msec, l_msec, userdata, ptr_vdata)
    retval = _fl_add_timeout(l_msec, cfn_TimeoutCallback, ptr_vdata)
    return retval


def fl_remove_timeout(timeoutid):
    """fl_remove_timeout(timeoutid)

    Removes a timeout callback function, created with fl_add_timeout().

    Parameters
    ----------
        timeoutid : int
            timeout id

    Examples
    --------
        >>> fl_remove_timeout(timnum)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_remove_timeout = library.cfuncproto(
        library.load_so_libforms(), "fl_remove_timeout", \
        None, [cty.c_int], \
        """void fl_remove_timeout(int id) """)
    library.check_if_flinitialized()
    i_timeoutid = library.convert_to_intc(timeoutid)
    library.keep_elem_refs(timeoutid, i_timeoutid)
    _fl_remove_timeout(i_timeoutid)


# Basic public routine prototypes

def fl_library_version():
    """fl_library_version() -> compver, ver, rev

    Finds out XForms consolidated, major and minor version informations.

    Returns
    -------
        version_rev : int
            consolidated version (computed as 1000 * version + revision)
        ver : int
            major version (e.g. 1 in 1.x.yy)
        rev : int
            revision (e.g. 0 in x.0.yy)

    Examples
    --------
        >>> compver, ver, rev = fl_library_version()

    API_diversion
    ----------
        API is changed from XForms, upstream is fl_library_version(ver, rev)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe
        It does not need initialization

    """
    _fl_library_version = library.cfuncproto(
        library.load_so_libforms(), "fl_library_version", \
        cty.c_int, [cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)], \
        """int fl_library_version(int * ver, int * rev) """)
    i_ver, ptr_ver = library.make_intc_and_pointer()
    i_rev, ptr_rev = library.make_intc_and_pointer()
    library.keep_elem_refs(i_ver, i_rev, ptr_ver, ptr_rev)
    retval = _fl_library_version(ptr_ver, ptr_rev)
    return retval, i_ver.value, i_rev.value


def fl_library_full_version():
    """fl_library_full_version() -> fcompver, ver, rev, fixl, extrafixl

    Finds out XForms full consolidated, major, minor and fixlevel version
    informations.

    Returns
    -------
        fversion_rev : int
            full consolidated version (computed as 1000000 * version +
            revision * 1000 + fixlevel)
        ver : int
            major version (e.g. 1 in 1.y.zz)
        rev : int
            revision (e.g. 0 in x.0.zz)
        fixlvl : int
            numeric part of fixlevel (e.g. 93 in x.y.93sp1)
        extrafixlvl : str
            textual part of fixlevel (e.g. sp1 in x.y.93sp1)

    Examples
    --------
        >>> fcompver, ver, rev, fixl, extrafixl = fl_library_full_version()

    API_diversion
    ----------
        API is changed from XForms, upstream is
        fl_library_full_version(ver, rev, fixlvl, extra) -> fconsolver

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe
        It does not need initialization

    """
    _fl_library_full_version = library.cfuncproto(
        library.load_so_libforms(), "fl_library_full_version", \
        cty.c_long, [cty.POINTER(cty.c_int), cty.POINTER(cty.c_int), \
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_char_p)], \
        """long fl_library_full_version(int * ver, int * rev, int * fix_level
           const char ** extra) """)
    i_ver, ptr_ver = library.make_intc_and_pointer()
    i_rev, ptr_rev = library.make_intc_and_pointer()
    i_fixlvl, ptr_fixlvl = library.make_intc_and_pointer()
    s_extrafixlvl, ptr_extrafixlvl = library.make_stringc_and_pointer()
    library.keep_elem_refs(i_ver, ptr_ver, i_rev, ptr_rev, i_fixlvl, \
            ptr_fixlvl, s_extrafixlvl, ptr_extrafixlvl)
    retval = _fl_library_full_version(ptr_ver, ptr_rev, ptr_fixlvl, \
            ptr_extrafixlvl)
    return retval, i_ver.value, i_rev.value, i_fixlvl.value, \
            s_extrafixlvl.value


# Generic routines that deal with FORMS

def fl_bgn_form(boxtype, width, height):
    """fl_bgn_form(boxtype, width, height) -> ptr_flform

    Starts the definition of a form call.

    Parameters
    ----------
        boxtype : int
            type of box used as a background. Values (from xfdata.py)
            - FL_NO_BOX (No box at all, it is transparent, just a label),
            - FL_UP_BOX (A box that comes out of the screen),
            - FL_DOWN_BOX (A box that goes down into the screen),
            - FL_BORDER_BOX (A flat box with a border),
            - FL_SHADOW_BOX (A flat box with a shadow),
            - FL_FRAME_BOX (A flat box with an engraved frame),
            - FL_ROUNDED_BOX (A rounded box),
            - FL_EMBOSSED_BOX (A flat box with an embossed frame),
            - FL_FLAT_BOX (A flat box without a border, normally invisible
              unless given a different color than the surroundings),
            - FL_RFLAT_BOX (A rounded box without a border, normally invisible
              unless given a different color than the surroundings),
            - FL_RSHADOW_BOX (A rounded box with a shadow),
            - FL_OVAL_BOX (A box shaped like an ellipse),
            - FL_ROUNDED3D_UPBOX (A rounded box coming out of the screen),
            - FL_ROUNDED3D_DOWNBOX (A rounded box going into the screen),
            - FL_OVAL3D_UPBOX (An oval box coming out of the screen),
            - FL_OVAL3D_DOWNBOX (An oval box going into the screen),
            - FL_OVAL3D_FRAMEBOX (An oval box with an engraved frame),
            - FL_OVAL3D_EMBOSSEDBOX (An oval box with an embossed frame)
        width : int
            width of the new form in coord units
        height : int
            height of the new form in coord units

    Returns
    -------
        ptr_flform : pointer to xfdata.FL_FORM
            form to be defined

    Examples
    --------
        >>> pform0 = fl_bgn_form(xfdata.FL_UP_BOX, 400, 500)

    Notes
    -----
        Status: UnitTest + Doc + Demo = OK

    """
    _fl_bgn_form = library.cfuncproto(
        library.load_so_libforms(), "fl_bgn_form", \
        cty.POINTER(xfdata.FL_FORM), [cty.c_int, xfdata.FL_Coord,
        xfdata.FL_Coord],
        """FL_FORM * fl_bgn_form(int type, FL_Coord w, FL_Coord h) """)
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(boxtype, xfdata.BOXTYPE_list)
    i_boxtype = library.convert_to_intc(boxtype)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(boxtype, i_boxtype, width, i_width, height, \
            i_height)
    retval = _fl_bgn_form(i_boxtype, i_width, i_height)
    return retval


def fl_end_form():
    """fl_end_form()

    Ends the definition for a form call, after all needed flobjects have
    been added to a form call.

    Examples
    --------
        >>> fl_end_form()

    Notes
    -----
        Status: UnitTest + Doc + Demo = OK

    """
    _fl_end_form = library.cfuncproto(
        library.load_so_libforms(), "fl_end_form", \
        None, [], \
        """void fl_end_form() """)
    library.check_if_flinitialized()
    _fl_end_form()


def fl_do_forms():
    """fl_do_forms() -> ptr_flobject

    Starts the main loop of the program and returns only when the state
    of a xfdata.FL_OBJECT (that has no callback bound to it) changes.

    Returns
    -------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            changed flobject

    Examples
    --------
        >>> while fl_do_forms():
        >>> ... pass

    Notes
    -----
        Status: UnitTest + Doc + Demo = OK

    """
    _fl_do_forms = library.cfuncproto(
        library.load_so_libforms(), "fl_do_forms", \
        cty.POINTER(xfdata.FL_OBJECT), [], \
        """FL_OBJECT * fl_do_forms() """)
    library.check_if_flinitialized()
    retval = _fl_do_forms()
    return retval


def fl_check_forms():
    """fl_check_forms() -> ptr_flobject

    Returns None immediately unless the state of one of xfdata.FL_OBJECT
    (without a callback bound to it) changed.

    Returns
    -------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject changed

    Examples
    --------
        >>> pobj = fl_check_forms()

    Notes
    -----
        Status: UnitTest + Doc + Demo = OK

    """
    _fl_check_forms = library.cfuncproto(
        library.load_so_libforms(), "fl_check_forms", \
        cty.POINTER(xfdata.FL_OBJECT), [], \
        """FL_OBJECT * fl_check_forms() """)
    library.check_if_flinitialized()
    retval = _fl_check_forms()
    return retval


def fl_do_only_forms():
    """fl_do_only_forms() -> ptr_flobject

    Starts the main loop of the program and returns only when the state
    of a flobject changes that has no callback bound to it. It does not
    handle user events generated by application windows opened via
    fl_winopen() or similar routines.

    Returns
    -------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            changed flobject

    Examples
    --------
        >>> pobj = fl_do_only_forms()

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_do_only_forms = library.cfuncproto(
        library.load_so_libforms(), "fl_do_only_forms", \
        cty.POINTER(xfdata.FL_OBJECT), [], \
        """FL_OBJECT * fl_do_only_forms() """)
    library.check_if_flinitialized()
    retval = _fl_do_only_forms()
    return retval


def fl_check_only_forms():
    """fl_check_only_forms() -> ptr_flobject

    Returns None immediately unless the state of one of the flobject
    (without a callback bound to it) changed. It does not handle user
    events generated by application windows opened via fl_winopen()
    or similar routines.

    Returns
    -------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            changed flobject

    Examples
    --------
        >>> pobj = fl_check_only_forms()

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_check_only_forms = library.cfuncproto(
        library.load_so_libforms(), "fl_check_only_forms", \
        cty.POINTER(xfdata.FL_OBJECT), [], \
        """FL_OBJECT * fl_check_only_forms() """)
    library.check_if_flinitialized()
    retval = _fl_check_only_forms()
    return retval


def fl_freeze_form(ptr_flform):
    """fl_freeze_form()

    Redraw of a form is temporarily suspended, while changes are being
    made, so all changes made are instead buffered internally.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form not to be re-drawn temporarily

    Examples
    --------
        >>> fl_freeze_form(pform1)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_freeze_form = library.cfuncproto(
        library.load_so_libforms(), "fl_freeze_form", \
        None, [cty.POINTER(xfdata.FL_FORM)], \
        """void fl_freeze_form(FL_FORM * form) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    _fl_freeze_form(ptr_flform)


def fl_set_focus_object(ptr_flform, ptr_flobject):
    """fl_set_focus_object(ptr_flform, ptr_flobject)

    Defines the input focus in form to flobject.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form whose flobject has to be focused
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be focused

    Examples
    --------
        >>> fl_set_focus_object(pform0, pobj0)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_focus_object = library.cfuncproto(
        library.load_so_libforms(), "fl_set_focus_object", \
        None, [cty.POINTER(xfdata.FL_FORM), cty.POINTER(xfdata.FL_OBJECT)],
        """void fl_set_focus_object(FL_FORM * form, FL_OBJECT * obj) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flform, ptr_flobject)
    _fl_set_focus_object(ptr_flform, ptr_flobject)


fl_set_object_focus = fl_set_focus_object


def fl_get_focus_object(ptr_flform):
    """fl_get_focus_object(ptr_flform) -> ptr_flobject

    Finds out the flobject that has the focus on a form.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form that has a focused flobject in

    Returns
    -------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            focused flobject

    Examples
    --------
        >>> pobj2 = fl_get_focus_object(pform1)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_focus_object = library.cfuncproto(
        library.load_so_libforms(), "fl_get_focus_object", \
        cty.POINTER(xfdata.FL_OBJECT), [cty.POINTER(xfdata.FL_FORM)], \
        """FL_OBJECT * fl_get_focus_object(FL_FORM * form) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    retval = _fl_get_focus_object(ptr_flform)
    return retval


def fl_reset_focus_object(ptr_flobject):
    """fl_reset_focus_object(ptr_flobject)

    Resets focus on current flobject, overriding the xfdata.FL_UNFOCUS
    event.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject towards applying event

    Examples
    --------
        >>> fl_reset_focus_object(pobj2)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_reset_focus_object = library.cfuncproto(
        library.load_so_libforms(), "fl_reset_focus_object", \
        None, [cty.POINTER(xfdata.FL_OBJECT)], \
        """void fl_reset_focus_object(FL_OBJECT * ob) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    _fl_reset_focus_object(ptr_flobject)


def fl_set_form_atclose(ptr_flform, pyfn_FormAtclose, userdata):
    """fl_set_form_atclose(ptr_flform, pyfn_FormAtclose, userdata)
    -> FormAtclose

    Calls a callback function before closing the form.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form that receives the message
        pyfn_FormAtclose : python callback to be called, returned value
            name referring to function(ptr_flform, [pointer to void]pvdata)
             -> [int]num
        userdata : any type (e.g. None, int, str, etc..)
            user data to be passed to function; invoked callback has to take
            care of type check and re-cast from ptr_void to chosen type using
            appropriate xfstruct.convert_ptrvoid_to_*() function

    Returns
    -------
        FormAtclose : xfdata.FL_FORM_ATCLOSE
            old form atclose function

    Examples
    --------
        >>> def atclosecb(pform, pvdata):
        >>> ... <something>
        >>> ... return 0
        >>> oldatclosecb = fl_set_form_atclose(pform1, atclosecb, None)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    # FL_FORM_ATCLOSE = cty.CFUNCTYPE(cty.c_int, cty.POINTER(xfdata.FL_FORM),
    #                                 cty.c_void_p)
    _fl_set_form_atclose = library.cfuncproto(
        library.load_so_libforms(), "fl_set_form_atclose", \
        xfdata.FL_FORM_ATCLOSE, [cty.POINTER(xfdata.FL_FORM), \
        xfdata.FL_FORM_ATCLOSE, cty.c_void_p], \
        """FL_FORM_ATCLOSE fl_set_form_atclose(FL_FORM * form,
           FL_FORM_ATCLOSE fmclose, void * data) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.verify_function_type(pyfn_FormAtclose)
    cfn_FormAtclose = xfdata.FL_FORM_ATCLOSE(pyfn_FormAtclose)
    ptr_vdata = library.convert_userdata_to_ptrvoid(userdata)
    library.keep_cfunc_refs(cfn_FormAtclose, pyfn_FormAtclose)
    library.keep_elem_refs(ptr_flform, userdata, ptr_vdata)
    retval = _fl_set_form_atclose(ptr_flform, cfn_FormAtclose, ptr_vdata)
    return retval


def fl_set_atclose(pyfn_FormAtclose, userdata):
    """fl_set_atclose(pyfn_FormAtclose, userdata) -> FormAtclose

    Calls a callback function before terminating the application.

    Parameters
    ----------
        pyfn_FormAtclose : python callback to be called, returned value
            name referring to function(ptr_flform, [pointer to void]pvdata)
             -> [int]num
        userdata : any type (e.g. None, int, str, etc..)
            user data to be passed to function; invoked callback has to take
            care of type check and re-cast from ptr_void to chosen type using
            appropriate xfstruct.convert_ptrvoid_to_*() function

    Returns
    -------
        FormAtclose : xfdata.FL_FORM_ATCLOSE
            old form atclose function

    Examples
    --------
        >>> def atclosecb(pform, vdata):
        >>> ... <something>
        >>> ... return 0
        >>> oldatclosefunc = fl_set_atclose(pform1, atclosecb, None)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    # FL_FORM_ATCLOSE = cty.CFUNCTYPE(cty.c_int, cty.POINTER(xfdata.FL_FORM), \
    #                                 cty.c_void_p)
    _fl_set_atclose = library.cfuncproto(
        library.load_so_libforms(), "fl_set_atclose", \
        xfdata.FL_FORM_ATCLOSE, [xfdata.FL_FORM_ATCLOSE, cty.c_void_p], \
        """FL_FORM_ATCLOSE fl_set_atclose(FL_FORM_ATCLOSE fmclose,
           void * data) """)
    library.check_if_flinitialized()
    library.verify_function_type(pyfn_FormAtclose)
    cfn_FormAtclose = xfdata.FL_FORM_ATCLOSE(pyfn_FormAtclose)
    ptr_vdata = library.convert_userdata_to_ptrvoid(userdata)
    library.keep_cfunc_refs(cfn_FormAtclose, pyfn_FormAtclose)
    library.keep_elem_refs(userdata, ptr_vdata)
    retval = _fl_set_atclose(cfn_FormAtclose, ptr_vdata)
    return retval


def fl_set_form_atactivate(ptr_flform, pyfn_FormAtactivate, userdata):
    """fl_set_form_atactivate(ptr_flform, pyfn_FormAtactivate, userdata)
    -> FormAtactivate

    Registers a callback that is called when activation status of a forms
    is enabled.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            activated form
        pyfn_FormAtactivate : python callback function called, no return
            name referring to function(ptr_flform, [pointer to void]pvdata)
        userdata : any type (e.g. None, int, str, etc..)
            user data to be passed to function; invoked callback has to take
            care of type check and re-cast from ptr_void to chosen type using
            appropriate xfstruct.convert_ptrvoid_to_*() function

    Return
    ------
        FormAtactivate : xfdata.FL_FORM_ATACTIVATE
            old form atactivate function

    Examples
    --------
        >>> def atactcb(pform, pvdata):
        >>> ... <something>
        >>> oldactfunc = fl_set_form_atdeactivate(pform0, atactcb, None)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    #FL_FORM_ATACTIVATE = cty.CFUNCTYPE(None, cty.POINTER(xfdata.FL_FORM), \
    #                                   cty.c_void_p)
    _fl_set_form_atactivate = library.cfuncproto(
        library.load_so_libforms(), "fl_set_form_atactivate", \
        xfdata.FL_FORM_ATACTIVATE, [cty.POINTER(xfdata.FL_FORM),
        xfdata.FL_FORM_ATACTIVATE, cty.c_void_p], \
        """FL_FORM_ATACTIVATE fl_set_form_atactivate(FL_FORM * form,
           FL_FORM_ATACTIVATE cb, void * data) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.verify_function_type(pyfn_FormAtactivate)
    cfn_FormAtactivate = xfdata.FL_FORM_ATACTIVATE(pyfn_FormAtactivate)
    ptr_vdata = library.convert_userdata_to_ptrvoid(userdata)
    library.keep_cfunc_refs(cfn_FormAtactivate, pyfn_FormAtactivate)
    library.keep_elem_refs(ptr_flform, userdata, ptr_vdata)
    retval = _fl_set_form_atactivate(ptr_flform, cfn_FormAtactivate, \
            ptr_vdata)
    return retval


def fl_set_form_atdeactivate(ptr_flform, pyfn_FormAtdeactivate, userdata):
    """fl_set_form_atdeactivate(ptr_flform, pyfn_FormAtdeactivate, userdata)
    -> FormAtdeactivate

    Registers a callback that is called when activation status of a form
    is disabled.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            de-activated form
        pyfn_FormAtdeactivate : python callback function called, no return
            name referring to function(ptr_flform, [pointer to void]pvdata)
        userdata : any type (e.g. None, int, str, etc..)
            user data to be passed to function; invoked callback has to take
            care of type check and re-cast from ptr_void to chosen type using
            appropriate xfstruct.convert_ptrvoid_to_*() function

    Returns
    -------
        FormAtdeactivate : xfdata.FL_FORM_ATDEACTIVATE
            old FL_FORM_ATDEACTIVATE function

    Examples
    --------
        >>> def atdeactcb(pform, vdata):
        >>> ... <something>
        >>> oldatdeactfunc = xf.fl_set_form_atdeactivate(pform0,
                atdeactcb, None)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    #FL_FORM_ATDEACTIVATE = cty.CFUNCTYPE(None, cty.POINTER(xfdata.FL_FORM),
    #                         cty.c_void_p)
    _fl_set_form_atdeactivate = library.cfuncproto(
        library.load_so_libforms(), "fl_set_form_atdeactivate", \
        xfdata.FL_FORM_ATDEACTIVATE, [cty.POINTER(xfdata.FL_FORM),
        xfdata.FL_FORM_ATDEACTIVATE, cty.c_void_p], \
        """FL_FORM_ATDEACTIVATE fl_set_form_atdeactivate(FL_FORM * form,
           FL_FORM_ATDEACTIVATE cb, void * data) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.verify_function_type(pyfn_FormAtdeactivate)
    cfn_FormAtdeactivate = xfdata.FL_FORM_ATDEACTIVATE( \
            pyfn_FormAtdeactivate)
    ptr_vdata = library.convert_userdata_to_ptrvoid(userdata)
    library.keep_cfunc_refs(cfn_FormAtdeactivate, pyfn_FormAtdeactivate)
    library.keep_elem_refs(ptr_flform, userdata, ptr_vdata)
    retval = _fl_set_form_atdeactivate(ptr_flform, cfn_FormAtdeactivate, \
            ptr_vdata)
    return retval


def fl_unfreeze_form(ptr_flform):
    """fl_unfreeze_form(ptr_flform)

    Reverts previous freeze, set with fl_freeze_form(); all changes made in
    the meantime in a form are drawn at once.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to be re-drawn after freezing

    Examples
    --------
        >>> fl_unfreeze_form(pform0)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_unfreeze_form = library.cfuncproto(
        library.load_so_libforms(), "fl_unfreeze_form", \
        None, [cty.POINTER(xfdata.FL_FORM)], \
        """void fl_unfreeze_form(FL_FORM * form) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    _fl_unfreeze_form(ptr_flform)


def fl_deactivate_form(ptr_flform):
    """fl_deactivate_form(ptr_flform)

    Deactivates form temporarily, without hiding it, but not allowing a
    user to interact with elements contained in form (buttons, etc.).

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to be de-activated

    Examples
    --------
        >>> fl_deactivate_form(pform0)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_deactivate_form = library.cfuncproto(
        library.load_so_libforms(), "fl_deactivate_form", \
        None, [cty.POINTER(xfdata.FL_FORM)], \
        """void fl_deactivate_form(FL_FORM * form) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    _fl_deactivate_form(ptr_flform)


def fl_activate_form(ptr_flform):
    """fl_activate_form(ptr_flform)

    (Re)activates form (deactivated with fl_deactivate_form), allowing
    the user to interact again with elements contained in form (buttons,
    etc.).

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to be re-activated

    Examples
    --------
        >>> fl_activate_form(pform0)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_activate_form = library.cfuncproto(
        library.load_so_libforms(), "fl_activate_form", \
        None, [cty.POINTER(xfdata.FL_FORM)], \
        """void fl_activate_form(FL_FORM * form) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    _fl_activate_form(ptr_flform)


def fl_deactivate_all_forms():
    """fl_deactivate_all_forms()

    De-activates all current forms, forbidding any event/user interaction.

    Examples
    --------
        >>> fl_deactivate_all_forms()

    Notes
    -----
        Status: NN-UTest + Doc + NoDemo = Maybe

    """
    _fl_deactivate_all_forms = library.cfuncproto(
        library.load_so_libforms(), "fl_deactivate_all_forms", \
        None, [], \
        """void fl_deactivate_all_forms() """)
    library.check_if_flinitialized()
    _fl_deactivate_all_forms()


def fl_activate_all_forms():
    """fl_activate_all_forms()

    (Re)activates all current forms, allowing event/user interaction.

    Examples
    --------
        >>> fl_activate_all_forms()

    Notes
    -----
        Status: NN-UTest + Doc + NoDemo = Maybe

    """
    _fl_activate_all_forms = library.cfuncproto(
        library.load_so_libforms(), "fl_activate_all_forms", \
        None, [], \
        """void fl_activate_all_forms() """)
    library.check_if_flinitialized()
    _fl_activate_all_forms()


def fl_freeze_all_forms():
    """fl_freeze_all_forms()

    All current forms are not temporarily redrawn, while changes
    are being made and are instead buffered internally.

    Examples
    --------
        >>> fl_freeze_all_forms()

    Notes
    -----
        Status: NN-UTest + Doc + NoDemo = Maybe

    """
    _fl_freeze_all_forms = library.cfuncproto(
        library.load_so_libforms(), "fl_freeze_all_forms", \
        None, [], \
        """void fl_freeze_all_forms() """)
    library.check_if_flinitialized()
    _fl_freeze_all_forms()


def fl_unfreeze_all_forms():
    """fl_unfreeze_all_forms()

    All changes made in the meantime in all current forms are drawn
    at once, reverting previous freeze.

    Examples
    --------
        >>> fl_unfreeze_all_forms()

    Notes
    -----
        Status: NN-UTest + Doc + NoDemo = Maybe

    """
    _fl_unfreeze_all_forms = library.cfuncproto(
        library.load_so_libforms(), "fl_unfreeze_all_forms", \
        None, [], \
        """void fl_unfreeze_all_forms() """)
    library.check_if_flinitialized()
    _fl_unfreeze_all_forms()


def fl_scale_form(ptr_flform, xscale, yscale):
    """fl_scale_form(ptr_flform, xscale, yscale)

    Scales a form and the flobjects on it in size and position, indicating
    a scaling factor in x- and y-direction (1.1 = 110 percent, 0.5 = 50,
    etc.) with respect to the current size, and reshapes the window.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to be scaled
        xscale : float
            scaling factor in horizontal direction
        yscale : float
            scaling factor in vertical direction

    Examples
    --------
        >>> fl_scale_form(pform0, 0.8, 1.2)

    Notes
    -----
        Status: UnitTest + Doc + Demo = OK

    """
    _fl_scale_form = library.cfuncproto(
        library.load_so_libforms(), "fl_scale_form", \
        None, [cty.POINTER(xfdata.FL_FORM), cty.c_double, cty.c_double], \
        """void fl_scale_form(FL_FORM * form, double xsc, double ysc) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    f_xscale = library.convert_to_doublec(xscale)
    f_yscale = library.convert_to_doublec(yscale)
    library.keep_elem_refs(ptr_flform, xscale, f_xscale, yscale, f_yscale)
    _fl_scale_form(ptr_flform, f_xscale, f_yscale)


def fl_set_form_position(ptr_flform, xpos, ypos):
    """fl_set_form_position(ptr_flform, xpos, ypos)

    Defines position of form, when placing a form on the screen with
    xfdata.FL_PLACE_GEOMETRY as place argument.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form whose position is to be set
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)

    Examples
    --------
        >>> fl_set_form_position(pform0, 125, 250)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_form_position = library.cfuncproto(
        library.load_so_libforms(), "fl_set_form_position", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_set_form_position(FL_FORM * form, FL_Coord x,
           FL_Coord y) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    library.keep_elem_refs(ptr_flform, xpos, i_xpos, ypos, i_ypos)
    _fl_set_form_position(ptr_flform, i_xpos, i_ypos)


def fl_set_form_title(ptr_flform, title):
    """fl_set_form_title(ptr_flform, title)

    Changes the form title (and the icon name) after it is shown.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form whose title has to be changed
        title : str
            new title text for the form

    Examples
    --------
        >>> fl_set_form_title(pform0, "My great form")

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_form_title = library.cfuncproto(
        library.load_so_libforms(), "fl_set_form_title", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.STRING], \
        """void fl_set_form_title(FL_FORM * form, const char * name) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    s_title = library.convert_to_stringc(title)
    library.keep_elem_refs(ptr_flform, title, s_title)
    _fl_set_form_title(ptr_flform, s_title)


def fl_set_app_mainform(ptr_flform):
    """fl_set_app_mainform(ptr_flform)

    Designates the main form. By default, the main form is set
    automatically by the library to the first full-bordered form shown.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to be set as main one

    Examples
    --------
        >>> fl_set_app_mainform(pform2)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_app_mainform = library.cfuncproto(
        library.load_so_libforms(), "fl_set_app_mainform",
        None, [cty.POINTER(xfdata.FL_FORM)], \
        """void fl_set_app_mainform(FL_FORM * form) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    _fl_set_app_mainform(ptr_flform)


def fl_get_app_mainform():
    """fl_get_app_mainform() -> ptr_flform

    Finds out the current mainform.

    Returns
    -------
        ptr_flform : pointer to xfdata.FL_FORM
            main form

    Examples
    --------
        >>> pform2 = fl_get_app_mainform()

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_app_mainform = library.cfuncproto(
        library.load_so_libforms(), "fl_get_app_mainform",
        cty.POINTER(xfdata.FL_FORM), [], \
        """FL_FORM * fl_get_app_mainform() """)
    library.check_if_flinitialized()
    retval = _fl_get_app_mainform()
    return retval


def fl_set_app_nomainform(yesno):
    """fl_set_app_nomainform(yesno)

    In some situations, either because the concept of an application
    main form does not apply (for example, an application might have
    multiple full-bordered windows), or under some (buggy) window
    managers, the designation of a main form may cause stacking order
    problems. To workaround these, it can disable the designation of
    a main form (must be called before any full-bordered form is shown).

    Parameters
    ----------
        yesno : int
            flag to disable/enable mainform designation. Values 1 (to
            disable) or 0 (to enable)

    Examples
    --------
        >>> fl_set_app_nomainform(1)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_app_nomainform = library.cfuncproto(
        library.load_so_libforms(), "fl_set_app_nomainform",
        None, [cty.c_int], \
        """void fl_set_app_nomainform(int flag) """)
    library.check_if_flinitialized()
    i_yesno = library.convert_to_intc(yesno)
    library.keep_elem_refs(yesno, i_yesno)
    _fl_set_app_nomainform(i_yesno)


def fl_set_form_callback(ptr_flform, pyfn_FormCallbackPtr, userdata):
    """fl_set_form_callback(ptr_flform, pyfn_FormCallbackPtr, userdata)

    Defines the callback function bound to an entire form. Whenever
    fl_do_forms() or fl_check_forms() would return a flobject in form they
    call the routine callback instead, with the flobject as an argument.
    So with each form you can associate its own callback routine. For
    flobjects that have their own callbacks, the flobject callbacks have
    priority over the form callback.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form whose callback has to be set
        pyfn_FormCallbackPtr : python callback to be set, no return
            name referring to function(ptr_flobject, [pointer to void]pvdata)
        userdata : any type (e.g. None, int, str, etc..)
            user data to be passed to function; invoked callback has to take
            care of type check and re-cast from ptr_void to chosen type using
            appropriate xfstruct.convert_ptrvoid_to_*() function

    Examples
    --------
        >>> def formcb(pobj, pvdata):
        >>> ... <something>
        >>> fl_set_form_callback(pform0, formcb, None)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    #FL_FORMCALLBACKPTR = cty.CFUNCTYPE(None, cty.POINTER(xfdata.FL_OBJECT),
    #                                   cty.c_void_p)
    _fl_set_form_callback = library.cfuncproto(
        library.load_so_libforms(), "fl_set_form_callback", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.FL_FORMCALLBACKPTR, \
        cty.c_void_p], \
        """void fl_set_form_callback(FL_FORM * form,
           FL_FORMCALLBACKPTR callback, void * d) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.verify_function_type(pyfn_FormCallbackPtr)
    cfn_FormCallbackPtr = xfdata.FL_FORMCALLBACKPTR(pyfn_FormCallbackPtr)
    ptr_vdata = library.convert_userdata_to_ptrvoid(userdata)
    library.keep_cfunc_refs(cfn_FormCallbackPtr, pyfn_FormCallbackPtr)
    library.keep_elem_refs(ptr_flform, userdata, ptr_vdata)
    _fl_set_form_callback(ptr_flform, cfn_FormCallbackPtr, ptr_vdata)


fl_set_form_call_back = fl_set_form_callback


def fl_set_form_size(ptr_flform, width, height):
    """fl_set_form_size(ptr_flform, width, height)

    Defines the size of form.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form whose size has to be set
        width : int
            width of form in coord units
        height : int
            height of form in coord units

    Examples
    --------
        >>> fl_set_form_size(pform, 200, 200)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_form_size = library.cfuncproto(
        library.load_so_libforms(), "fl_set_form_size", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.FL_Coord,
        xfdata.FL_Coord], \
        """void fl_set_form_size(FL_FORM * form, FL_Coord w, FL_Coord h)""")
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(ptr_flform, width, i_width, height, i_height)
    _fl_set_form_size(ptr_flform, i_width, i_height)


def fl_set_form_hotspot(ptr_flform, xpos, ypos):
    """fl_set_form_hotspot(ptr_flform, xpos, ypos)

    Defines the position of the hotspot, for showing a form so
    that a particular point is under the mouse. You have to use
    xfdata.FL_PLACE_HOTSPOT as place argument in fl_show_form().

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to be set
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)

    Examples
    --------
        >>> fl_set_form_hotspot(pform3, 300, 50)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_form_hotspot = library.cfuncproto(
        library.load_so_libforms(), "fl_set_form_hotspot", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.FL_Coord,
        xfdata.FL_Coord], \
        """void fl_set_form_hotspot(FL_FORM * form, FL_Coord x,
           FL_Coord y) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    library.keep_elem_refs(ptr_flform, xpos, i_xpos, ypos, i_ypos)
    _fl_set_form_hotspot(ptr_flform, i_xpos, i_ypos)


def fl_set_form_hotobject(ptr_flform, ptr_flobject):
    """fl_set_form_hotobject(ptr_flform, ptr_flobject)

    Defines the hotspot for showing a form so that a particular flobject
    is under the mouse. You have to use xfdata.FL_PLACE_HOTSPOT as
    place argument in fl_show_form().

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form whose flobject has to be set
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set

    Examples
    --------
        >>> fl_set_form_hotobject(pform0, pobj)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_form_hotobject = library.cfuncproto(
        library.load_so_libforms(), "fl_set_form_hotobject", \
        None, [cty.POINTER(xfdata.FL_FORM), cty.POINTER(xfdata.FL_OBJECT)],
        """void fl_set_form_hotobject(FL_FORM * form, FL_OBJECT * ob) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flform, ptr_flobject)
    _fl_set_form_hotobject(ptr_flform, ptr_flobject)


def fl_set_form_minsize(ptr_flform, width, height):
    """fl_set_form_minsize(ptr_flform, width, height)

    Defines the minimum size a form can have, if interactive resizing is
    allowed (e.g., by showing the form with xfdata.FL_PLACE_POSITION).

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form
        width : int
            width of form in coord units
        height : int
            height of form in coord units

    Examples
    --------
        >>> fl_set_form_minsize(pform0, 200, 300)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_form_minsize = library.cfuncproto(
        library.load_so_libforms(), "fl_set_form_minsize", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.FL_Coord,
        xfdata.FL_Coord],
        """void fl_set_form_minsize(FL_FORM * form, FL_Coord w,
           FL_Coord h) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(ptr_flform, width, i_width, height, i_height)
    _fl_set_form_minsize(ptr_flform, i_width, i_height)


def fl_set_form_maxsize(ptr_flform, width, height):
    """fl_set_form_maxsize(ptr_flform, width, height)

    Defines the maximum size a form can have, if interactive resizing is
    allowed (e.g. by showing the form with xfdata.FL_PLACE_POSITION).

    Parameters
    ----------
        ptr_flform : pointer to xdata.FL_FORM
            form whose size has to be set
        width : int
            width of form in coord units
        height : int
            height of form in coord units

    Examples
    --------
        >>> fl_set_form_maxsize(pform0, 400, 450)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_form_maxsize = library.cfuncproto(
        library.load_so_libforms(), "fl_set_form_maxsize", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.FL_Coord,
        xfdata.FL_Coord], \
        """void fl_set_form_maxsize(FL_FORM * form, FL_Coord w,
           FL_Coord h) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(ptr_flform, width, i_width, height, i_height)
    _fl_set_form_maxsize(ptr_flform, i_width, i_height)


# TODO: find if key mask have to be included
def fl_set_form_event_cmask(ptr_flform, cmask):
    """fl_set_form_event_cmask(ptr_flform, cmask)

    Defines the event compress mask a form can react to.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to be set
        cmask : long_pos
            event compress mask for form. Values (from xfdata.py) one or
            more OR-ed between NoEventMask, KeyPressMask, KeyReleaseMask,
            ButtonPressMask, ButtonReleaseMask, EnterWindowMask,
            LeaveWindowMask, PointerMotionMask, PointerMotionHintMask,
            Button1MotionMask, Button2MotionMask, Button3MotionMask,
            Button4MotionMask, Button5MotionMask, ButtonMotionMask,
            KeymapStateMask, ExposureMask, VisibilityChangeMask,
            StructureNotifyMask, ResizeRedirectMask, SubstructureNotifyMask,
            SubstructureRedirectMask, FocusChangeMask, ColormapChangeMask,
            OwnerGrabButtonMask, FL_ALL_EVENT, ... ?

    Examples
    --------
        >>> fl_set_form_event_cmask(pform0, xfdata.FL_ALL_EVENT)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_form_event_cmask = library.cfuncproto(
        library.load_so_libforms(), "fl_set_form_event_cmask", \
        None, [cty.POINTER(xfdata.FL_FORM), cty.c_ulong], \
        """void fl_set_form_event_cmask(FL_FORM * form,
           long unsigned int cmask) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    ul_cmask = library.convert_to_ulongc(cmask)
    library.keep_elem_refs(ptr_flform, cmask, ul_cmask)
    _fl_set_form_event_cmask(ptr_flform, ul_cmask)


def fl_get_form_event_cmask(ptr_flform):
    """fl_get_form_event_cmask(ptr_flform) -> cmask

    Finds out event compress mask a form can react to.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to evaluate

    Returns
    -------
        cmask : long_pos
            event compress mask id

    Examples
    --------
        >>> cmaskid = fl_get_form_event_cmask(pform0)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_form_event_cmask = library.cfuncproto(
        library.load_so_libforms(), "fl_get_form_event_cmask", \
        cty.c_ulong, [cty.POINTER(xfdata.FL_FORM)], \
        """long unsigned int fl_get_form_event_cmask(FL_FORM * form)""")
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    retval = _fl_get_form_event_cmask(ptr_flform)
    return retval


def fl_set_form_geometry(ptr_flform, xpos, ypos, width, height):
    """fl_set_form_geometry(ptr_flform, xpos, ypos, width, height)

    Defines the geometry (position and size) of a form.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            pointer to form to be set
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width of form in coord units
        height : int
            height of form in coord units

    Examples
    --------
        >>> fl_set_form_geometry(pform0, 300, 400, 150, 150)

    Notes
    -----
        Status: NA-UTested + Doc + Demo = OK

    """
    _fl_set_form_geometry = library.cfuncproto(
        library.load_so_libforms(), "fl_set_form_geometry", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord], \
        """void fl_set_form_geometry(FL_FORM * form, FL_Coord x,
           FL_Coord y, FL_Coord w, FL_Coord h) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(ptr_flform, xpos, i_xpos, ypos, i_ypos, width, \
            i_width, height, i_height)
    _fl_set_form_geometry(ptr_flform, i_xpos, i_ypos, i_width, i_height)


fl_set_initial_placement = fl_set_form_geometry


def fl_show_form(ptr_flform, place, border, title):
    """fl_show_form(ptr_flform, place, border, title) -> win

    Shows the form.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to be shown
        place : int
            where form has to be placed. Values (from xfdata.py)
            FL_PLACE_FREE, FL_PLACE_MOUSE, FL_PLACE_CENTER,
            FL_PLACE_POSITION, FL_PLACE_SIZE, FL_PLACE_GEOMETRY,
            FL_PLACE_ASPECT, FL_PLACE_FULLSCREEN, FL_PLACE_HOTSPOT,
            FL_PLACE_ICONIC, FL_FREE_SIZE, FL_PLACE_FREE_CENTER,
            FL_PLACE_CENTERFREE, FL_PLACE_MOUSE|FL_FREE_SIZE,
            FL_PLACE_FULLSCREEN|FL_FREE_SIZE, FL_PLACE_HOTSPOT|FL_FREE_SIZE
        border : int
            window manager decoration. Values (from xfdata.py)
            - FL_FULLBORDER (normal, draw full border with title),
            - FL_TRANSIENT (draws borders with possibly less decoration,
              depends on the window managers behaviour. You might not be able
              to iconify a form under some WMs),
            - FL_NOBORDER (Draw no border at all. You cannot iconify a form
              with no borders)
        title : str
            title of form

    Returns
    -------
        win : long_pos
            window id

    Examples
    --------
        >>> wind = fl_show_form(pform0, FL_PLACE_FREE, FL_FULLBORDER,
                "MyForm")

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_show_form = library.cfuncproto(
        library.load_so_libforms(), "fl_show_form",
        xfdata.Window, [cty.POINTER(xfdata.FL_FORM), cty.c_int, cty.c_int,
        xfdata.STRING], \
        """Window fl_show_form(FL_FORM * form, int place, int border,
           const char * name) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.checkfatal_allowed_value_in_list(place, xfdata.PLACE_list)
    i_place = library.convert_to_intc(place)
    library.checkfatal_allowed_value_in_list(border, \
            xfdata.DECORATION_list)
    i_border = library.convert_to_intc(border)
    s_title = library.convert_to_stringc(title)
    library.keep_elem_refs(ptr_flform, place, i_place, border, i_border, \
            title, s_title)
    retval = _fl_show_form(ptr_flform, i_place, i_border, s_title)
    return retval


def fl_hide_form(ptr_flform):
    """fl_hide_form(ptr_flform)

    Hides the form.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to be hidden

    Examples
    --------
        >>> fl_hide_form(pform0)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_hide_form = library.cfuncproto(
        library.load_so_libforms(), "fl_hide_form",
        None, [cty.POINTER(xfdata.FL_FORM)], \
        """void fl_hide_form(FL_FORM * form) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    _fl_hide_form(ptr_flform)


def fl_free_form(ptr_flform):
    """fl_free_form(ptr_flform)

    Frees the memory used by a form, hiding and deleting it together
    with all its flobjects.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to be freed

    Examples
    --------
        >>> fl_free_form(pform0)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_free_form = library.cfuncproto(
        library.load_so_libforms(), "fl_free_form",
        None, [cty.POINTER(xfdata.FL_FORM)], \
        """void fl_free_form(FL_FORM * form) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    _fl_free_form(ptr_flform)


def fl_redraw_form(ptr_flform):
    """fl_redraw_form(ptr_flform)

    (Re)draws an entire form.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to redraw

    Examples
    --------
        >>> fl_redraw_form(pform0)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_redraw_form = library.cfuncproto(
        library.load_so_libforms(), "fl_redraw_form",
        None, [cty.POINTER(xfdata.FL_FORM)], \
        """void fl_redraw_form(FL_FORM * form) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    _fl_redraw_form(ptr_flform)


def fl_set_form_dblbuffer(ptr_flform, yesno):
    """fl_set_form_dblbuffer(ptr_flform, yesno)

    Uses double buffering on a per-form basis. Since Xlib does not
    support double buffering, XForms library simulates this functionality
    with pixmap bit-bliting. In practice, the effect is hardly
    distinguishable from double buffering and performance is on par with
    multi-buffering extensions (it is slower than drawing into a window
    directly on most workstations however). Bear in mind that a pixmap
    can be resource hungry, so use this option with discretion.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to set
        yesno : int
            flag to disable/enable doublebuffer. Values 0 (disabled)
            or 1 (enabled)

    Examples
    --------
        >>> fl_set_form_dblbuffer(1)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_form_dblbuffer = library.cfuncproto(
        library.load_so_libforms(), "fl_set_form_dblbuffer", \
        None, [cty.POINTER(xfdata.FL_FORM), cty.c_int], \
        """void fl_set_form_dblbuffer(FL_FORM * form, int y) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    i_yesno = library.convert_to_intc(yesno)
    library.keep_elem_refs(ptr_flform, yesno, i_yesno)
    _fl_set_form_dblbuffer(ptr_flform, i_yesno)


def fl_prepare_form_window(ptr_flform, place, border, title):
    """fl_prepare_form_window(ptr_flform, place, border, title) -> win

    Creates a window that obeys any and all constraints just as
    fl_show_form() does but remains unmapped (not shown), returning its
    window handle. You need fl_show_form_window() after to show it.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to display
        place : int
            where has to be placed. Values (from xfdata.py) FL_PLACE_FREE,
            FL_PLACE_MOUSE, FL_PLACE_CENTER, FL_PLACE_POSITION,
            FL_PLACE_SIZE, FL_PLACE_GEOMETRY, FL_PLACE_ASPECT,
            FL_PLACE_FULLSCREEN, FL_PLACE_HOTSPOT, FL_PLACE_ICONIC,
            FL_FREE_SIZE, FL_PLACE_FREE_CENTER, FL_PLACE_CENTERFREE,
            FL_PLACE_MOUSE|FL_FREE_SIZE, FL_PLACE_FULLSCREEN|FL_FREE_SIZE,
            FL_PLACE_HOTSPOT|FL_FREE_SIZE
        border : int
            window manager decoration. Values (from xfdata.py)
            - FL_FULLBORDER (normal, draw full border with title),
            - FL_TRANSIENT (draws borders with possibly less decoration,
              depends on the window managers behaviour. You might not be able
              to iconify a form under some WMs),
            - FL_NOBORDER (Draw no border at all. You cannot iconify a form
              with no borders)
        title : str
            text title of form

    Returns
    -------
        win : long_pos
            window id

    Examples
    --------
        >>> wind = fl_prepare_form_window(pform2, FL_PLACE_FREE,
                FL_FULLBORDER, "MyForm")

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_prepare_form_window = library.cfuncproto(
        library.load_so_libforms(), "fl_prepare_form_window", \
        xfdata.Window, [cty.POINTER(xfdata.FL_FORM), cty.c_int, cty.c_int,
        xfdata.STRING], \
        """Window fl_prepare_form_window(FL_FORM * form, int place,
           int border, const char * name) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.checkfatal_allowed_value_in_list(place, xfdata.PLACE_list)
    i_place = library.convert_to_intc(place)
    library.checkfatal_allowed_value_in_list(border, \
            xfdata.DECORATION_list)
    i_border = library.convert_to_intc(border)
    s_title = library.convert_to_stringc(title)
    library.keep_elem_refs(ptr_flform, place, i_place, border, i_border, \
            title, s_title)
    retval = _fl_prepare_form_window(ptr_flform, i_place, i_border, \
            s_title)
    return retval


def fl_show_form_window(ptr_flform):
    """fl_show_form_window(ptr_flform) -> win

    Shows (maps) a window of form that has been created before
    with fl_prepare_form_window().

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form whose window has to be shown

    Returns
    -------
        win : long_pos
            window id

    Examples
    --------
        >>> win1 = fl_show_form_window(pform2)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_show_form_window = library.cfuncproto(
        library.load_so_libforms(), "fl_show_form_window", \
        xfdata.Window, [cty.POINTER(xfdata.FL_FORM)], \
        """Window fl_show_form_window(FL_FORM * form) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    retval = _fl_show_form_window(ptr_flform)
    return retval


def fl_adjust_form_size(ptr_flform):
    """fl_adjust_form_size(ptr_flform) -> maxfact

    Similar to fl_fit_object_label(), but will do it for all flobjects
    and has a smaller threshold. Mainly intended for compensation for
    font size variations.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form whose size has to be adjusted

    Returns
    -------
        maxfact : float
            max factor number

    Examples
    --------
        >>> mfactor = fl_adjust_form_size(pform)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_adjust_form_size = library.cfuncproto(
        library.load_so_libforms(), "fl_adjust_form_size", \
        cty.c_double, [cty.POINTER(xfdata.FL_FORM)], \
        """double fl_adjust_form_size(FL_FORM * form) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    retval = _fl_adjust_form_size(ptr_flform)
    return retval


def fl_form_is_visible(ptr_flform):
    """fl_form_is_visible(ptr_flform) -> visibstate

    Tells if form is visible or not.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to evaluate

    Returns
    -------
        visibstate : int
            visibility state, or FL_INVISIBLE (on failure)
            Values (from xfdata.py)
            FL_BEING_HIDDEN (The forms is visible but is in the process
            of being hidden), FL_HIDDEN or FL_INVISIBLE (The form is not
            visible), FL_VISIBLE (The form is visible).

    Examples
    --------
        >>> visib = fl_form_is_visible(pform0)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_form_is_visible = library.cfuncproto(
        library.load_so_libforms(), "fl_form_is_visible", \
        cty.c_int, [cty.POINTER(xfdata.FL_FORM)], \
        """int fl_form_is_visible(FL_FORM * form) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    retval = _fl_form_is_visible(ptr_flform)
    return retval


def fl_form_is_iconified(ptr_flform):
    """fl_form_is_iconified(ptr_flform) -> icostate

    Tells if a form's window is in iconified state or not.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to evaluate

    Returns
    -------
        icostate : int
            iconic state (0 not iconified, non-zero iconified)

    Examples
    --------
        >>> iconif = fl_form_is_iconified(pform0)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_form_is_iconified = library.cfuncproto(
        library.load_so_libforms(), "fl_form_is_iconified", \
        cty.c_int, [cty.POINTER(xfdata.FL_FORM)], \
        """int fl_form_is_iconified(FL_FORM * form) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    retval = _fl_form_is_iconified(ptr_flform)
    return retval


def fl_register_raw_callback(ptr_flform, evmask, pyfn_RawCallback):
    """fl_register_raw_callback(ptr_flform, evmask, pyfn_RawCallback)
    -> RawCallback

    Registers preemptive event handlers. Only one handler is allowed
    for each event pair.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form
        evmask : long_pos
            key/button/window event mask (press, release, motion, enter,
            leave, etc..). Values (from xfdata.py) KeyPressMask and
            KeyReleaseMask, ButtonPressMask and ButtonReleaseMask,
            EnterWindowMask and LeaveWindowMask, ButtonMotionMask and
            PointerMotionMask, FL_ALL_EVENT
        pyfn_RawCallback : python callback function, returned value
            name referring to function(ptr_flform, ptr_xevent) -> [int]num
            function for handling a raw callback for X events

    Returns
    -------
        RawCallback : xfdata.FL_RAW_CALLBACK
            old xfdata.FL_RAW_CALLBACK function

    Examples
    --------
        >>> def rawcb(pform, pxev):
        >>> ... <something>
        >>> ... return 0
        >>> oldrawcb = fl_register_callback(pform3, xfdata.KeyPressMask,
                rawcb)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    #FL_RAW_CALLBACK = cty.CFUNCTYPE(cty.c_int, cty.POINTER(xfdata.FL_FORM), \
    #                                 cty.POINTER(xfdata.XEvent))
    _fl_register_raw_callback = library.cfuncproto(
        library.load_so_libforms(), "fl_register_raw_callback", \
        xfdata.FL_RAW_CALLBACK, [cty.POINTER(xfdata.FL_FORM), cty.c_ulong,
        xfdata.FL_RAW_CALLBACK], \
        """FL_RAW_CALLBACK fl_register_raw_callback(FL_FORM * form,
           long unsigned int mask, FL_RAW_CALLBACK rcb) """)
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    ul_evmask = library.convert_to_ulongc(evmask)
    library.verify_function_type(pyfn_RawCallback)
    cfn_RawCallback = xfdata.FL_RAW_CALLBACK(pyfn_RawCallback)
    library.keep_cfunc_refs(cfn_RawCallback, pyfn_RawCallback)
    library.keep_elem_refs(ptr_flform, evmask, ul_evmask)
    retval = _fl_register_raw_callback(ptr_flform, ul_evmask, \
            cfn_RawCallback)
    return retval


fl_register_call_back = fl_register_raw_callback


def fl_bgn_group():
    """fl_bgn_group()

    Starts a group of flobjects definition. Its purpose can be e.g. to
    define a series of flobjects to be hidden or deactivated or to
    define a series of radio buttons.

    Returns
    -------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            group to be started

    Examples
    --------
        >>> group0 = fl_bgn_group()

    Notes
    -----
        Status: NN-UTest + Doc + Demo = OK

    """
    _fl_bgn_group = library.cfuncproto(
        library.load_so_libforms(), "fl_bgn_group", \
        cty.POINTER(xfdata.FL_OBJECT), [], \
        """FL_OBJECT * fl_bgn_group() """)
    library.check_if_flinitialized()
    retval = _fl_bgn_group()
    return retval


def fl_end_group():
    """fl_end_group()

    Ends a group definition, previously started with fl_bgn_group().

    Examples
    --------
        >>> fl_end_group()

    Notes
    -----
        Status: NN-UTest + Doc + Demo = OK

    """
    _fl_end_group = library.cfuncproto(
        library.load_so_libforms(), "fl_end_group", \
        None, [], \
        """void fl_end_group() """)
    library.check_if_flinitialized()
    _fl_end_group()


def fl_addto_group(ptr_flobject):
    """fl_addto_group(ptr_flobject) -> ptr_flform

    Reopens a group, after fl_end_group(), to allow addition of
    further flobjects.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            group to be reopened

    Returns
    -------
        ptr_flform : pointer to xfdata.FL_FORM
            form, or None (on failure)

    Examples
    --------
        >>> group1 = fl_addto_group(closedgroup)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_addto_group = library.cfuncproto(
        library.load_so_libforms(), "fl_addto_group", \
        cty.POINTER(xfdata.FL_OBJECT), [cty.POINTER(xfdata.FL_OBJECT)], \
        """FL_OBJECT * fl_addto_group(FL_OBJECT * group) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_addto_group(ptr_flobject)
    return retval


# Routines that deal with FL_OBJECTS

def fl_get_object_objclass(ptr_flobject):
    """fl_get_object_objclass(ptr_flobject) -> flobjclass

    Finds out the class of a flobject (e.g. button, lightbutton,
    box, nmenu, counter, etc.).

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        flobjclass : int
            flobject class id, or -1 (on failure)

    Examples
    --------
        >>> obcls = fl_get_object_objclass(pobj)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_object_objclass = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_objclass", \
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)], \
        """int fl_get_object_objclass(FL_OBJECT * obj) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_get_object_objclass(ptr_flobject)
    return retval


def fl_get_object_type(ptr_flobject):
    """fl_get_object_type(ptr_flobject) -> typeid

    Finds out the type of a flobject (e.g. radio button, multiline
    input, normal browser, etc..).

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        typeid : int
            flobject type id, or -1 (on failure)

    Examples
    --------
        >>> obtype = fl_get_object_type(pobj)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_object_type = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_type", \
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)], \
        """int fl_get_object_type(FL_OBJECT * obj) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_get_object_type(ptr_flobject)
    return retval


def fl_set_object_boxtype(ptr_flobject, boxtype):
    """fl_set_object_boxtype(ptr_flobject, boxtype)

    Defines the shape of box of a flobject. Not all possible boxtypes are
    suitable for all types of flobjects.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject whose boxtype has to be set
        boxtype : int
            type of the box to be set. Values (from xfdata.py)
            - FL_NO_BOX (No box at all, it is transparent, just a label),
            - FL_UP_BOX (A box that comes out of the screen),
            - FL_DOWN_BOX (A box that goes down into the screen),
            - FL_BORDER_BOX (A flat box with a border),
            - FL_SHADOW_BOX (A flat box with a shadow),
            - FL_FRAME_BOX (A flat box with an engraved frame),
            - FL_ROUNDED_BOX (A rounded box),
            - FL_EMBOSSED_BOX (A flat box with an embossed frame),
            - FL_FLAT_BOX (A flat box without a border, normally invisible
              unless given a different color than the surroundings),
            - FL_RFLAT_BOX (A rounded box without a border, normally invisible
              unless given a different color than the surroundings),
            - FL_RSHADOW_BOX (A rounded box with a shadow),
            - FL_OVAL_BOX (A box shaped like an ellipse),
            - FL_ROUNDED3D_UPBOX (A rounded box coming out of the screen),
            - FL_ROUNDED3D_DOWNBOX (A rounded box going into the screen),
            - FL_OVAL3D_UPBOX (An oval box coming out of the screen),
            - FL_OVAL3D_DOWNBOX (An oval box going into the screen),
            - FL_OVAL3D_FRAMEBOX (An oval box with an engraved frame),
            - FL_OVAL3D_EMBOSSEDBOX (An oval box with an embossed frame)

    Examples
    --------
        >>> fl_set_object_boxtype(ptextobj, xfdata.FL_BORDER_BOX)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_object_boxtype = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_boxtype", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int], \
        """void fl_set_object_boxtype(FL_OBJECT * ob, int boxtype) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.checkfatal_allowed_value_in_list(boxtype, xfdata.BOXTYPE_list)
    i_boxtype = library.convert_to_intc(boxtype)
    library.keep_elem_refs(ptr_flobject, boxtype, i_boxtype)
    _fl_set_object_boxtype(ptr_flobject, i_boxtype)


def fl_get_object_boxtype(ptr_flobject):
    """fl_get_object_boxtype(ptr_flobject) -> typeid

    Finds out the current boxtype of a flobject.


    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        typeid : int
            boxtype id (e.g. from xfdata.py FL_NO_BOX, FL_BORDER_BOX ..),
            or -1 (on failure)

    Examples
    --------
        >>> boxtp = fl_get_object_boxtype(ptextobj)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_object_boxtype = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_boxtype", \
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)], \
        """int fl_get_object_boxtype(FL_OBJECT * obj) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_get_object_boxtype(ptr_flobject)
    return retval


def fl_set_object_bw(ptr_flobject, borderwidth):
    """fl_set_object_bw(ptr_flobject, borderwidth)

    Defines the borderwidth of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set
        borderwidth : int
            borderwidth of flobject to be set. If it is 0, -1 is
            used; if it is a negative number, all flobjects appear
            to have a softer appearance.

    Examples
    --------
        >>> fl_set_object_bw(pobj, 2)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_object_bw = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_bw", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int], \
        """void fl_set_object_bw(FL_OBJECT * ob, int bw) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    i_borderwidth = library.convert_to_intc(borderwidth)
    library.keep_elem_refs(ptr_flobject, borderwidth, i_borderwidth)
    _fl_set_object_bw(ptr_flobject, i_borderwidth)


def fl_get_object_bw(ptr_flobject):
    """fl_get_object_bw(ptr_flobject) -> borderwidth

    Finds out the borderwidth of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        borderwidth : int
            borderwidth value of flobject

    Examples
    --------
        >>> currbw = fl_get_object_bw(pobj)

    API_diversion
    ----------
        API changed from XForms, upstream is
        fl_get_object_bw(ptr_flobject, bw)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_object_bw = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_bw", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(cty.c_int)], \
        """void fl_get_object_bw(FL_OBJECT * ob, int * bw) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    i_borderwidth, ptr_borderwidth = library.make_intc_and_pointer()
    library.keep_elem_refs(ptr_flobject, i_borderwidth, ptr_borderwidth)
    _fl_get_object_bw(ptr_flobject, ptr_borderwidth)
    return i_borderwidth.value


def fl_set_object_resize(ptr_flobject, whatresz):
    """fl_set_object_resize(ptr_flobject, whatresz)

    Defines the resize property of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to set
        whatresz : int_pos
            resize property. Values (from xfdata.py)
            - FL_RESIZE_NONE (Cannot be rescaled/resized),
            - FL_RESIZE_X (Can be rescaled on horizontal axis),
            - FL_RESIZE_Y (Can be rescaled on vertical axis),
            - FL_RESIZE_ALL (Can be rescaled on both axis)

    Examples
    --------
        >>> fl_set_object_resize(pobj, xfdata.FL_RESIZE_ALL)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_object_resize = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_resize", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_uint], \
        """void fl_set_object_resize(FL_OBJECT * ob, unsigned int what) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.checkfatal_allowed_value_in_list(whatresz, xfdata.RESIZE_list)
    ui_whatresz = library.convert_to_uintc(whatresz)
    library.keep_elem_refs(ptr_flobject, whatresz, ui_whatresz)
    _fl_set_object_resize(ptr_flobject, ui_whatresz)


def fl_get_object_resize(ptr_flobject):
    """fl_get_object_resize(ptr_flobject) -> whatresz

    Finds out the resize property of a flobject (e.g. resize all,
    resize none, etc..).

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        whatresz : int_pos
            resize property
            Values (from xfdata.py) FL_RESIZE_NONE (Cannot be
            rescaled/resized), FL_RESIZE_X (Can be rescaled on horizontal
            axis), FL_RESIZE_Y (Can be rescaled on vertical axis),
            FL_RESIZE_ALL (Can be rescaled on both axis)

    Examples
    --------
        >>> reszprop = fl_get_object_resize(pobj)

    API_diversion
    ----------
        API changedfrom XForms, upstream is
        fl_get_object_resize(ptr_flobject, what)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_object_resize = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_resize", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(cty.c_uint)], \
        """void fl_get_object_resize(FL_OBJECT * ob,
           unsigned int * what) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    ui_whatresz, ptr_whatresz = library.make_uintc_and_pointer()
    library.keep_elem_refs(ptr_flobject, ui_whatresz, ptr_whatresz)
    _fl_get_object_resize(ptr_flobject, ptr_whatresz)
    return ui_whatresz.value


def fl_set_object_gravity(ptr_flobject, northwest, southeast):
    """fl_set_object_gravity(ptr_flobject, northwest, southeast)

    Defines the gravity properties of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set
        northwest : int_pos
            gravity property for NorthWest. Values (from xfdata.py)
            FL_North, FL_NorthEast, FL_NorthWest, FL_South, FL_SouthEast,
            FL_SouthWest, FL_East, FL_West, FL_NoGravity, FL_ForgetGravity
        southeast : int_pos
            gravity property for SouthEast. Values (from xfdata.py)
            FL_North, FL_NorthEast, FL_NorthWest, FL_South, FL_SouthEast,
            FL_SouthWest, FL_East, FL_West, FL_NoGravity, FL_ForgetGravity

    Examples
    --------
        >>> fl_set_object_gravity(pobj, xfdata.FL_North, xfdata.FL_East)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_object_gravity = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_gravity", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_uint, cty.c_uint], \
        """void fl_set_object_gravity(FL_OBJECT * ob, unsigned int nw,
           unsigned int se) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.checkfatal_allowed_value_in_list(northwest, xfdata.GRAVITY_list)
    ui_northwest = library.convert_to_uintc(northwest)
    library.checkfatal_allowed_value_in_list(southeast, xfdata.GRAVITY_list)
    ui_southeast = library.convert_to_uintc(southeast)
    library.keep_elem_refs(ptr_flobject, northwest, ui_northwest, southeast, \
            ui_southeast)
    _fl_set_object_gravity(ptr_flobject, ui_northwest, ui_southeast)


def fl_get_object_gravity(ptr_flobject):
    """fl_get_object_gravity(ptr_flobject) -> northwest, southeast

    Finds out the NorthWest and SouthEast gravity properties of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        northwest : int_pos
            NorthWest gravity
        southeast : int_pos
            SouthEast gravity

    Examples
    --------
        >>> nowe, soea = fl_get_object_gravity(pobj)

    API_diversion
    ----------
        API changed from XForms, upstream is
        fl_get_object_gravity(ptr_flobject, nw, se)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_object_gravity = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_gravity", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(cty.c_uint),
        cty.POINTER(cty.c_uint)], \
        """void fl_get_object_gravity(FL_OBJECT * ob,
           unsigned int * nw, unsigned int * se) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    ui_northwest, ptr_northwest = library.make_uintc_and_pointer()
    ui_southeast, ptr_southeast = library.make_uintc_and_pointer()
    library.keep_elem_refs(ptr_flobject, ui_northwest, ui_southeast, \
            ptr_northwest, ptr_southeast)
    _fl_get_object_gravity(ptr_flobject, ptr_northwest, ptr_southeast)
    return ui_northwest.value, ui_southeast.value


def fl_set_object_lsize(ptr_flobject, size):
    """fl_set_object_lsize(ptr_flobject, size)

    Defines the label size of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set
        size : int
            label size. Values (from xfdata.py)
            - FL_TINY_SIZE (8 points font),
            - FL_SMALL_SIZE or FL_DEFAULT_SIZE (10 points font, default),
            - FL_NORMAL_SIZE (12 points font),
            - FL_MEDIUM_SIZE (14 points font),
            - FL_LARGE_SIZE (18 points font),
            - FL_HUGE_SIZE (24 points font),
            - or other numeric odd or even value.

    Examples
    --------
        >>> fl_set_object_lsize(pobj, xfdata.FL_MEDIUM_SIZE)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_object_lsize = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_lsize", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int], \
        """void fl_set_object_lsize(FL_OBJECT * ob, int lsize) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    i_size = library.convert_to_intc(size)
    library.keep_elem_refs(ptr_flobject, size, i_size)
    _fl_set_object_lsize(ptr_flobject, i_size)


def fl_get_object_lsize(ptr_flobject):
    """fl_get_object_lsize(ptr_flobject) -> size

    Finds out the size of the flobject's label.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        size : int
            label size
            Values (from xfdata.py) FL_TINY_SIZE (8 points font),
            FL_SMALL_SIZE or FL_DEFAULT_SIZE (10 points font, default),
            FL_NORMAL_SIZE (12 points font), FL_MEDIUM_SIZE (14 points
            font), FL_LARGE_SIZE (18 points font), FL_HUGE_SIZE (24
            points font), or other numeric odd or even value.

    Examples
    --------
        >>> lsize = fl_get_object_lsize(pobj)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_get_object_lsize = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_lsize", \
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)], \
        """int fl_get_object_lsize(FL_OBJECT * obj) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_get_object_lsize(ptr_flobject)
    return retval


def fl_set_object_lstyle(ptr_flobject, style):
    """fl_set_object_lstyle(ptr_flobject, style)

    Defines the label style of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set
        style : int
            label style. Values (from xfdata.py)
            - FL_NORMAL_STYLE (Helvetica normal text),
            - FL_BOLD_STYLE (Helvetica boldface text),
            - FL_ITALIC_STYLE (Helvetica italic text),
            - FL_BOLDITALIC_STYLE (Helvetica boldface and italic text),
            - FL_FIXED_STYLE (Courier fixed width, good for tables),
            - FL_FIXEDBOLD_STYLE (Courier bold fixed text),
            - FL_FIXEDITALIC_STYLE (Courier italic fixed text),
            - FL_FIXEDBOLDITALIC_STYLE (Courier boldface and italic fixed
              text),
            - FL_TIMES_STYLE (Times-Roman like normal font),
            - FL_TIMESBOLD_STYLE (Times-Roman like boldface text),
            - FL_TIMESITALIC_STYLE (Times-Roman like italic text),
            - FL_TIMESBOLDITALIC_STYLE (Times-Roman like boldface and italic
              text), FL_MISC_STYLE (Charter normal text),
            - FL_MISCBOLD_STYLE (Charter boldface text),
            - FL_MISCITALIC_STYLE (Charter italic text),
            - FL_SYMBOL_STYLE (Symbol text),
            - FL_SHADOW_STYLE (Text casting a shadow, modifier mask),
            - FL_ENGRAVED_STYLE (Text engraved into the form, modifier mask),
            - FL_EMBOSSED_STYLE (Text standing out, modifier mask).
            Bitwise OR with any of modifiers is allowed.

    Examples
    --------
        >>> fl_set_object_lstyle(pobj, xfdata.FL_TIMESITALIC_STYLE)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_object_lstyle = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_lstyle", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int], \
        """void fl_set_object_lstyle(FL_OBJECT * ob, int lstyle) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.checkfatal_allowed_value_in_list(style, xfdata.TEXTSTYLE_list)
    i_style = library.convert_to_intc(style)
    library.keep_elem_refs(ptr_flobject, style, i_style)
    _fl_set_object_lstyle(ptr_flobject, i_style)


def fl_get_object_lstyle(ptr_flobject):
    """fl_get_object_lstyle(ptr_flobject) -> style

    Finds out the label style of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        style : int
            label style
            Values (from xfdata.py)
            FL_NORMAL_STYLE (Helvetica normal text), FL_BOLD_STYLE (Helvetica
            boldface text), FL_ITALIC_STYLE (Helvetica italic text),
            FL_BOLDITALIC_STYLE (Helvetica boldface and italic text),
            FL_FIXED_STYLE (Courier fixed width, good for tables),
            FL_FIXEDBOLD_STYLE (Courier bold fixed text), FL_FIXEDITALIC_STYLE
            (Courier italic fixed text), FL_FIXEDBOLDITALIC_STYLE (Courier
            boldface and italic fixed text), FL_TIMES_STYLE (Times-Roman like
            normal font), FL_TIMESBOLD_STYLE (Times-Roman like boldface text),
            FL_TIMESITALIC_STYLE (Times-Roman like italic text),
            FL_TIMESBOLDITALIC_STYLE (Times-Roman like boldface and italic
            text), FL_MISC_STYLE (Charter normal text), FL_MISCBOLD_STYLE
            (Charter boldface text), FL_MISCITALIC_STYLE (Charter italic text),
            FL_SYMBOL_STYLE (Symbol text), FL_SHADOW_STYLE (Text casting a
            shadow, modifier mask), FL_ENGRAVED_STYLE (Text engraved into the
            form, modifier mask), FL_EMBOSSED_STYLE (Text standing out,
            modifier mask). Bitwise OR with any of modifiers is allowed.

    Examples
    --------
        >>> lstyle = fl_get_object_lstyle(pobj)

    Notes
    -----
        Status: NA-UTest + NoDoc + Demo = OK

    """
    _fl_get_object_lstyle = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_lstyle", \
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)], \
        """int fl_get_object_lstyle(FL_OBJECT * obj) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_get_object_lstyle(ptr_flobject)
    return retval


def fl_set_object_lcol(ptr_flobject, colr):
    """fl_set_object_lcol(ptr_flobject, colr)

    Defines the label color of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set
        colr : long_pos
            XForms colormap index as label color. Values (from xfdata.py)
             one of defined colors FL_BLACK, FL_BLUE, FL_GREEN, FL_RED, etc..

    Examples
    --------
        >>> fl_set_object_lcol(pobj, xfdata.FL_BLUE)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_object_lcol = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_lcol", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_COLOR], \
        """void fl_set_object_lcol(FL_OBJECT * ob, FL_COLOR lcol) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(ptr_flobject, colr, ul_colr)
    _fl_set_object_lcol(ptr_flobject, ul_colr)


fl_set_object_lcolor = fl_set_object_lcol


def fl_get_object_lcol(ptr_flobject):
    """fl_get_object_lcol(ptr_flobject) -> colr

    Finds out the label color of a flobject (from xfdata, e.g.
    FL_WHITE, FL_LIME, etc..).

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        colr : long_pos
            XForms colormap index as color value

    Examples
    --------
        >>> obcolor = fl_get_object_lcol(pobj)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_object_lcol = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_lcol", \
        xfdata.FL_COLOR, [cty.POINTER(xfdata.FL_OBJECT)], \
        """FL_COLOR fl_set_object_lcol(FL_OBJECT * obj) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_get_object_lcol(ptr_flobject)
    return retval


def fl_set_object_return(ptr_flobject, whenretn):
    """fl_set_object_return(ptr_flobject, whenretn) -> oldwhenretn

    Defines the conditions under which a flobject gets returned (or its
    callback invoked). If the flobject has to do additional work on setting
    the condition (e.g. it has child flobjects that also need to be set) it
    has to set up it is own function that then will called in the end. This
    should only be called once a flobject has been created completely! Not
    all return types make sense for all flobjects.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject
        whenretn : int_pos
            return type (when it returns). Values (from xfdata.py)
            - FL_RETURN_NONE (Never notify the application about interactions
              with this flobject, i.e. never return it nor invoke its callback.
              Note, this is not meant for deactivation of a flobject, it will
              still seem to work as normal, it just does not get returned
              to the application nor does its callback get invoked),
            - FL_RETURN_CHANGED (Return or invoke callback whenever an item is
              selected, default),
            - FL_RETURN_END (Return or invoke callback on end of an
              interaction),
            - FL_RETURN_END_CHANGED (Return or invoke callback if end of
              interaction and selection of an item coincide),
            - FL_RETURN_SELECTION (Return or invoke callback on selection of a
              line. Note that for FL_MULTI_BROWSER the browser may be returned
              just once for a number of lines having been selected),
            - FL_RETURN_DESELECTION (Return or invoke callback on deselection
              of a line. This only works for FL_MULTI_BROWSER browsers and the
              browser may be returned just once for a number of lines having
              been deselected),
            - FL_RETURN_TRIGGERED (*todo*),
            - FL_RETURN_ALWAYS (Return or invoke callback whenever the
              interaction ends and/or an item is selected. It includes all
              conditions except FL_RETURN_END_CHANGED).
            Bitwise OR is allowed.

    Returns
    -------
        oldwhenretn : int
            old return type id

    Examples
    --------
        >>> fl_set_object_return(pobj, xfdata.FL_RETURN_CHANGED)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_object_return = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_return", \
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT), cty.c_uint], \
        """int fl_set_object_return(FL_OBJECT * ob, unsigned int when) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    ui_whenretn = library.convert_to_uintc(whenretn)
    library.keep_elem_refs(ptr_flobject, whenretn, ui_whenretn)
    retval = _fl_set_object_return(ptr_flobject, ui_whenretn)
    return retval


# TODO: verify what its purpose is (internal use only?)
def fl_notify_object(ptr_flobject, cause):
    """fl_notify_object(ptr_flobject, cause)

    Notifies to XForms if attributes, size or position are to be changed.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject
        cause : int
            cause for notification. Values (from xfdata.py) FL_ATTRIB,
            FL_RESIZED, FL_MOVEORIGIN

    Examples
    --------
        >>> fl_notify_object(pobj5, xfdata.FL_RESIZED)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = KO (not clear purpose)

    """
    _fl_notify_object = library.cfuncproto(
        library.load_so_libforms(), "fl_notify_object", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int], \
        """void fl_notify_object(FL_OBJECT * obj, int cause) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    #library.checkfatal_allowed_value_in_list(cause, xfdata.EVENTS_list)
    icause = library.convert_to_intc(cause)
    library.keep_elem_refs(ptr_flobject, cause, icause)
    _fl_notify_object(ptr_flobject, icause)


def fl_set_object_lalign(ptr_flobject, align):
    """fl_set_object_lalign(ptr_flobject, align)

    Defines alignment of a flobject's label.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set
        align : int
            alignment of label. Values (from xfdata.py)
            - FL_ALIGN_CENTER (In the middle of the box, inside it),
            - FL_ALIGN_TOP (To the top of the box, outside it),
            - FL_ALIGN_BOTTOM (To the bottom of the box, outside it),
            - FL_ALIGN_LEFT (To the left of the box, outside it),
            - FL_ALIGN_RIGHT (To the right of the box, outside it),
            - FL_ALIGN_LEFT_TOP (To the left and top of the box, outside it),
            - FL_ALIGN_RIGHT_TOP (To the right and top of the box, outside it),
            - FL_ALIGN_LEFT_BOTTOM (To the left and bottom of the box,
              outside it),
            - FL_ALIGN_RIGHT_BOTTOM (To the right and bottom of the box,
              outside it), FL_ALIGN_INSIDE (places the text inside the box),
            - FL_ALIGN_VERT (not functional yet).
            Bitwise OR with FL_ALIGN_INSIDE is allowed.

    Examples
    --------
        >>> fl_set_object_lalign(pobj8, xfdata.FL_ALIGN_RIGHT)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_object_lalign = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_lalign", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int], \
        """void fl_set_object_lalign(FL_OBJECT * ob, int align) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.checkfatal_allowed_value_in_list(align, xfdata.ALIGN_list)
    i_align = library.convert_to_intc(align)
    library.keep_elem_refs(ptr_flobject, align, i_align)
    _fl_set_object_lalign(ptr_flobject, i_align)


def fl_get_object_lalign(ptr_flobject):
    """fl_get_object_lalign(ptr_flobject) -> align

    Finds out alignment of a flobject's label.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set

    Returns
    -------
        align : int
            alignment (from xfdata, e.g. FL_ALIGN_LEFT, FL_ALIGN_RIGHT_TOP,
            etc..)

    Examples
    --------
        >>> obalign = fl_get_object_lalign(pobj8)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_get_object_lalign = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_lalign", \
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)], \
        """int fl_set_object_lalign(FL_OBJECT * ob) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_get_object_lalign(ptr_flobject)
    return retval


fl_set_object_align = fl_set_object_lalign


def fl_set_object_shortcut(ptr_flobject, sctext, showit):
    """fl_set_object_shortcut(ptr_flobject, sctext, showit)

    Defines a shortcut, binding a key or a series of keys to a flobject.
    It resets any previous defined shortcuts for the flobject. Using e.g.
    "acE#d^h" the keys 'a', 'c', 'E', <Alt>d and <Ctrl>h are associated
    with the flobject. The precise format is as follows: any character in
    the string is considered as a shortcut, except '^' and '#', which stand
    for combinations with the <Ctrl> and <Alt> keys; the case of the key
    following '#' or '^' is not important, i.e. no distinction is made
    between e.g. "^C" and "^c", both encode the key combination <Ctrl>C as
    well as <Ctrl>C.) The key '^' itself can be set as a shortcut key by
    using "^^" in the string defining the shortcut. The key '#' can be
    obtained as a shortcut by using the string "^#". So, e.g. "#^#" encodes
    <ALT>#. The <Esc> key can be given as "^[". Another special character
    not mentioned yet is '&', which indicates function and arrow keys. Use
    a sequence starting with '&' and directly followed by a number between
    1 and 35 to represent one of the function keys. For example, "&2"
    stands for the <F2> function key. The four cursors keys (up, down, right,
    and left) can be given as "&A", "&B", "&C" and "&D", respectively. The
    key '&' itself can be obtained as a shortcut by prefixing it with '^'.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject
        sctext : str
            shortcut text to be set
        showit : int
            flag if shortcut letter has to be underlined or not if a match
            exists (only the 1st alphanumeric character is used). Values 0
            (underline not shown) or 1 (shown)

    Examples
    --------
        >>> fl_set_object_shortcut(pobj6, "aA#A^A", 1)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_object_shortcut = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_shortcut", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.STRING, cty.c_int], \
        """void fl_set_object_shortcut(FL_OBJECT * obj,
           const char * sstr, int showit) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    s_sctext = library.convert_to_stringc(sctext)
    i_showit = library.convert_to_intc(showit)
    library.keep_elem_refs(ptr_flobject, sctext, s_sctext, showit, \
            i_showit)
    _fl_set_object_shortcut(ptr_flobject, s_sctext, i_showit)


def fl_set_object_shortcutkey(ptr_flobject, keysym):
    """fl_set_object_shortcutkey(ptr_flobject, keysym)

    Uses a special key as a flobject shortcut. It always appends the specified
    key to the current shortcuts. Special keys cannot be underlined.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject
        keysym : int_pos
            X key symbolic num. See xfdata.py for a (maybe) incomplete list

    Examples
    --------
        >>> fl_set_object_shortcutkey(pobj, xfdata.XK_Home)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_object_shortcutkey = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_shortcutkey",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_uint], \
        """void fl_set_object_shortcutkey(FL_OBJECT * obj,
           unsigned int keysym) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    ui_keysym = library.convert_to_uintc(keysym)
    library.keep_elem_refs(ptr_flobject, keysym, ui_keysym)
    _fl_set_object_shortcutkey(ptr_flobject, ui_keysym)


def fl_set_object_dblbuffer(ptr_flobject, yesno):
    """fl_set_object_dblbuffer(ptr_flobject, yesno)

    Uses double buffering on a per-object basis. Currently double
    buffering for flobjects having a non-rectangular box might not work
    well. A nonrectangular box means that there are regions within the
    bounding box that should not be painted, which is not easily done
    without complex and expensive clipping and unacceptable inefficiency.
    Since Xlib does not support double buffering, XForms simulates this
    functionality with pixmap bit-bliting. In practice, the effect is
    hardly distinguishable from double buffering and performance is on par
    with multi-buffering extensions (it is slower than drawing into a
    window directly on most workstations however). Bear in mind that a
    pixmap can be resource hungry, so use this option with discretion.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to set
        yesno : int
            flag to disable/enable double buffer. Values 0 (disabled)
            or 1 (enabled)

    Examples
    --------
        >>> fl_set_object_dblbuffer(pobj7, 1)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_object_dblbuffer = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_dblbuffer", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int], \
        """void fl_set_object_dblbuffer(FL_OBJECT * ob, int y) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    i_yesno = library.convert_to_intc(yesno)
    library.keep_elem_refs(ptr_flobject, yesno, i_yesno)
    _fl_set_object_dblbuffer(ptr_flobject, i_yesno)


def fl_set_object_color(ptr_flobject, fgcolr, bgcolr):
    """fl_set_object_color(ptr_flobject, fgcolr, bgcolr)

    Defines the foreground and background colors of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set
        fgcolr : long_pos
            XForms colormap index as foreground color
        bgcolr : long_pos
            XForms colormap index as background color

    Examples
    --------
        >>> fl_set_object_color(pbutobj7, xfdata.FL_AQUA, xfdata.FL_WHEAT)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_object_color = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_color", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_COLOR,
        xfdata.FL_COLOR],
        """void fl_set_object_color(FL_OBJECT * ob, FL_COLOR col1,
           FL_COLOR col2) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    #library.checknonfatal_allowed_value_in_list(fgcolr, xfdata.COLOR_list)
    #library.checknonfatal_allowed_value_in_list(bgcolr, xfdata.COLOR_list)
    ul_fgcolr = library.convert_to_FL_COLOR(fgcolr)
    ul_bgcolr = library.convert_to_FL_COLOR(bgcolr)
    library.keep_elem_refs(ptr_flobject, fgcolr, ul_fgcolr, \
            bgcolr, ul_bgcolr)
    _fl_set_object_color(ptr_flobject, ul_fgcolr, ul_bgcolr)


def fl_get_object_color(ptr_flobject):
    """fl_get_object_color(ptr_flobject) -> fgcolr, bgcolr

    Finds out the foreground and background colors of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject

    Returns
    -------
        fgcolr : long_pos
            XForms colormap index as foreground color
        bgcolr : long_pos
            XForms colormap index as background color

    Examples
    --------
        >>> primcol, secncol = fl_get_object_color(pobj)

    API_diversion
    ----------
        API changed from XForms, upstream is
        fl_set_object_color(ptr_flobject, fgcolr, bgcolr)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_object_color = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_color", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(xfdata.FL_COLOR),
        cty.POINTER(xfdata.FL_COLOR)], \
        """void fl_get_object_color(FL_OBJECT * ob, FL_COLOR * col1,
           FL_COLOR * col2)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    ul_fgcolr, ptr_fgcolr = library.make_FL_COLOR_and_pointer()
    ul_bgcolr, ptr_bgcolr = library.make_FL_COLOR_and_pointer()
    library.keep_elem_refs(ptr_flobject, ul_fgcolr, ptr_fgcolr, \
            ul_bgcolr, ptr_bgcolr)
    _fl_get_object_color(ptr_flobject, ptr_fgcolr, ptr_bgcolr)
    return ul_fgcolr.value, ul_bgcolr.value


def fl_set_object_label(ptr_flobject, label):
    """fl_set_object_label(ptr_flobject, label)

    Defines the label of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set
        label : str
            text label of flobject

    Examples
    --------
        >>> fl_set_object_label(pobj, "My New Label")

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_object_label = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_label", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.STRING], \
        """void fl_set_object_label(FL_OBJECT * ob, const char * label) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    s_label = library.convert_to_stringc(label)
    library.keep_elem_refs(ptr_flobject, label, s_label)
    _fl_set_object_label(ptr_flobject, s_label)


def fl_get_object_label(ptr_flobject):
    """fl_get_object_label(ptr_flobject) -> label

    Finds out the label of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        label : str
            text of label

    Examples
    --------
        >>> currlbl = fl_get_object_label(pobj)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_object_label = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_label", \
        xfdata.STRING, [cty.POINTER(xfdata.FL_OBJECT)], \
        """const char * fl_set_object_label(FL_OBJECT * obj) """)
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_get_object_label(ptr_flobject)
    return retval


def fl_set_object_helper(ptr_flobject, tooltip):
    """fl_set_object_helper(ptr_flobject, tooltip)

    Defines the tooltip of a flobject (with possible embedded newlines
    in it) that will be shown when the mouse hovers over the flobject
    for more than about 600 msec.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set
        tooltip : str
            tooltip text for flobject

    Examples
    --------
        >>> fl_set_object_helper(pobj, "Button to exit the procedure.")

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_object_helper = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_helper", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.STRING], \
        """void fl_set_object_helper(FL_OBJECT * ob, const char * tip)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    s_tooltip = library.convert_to_stringc(tooltip)
    library.keep_elem_refs(ptr_flobject, tooltip, s_tooltip)
    _fl_set_object_helper(ptr_flobject, s_tooltip)


def fl_set_object_position(ptr_flobject, xpos, ypos):
    """fl_set_object_position(ptr_flobject, xpos, ypos)

    Defines the position of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)

    Examples
    --------
        >>> fl_set_object_position(pobj, 235, 123)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_object_position = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_position", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_Coord,
        xfdata.FL_Coord], \
        """void fl_set_object_position(FL_OBJECT * obj, FL_Coord x,
           FL_Coord y)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    library.keep_elem_refs(ptr_flobject, xpos, i_xpos, ypos, i_ypos)
    _fl_set_object_position(ptr_flobject, i_xpos, i_ypos)


def fl_get_object_size(ptr_flobject):
    """fl_get_object_size(ptr_flobject) -> width, height

    Finds out the size of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        width : int
            width of flobject in coord units
        height : int
            height of flobject in coord units

    Examples
    --------
        >>> wid, hei = fl_get_object_size(pobj)

    API_diversion
    ----------
        API changed from XForms, upstream is
        fl_get_object_size(ptr_flobject, width, height)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_object_size = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_size", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord)], \
        """void fl_get_object_size(FL_OBJECT * obj, FL_Coord * w,
           FL_Coord * h)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    i_width, ptr_width = library.make_FL_Coord_and_pointer()
    i_height, ptr_height = library.make_FL_Coord_and_pointer()
    library.keep_elem_refs(ptr_flobject, i_width, i_height, ptr_width, \
            ptr_height)
    _fl_get_object_size(ptr_flobject, ptr_width, ptr_height)
    return i_width.value, i_height.value


def fl_set_object_size(ptr_flobject, width, height):
    """fl_set_object_size(ptr_flobject, width, height)

    Defines the size of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set
        width : int
            width of flobject in coord units
        height : int
            height of flobject in coord units

    Examples
    --------
        >>> fl_set_object_size(pobj, 90, 35)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_object_size = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_size", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_Coord,
        xfdata.FL_Coord], \
        """void fl_set_object_size(FL_OBJECT * obj, FL_Coord w,
           FL_Coord h)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(ptr_flobject, width, i_width, height, i_height)
    _fl_set_object_size(ptr_flobject, i_width, i_height)


def fl_set_object_automatic(ptr_flobject, yesno):
    """fl_set_object_automatic(ptr_flobject, yesno)

    Enables or disables a flobject to receive a xfdata.FL_STEP event.
    This should not be used with built-in flobjects. A flobject is automatic
    if it automatically (without user actions) has to change its contents.
    Automatic flobjects get a xfdata.FL_STEP event about every 50 msec.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set
        yesno : int
            flag if automatic or not. Values 0 (not automatic)
            or 1 (automatic)

    Examples
    --------
        >>> fl_set_object_automatic(pMyobj, 1)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_object_automatic = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_automatic",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int], \
        """void fl_set_object_automatic(FL_OBJECT * ob, int flag)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    i_yesno = library.convert_to_intc(yesno)
    library.keep_elem_refs(ptr_flobject, yesno, i_yesno)
    _fl_set_object_automatic(ptr_flobject, i_yesno)


def fl_object_is_automatic(ptr_flobject):
    """fl_object_is_automatic(ptr_flobject) -> yesno

    Tells if a flobject receives xfdata.FL_STEP events. An flobject is
    automatic if it automatically (without user actions) has to change its
    contents. Automatic flobjects get a xfdata.FL_STEP event about every 50
    msec.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        yesno : int
            flag if it is automatic (1) or not (0)

    Examples
    --------
        >>> if fl_object_is_automatic(pMyobj):
        >>> ... <something>

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_object_is_automatic = library.cfuncproto(
        library.load_so_libforms(), "fl_object_is_automatic",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)], \
        """int fl_object_is_automatic(FL_OBJECT * obj)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_object_is_automatic(ptr_flobject)
    return retval


def fl_draw_object_label(ptr_flobject):
    """fl_draw_object_label(ptr_flobject)

    Draws the label of a flobject according to the alignment, which
    could be inside or outside of the bounding box.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set

    Examples
    --------
        >>> fl_draw_object_label(pobj3)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_draw_object_label = library.cfuncproto(
        library.load_so_libforms(), "fl_draw_object_label", \
        None, [cty.POINTER(xfdata.FL_OBJECT)], \
        """void fl_draw_object_label(FL_OBJECT * ob)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    _fl_draw_object_label(ptr_flobject)


def fl_draw_object_label_outside(ptr_flobject):
    """fl_draw_object_label_outside(ptr_flobject)

    Draws the label of a flobject outside of the bounding box.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set

    Examples
    --------
        >>> fl_draw_object_label_outside(pobj3)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_draw_object_label_outside = library.cfuncproto(
        library.load_so_libforms(), "fl_draw_object_label_outside",
        None, [cty.POINTER(xfdata.FL_OBJECT)], \
        """void fl_draw_object_label_outside(FL_OBJECT * ob)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    _fl_draw_object_label_outside(ptr_flobject)


fl_draw_object_outside_label = fl_draw_object_label_outside


def fl_get_object_component(ptr_flobject, flobjclass, compontype, seqnum):
    """fl_get_object_component(ptr_flobject, flobjclass, compontype, seqnum)
    -> ptr_flobject

    Finds out the flobject that is a component of a composite flobject. E.g.
    the scrollbar flobject is made of a slider and two scroll buttons.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            composite flobject
        flobjclass : int
            component flobject's class id
        compontype : int
            component flobject's type id
        seqnum : int
            the sequence number of the desired flobject in case the
            composite has more than one flobject of the same class and
            type. If it is -1, indicates any type of specified class

    Returns
    -------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            component flobject, or None (no flobject found)

    Examples
    --------
        >>> baseobj = fl_get_object_component(browserobj,
                xfdata.FL_SCROLLBAR, xfdata.FL_HOR_THIN_SCROLLBAR, 0)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_object_component = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_component",
        cty.POINTER(xfdata.FL_OBJECT), [cty.POINTER(xfdata.FL_OBJECT),
        cty.c_int, cty.c_int, cty.c_int], \
        """FL_OBJECT * fl_get_object_component(FL_OBJECT * composite,
           int objclass, int type, int numb)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    i_flobjclass = library.convert_to_intc(flobjclass)
    i_compontype = library.convert_to_intc(compontype)
    i_seqnum = library.convert_to_intc(seqnum)
    library.keep_elem_refs(ptr_flobject, flobjclass, i_flobjclass, \
            compontype, i_compontype, seqnum, i_seqnum)
    retval = _fl_get_object_component(ptr_flobject, i_flobjclass, \
            i_compontype, i_seqnum)
    return retval


def fl_for_all_objects(ptr_flform, pyfn_operatecb, userdata):
    """fl_for_all_objects(ptr_flform, pyfn_operatecb, userdata)

    Serves as an iterator to change an attribute for all flobjects on a
    particular form. Specified operating function is called for every
    flobject of the form form unless it returns nonzero, which terminates
    the iterator.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form
        pyfn_operatecb : python callback function, returned value
            name referring to function(ptr_flobject, [pointer to void]pvdata)
            -> [int]num
        userdata : any type (e.g. None, int, str, etc..)
            user data to be passed to function; invoked callback has to take
            care of type check and re-cast from ptr_void to chosen type using
            appropriate xfstruct.convert_ptrvoid_to_*() function

    Examples
    --------
        >>> def operatecb(pobj, pvdata):
        >>> ... <something>
        >>> return 0
        >>> fl_for_all_objects(pform5, operatecb, None)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    cfunc_int_pobject_pvoid = cty.CFUNCTYPE(cty.c_int,
            cty.POINTER(xfdata.FL_OBJECT), cty.c_void_p)
    _fl_for_all_objects = library.cfuncproto(
        library.load_so_libforms(), "fl_for_all_objects", \
        None, [cty.POINTER(xfdata.FL_FORM), cfunc_int_pobject_pvoid,
        cty.c_void_p], \
        """void fl_for_all_objects(FL_FORM * form, int ( * cb ) \
           ( FL_OBJECT *, void * ), void * v)""")
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.verify_function_type(pyfn_operatecb)
    cfn_operatecb = cfunc_int_pobject_pvoid(pyfn_operatecb)
    ptr_vdata = library.convert_userdata_to_ptrvoid(userdata)
    library.keep_cfunc_refs(cfn_operatecb, pyfn_operatecb)
    library.keep_elem_refs(ptr_flform, userdata, ptr_vdata)
    _fl_for_all_objects(ptr_flform, cfn_operatecb, ptr_vdata)


def fl_set_object_dblclick(ptr_flobject, timeout):
    """fl_set_object_dblclick(ptr_flobject, timeout)

    Defines double-click timeout value of a flobject, enabling
    or disabling it to receive the xfdata.FL_DBLCLICK event.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set
        timeout : long_pos
            maximum time interval (in msec) between two clicks for
            them to be considered a double-click. If it is 0,
            disables double-click detection.

    Examples
    --------
        >>> fl_set_object_dblclick(pobj, 750)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_object_dblclick = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_dblclick", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_ulong], \
        """void fl_set_object_dblclick(FL_OBJECT *obj, unsigned \
           long timeout)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    ul_timeout = library.convert_to_ulongc(timeout)
    library.keep_elem_refs(ptr_flobject, timeout, ul_timeout)
    _fl_set_object_dblclick(ptr_flobject, ul_timeout)


def fl_get_object_dblclick(ptr_flobject):
    """fl_get_object_dblclick(ptr_flobject) -> timeout

    Finds out double-click timeout value of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        timeout : long_pos
            timeout value

    Examples
    --------
        >>> dctim = fl_get_object_dblclick(pobj0)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_object_dblclick = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_dblclick", \
        cty.c_ulong, [cty.POINTER(xfdata.FL_OBJECT)], \
        """unsigned long fl_get_object_dblclick(FL_OBJECT *obj)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_get_object_dblclick(ptr_flobject)
    return retval


def fl_set_object_geometry(ptr_flobject, xpos, ypos, width, height):
    """fl_set_object_geometry(ptr_flobject, xpos, ypos, width, height)

    Defines the geometry (position and size) of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width of flobject in coord units
        height : int
            height of flobject in coord units

    Examples
    --------
        >>> fl_set_object_geometry(pobj, 200, 250, 120, 25)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_object_geometry = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_geometry", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord], \
        """void fl_set_object_geometry(FL_OBJECT * obj, FL_Coord x,
        FL_Coord y, FL_Coord w, FL_Coord h)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    library.keep_elem_refs(ptr_flobject, xpos, i_xpos, ypos, \
            i_ypos, width, i_width, height, i_height)
    _fl_set_object_geometry(ptr_flobject, i_xpos, i_ypos, i_width, \
            i_height)


def fl_move_object(ptr_flobject, xpos, ypos):
    """fl_move_object(ptr_flobject, xpos, ypos)

    Moves a flobject to a new position.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be moved
        xpos : int
            new horizontal position (upper-left corner)
        ypos : int
            new vertical position (upper-left corner)

    Examples
    --------
        >>> fl_move_object(pobj0, 120, 380)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_move_object = library.cfuncproto(
        library.load_so_libforms(), "fl_move_object", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_Coord,
        xfdata.FL_Coord], \
        """void fl_move_object(FL_OBJECT * obj, FL_Coord dx,
           FL_Coord dy)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    i_xpos = library.convert_to_intc(xpos)
    i_ypos = library.convert_to_intc(ypos)
    library.keep_elem_refs(ptr_flobject, xpos, i_xpos, ypos, i_ypos)
    _fl_move_object(ptr_flobject, i_xpos, i_ypos)


def fl_fit_object_label(ptr_flobject, xmargin, ymargin):
    """fl_fit_object_label(ptr_flobject, xmargin, ymargin)

    Checks if the label of a flobject fits into it (after x- and y-margin
    have been added). If not, all flobjects and the form are enlarged by
    the necessary factor (but never by more than a factor of 1.5).

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set
        xmargin : int
            horizontal margin of label in coord units
        ymargin : int
            vertical margin of label in coord units

    Examples
    --------
        >>> fl_fit_object_label(pobj2, 10, 10)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_fit_object_label = library.cfuncproto(
        library.load_so_libforms(), "fl_fit_object_label",\
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_Coord,
        xfdata.FL_Coord],\
        """void fl_fit_object_label(FL_OBJECT * obj, FL_Coord xmargin,
           FL_Coord ymargin)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    i_xmargin = library.convert_to_intc(xmargin)
    i_ymargin = library.convert_to_intc(ymargin)
    library.keep_elem_refs(ptr_flobject, xmargin, i_xmargin, \
            ymargin, i_ymargin)
    _fl_fit_object_label(ptr_flobject, i_xmargin, i_ymargin)


def fl_get_object_geometry(ptr_flobject):
    """fl_get_object_geometry(ptr_flobject) -> xpos, ypos, width, height

    Finds out the geometry (position and size) of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        xpos : int
            horizontal position
        ypos : int
            vertical position
        width : int
            width
        height : int
            height

    Examples
    --------
        >>> x, y, w, h = fl_get_object_geometry(pobj1)

    API_diversion
    ----------
        API changed from XForms, upstream is
        fl_get_object_geometry(ptr_flobject, xpos, ypos, width, height)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_get_object_geometry = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_geometry",\
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(xfdata.FL_Coord),\
        cty.POINTER(xfdata.FL_Coord), cty.POINTER(xfdata.FL_Coord), \
        cty.POINTER(xfdata.FL_Coord)],
        """void fl_get_object_geometry(FL_OBJECT * ob, FL_Coord * x,
           FL_Coord * y, FL_Coord * w, FL_Coord * h)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    i_xpos, ptr_xpos = library.make_FL_Coord_and_pointer()
    i_ypos, ptr_ypos = library.make_FL_Coord_and_pointer()
    i_width, ptr_width = library.make_FL_Coord_and_pointer()
    i_height, ptr_height = library.make_FL_Coord_and_pointer()
    library.keep_elem_refs(ptr_flobject, i_xpos, ptr_xpos, i_ypos, \
            ptr_ypos, i_width, ptr_width, i_height, ptr_height)
    _fl_get_object_geometry(ptr_flobject, ptr_xpos, ptr_ypos, ptr_width, \
            ptr_height)
    return i_xpos.value, i_ypos.value, i_width.value, i_height.value


def fl_get_object_position(ptr_flobject):
    """fl_get_object_position(ptr_flobject) -> xpos, ypos

    Finds out the position of a flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        xpos : int
            horizontal position
        ypos : int
            vertical position

    Examples
    --------
        >>> x, y = fl_get_object_position(pobj2)

    API_diversion
    ----------
        API changed from XForms, upstream is
        fl_get_object_position(ptr_flobject, xpos, ypos)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_object_position = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_position",\
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord)],\
        """void fl_get_object_position(FL_OBJECT * ob, FL_Coord * x,
           FL_Coord * y)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    i_xpos, ptr_xpos = library.make_FL_Coord_and_pointer()
    i_ypos, ptr_ypos = library.make_FL_Coord_and_pointer()
    library.keep_elem_refs(ptr_flobject, i_xpos, ptr_xpos, \
            i_ypos, ptr_ypos)
    _fl_get_object_position(ptr_flobject, ptr_xpos, ptr_ypos)
    return i_xpos.value, i_ypos.value


# this one takes into account the label

def fl_get_object_bbox(ptr_flobject):
    """fl_get_object_bbox(ptr_flobject) -> xpos, ypos, width, height

    Finds out the bounding box size that has the label, which could be
    drawn outside of the flobject figured in.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        xpos : int
            horizontal position of bounding box (upper-left corner)
        ypos : int
            vertical position of bounding box (upper-left corner)
        width : int
            width of bounding box
        height : int
            height of bounding box

    Examples
    --------
        >>> x, y, w, h = fl_get_object_bbox(pobj4)

    API_diversion
    ----------
        API changed from XForms, upstream is
        fl_get_object_bbox(ptr_flobject, xpos, ypos, width, height)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_object_bbox = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_bbox",\
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(xfdata.FL_Coord),\
        cty.POINTER(xfdata.FL_Coord), cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord)],\
        """void fl_get_object_bbox(FL_OBJECT * obj, FL_Coord * x,
           FL_Coord * y, FL_Coord * w, FL_Coord * h)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    i_xpos, ptr_xpos = library.make_FL_Coord_and_pointer()
    i_ypos, ptr_ypos = library.make_FL_Coord_and_pointer()
    i_width, ptr_width = library.make_FL_Coord_and_pointer()
    i_height, ptr_height = library.make_FL_Coord_and_pointer()
    library.keep_elem_refs(ptr_flobject, i_xpos, i_ypos, i_width, \
            i_height, ptr_xpos, ptr_ypos, ptr_width, ptr_height)
    _fl_get_object_bbox(ptr_flobject, ptr_xpos, ptr_ypos, \
            ptr_width, ptr_height)
    return i_xpos.value, i_ypos.value, i_width.value, i_height.value


fl_compute_object_geometry = fl_get_object_bbox


def fl_call_object_callback(ptr_flobject):
    """fl_call_object_callback(ptr_flobject)

    Invokes the callback manually (as opposed to invocation by the main
    loop). If the flobject does not have a callback associated with it,
    this call has not effect.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set

    Examples
    --------
        >>> fl_call_object_callback(pobj7_with_cb)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_call_object_callback = library.cfuncproto(
        library.load_so_libforms(), "fl_call_object_callback",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_call_object_callback(FL_OBJECT * ob)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    _fl_call_object_callback(ptr_flobject)


def fl_set_object_prehandler(ptr_flobject, pyfn_HandlePtr):
    """fl_set_object_prehandler(ptr_flobject, pyfn_HandlePtr) -> HandlePtr

    By-passes the internal event processing for a particular flobject.
    The pre-handler will be called before the built-in flobject handler.
    By electing to handle some of the events, a pre-handler can, in
    effect, replace part of the built-in handler.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be set
        pyfn_HandlePtr : python callback function, returned value
            name referring to function(ptr_flobject, [int]event, [int]xpos,
            [int]ypos, [int]key, [pointer to void]ptr_xevent) -> [int]num

    Returns
    -------
        HandlePtr : xfdata.FL_HANDLEPTR
            old flobject prehandler function

    Examples
    --------
        >>> def prehandlecb(pobj, num, crd, crd, num2, pvdata):
        >>> ... <something>
        >>> ... return 0
        >>> fl_set_object_prehandler(pobj2, prehandlecb)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    #FL_HANDLEPTR = cty.CFUNCTYPE(cty.c_int, cty.POINTER(xfdata.FL_OBJECT),
    #    cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, cty.c_int, cty.c_void_p)
    _fl_set_object_prehandler = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_prehandler",
        xfdata.FL_HANDLEPTR, [cty.POINTER(xfdata.FL_OBJECT),
        xfdata.FL_HANDLEPTR], \
        """FL_HANDLEPTR fl_set_object_prehandler(FL_OBJECT * ob,
           FL_HANDLEPTR phandler)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.verify_function_type(pyfn_HandlePtr)
    cfn_HandlePtr = xfdata.FL_HANDLEPTR(pyfn_HandlePtr)
    library.keep_cfunc_refs(cfn_HandlePtr, pyfn_HandlePtr)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_set_object_prehandler(ptr_flobject, cfn_HandlePtr)
    return retval


def fl_set_object_posthandler(ptr_flobject, pyfn_HandlePtr):
    """fl_set_object_posthandler(ptr_flobject, pyfn_HandlePtr) -> HandlePtr

    By-passes the internal event processing for a particular flobject. The
    post-handler will be invoked after the built-in handler finishes.
    Whenever possible a post-handler should be used instead of a pre-handler.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject
        pyfn_HandlePtr : python callback function, returned value
            name referring to function(ptr_flobject, [int]event, [int]xpos,
            [int]ypos, [int]key, [pointer to void]ptr_xevent) -> [int]num

    Returns
    -------
        HandlePtr : xfdata.FL_HANDLEPTR
            old flobject posthandler function

    Examples
    --------
        >>> def posthandlecb(pobj, num, crd, crd, num2, pvdata):
        >>> ... <something>
        >>> ... return 0
        >>> fl_set_object_posthandler(pobj2, posthandlecb)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    #FL_HANDLEPTR = cty.CFUNCTYPE(cty.c_int, cty.POINTER(xfdata.FL_OBJECT),
    #    cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, cty.c_int, cty.c_void_p)
    _fl_set_object_posthandler = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_posthandler",
        xfdata.FL_HANDLEPTR, [cty.POINTER(xfdata.FL_OBJECT),
        xfdata.FL_HANDLEPTR],\
        """FL_HANDLEPTR fl_set_object_posthandler(FL_OBJECT * ob,
           FL_HANDLEPTR post)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.verify_function_type(pyfn_HandlePtr)
    cfn_HandlePtr = xfdata.FL_HANDLEPTR(pyfn_HandlePtr)
    library.keep_cfunc_refs(cfn_HandlePtr, pyfn_HandlePtr)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_set_object_posthandler(ptr_flobject, cfn_HandlePtr)
    return retval


def fl_set_object_callback(ptr_flobject, pyfn_CallbackPtr, numdata):
    """fl_set_object_callback(ptr_flobject, pyfn_CallbackPtr, numdata)
    -> CallbackPtr

    Defines a callback function bound to a flobject and calls it if a
    condition is met.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject the callback is bound to
        pyfn_CallbackPtr : python function, no return
            name referring to function(ptr_flobject, [long]numdata)
            Function to be used as callback for a flobject. Do not use
            () nor arguments.
        numdata : long
            numeric argument being passed to function

    Returns
    -------
        CallbackPtr : xfdata.FL_CALLBACKPTR
            old xfdata.FL_CALLBACKPTR function

    Examples
    --------
        >>> def myobcb(pobj, longdata):
        >>> ... <something>
        >>> oldcb = fl_set_object_callback(pobj3, myobjcb, 0)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    #FL_CALLBACKPTR = cty.CFUNCTYPE(None, cty.POINTER(xfdata.FL_OBJECT),
    #                               cty.c_long)
    _fl_set_object_callback = library.cfuncproto(
        library.load_so_libforms(), "fl_set_object_callback",\
        xfdata.FL_CALLBACKPTR, [cty.POINTER(xfdata.FL_OBJECT),
        xfdata.FL_CALLBACKPTR, cty.c_long],
        """FL_CALLBACKPTR fl_set_object_callback(FL_OBJECT * obj,\
           FL_CALLBACKPTR callback, long int argument)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    l_numdata = library.convert_to_longc(numdata)
    library.verify_function_type(pyfn_CallbackPtr)
    cfn_CallbackPtr = xfdata.FL_CALLBACKPTR(pyfn_CallbackPtr)
    library.keep_cfunc_refs(cfn_CallbackPtr, pyfn_CallbackPtr)
    library.keep_elem_refs(ptr_flobject, numdata, l_numdata)
    retval = _fl_set_object_callback(ptr_flobject, cfn_CallbackPtr, \
            l_numdata)
    return retval


fl_set_call_back = fl_set_object_callback


def fl_redraw_object(ptr_flobject):
    """fl_redraw_object(ptr_flobject)

    Redraws the particular flobject. If it is a group it redraws the
    complete group. Normally you should never need this routine because
    all library routines take care of redrawing flobjects when necessary,
    but there might be situations in which an explicit redraw is required.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to redraw

    Examples
    --------
        >>> fl_redraw_object(pobj)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_redraw_object = library.cfuncproto(
        library.load_so_libforms(), "fl_redraw_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_redraw_object(FL_OBJECT * obj)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    _fl_redraw_object(ptr_flobject)


def fl_scale_object(ptr_flobject, xscale, yscale):
    """fl_scale_object(ptr_flobject, xscale, yscale)

    Scales (shrinking or enlarging) a flobject, indicating a scaling
    factor in x- and y-direction (1.1 = 110 percent, 0.5 = 50, etc.)

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be scaled
        xscale : float
            new horizontal factor
        yscale : float
            new vertical factor

    Examples
    --------
        >>> fl_scale_object(pobj, 0.8, 1.1)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_scale_object = library.cfuncproto(
        library.load_so_libforms(), "fl_scale_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_double, cty.c_double],\
        """void fl_scale_object(FL_OBJECT * ob, double xs, double ys)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    f_xscale = library.convert_to_doublec(xscale)
    f_yscale = library.convert_to_doublec(yscale)
    library.keep_elem_refs(ptr_flobject, xscale, f_xscale, \
            yscale, f_yscale)
    _fl_scale_object(ptr_flobject, f_xscale, f_yscale)


def fl_show_object(ptr_flobject):
    """fl_show_object(ptr_flobject)

    Shows a flobject, already hidden by fl_hide_object().

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be shown

    Examples
    --------
        >>> fl_show_object(pobj8)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_show_object = library.cfuncproto(
        library.load_so_libforms(), "fl_show_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_show_object(FL_OBJECT * ob)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    _fl_show_object(ptr_flobject)


def fl_hide_object(ptr_flobject):
    """fl_hide_object(ptr_flobject)

    Hides a shown flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be hidden

    Examples
    --------
        >>> fl_hide_object(pobj8)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_hide_object = library.cfuncproto(
        library.load_so_libforms(), "fl_hide_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_hide_object(FL_OBJECT * ob)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    _fl_hide_object(ptr_flobject)


def fl_object_is_visible(ptr_flobject):
    """fl_object_is_visible(ptr_flobject) -> yesno

    Tells if a flobject is visible or not.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        yesno : int
            visibility flag. Values 0 (invisible) or non-zero
            (visible)

    Examples
    --------
        >>> if not fl_object_is_visible(pobj2):
        >>> ... <something>

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_object_is_visible = library.cfuncproto(
        library.load_so_libforms(), "fl_object_is_visible",\
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],\
        """int fl_object_is_visible(FL_OBJECT * obj)""")
    library.check_if_flinitialized()
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_object_is_visible(ptr_flobject)
    return retval


def fl_free_object(ptr_flobject):
    """fl_free_object(ptr_flobject)

    Frees the flobject and finally destroys it (if necessary, deletes
    the flobject first).

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be freed

    Examples
    --------
        >>> fl_free_object(pobj)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_free_object = library.cfuncproto(
        library.load_so_libforms(), "fl_free_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_free_object(FL_OBJECT * obj)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    _fl_free_object(ptr_flobject)


def fl_delete_object(ptr_flobject):
    """fl_delete_object(ptr_flobject)

    Deletes a flobject, breaking its connection to the form,
    but not destroying it.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be deleted

    Examples
    --------
        >>> fl_delete_object(pobj)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_delete_object = library.cfuncproto(
        library.load_so_libforms(), "fl_delete_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_delete_object(FL_OBJECT * obj)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    _fl_delete_object(ptr_flobject)


def fl_get_object_return_state(ptr_flobject):
    """fl_get_object_return_state(ptr_flobject) -> retnstate

    Tells the reason a flobject was returned (or its callback
    invoked).

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        retnstate : int
            current return state as a logical 'OR' of the conditions
            that led to the flobject getting returned.

    Examples
    --------
        >>> currstate = fl_get_object_return_state(pobj5)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_object_return_state = library.cfuncproto(
        library.load_so_libforms(), "fl_get_object_return_state",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],\
        """int fl_get_object_return_state(FL_OBJECT * obj)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_get_object_return_state(ptr_flobject)
    return retval


def fl_trigger_object(ptr_flobject):
    """fl_trigger_object(ptr_flobject)

    Simulates the action of a flobject being triggered from within
    the program. Calling this routine on a flobject results in the
    flobject returned to the application program or its callback being
    called if it exists. Note, however, there is no visual feedback,
    i.e. fl_trigger_object(button) will not make the button flobject
    named button appearing to be pushed.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to trigger

    Examples
    --------
        >>> fl_trigger_object(pobj)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_trigger_object = library.cfuncproto(
        library.load_so_libforms(), "fl_trigger_object", \
        None, [cty.POINTER(xfdata.FL_OBJECT)], \
        """void fl_trigger_object(FL_OBJECT * obj)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    _fl_trigger_object(ptr_flobject)


def fl_activate_object(ptr_flobject):
    """fl_activate_object(ptr_flobject)

    (Re)activates a flobject, (re)enabling user interaction,
    previously disabled with fl_deactivate_object().

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be activated

    Examples
    --------
        >>> fl_activate_object(pobj)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_activate_object = library.cfuncproto(
        library.load_so_libforms(), "fl_activate_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_activate_object(FL_OBJECT * ob)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    _fl_activate_object(ptr_flobject)


def fl_deactivate_object(ptr_flobject):
    """fl_deactivate_object(ptr_flobject)

    Makes a particular flobject to be temporarily inactive, disabling
    user interaction, e.g., you want to make it impossible for the user
    to press a particular button or to type input in a particular field.
    When flobject is a group, the whole group is deactivated.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be deactivated

    Examples
    --------
        >>> fl_deactivate_object(pobj)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_deactivate_object = library.cfuncproto(
        library.load_so_libforms(), "fl_deactivate_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_deactivate_object(FL_OBJECT * ob)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    _fl_deactivate_object(ptr_flobject)


def fl_object_is_active(ptr_flobject):
    """fl_object_is_active(ptr_flobject) -> yesno

    Tells if flobject is active and reacting to events, or not.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to evaluate

    Returns
    -------
        yesno : int
            flag of activity of a flobject. Values 0 (not active)
            or non-zero (active)

    Examples
    --------
        >>> if not fl_object_is_active(pobj):
        >>> ... <something>

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_object_is_active = library.cfuncproto(
        library.load_so_libforms(), "fl_object_is_active",\
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],\
        """int fl_object_is_active(FL_OBJECT * ob)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_object_is_active(ptr_flobject)
    return retval


def fl_enumerate_fonts(pyfn_output, shortform):
    """fl_enumerate_fonts(pyfn_output, shortform) -> numfonts

    Lists built-in fonts.

    Parameters
    ----------
        pyfn_output : python function, no return
            function referring to fn(string)
            Functions to be used as callback to enumerate fonts
        shortform : int
            flag to use short form (non-zero) or not (0 for long form)

    Returns
    -------
        numfonts : int
            number of listed fonts

    Examples
    --------
        >>> def pyoutput(strng):
        >>> ... print strng
        >>> nfonts = fl_enumerate(pyoutput, 0)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    cfunc_none_string = cty.CFUNCTYPE(None, xfdata.STRING)
    _fl_enumerate_fonts = library.cfuncproto(
        library.load_so_libforms(), "fl_enumerate_fonts",\
        cty.c_int, [cfunc_none_string, cty.c_int],\
        """int fl_enumerate_fonts(void ( * output )( const char *s ), \
           int shortform)""")
    library.check_if_flinitialized()
    library.verify_function_type(pyfn_output)
    cfn_output = cfunc_none_string(pyfn_output)
    i_shortform = library.convert_to_intc(shortform)
    library.keep_cfunc_refs(cfn_output, pyfn_output)
    library.keep_elem_refs(shortform, i_shortform)
    retval = _fl_enumerate_fonts(cfn_output, i_shortform)
    return retval


# TODO: verify if name must conform to other (built-in) font names
def fl_set_font_name(fontnum, name):
    """fl_set_font_name(fontnum, name) -> result

    Adds a new font (indexed by a number) or changes an existing font.
    Preferably the font name contains a '?' in the size position so
    different sizes can be used. Redraw of all forms is required to
    actually see the change for visible form.

    Parameters
    ----------
        fontnum : int
            font number. Values between 0 and xfdata.FL_MAXFONTS-1
        name : str
            font name. It should respect X Logical Font Description
            (-foundry-family-weight-slant-setwidth-addstyle-pixels-points
            -horiz-vert-spacing-avgwidth-rgstry-encoding). The fields are
            foundry (The name of the company that digitized the font), 
            family (The typeface family - Courier, Times Roman, Helvetica,
            etc.), weight (The "blackness" of the font - bold, medium,
            demibold, etc.), slant (The "posture" of the font. "r" for
            upright, "i" for italic, etc.), setwidth (Typographic
            proportionate width of the font), addstyle (Additional
            typographic style information), pixels (Size of the font in
            device-dependent pixels), points (Size of the font in
            device-independent points), horiz (Horizontal dots-per-inch for
            which the font was designed), vert (Vertical dots-per-inch for
            which the font was designed), spacing (The spacing class of the
            font. "p" for proportional, "m" for monospaced, etc.), avgwidth
            (Average width of all glyphs in the font), rgstry (Tells the
            language the characters conform to. iso8859 = Latin characters),
            encoding (Further language encoding information).
    Returns
    -------
        result : int
            0 on success), or 1 (if no display), or -1 (on errors, if
            bad font name or number)

    Examples
    --------
        >>> fl_set_font_name(40,
                "-adobe-utopia-bold-i-normal--19-140-100-100-p-109-iso8859-4")

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_font_name = library.cfuncproto(
        library.load_so_libforms(), "fl_set_font_name",\
        cty.c_int, [cty.c_int, xfdata.STRING],\
        """int fl_set_font_name(int n, const char * name)""")
    library.check_if_flinitialized()
    i_fontnum = library.convert_to_intc(fontnum)
    s_name = library.convert_to_stringc(name)
    library.keep_elem_refs(fontnum, i_fontnum, name, s_name)
    retval = _fl_set_font_name(i_fontnum, s_name)
    return retval


def fl_set_font(fontnum, size):
    """fl_set_font(fontnum, size)

    Makes the specified font as the current.

    Parameters
    ----------
        fontnum : int
            font number
        size : int
            font size. Values (from xfdata.py)
            - FL_TINY_SIZE (8 points font),
            - FL_SMALL_SIZE or FL_DEFAULT_SIZE (10 points font, default),
            - FL_NORMAL_SIZE (12 points font),
            - FL_MEDIUM_SIZE (14 points font),
            - FL_LARGE_SIZE (18 points font),
            - FL_HUGE_SIZE (24 points font),
            - or other numeric odd or even value

    Examples
    --------
        >>> fl_set_font(5, xfdata.FL_SMALL_SIZE)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_font = library.cfuncproto(
        library.load_so_libforms(), "fl_set_font",\
        None, [cty.c_int, cty.c_int],\
        """void fl_set_font(int numb, int size)""")
    library.check_if_flinitialized()
    i_fontnum = library.convert_to_intc(fontnum)
    i_size = library.convert_to_intc(size)
    library.keep_elem_refs(fontnum, i_fontnum, size, i_size)
    _fl_set_font(i_fontnum, i_size)


# routines that facilitate free flobject

def fl_get_char_height(style, size):
    """fl_get_char_height(style, size) -> height, ascndt, descndt

    Finds out the maximum height of the used font and the height above and
    below the baseline of the font.

    Parameters
    ----------
        style : int
            font style. Values (from xfdata.py)
            - FL_NORMAL_STYLE (Helvetica normal text),
            - FL_BOLD_STYLE (Helvetica boldface text),
            - FL_ITALIC_STYLE (Helvetica italic text),
            - FL_BOLDITALIC_STYLE (Helvetica boldface and italic text),
            - FL_FIXED_STYLE (Courier fixed width, good for tables),
            - FL_FIXEDBOLD_STYLE (Courier bold fixed text),
            - FL_FIXEDITALIC_STYLE (Courier italic fixed text),
            - FL_FIXEDBOLDITALIC_STYLE (Courier boldface and italic fixed
              text),
            - FL_TIMES_STYLE (Times-Roman like normal font),
            - FL_TIMESBOLD_STYLE (Times-Roman like boldface text),
            - FL_TIMESITALIC_STYLE (Times-Roman like italic text),
            - FL_TIMESBOLDITALIC_STYLE (Times-Roman like boldface and italic
            text),
            - FL_MISC_STYLE (Charter normal text),
            - FL_MISCBOLD_STYLE (Charter boldface text),
            - FL_MISCITALIC_STYLE (Charter italic text),
            - FL_SYMBOL_STYLE (Symbol text),
            - FL_SHADOW_STYLE (Text casting a shadow, modifier mask),
            - FL_ENGRAVED_STYLE (Text engraved into the form, modifier mask),
            - FL_EMBOSSED_STYLE (Text standing out, modifier mask).
            Bitwise OR with any of modifiers is allowed.
        size : int
            font size. Values (from xfdata.py)
            - FL_TINY_SIZE (8 points font),
            - FL_SMALL_SIZE or FL_DEFAULT_SIZE (10 points font, default),
            - FL_NORMAL_SIZE (12 points font),
            - FL_MEDIUM_SIZE (14 points font),
            - FL_LARGE_SIZE (18 points font),
            - FL_HUGE_SIZE (24 points font),
            - or other numeric odd or even value.

    Returns
    -------
        height : int
            totale height of font
        ascndt : int
            ascendent height of font
        descndt : int
            descendent height of font

    Examples
    --------
        >>> hei, asc, desc = fl_get_char_height(xfdata.FL_BOLD_STYLE,
                xfdata.FL_TINY_SIZE)

    API_diversion
    ----------
        API changed from XForms, upstream is
        fl_get_char_height(style, size, asc, desc)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_char_height = library.cfuncproto(
        library.load_so_libforms(), "fl_get_char_height",\
        cty.c_int, [cty.c_int, cty.c_int, cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int)],\
        """int fl_get_char_height(int style, int size, int * asc,
           int * desc)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(style, \
            xfdata.TEXTSTYLE_list)
    i_style = library.convert_to_intc(style)
    i_size = library.convert_to_intc(size)
    i_ascndt, ptr_ascndt = library.make_intc_and_pointer()
    i_descndt, ptr_descndt = library.make_intc_and_pointer()
    library.keep_elem_refs(style, i_style, size, i_size, i_ascndt, \
            i_descndt, ptr_ascndt, ptr_descndt)
    retval = _fl_get_char_height(i_style, i_size, ptr_ascndt, ptr_descndt)
    return retval, i_ascndt.value, i_descndt.value


def fl_get_char_width(style, size):
    """fl_get_char_width(style, size) -> width

    Finds out the maximum width of the used font.

    Parameters
    ----------
        style : int
            font style. Values (from xfdata.py)
            - FL_NORMAL_STYLE (Helvetica normal text),
            - FL_BOLD_STYLE (Helvetica boldface text),
            - FL_ITALIC_STYLE (Helvetica italic text),
            - FL_BOLDITALIC_STYLE (Helvetica boldface and italic text),
            - FL_FIXED_STYLE (Courier fixed width, good for tables),
            - FL_FIXEDBOLD_STYLE (Courier bold fixed text),
            - FL_FIXEDITALIC_STYLE (Courier italic fixed text),
            - FL_FIXEDBOLDITALIC_STYLE (Courier boldface and italic fixed
              text),
            - FL_TIMES_STYLE (Times-Roman like normal font),
            - FL_TIMESBOLD_STYLE (Times-Roman like boldface text),
            - FL_TIMESITALIC_STYLE (Times-Roman like italic text),
            - FL_TIMESBOLDITALIC_STYLE (Times-Roman like boldface and italic
              text),
            - FL_MISC_STYLE (Charter normal text),
            - FL_MISCBOLD_STYLE (Charter boldface text),
            - FL_MISCITALIC_STYLE (Charter italic text),
            - FL_SYMBOL_STYLE (Symbol text),
            - FL_SHADOW_STYLE (Text casting a shadow, modifier mask),
            - FL_ENGRAVED_STYLE (Text engraved into the form, modifier mask),
            - FL_EMBOSSED_STYLE (Text standing out, modifier mask).
            Bitwise OR with any of modifiers is allowed.
        size : int
            font size. Values (from xfdata.py)
            - FL_TINY_SIZE (8 points font),
            - FL_SMALL_SIZE or FL_DEFAULT_SIZE (10 points font, default),
            - FL_NORMAL_SIZE (12 points font),
            - FL_MEDIUM_SIZE (14 points font),
            - FL_LARGE_SIZE (18 points font),
            - FL_HUGE_SIZE (24 points font),
            - or other numeric odd or even value

    Returns
    -------
        width : int
            width of font

    Examples
    --------
        >>> wid = fl_get_char_width(xfdata.FL_TIMES_STYLE,
                xfdata.FL_HUGE_SIZE)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_char_width = library.cfuncproto(
        library.load_so_libforms(), "fl_get_char_width",\
        cty.c_int, [cty.c_int, cty.c_int],\
        """int fl_get_char_width(int style, int size)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(style, xfdata.TEXTSTYLE_list)
    i_style = library.convert_to_intc(style)
    i_size = library.convert_to_intc(size)
    library.keep_elem_refs(style, i_style, size, i_size)
    retval = _fl_get_char_width(i_style, i_size)
    return retval


def fl_get_string_height(style, size, txtstr, strlng):
    """fl_get_string_height(style, size, txtstr, strlng)
    -> height, ascndt, descndt

    Finds out the height information of a specific string and the height
    above and below the font's baseline.

    Parameters
    ----------
        style : int
            font style for text. Values (from xfdata.py)
            - FL_NORMAL_STYLE (Helvetica normal text),
            - FL_BOLD_STYLE (Helvetica boldface text),
            - FL_ITALIC_STYLE (Helvetica italic text),
            - FL_BOLDITALIC_STYLE (Helvetica boldface and italic text),
            - FL_FIXED_STYLE (Courier fixed width, good for tables),
            - FL_FIXEDBOLD_STYLE (Courier bold fixed text),
            - FL_FIXEDITALIC_STYLE (Courier italic fixed text),
            - FL_FIXEDBOLDITALIC_STYLE (Courier boldface and italic fixed),
            - FL_TIMES_STYLE (Times-Roman like normal font),
            - FL_TIMESBOLD_STYLE (Times-Roman like boldface text),
            - FL_TIMESITALIC_STYLE (Times-Roman like italic text),
            - FL_TIMESBOLDITALIC_STYLE (Times-Roman like boldface and italic),
            - FL_MISC_STYLE (Charter normal text),
            - FL_MISCBOLD_STYLE (Charter boldface text),
            - FL_MISCITALIC_STYLE (Charter italic text),
            - FL_SYMBOL_STYLE (Symbol text),
            - FL_SHADOW_STYLE (Text casting a shadow, modifier mask),
            - FL_ENGRAVED_STYLE (Text engraved into the form, modifier mask),
            - FL_EMBOSSED_STYLE (Text standing out, modifier mask).
            Bitwise OR with any of modifiers is allowed.
        size : int
            font size. Values (from xfdata.py)
            - FL_TINY_SIZE (8 points font),
            - FL_SMALL_SIZE or FL_DEFAULT_SIZE (10 points font, default),
            - FL_NORMAL_SIZE (12 points font),
            - FL_MEDIUM_SIZE (14 points font),
            - FL_LARGE_SIZE (18 points font),
            - FL_HUGE_SIZE (24 points font),
            - or other numeric odd or even value
        txtstr : str
            text to evaluate
        strlng : int
            length of text

    Returns
    -------
        height : int
            height of font
        ascndt : int
            ascendent of font
        descndt : int
            descendent of font

    Examples
    --------
        >>> hei, asc, desc = fl_get_string_height(xfdata.FL_MISC_STYLE,
                xfdata.FL_MEDIUM_SIZE, "Mystring", 8)

    API_diversion
    ----------
        API changed from XForms, upstream is
        fl_get_string_height(style, size, strng, strglen, asc, desc)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_get_string_height = library.cfuncproto(
        library.load_so_libforms(), "fl_get_string_height",\
        cty.c_int, [cty.c_int, cty.c_int, xfdata.STRING, cty.c_int,
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],\
        """int fl_get_string_height(int style, int size, const char * s,
           int len, int * asc, int * desc)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(style, xfdata.TEXTSTYLE_list)
    i_style = library.convert_to_intc(style)
    i_size = library.convert_to_intc(size)
    s_txtstr = library.convert_to_stringc(txtstr)
    i_strlng = library.convert_to_intc(strlng)
    i_ascndt, ptr_ascndt = library.make_intc_and_pointer()
    i_descndt, ptr_descndt = library.make_intc_and_pointer()
    library.keep_elem_refs(style, i_style, size, i_size, txtstr, \
            s_txtstr, strlng, i_strlng, i_ascndt, i_descndt, \
            ptr_ascndt, ptr_descndt)
    retval = _fl_get_string_height(i_style, i_size, s_txtstr, \
            i_strlng, ptr_ascndt, ptr_descndt)
    return retval, i_ascndt.value, i_descndt.value


def fl_get_string_width(style, size, txtstr, strlng):
    """fl_get_string_width(style, size, txtstr, strlng) -> width

    Finds out the width information for a specific string.

    Parameters
    ----------
        style : int
            font style for text. Values (from xfdata.py)
            - FL_NORMAL_STYLE (Helvetica normal text),
            - FL_BOLD_STYLE (Helvetica boldface text),
            - FL_ITALIC_STYLE (Helvetica italic text),
            - FL_BOLDITALIC_STYLE (Helvetica boldface and italic text),
            - FL_FIXED_STYLE (Courier fixed width, good for tables),
            - FL_FIXEDBOLD_STYLE (Courier bold fixed text),
            - FL_FIXEDITALIC_STYLE (Courier italic fixed text),
            - FL_FIXEDBOLDITALIC_STYLE (Courier boldface and italic fixed),
            - FL_TIMES_STYLE (Times-Roman like normal font),
            - FL_TIMESBOLD_STYLE (Times-Roman like boldface text),
            - FL_TIMESITALIC_STYLE (Times-Roman like italic text),
            - FL_TIMESBOLDITALIC_STYLE (Times-Roman like boldface and italic),
            - FL_MISC_STYLE (Charter normal text),
            - FL_MISCBOLD_STYLE (Charter boldface text),
            - FL_MISCITALIC_STYLE (Charter italic text),
            - FL_SYMBOL_STYLE (Symbol text),
            - FL_SHADOW_STYLE (Text casting a shadow, modifier mask),
            - FL_ENGRAVED_STYLE (Text engraved into the form, modifier mask),
            - FL_EMBOSSED_STYLE (Text standing out, modifier mask).
            Bitwise OR with any of modifiers is allowed.
        size : int
            font size. Values (from xfdata.py)
            - FL_TINY_SIZE (8 points font),
            - FL_SMALL_SIZE or FL_DEFAULT_SIZE (10 points font, default),
            - FL_NORMAL_SIZE (12 points font),
            - FL_MEDIUM_SIZE (14 points font),
            - FL_LARGE_SIZE (18 points font),
            - FL_HUGE_SIZE (24 points font),
            - or other numeric odd or even value
        txtstr : str
            text
        strlng : int
            length of text

    Returns
    -------
        width : int
            width of string

    Examples
    --------
        >>> wid = fl_get_string_width(xfdata.FL_MISC_STYLE,
                xfdata.FL_MEDIUM_SIZE, "Mystring", 8)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_get_string_width = library.cfuncproto(
        library.load_so_libforms(), "fl_get_string_width",\
        cty.c_int, [cty.c_int, cty.c_int, xfdata.STRING, cty.c_int],\
        """int fl_get_string_width(int style, int size, const char * s,
           int len)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(style, xfdata.TEXTSTYLE_list)
    i_style = library.convert_to_intc(style)
    i_size = library.convert_to_intc(size)
    s_txtstr = library.convert_to_stringc(txtstr)
    i_strlng = library.convert_to_intc(strlng)
    library.keep_elem_refs(style, i_style, size, i_size, txtstr, \
            s_txtstr, strlng, i_strlng)
    retval = _fl_get_string_width(i_style, i_size, s_txtstr, i_strlng)
    return retval


def fl_get_string_widthTAB(style, size, txtstr, strlng):
    """fl_get_string_widthTAB(style, size, txtstr, strlng) -> width

    Finds out the width information for a specific string, including Tab
    characters.

    Parameters
    ----------
        style : int
            font style. Values (from xfdata.py)
            - FL_NORMAL_STYLE (Helvetica normal text),
            - FL_BOLD_STYLE (Helvetica boldface text),
            - FL_ITALIC_STYLE (Helvetica italic text),
            - FL_BOLDITALIC_STYLE (Helvetica boldface and italic text),
            - FL_FIXED_STYLE (Courier fixed width, good for tables),
            - FL_FIXEDBOLD_STYLE (Courier bold fixed text),
            - FL_FIXEDITALIC_STYLE (Courier italic fixed text),
            - FL_FIXEDBOLDITALIC_STYLE (Courier boldface and italic fixed),
            - FL_TIMES_STYLE (Times-Roman like normal font),
            - FL_TIMESBOLD_STYLE (Times-Roman like boldface text),
            - FL_TIMESITALIC_STYLE (Times-Roman like italic text),
            - FL_TIMESBOLDITALIC_STYLE (Times-Roman like boldface and italic),
            - FL_MISC_STYLE (Charter normal text),
            - FL_MISCBOLD_STYLE (Charter boldface text),
            - FL_MISCITALIC_STYLE (Charter italic text),
            - FL_SYMBOL_STYLE (Symbol text),
            - FL_SHADOW_STYLE (Text casting a shadow, modifier mask),
            - FL_ENGRAVED_STYLE (Text engraved into the form, modifier mask),
            - FL_EMBOSSED_STYLE (Text standing out, modifier mask).
            Bitwise OR with any of modifiers is allowed.
        size : int
            font size. Values (from xfdata.py)
            - FL_TINY_SIZE (8 points font),
            - FL_SMALL_SIZE or FL_DEFAULT_SIZE (10 points font, default),
            - FL_NORMAL_SIZE (12 points font),
            - FL_MEDIUM_SIZE (14 points font),
            - FL_LARGE_SIZE (18 points font),
            - FL_HUGE_SIZE (24 points font),
            - or other numeric odd or even value
        txtstr : str
            text
        strlng : int
            length of text

    Returns
    -------
        width : int
            width

    Examples
    --------
        >>> wid = fl_get_string_width(xfdata.FL_MISC_STYLE,
                xfdata.FL_MEDIUM_SIZE, "\tMystring", 8)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_string_widthTAB = library.cfuncproto(
        library.load_so_libforms(), "fl_get_string_widthTAB",\
        cty.c_int, [cty.c_int, cty.c_int, xfdata.STRING, cty.c_int],\
        """int fl_get_string_widthTAB(int style, int size, const char * s,
           int len)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(style, xfdata.TEXTSTYLE_list)
    i_style = library.convert_to_intc(style)
    i_size = library.convert_to_intc(size)
    s_txtstr = library.convert_to_stringc(txtstr)
    i_strlng = library.convert_to_intc(strlng)
    library.keep_elem_refs(style, i_style, size, i_size, txtstr, \
            s_txtstr, strlng, i_strlng)
    retval = _fl_get_string_widthTAB(i_style, i_size, s_txtstr, i_strlng)
    return retval


def fl_get_string_dimension(style, size, txtstr, strlng):
    """fl_get_string_dimension(style, size, txtstr, strlng) -> width, height

    Finds out the width and height of a string in one call. In addition, the
    string passed can contain embedded newline characters and the routine
    will make proper adjustment so the values returned are (just) large
    enough to contain the multiple lines of text.

    Parameters
    ----------
        style : int
            font style. Values (from xfdata.py)
            - FL_NORMAL_STYLE (Helvetica normal text),
            - FL_BOLD_STYLE (Helvetica boldface text),
            - FL_ITALIC_STYLE (Helvetica italic text),
            - FL_BOLDITALIC_STYLE (Helvetica boldface and italic text),
            - FL_FIXED_STYLE (Courier fixed width, good for tables),
            - FL_FIXEDBOLD_STYLE (Courier bold fixed text),
            - FL_FIXEDITALIC_STYLE (Courier italic fixed text),
            - FL_FIXEDBOLDITALIC_STYLE (Courier boldface and italic fixed),
            - FL_TIMES_STYLE (Times-Roman like normal font),
            - FL_TIMESBOLD_STYLE (Times-Roman like boldface text),
            - FL_TIMESITALIC_STYLE (Times-Roman like italic text),
            - FL_TIMESBOLDITALIC_STYLE (Times-Roman like boldface and italic),
            - FL_MISC_STYLE (Charter normal text),
            - FL_MISCBOLD_STYLE (Charter boldface text),
            - FL_MISCITALIC_STYLE (Charter italic text),
            - FL_SYMBOL_STYLE (Symbol text),
            - FL_SHADOW_STYLE (Text casting a shadow, modifier mask),
            - FL_ENGRAVED_STYLE (Text engraved into the form, modifier mask),
            - FL_EMBOSSED_STYLE (Text standing out, modifier mask).
            Bitwise OR with any of modifiers is allowed.
        size : int
            font size. Values (from xfdata.py)
            - FL_TINY_SIZE (8 points font),
            - FL_SMALL_SIZE or FL_DEFAULT_SIZE (10 points font, default),
            - FL_NORMAL_SIZE (12 points font),
            - FL_MEDIUM_SIZE (14 points font),
            - FL_LARGE_SIZE (18 points font),
            - FL_HUGE_SIZE (24 points font),
            - or other numeric odd or even value
        txtstr : str
            text
        strlng : int
            length of text

    Returns
    -------
        width : int
            width
        height : int
            height

    Examples
    --------
        >>> fl_get_string_dimension(xfdata.FL_ENGRAVED_STYLE,
                xfdata.FL_DEFAULT_SIZE, "CustomString", 12)

    API_diversion
    ----------
        API changed from XForms, upstream is fl_get_string_dimension(fntstyle,
        fntsize, strng, strglen, width, height)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_string_dimension = library.cfuncproto(
        library.load_so_libforms(), "fl_get_string_dimension",\
        None, [cty.c_int, cty.c_int, xfdata.STRING, cty.c_int,
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],\
        """void fl_get_string_dimension(int fntstyle, int fntsize,
           const char * s, int len, int * width, int * height)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(style, xfdata.TEXTSTYLE_list)
    i_style = library.convert_to_intc(style)
    i_size = library.convert_to_intc(size)
    s_txtstr = library.convert_to_stringc(txtstr)
    i_strlng = library.convert_to_intc(strlng)
    i_width, ptr_width = library.make_intc_and_pointer()
    i_height, ptr_height = library.make_intc_and_pointer()
    library.keep_elem_refs(style, i_style, size, i_size, txtstr, s_txtstr, \
            strlng, i_strlng, i_width, i_height, ptr_width, ptr_height)
    _fl_get_string_dimension(i_style, i_size, s_txtstr, i_strlng, \
            ptr_width, ptr_height)
    return i_width.value, i_height.value


fl_get_string_size = fl_get_string_dimension


def fl_get_align_xy(align, xpos, ypos, width, height, xsize, ysize, \
                    xmargin, ymargin):
    """fl_get_align_xy(align, xpos, ypos, width, height, xsize, ysize,
    xmargin, ymargin) -> xpos, ypos

    Finds out the position of where to draw the flobject with a certain
    alignment and including padding. It works regardless if it is to be
    drawn inside or outside of the bounding box.

    Parameters
    ----------
        align : int
            alignment. Values (from xfdata.py)
            - FL_ALIGN_CENTER (In the middle of the box, inside it),
            - FL_ALIGN_TOP (To the top of the box, outside it),
            - FL_ALIGN_BOTTOM (To the bottom of the box, outside it),
            - FL_ALIGN_LEFT (To the left of the box, outside it),
            - FL_ALIGN_RIGHT (To the right of the box, outside it),
            - FL_ALIGN_LEFT_TOP (To the left and top of the box, outside it),
            - FL_ALIGN_RIGHT_TOP (To the right and top of the box, outside it),
            - FL_ALIGN_LEFT_BOTTOM (To the left and bottom of box, outside it),
            - FL_ALIGN_RIGHT_BOTTOM (To the right and bottom of box, outside),
            - FL_ALIGN_INSIDE (places the text inside the box),
            - FL_ALIGN_VERT (not functional yet).
            Bitwise OR with FL_ALIGN_INSIDE is allowed.
        xpos : int
            horizontal position of bounding box (upper-left corner)
        ypos : int
            vertical position of bounding box (upper-left corner)
        width : int
            width of bounding box in coord units
        height : int
            height of bounding box in coord units
        xsize : int
            width of the flobject to be drawn
        ysize : int
            height of the flobject to be drawn
        xmargin : int
            additional horizontal padding to use
        ymargin : int
            additional vertical padding to use

    Returns
    -------
        xpos : int
            horizontal position used for drawing flobject
        ypos : int
            vertical position used for drawing flobject

    Examples
    --------
        >>> x, y = fl_get_align_xy(xfdata.FL_ALIGN_CENTER, 200, 300,
                110, 30, 120, 40, 15, 15)

    API_diversion
    ----------
        API changed from XForms, upstream is fl_get_align_xy(align, xpos,
        ypos, width, height, xsize, ysize, xoff, yoff, xx, yy)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_align_xy = library.cfuncproto(
        library.load_so_libforms(), "fl_get_align_xy",\
        None, [cty.c_int, cty.c_int, cty.c_int, cty.c_int, cty.c_int,\
        cty.c_int, cty.c_int, cty.c_int, cty.c_int,
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],\
        """void fl_get_align_xy(int align, int x, int y, int w, int h,
           int xsize, int ysize, int xoff, int yoff, int * xx, int * yy)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(align, xfdata.ALIGN_list)
    i_align = library.convert_to_intc(align)
    i_xpos = library.convert_to_intc(xpos)
    i_ypos = library.convert_to_intc(ypos)
    i_width = library.convert_to_intc(width)
    i_height = library.convert_to_intc(height)
    i_xsize = library.convert_to_intc(xsize)
    i_ysize = library.convert_to_intc(ysize)
    i_xmargin = library.convert_to_intc(xmargin)
    i_ymargin = library.convert_to_intc(ymargin)
    i_xx, ptr_xx = library.make_intc_and_pointer()
    i_yy, ptr_yy = library.make_intc_and_pointer()
    library.keep_elem_refs(align, i_align, xpos, i_xpos, ypos, i_ypos, \
            width, i_width, height, i_height, xsize, i_xsize, ysize, \
            i_ysize, xmargin, i_xmargin, ymargin, i_ymargin, i_xx, i_yy, \
            ptr_xx, ptr_yy)
    _fl_get_align_xy(i_align, i_xpos, i_ypos, i_width, i_height, i_xsize, \
            i_ysize, i_xmargin, i_ymargin, ptr_xx, ptr_yy)
    return i_xx.value, i_yy.value


def fl_drw_text(align, xpos, ypos, width, height, colr, style, size, txtstr):
    """fl_drw_text(align, xpos, ypos, width, height, colr, style, size, txtstr)

    Draws the text inside the bounding box according to the alignment
    requested. It puts a padding of 5 pixels in vertical direction and
    4 in horizontal around the text. Thus the bounding box should be 10
    pixels wider and 8 pixels higher than required for the text to be
    drawn. It interprets a text string starting with the character @
    differently in drawing some symbols instead.

    Parameters
    ----------
        align : int
            alignment of text. Values (from xfdata.py)
            - FL_ALIGN_CENTER (In the middle of the box, inside it),
            - FL_ALIGN_TOP (To the top of the box, outside it),
            - FL_ALIGN_BOTTOM (To the bottom of the box, outside it),
            - FL_ALIGN_LEFT (To the left of the box, outside it),
            - FL_ALIGN_RIGHT (To the right of the box, outside it),
            - FL_ALIGN_LEFT_TOP (To the left and top of the box, outside it),
            - FL_ALIGN_RIGHT_TOP (To the right and top of the box, outside it),
            - FL_ALIGN_LEFT_BOTTOM (To the left and bottom of box, outside it),
            - FL_ALIGN_RIGHT_BOTTOM (To the right and bottom of box, outside),
            - FL_ALIGN_INSIDE (places the text inside the box),
            - FL_ALIGN_VERT (not functional yet).
            Bitwise OR with FL_ALIGN_INSIDE is allowed.
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color
        style : int
            font style for text. Values (from xfdata.py)
            - FL_NORMAL_STYLE (Helvetica normal text),
            - FL_BOLD_STYLE (Helvetica boldface text),
            - FL_ITALIC_STYLE (Helvetica italic text),
            - FL_BOLDITALIC_STYLE (Helvetica boldface and italic text),
            - FL_FIXED_STYLE (Courier fixed width, good for tables),
            - FL_FIXEDBOLD_STYLE (Courier bold fixed text),
            - FL_FIXEDITALIC_STYLE (Courier italic fixed text),
            - FL_FIXEDBOLDITALIC_STYLE (Courier boldface and italic fixed),
            - FL_TIMES_STYLE (Times-Roman like normal font),
            - FL_TIMESBOLD_STYLE (Times-Roman like boldface text),
            - FL_TIMESITALIC_STYLE (Times-Roman like italic text),
            - FL_TIMESBOLDITALIC_STYLE (Times-Roman like boldface and italic
            - FL_MISC_STYLE (Charter normal text),
            - FL_MISCBOLD_STYLE (Charter boldface text),
            - FL_MISCITALIC_STYLE (Charter italic text),
            - FL_SYMBOL_STYLE (Symbol text),
            - FL_SHADOW_STYLE (Text casting a shadow, modifier mask),
            - FL_ENGRAVED_STYLE (Text engraved into the form, modifier mask),
            - FL_EMBOSSED_STYLE (Text standing out, modifier mask).
            Bitwise OR with any of modifiers is allowed.
        size : int
            font size. Values (from xfdata.py)
            - FL_TINY_SIZE (8 points font),
            - FL_SMALL_SIZE or FL_DEFAULT_SIZE (10 points font, default),
            - FL_NORMAL_SIZE (12 points font),
            - FL_MEDIUM_SIZE (14 points font),
            - FL_LARGE_SIZE (18 points font),
            - FL_HUGE_SIZE (24 points font),
            - or other numeric odd or even value
        txtstr : str
            text to draw

    Examples
    --------
        >>> fl_drw_text(xfdata.FL_ALIGN_BOTTOM, 400, 175, 150, 45,
                xfdata.FL_GREEN, xfdata.FL_ITALIC_STYLE,
                xfdata.FL_SMALL_SIZE, "A Good Old String")

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_drw_text = library.cfuncproto(
        library.load_so_libforms(), "fl_drw_text",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR, cty.c_int, cty.c_int, xfdata.STRING],
        """void fl_drw_text(int align, FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, FL_COLOR c, int style, int size, const char * istr)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(align, xfdata.ALIGN_list)
    i_align = library.convert_to_intc(align)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.checkfatal_allowed_value_in_list(style, xfdata.TEXTSTYLE_list)
    i_style = library.convert_to_intc(style)
    i_size = library.convert_to_intc(size)
    s_txtstr = library.convert_to_stringc(txtstr)
    library.keep_elem_refs(align, i_align, xpos, i_xpos, ypos, i_ypos, \
            width, i_width, height, i_height, colr, ul_colr, style, \
            i_style, size, i_size, txtstr, s_txtstr)
    _fl_drw_text(i_align, i_xpos, i_ypos, i_width, i_height, ul_colr, \
            i_style, i_size, s_txtstr)


def fl_drw_text_beside(align, xpos, ypos, width, height, colr, style,
                       size, txtstr):
    """fl_drw_text_beside(align, xpos, ypos, width, height, colr, style,
    size, txtstr)

    Draws the text aligned outside of the box. It interprets a text string
    starting with the character @ differently in drawing some symbols instead.

    Parameters
    ----------
        align : int
            alignment of text. Values (from xfdata.py)
            - FL_ALIGN_CENTER (In the middle of the box, inside it),
            - FL_ALIGN_TOP (To the top of the box, outside it),
            - FL_ALIGN_BOTTOM (To the bottom of the box, outside it),
            - FL_ALIGN_LEFT (To the left of the box, outside it),
            - FL_ALIGN_RIGHT (To the right of the box, outside it),
            - FL_ALIGN_LEFT_TOP (To the left and top of the box, outside it),
            - FL_ALIGN_RIGHT_TOP (To the right and top of the box, outside it),
            - FL_ALIGN_LEFT_BOTTOM (To the left and bottom of box, outside it),
            - FL_ALIGN_RIGHT_BOTTOM (To the right and bottom of box, outside),
            - FL_ALIGN_INSIDE (places the text inside the box),
            - FL_ALIGN_VERT (not functional yet).
            Bitwise OR with FL_ALIGN_INSIDE is allowed.
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color
        style : int
            font style. Values (from xfdata.py)
            - FL_NORMAL_STYLE (Helvetica normal text),
            - FL_BOLD_STYLE (Helvetica boldface text),
            - FL_ITALIC_STYLE (Helvetica italic text),
            - FL_BOLDITALIC_STYLE (Helvetica boldface and italic text),
            - FL_FIXED_STYLE (Courier fixed width, good for tables),
            - FL_FIXEDBOLD_STYLE (Courier bold fixed text),
            - FL_FIXEDITALIC_STYLE (Courier italic fixed text),
            - FL_FIXEDBOLDITALIC_STYLE (Courier boldface and italic fixed),
            - FL_TIMES_STYLE (Times-Roman like normal font),
            - FL_TIMESBOLD_STYLE (Times-Roman like boldface text),
            - FL_TIMESITALIC_STYLE (Times-Roman like italic text),
            - FL_TIMESBOLDITALIC_STYLE (Times-Roman like boldface and italic
            - FL_MISC_STYLE (Charter normal text),
            - FL_MISCBOLD_STYLE (Charter boldface text),
            - FL_MISCITALIC_STYLE (Charter italic text),
            - FL_SYMBOL_STYLE (Symbol text),
            - FL_SHADOW_STYLE (Text casting a shadow, modifier mask),
            - FL_ENGRAVED_STYLE (Text engraved into the form, modifier mask),
            - FL_EMBOSSED_STYLE (Text standing out, modifier mask).
            Bitwise OR with any of modifiers is allowed.
        size : int
            font size. Values (from xfdata.py)
            - FL_TINY_SIZE (8 points font),
            - FL_SMALL_SIZE or FL_DEFAULT_SIZE (10 points font, default),
            - FL_NORMAL_SIZE (12 points font),
            - FL_MEDIUM_SIZE (14 points font),
            - FL_LARGE_SIZE (18 points font),
            - FL_HUGE_SIZE (24 points font),
            - or other numeric odd or even value
        txtstr : str
            text to draw

    Examples
    --------
        >>> fl_drw_text_beside(xfdata.FL_ALIGN_BOTTOM, 400, 175, 150, 45,
                xfdata.FL_GREEN, xfdata.FL_BOLD_STYLE|xfdata.FL_SHADOW_STYLE,
                xfdata.FL_SMALL_SIZE, "A Good Old String")

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_drw_text_beside = library.cfuncproto(
        library.load_so_libforms(), "fl_drw_text_beside",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR, cty.c_int, cty.c_int, xfdata.STRING],
        """void fl_drw_text_beside(int align, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR c, int style, int size,
           const char * str)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(align, xfdata.ALIGN_list)
    i_align = library.convert_to_intc(align)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.checkfatal_allowed_value_in_list(style, xfdata.TEXTSTYLE_list)
    i_style = library.convert_to_intc(style)
    i_size = library.convert_to_intc(size)
    s_txtstr = library.convert_to_stringc(txtstr)
    library.keep_elem_refs(align, i_align, xpos, i_xpos, ypos, i_ypos, \
            width, i_width, height, i_height, colr, ul_colr, style, \
            i_style, size, i_size, txtstr, s_txtstr)
    _fl_drw_text_beside(i_align, i_xpos, i_ypos, i_width, i_height, \
            ul_colr, i_style, i_size, s_txtstr)


def fl_drw_text_cursor(align, xpos, ypos, width, height, colr, style, size,
                       txtstr, curscolr, pos):
    """fl_drw_text_cursor(align, xpos, ypos, width, height, colr, style,
    size, txtstr, curscolr, pos)

    Draws text and, in addition, a cursor can optionally be drawn. It does
    no interpretation of the special character @, nor does it add padding
    around the text.

    Parameters
    ----------
        align : int
            alignment of text. Values (from xfdata.py)
            - FL_ALIGN_CENTER (In the middle of the box, inside it),
            - FL_ALIGN_TOP (To the top of the box, outside it),
            - FL_ALIGN_BOTTOM (To the bottom of the box, outside it),
            - FL_ALIGN_LEFT (To the left of the box, outside it),
            - FL_ALIGN_RIGHT (To the right of the box, outside it),
            - FL_ALIGN_LEFT_TOP (To the left and top of the box, outside it),
            - FL_ALIGN_RIGHT_TOP (To the right and top of the box, outside it),
            - FL_ALIGN_LEFT_BOTTOM (To the left and bottom of box, outside it),
            - FL_ALIGN_RIGHT_BOTTOM (To the right and bottom of box, outside),
            - FL_ALIGN_INSIDE (places the text inside the box),
            - FL_ALIGN_VERT (not functional yet).
            Bitwise OR with FL_ALIGN_INSIDE is allowed.
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color
        style : int
            font style for text. Values (from xfdata.py)
            - FL_NORMAL_STYLE (Helvetica normal text),
            - FL_BOLD_STYLE (Helvetica boldface text),
            - FL_ITALIC_STYLE (Helvetica italic text),
            - FL_BOLDITALIC_STYLE (Helvetica boldface and italic text),
            - FL_FIXED_STYLE (Courier fixed width, good for tables),
            - FL_FIXEDBOLD_STYLE (Courier bold fixed text),
            - FL_FIXEDITALIC_STYLE (Courier italic fixed text),
            - FL_FIXEDBOLDITALIC_STYLE (Courier boldface and italic fixed),
            - FL_TIMES_STYLE (Times-Roman like normal font),
            - FL_TIMESBOLD_STYLE (Times-Roman like boldface text),
            - FL_TIMESITALIC_STYLE (Times-Roman like italic text),
            - FL_TIMESBOLDITALIC_STYLE (Times-Roman like boldface and italic
            - FL_MISC_STYLE (Charter normal text),
            - FL_MISCBOLD_STYLE (Charter boldface text),
            - FL_MISCITALIC_STYLE (Charter italic text),
            - FL_SYMBOL_STYLE (Symbol text),
            - FL_SHADOW_STYLE (Text casting a shadow, modifier mask),
            - FL_ENGRAVED_STYLE (Text engraved into the form, modifier mask),
            - FL_EMBOSSED_STYLE (Text standing out, modifier mask).
            Bitwise OR with any of modifiers is allowed.
        size : int
            font size. Values (from xfdata.py)
            - FL_TINY_SIZE (8 points font),
            - FL_SMALL_SIZE or FL_DEFAULT_SIZE (10 points font, default),
            - FL_NORMAL_SIZE (12 points font),
            - FL_MEDIUM_SIZE (14 points font),
            - FL_LARGE_SIZE (18 points font),
            - FL_HUGE_SIZE (24 points font),
            - or other numeric odd or even value
        txtstr : str
            text to draw
        curscolr : int
            XForms colormap index as color of the cursor
        pos : int
            position which indicates the index of the character before
            which to draw the cursor (-1 for not showing it)

    Examples
    --------
        >>> fl_drw_text_cursor(xfdata.FL_ALIGN_BOTTOM, 400, 175, 150, 45,
                xfdata.FL_GREEN, xfdata.FL_ITALIC_STYLE,
                xfdata.FL_SMALL_SIZE, "A Good Old String",
                xfdata.FL_YELLOW, 7)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_drw_text_cursor = library.cfuncproto(
        library.load_so_libforms(), "fl_drw_text_cursor",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR, cty.c_int, cty.c_int, xfdata.STRING,
        cty.c_int, cty.c_int],
        """void fl_drw_text_cursor(int align, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR c, int style, int size,
           const char * str, int cc, int pos)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(align, xfdata.ALIGN_list)
    i_align = library.convert_to_intc(align)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.checkfatal_allowed_value_in_list(style, xfdata.TEXTSTYLE_list)
    i_style = library.convert_to_intc(style)
    i_size = library.convert_to_intc(size)
    s_txtstr = library.convert_to_stringc(txtstr)
    #library.checknonfatal_allowed_value_in_list(curscolr, xfdata.COLOR_list)
    i_curscolr = library.convert_to_intc(curscolr)
    i_pos = library.convert_to_intc(pos)
    library.keep_elem_refs(align, i_align, xpos, i_xpos, ypos, i_ypos, \
            width, i_width, height, i_height, colr, ul_colr, style, \
            i_style, size, i_size, txtstr, s_txtstr, curscolr, \
            i_curscolr, pos, i_pos)
    _fl_drw_text_cursor(i_align, i_xpos, i_ypos, i_width, i_height, \
            ul_colr, i_style, i_size, s_txtstr, i_curscolr, i_pos)


def fl_drw_box(boxtype, xpos, ypos, width, height, colr, bndrwidth):
    """fl_drw_box(boxtype, xpos, ypos, width, height, colr, bndwidth)

    Draws the bounding box of a flobject.

    Parameters
    ----------
        boxtype : int
            type of box to draw. Values (from xfdata.py)
            - FL_NO_BOX (No box at all, it is transparent, just a label),
            - FL_UP_BOX (A box that comes out of the screen),
            - FL_DOWN_BOX (A box that goes down into the screen),
            - FL_BORDER_BOX (A flat box with a border),
            - FL_SHADOW_BOX (A flat box with a shadow),
            - FL_FRAME_BOX (A flat box with an engraved frame),
            - FL_ROUNDED_BOX (A rounded box),
            - FL_EMBOSSED_BOX (A flat box with an embossed frame),
            - FL_FLAT_BOX (A flat box without a border, normally invisible
              unless given a different color than the surroundings),
            - FL_RFLAT_BOX (A rounded box without a border, normally invisible
              unless given a different color than the surroundings),
            - FL_RSHADOW_BOX (A rounded box with a shadow),
            - FL_OVAL_BOX (A box shaped like an ellipse),
            - FL_ROUNDED3D_UPBOX (A rounded box coming out of the screen),
            - FL_ROUNDED3D_DOWNBOX (A rounded box going into the screen),
            - FL_OVAL3D_UPBOX (An oval box coming out of the screen),
            - FL_OVAL3D_DOWNBOX (An oval box going into the screen),
            - FL_OVAL3D_FRAMEBOX (An oval box with an engraved frame),
            - FL_OVAL3D_EMBOSSEDBOX (An oval box with an embossed frame)
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color
        bndrwidth : int
            width of the boundary

    Examples
    --------
        >>> fl_drw_box(xfdata.FL_DOWN_BOX, 700, 800, 600, 450,
                xfdata.FL_INDIGO, 3)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_drw_box = library.cfuncproto(
        library.load_so_libforms(), "fl_drw_box",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR, cty.c_int],\
        """void fl_drw_box(int style, FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, FL_COLOR c, int bw_in)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(boxtype, xfdata.BOXTYPE_list)
    i_boxtype = library.convert_to_intc(boxtype)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    i_bndrwidth = library.convert_to_intc(bndrwidth)
    library.keep_elem_refs(boxtype, i_boxtype, xpos, i_xpos, ypos, \
            i_ypos, width, i_width, height, i_height, colr, ul_colr, \
            bndrwidth, i_bndrwidth)
    _fl_drw_box(i_boxtype, i_xpos, i_ypos, i_width, i_height, ul_colr, \
            i_bndrwidth)


def fl_add_symbol(symbname, pyfn_DrawPtr, scalable):
    """fl_add_symbol(symbname, pyfn_DrawPtr, scalable) -> result

    Adds a customly drawn symbol to the system which it can then use to
    display symbols on flobjects that are not provided by XForms.

    Parameters
    ----------
        symbname : str
            name under which the symbol should be known (at most 15
            characters), without the leading @
        pyfn_DrawPtr : python function, no return
            name referring to function([int]coord, [int]coord, [int]coord,
            [int]coord, [int]angle_degree_rotation, [long_pos]colr)
            Function to draw a symbol
        scalable : int
            not used, a value of 0 will be fine

    Returns
    -------
        result : int
            1 (on success), or -1 (on failure, if no symbol
            or no function)

    Examples
    --------
        >>> def drawsymb(xpos, ypos, width, height, angle, col):
        >>> ... <something>
        >>> fl_add_symbol("MySymbol", drawsymb, 0)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    #FL_DRAWPTR = cty.CFUNCTYPE(None, xfdata.FL_Coord, xfdata.FL_Coord,
    #        xfdata.FL_Coord, FL_Coord, cty.c_int, FL_COLOR)
    _fl_add_symbol = library.cfuncproto(
        library.load_so_libforms(), "fl_add_symbol",\
        cty.c_int, [xfdata.STRING, xfdata.FL_DRAWPTR, cty.c_int],\
        """int fl_add_symbol(const char * name, FL_DRAWPTR drawit,
           int scalable)""")
    library.check_if_flinitialized()
    s_symbname = library.convert_to_stringc(symbname)
    i_scalable = library.convert_to_intc(scalable)
    library.verify_function_type(pyfn_DrawPtr)
    cfn_DrawPtr = xfdata.FL_DRAWPTR(pyfn_DrawPtr)
    library.keep_cfunc_refs(cfn_DrawPtr, pyfn_DrawPtr)
    library.keep_elem_refs(symbname, s_symbname, scalable, i_scalable)
    retval = _fl_add_symbol(s_symbname, cfn_DrawPtr, i_scalable)
    return retval


def fl_draw_symbol(symbname, xpos, ypos, width, height, colr):
    """fl_draw_symbol(symbname, xpos, ypos, width, height, colr) -> result

    Draws directly a symbol on the screen.

    Parameters
    ----------
        symbname : str
            name given to the symbol, with an initial @
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        colr : long_pos
            XForms colormap index as color

    Returns
    -------
        result : int
            1 (on success), or 0 (on failure)

    Examples
    --------
        >>> fl_draw_symbol("willsym", 120, 120, 15, 20,
                xfdata.FL_LIGHTGRAY)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_draw_symbol = library.cfuncproto(
        library.load_so_libforms(), "fl_draw_symbol",\
        cty.c_int, [xfdata.STRING, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_COLOR],\
        """int fl_draw_symbol(const char * label, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR col)""")
    library.check_if_flinitialized()
    s_symbname = library.convert_to_stringc(symbname)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(symbname, s_symbname, xpos, i_xpos, ypos, \
            i_ypos, width, i_width, height, i_height, colr, ul_colr)
    retval = _fl_draw_symbol(s_symbname, i_xpos, i_ypos, i_width, \
            i_height, ul_colr)
    return retval


def fl_mapcolor(colr, red, green, blue):
    """fl_mapcolor(colr, red, green, blue) -> pixelval

    Changes the colormap and make a color index active so that it can be
    used in various drawing routines after initialization. It maps a new
    color using specific values for red, green and blue. In case a request
    fails, it is substituted by the closest color. It is recommended that
    you use an index larger than xfdata.FL_FREE_COL1 for your remap request
    to avoid accidentally free the colors you have not explicitly allocated.
    Indices larger than 224 are reserved and should not be used.

    Parameters
    ----------
        colr : long_pos
            XForms colormap index as new color to be mapped
        red : int
            value for red
        green : int
            value for green
        blue : int
            value for blue

    Returns
    -------
        pixelval : long_pos
            actual pixel value X understands, or 0 (on failure, if colr
            exceeds colormap indices)

    Examples
    --------
        >>> fl_mapcolor(xfdata.FL_FREE_COL1, 100, 200, 300)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_mapcolor = library.cfuncproto(
        library.load_so_libforms(), "fl_mapcolor",\
        cty.c_ulong, [xfdata.FL_COLOR, cty.c_int, cty.c_int, cty.c_int],
        """unsigned long fl_mapcolor(FL_COLOR col, int r, int g, int b)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    i_red = library.convert_to_intc(red)
    i_green = library.convert_to_intc(green)
    i_blue = library.convert_to_intc(blue)
    library.keep_elem_refs(colr, ul_colr, red, green, blue, i_red, \
            i_green, i_blue)
    retval = _fl_mapcolor(ul_colr, i_red, i_green, i_blue)
    return retval


def fl_mapcolorname(colr, rgbcolrname):
    """fl_mapcolorname(colr, rgbcolrname) -> pixelval

    Defines the color in the colormap indexed by colr to the specified color
    name. It associates an index with a color name, which may have been
    obtained via resources.

    Parameters
    ----------
        colr : long_pos
            XForms colormap index as color to be mapped
        rgbcolrname : str
            name of mapped color from the systems color database file
            "rgb.txt" in /usr/share/X11 or /usr/lib/X11 (see that file
            for possible values)

    Returns
    -------
        pixelval : long
            pixel value X understands, or -1 (on failure)

    Examples
    --------
        >>> pxl = fl_mapcolorname(xfdata.FL_FREE_COL3, "PowderBlue")

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_mapcolorname = library.cfuncproto(
        library.load_so_libforms(), "fl_mapcolorname",\
        cty.c_long, [xfdata.FL_COLOR, xfdata.STRING],\
        """long int fl_mapcolorname(FL_COLOR col, const char * name)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    s_rgbcolrname = library.convert_to_stringc(rgbcolrname)
    library.keep_elem_refs(colr, ul_colr, rgbcolrname, s_rgbcolrname)
    retval = _fl_mapcolorname(ul_colr, s_rgbcolrname)
    return retval


fl_mapcolor_name = fl_mapcolorname


def fl_free_colors(colrlist, numcolr):
    """fl_free_colors(colrlist, numcolr)

    Frees allocated array of colors from the default colormap, if index
    of colors are known. You should not do that for the reserved colors
    (i.e. colors with indices below xfdata.FL_FREE_COL1).

    Parameters
    ----------
        colrlist : list of long_pos
            sequence of XForms colormap indices as colors
        numcolr : int
            number of colors stored in the sequence

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_free_colors = library.cfuncproto(
        library.load_so_libforms(), "fl_free_colors",\
        None, [cty.POINTER(xfdata.FL_COLOR), cty.c_int],\
        """void fl_free_colors(FL_COLOR * c, int n)""")
    library.check_if_flinitialized()
    #ptr_colr = cty.cast(colr, cty.POINTER(xfdata.FL_COLOR))
    ptr_colrlist = library.convert_to_ptr_ulongc(colrlist)
    i_numcolr = library.convert_to_intc(numcolr)
    library.keep_elem_refs(colrlist, ptr_colrlist, numcolr, i_numcolr)
    _fl_free_colors(ptr_colrlist, i_numcolr)


def fl_free_pixels(pixelvallist, numcolrs):
    """fl_free_pixels(pixelvallist, numcolrs)

    Frees allocated colors from the default colormap, if pixel values
    are known. You should not do that for the reserved colors (i.e.
    colors with indices below xfdata.FL_FREE_COL1).

    Parameters
    ----------
        pixelvallist : list of long_pos
            sequence of pixel values X understands
        numcolrs : int
            number of colors stored in the sequence

    Examples
    --------
         >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_free_pixels = library.cfuncproto(
        library.load_so_libforms(), "fl_free_pixels",\
        None, [cty.POINTER(cty.c_ulong), cty.c_int],\
        """void fl_free_pixels(long unsigned int * pix, int n)""")
    library.check_if_flinitialized()
    #ptr_pixel = cty.cast(pixel, cty.POINTER(cty.c_ulong))
    ptr_pixelvallist = library.convert_to_ptr_ulongc(pixelvallist)
    i_numcolrs = library.convert_to_intc(numcolrs)
    library.keep_elem_refs(pixelvallist, ptr_pixelvallist, numcolrs, \
            i_numcolrs)
    _fl_free_pixels(ptr_pixelvallist, i_numcolrs)


# def fl_set_color_leak(yesno) function placeholder (backwards)


def fl_getmcolor(colr):
    """fl_getmcolor(colr) -> pixelval, red, green, blue

    Finds out the RGB values of a XForms color, returning also the pixel
    value as known by the X server. If you are interested in the internal
    colormap of XForms fl_get_icm_color() is more efficient.

    Parameters
    ----------
        colr : long_pos
            XForms colormap index as color

    Returns
    -------
        pixelval : long_pos
            pixel value X understands
        red : int
            red value
        green : int
            green value
        blue : int
            blue value

    Examples
    --------
        >>> pixl, r, g, b = fl_getmcolor(xfdata.FL_VIOLET)

    API_diversion
    ----------
        API changed from XForms, upstream is
        fl_getmcolor(colr, r, g, b)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_getmcolor = library.cfuncproto(
        library.load_so_libforms(), "fl_getmcolor",\
        cty.c_ulong, [xfdata.FL_COLOR, cty.POINTER(cty.c_int),\
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],\
        """long unsigned int fl_getmcolor(FL_COLOR i, int * r, int * g,
           int * b)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    i_red, ptr_red = library.make_intc_and_pointer()
    i_green, ptr_green = library.make_intc_and_pointer()
    i_blue, ptr_blue = library.make_intc_and_pointer()
    library.keep_elem_refs(colr, ul_colr, i_red, i_green, i_blue, \
            ptr_red, ptr_green, ptr_blue)
    retval = _fl_getmcolor(ul_colr, ptr_red, ptr_green, ptr_blue)
    return retval, i_red.value, i_green.value, i_blue.value


def fl_get_pixel(colr):
    """fl_get_pixel(colr) -> pixelval

    Finds out the actual pixel value the X server understands from a XForms
    colormap index. XForms library keeps an internal colormap, initialized
    to predefined colors. The predefined colors do not correspond to pixel
    values the X server understands but are indexes into the colormap.
    Therefore, they cannot be used in any of the Graphics Context (GC)
    altering or Xlib routines.

    Parameters
    ----------
        colr : long_pos
            XForms colormap index as color. Values (from xfdata.py)
            FL_GREEN, FL_WHITE, FL_RED, etc..

    Returns
    -------
        pixelval : long_pos
            pixel value X understands

    Examples
    --------
        >>> pixl = fl_get_pixel(xfdata.FL_PEACHPUFF)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_get_pixel = library.cfuncproto(
        library.load_so_libforms(), "fl_get_pixel",\
        cty.c_ulong, [xfdata.FL_COLOR],\
        """long unsigned int fl_get_pixel(FL_COLOR col)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(colr, ul_colr)
    retval = _fl_get_pixel(ul_colr)
    return retval


fl_get_flcolor = fl_get_pixel


def fl_get_icm_color(colr):
    """fl_get_icm_color(colr) -> red, green, blue

    Queries the internal colormap handled by XForms, returning red, green
    and blue values corresponding to color index. Note that it does not
    communicate with the X server, it only return information about the
    internal colormap, which is made known to the X server by the
    initialization routine fl_initialize().

    Parameters
    ----------
        colr : long_pos
            XForms colormap index as color

    Returns
    -------
        red : int
            red value
        green : int
            green value
        blue : int
            blue value

    Examples
    --------
        >>> r, g, b = fl_get_icm_color(xfdata.FL_OLIVE)

    API_diversion
    ----------
        API changed from XForms, upstream is fl_get_icm_color(colr, r, g, b)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_icm_color = library.cfuncproto(
        library.load_so_libforms(), "fl_get_icm_color",\
        None, [xfdata.FL_COLOR, cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],\
        """void fl_get_icm_color(FL_COLOR col, int * r, int * g, int * b)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    i_red, ptr_red = library.make_intc_and_pointer()
    i_green, ptr_green = library.make_intc_and_pointer()
    i_blue, ptr_blue = library.make_intc_and_pointer()
    library.keep_elem_refs(colr, ul_colr, i_red, i_green, i_blue, \
            ptr_red, ptr_green, ptr_blue)
    _fl_get_icm_color(ul_colr, ptr_red, ptr_green, ptr_blue)
    return i_red.value, i_green.value, i_blue.value


def fl_set_icm_color(colr, red, green, blue):
    """fl_set_icm_color(colr, red, green, blue)

    Changes the internal colormap handled by XForms, setting a color
    index using a combination of red, green and blue values. You have
    to call fl_set_icm_color() before fl_initialize() to change XForms's
    default colormap. Note that it does not communicate with the X server,
    it only populates the internal colormap, which is made known to the X
    server by the initialization routine fl_initialize().

    Parameters
    ----------
        colr : long_pos
            XForms colormap index as color
        red : int
            value for red
        green : int
            value for green
        blue : int
            value for blue

    Examples
    --------
        >>> fl_set_icm_color(xfdata.FL_FREE_COL8, 75, 150, 225)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe
        Precondition: to be called before fl_initialize()

    """
    _fl_set_icm_color = library.cfuncproto(
        library.load_so_libforms(), "fl_set_icm_color",\
        None, [xfdata.FL_COLOR, cty.c_int, cty.c_int, cty.c_int],\
        """void fl_set_icm_color(FL_COLOR col, int r, int g, int b)""")
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    i_red = library.convert_to_intc(red)
    i_green = library.convert_to_intc(green)
    i_blue = library.convert_to_intc(blue)
    library.keep_elem_refs(colr, ul_colr, red, green, blue, i_red, \
            i_green, i_blue)
    _fl_set_icm_color(ul_colr, i_red, i_green, i_blue)


def fl_color(colr):
    """fl_color(colr)

    Defines the foreground color in the XForms' default Graphics Context
    (gc[0]).

    Parameters
    ----------
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_color(xfdata.FL_ORANGE)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_color = library.cfuncproto(
        library.load_so_libforms(), "fl_color",\
        None, [xfdata.FL_COLOR],\
        """void fl_color(FL_COLOR col)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(colr, ul_colr)
    _fl_color(ul_colr)


def fl_bk_color(colr):
    """fl_bk_color(colr)

    Defines the background color in the XForms' default Graphics Context
    (gc[0]).

    Parameters
    ----------
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_bk_color(xfdata.FL_MEDIUMORCHID)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_bk_color = library.cfuncproto(
        library.load_so_libforms(), "fl_bk_color",\
        None, [xfdata.FL_COLOR],\
        """void fl_bk_color(FL_COLOR col)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(colr, ul_colr)
    _fl_bk_color(ul_colr)


def fl_textcolor(colr):
    """fl_textcolor(colr)

    Defines the foreground color for text in the XForms' default Graphics
    Context (gc[0]).

    Parameters
    ----------
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_textcolor(xfdata.FL_LIGHTCORAL)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_textcolor = library.cfuncproto(
        library.load_so_libforms(), "fl_textcolor",\
        None, [xfdata.FL_COLOR],\
        """void fl_textcolor(FL_COLOR col)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(colr, ul_colr)
    _fl_textcolor(ul_colr)


def fl_bk_textcolor(colr):
    """fl_bk_textcolor(colr)

    Defines the background color for text in the XForms' default Graphics
    Context (gc[0]).

    Parameters
    ----------
        colr : long_pos
            XForms colormap index as color

    Examples
    --------
        >>> fl_bk_textcolor(xfdata.FL_IVORY)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_bk_textcolor = library.cfuncproto(
        library.load_so_libforms(), "fl_bk_textcolor",\
        None, [xfdata.FL_COLOR],\
        """void fl_bk_textcolor(FL_COLOR col)""")
    library.check_if_flinitialized()
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(colr, ul_colr)
    _fl_bk_textcolor(ul_colr)


def fl_set_gamma(red, green, blue):
    """fl_set_gamma(red, green, blue)

    Adjusts the brightness of the builtin colors. Larger the value, brighter
    the colors.

    Parameters
    ----------
        red : float
            gamma value for red. By default gamma is 1.0
        green : float
            gamma value for green. By default gamma is 1.0
        blue : float
            gamma value for blue. By default gamma is 1.0

    Examples
    --------
        >>> fl_set_gamma(2.0, 2.0, 2.0)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe
        Precondition: to be called before fl_initialize()

    """
    _fl_set_gamma = library.cfuncproto(
        library.load_so_libforms(), "fl_set_gamma",\
        None, [cty.c_double, cty.c_double, cty.c_double],\
        """void fl_set_gamma(double r, double g, double b)""")
    f_red = library.convert_to_doublec(red)
    f_green = library.convert_to_doublec(green)
    f_blue = library.convert_to_doublec(blue)
    library.keep_elem_refs(red, green, blue, f_red, f_green, f_blue)
    _fl_set_gamma(f_red, f_green, f_blue)


# fl_show_errors() function placeholder (backwards)


# TODO: verify if they are necessary in python
# Some macros

def FL_max(a, b):
    if (a > b):
        return a
    else:
        return b


def FL_min(a, b):
    if (a < b):
        return a
    else:
        return b


def FL_abs(a):
    if (a > 0):
        return a
    else:
        return (-a)


def FL_nint(a):
    library.convert_to_intc(a)
    if a > 0:
        return (a + 0.5)
    else:
        return (a - 0.5)


def FL_clamp(a, amin, amax):
    if (a < amin):
        return amin
    elif (a > amax):
        return amax
    else:
        return a


def FL_crnd(a):
    library.convert_to_FL_Coord(a)
    if a > 0:
        return (a + 0.5)
    else:
        return (a - 0.5)


# utilities for new flobjects

def fl_add_object(ptr_flform, ptr_flobject):
    """fl_add_object(ptr_flform, ptr_flobject)

    The flobject remains available (except if it is a flobject that
    marks the start or end of a group) and can be added again to the
    same or another form later. Normally, this function is used in
    flobject classes to add a newly created flobject to a form. It
    may not be used for flobjects representing the start or end of
    a group.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form which a flobject will be added to
        ptr_flobject : pointer to xfdata.FL_OBJECT
            flobject to be added

    Examples
    --------
        >>> fl_add_object(pform2, pobjnew2)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_add_object = library.cfuncproto(
        library.load_so_libforms(), "fl_add_object",\
        None, [cty.POINTER(xfdata.FL_FORM), cty.POINTER(xfdata.FL_OBJECT)],
        """void fl_add_object(FL_FORM * form, FL_OBJECT * obj)""")
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flform, ptr_flobject)
    _fl_add_object(ptr_flform, ptr_flobject)


def fl_addto_form(ptr_flform):
    """fl_addto_form(ptr_flform) -> ptr_flform

    Reopens a form, after fl_end_form(), for adding further
    flobjects to it.

    Parameters
    ----------
        ptr_flform : pointer to xfdata.FL_FORM
            form to be reopened

    Returns
    -------
        ptr_flform : pointer to xfdata.FL_FORM
            reopened form, or None (on failure)

    Examples
    --------
        >>> form = fl_addto_form(closedform)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_addto_form = library.cfuncproto(
        library.load_so_libforms(), "fl_addto_form",
        cty.POINTER(xfdata.FL_FORM), [cty.POINTER(xfdata.FL_FORM)],\
        """FL_FORM * fl_addto_form(FL_FORM * form)""")
    library.check_if_flinitialized()
    library.verify_flformptr_type(ptr_flform)
    library.keep_elem_refs(ptr_flform)
    retval = _fl_addto_form(ptr_flform)
    return retval


def fl_make_object(flobjclass, otype, xpos, ypos, width, height, label,
        pyfn_HandlePtr):
    """fl_make_object(flobjclass, otype, xpos, ypos, width, height,
    label, pyfn_HandlePtr) -> ptr_flobject

    Makes a custom flobject.

    Parameters
    ----------
        flobjclass : int
            class type of flobject to be made
        otype : int
            type of the flobject to be made *todo*
        xpos : int
            horizontal position of flobject (upper-left corner)
        ypos : int
            vertical position of flobject (upper-left corner)
        width : int
            width in coord units
        height : int
            height coord units
        label : str
            text label of flobject
        pyfn_HandlePtr : python function, returned value
            name referring to function(ptr_flobject, [int]event [int]xpos,
            [int]ypos, [int]key, [pointer to void]ptr_xevent) -> [int]num
            Function for handling flobject

    Returns
    -------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            made flobject

    Examples
    --------
        >>> def handlecb(pobj, evtnum, mx, my, key, pxevent):
        >>> ... <something>
        >>> ... return 0
        >>> fl_make_object(...)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    #FL_HANDLEPTR = cty.CFUNCTYPE(cty.c_int, cty.POINTER(xfdata.FL_OBJECT),
    #    cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, cty.c_int, cty.c_void_p)
    _fl_make_object = library.cfuncproto(
        library.load_so_libforms(), "fl_make_object",\
        cty.POINTER(xfdata.FL_OBJECT), [cty.c_int, cty.c_int, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.STRING,
        xfdata.FL_HANDLEPTR],
        """FL_OBJECT * fl_make_object(int objclass, int type, FL_Coord x,
           FL_Coord y, FL_Coord w, FL_Coord h, const char * label,
           FL_HANDLEPTR handle)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(flobjclass, \
            xfdata.OBJCLASS_list)
    i_flobjclass = library.convert_to_intc(flobjclass)
    i_otype = library.convert_to_intc(otype)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    s_label = library.convert_to_stringc(label)
    library.verify_function_type(pyfn_HandlePtr)
    cfn_HandlePtr = xfdata.FL_HANDLEPTR(pyfn_HandlePtr)
    library.keep_cfunc_refs(cfn_HandlePtr, pyfn_HandlePtr)
    library.keep_elem_refs(flobjclass, otype, xpos, ypos, width, \
            height, label, i_flobjclass, i_otype, i_xpos, i_ypos, \
            i_width, i_height, s_label)
    retval = _fl_make_object(i_flobjclass, i_otype, i_xpos, i_ypos, \
            i_width, i_height, s_label, cfn_HandlePtr)
    return retval


def fl_add_child(ptr_flobject1, ptr_flobject2):
    """fl_add_child(ptr_flobject1, ptr_flobject2)

    Makes a flobject a child of another flobject. An example is the
    scrollbar flobject, tt has three child flobjects, a slider and
    two buttons, which all three are childs of the scrollbar flobject.

    Parameters
    ----------
        ptr_flobject1 : pointer to xfdata.FL_OBJECT
            father flobject
        ptr_flobject2 : pointer to xfdata.FL_OBJECT
            child flobject to add

    Examples
    --------
        >>> fl_add_child(pobjfa, pobjch)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_add_child = library.cfuncproto(
        library.load_so_libforms(), "fl_add_child",\
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(xfdata.FL_OBJECT)],
        """void fl_add_child(FL_OBJECT * p1, FL_OBJECT * p2)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject1)
    library.verify_flobjectptr_type(ptr_flobject2)
    library.keep_elem_refs(ptr_flobject1, ptr_flobject2)
    _fl_add_child(ptr_flobject1, ptr_flobject2)


def fl_set_coordunit(unit):
    """fl_set_coordunit(unit)

    Defines the unit to be used for screen coordinates, instead of default
    ones (pixels).

    Parameters
    ----------
        unit : int
            coord unit type to set. Values (from xfdata.py)
            - FL_COORD_PIXEL (default, screen coordinate units in pixel),
            - FL_COORD_MM (Screen coordinate units in millimeters),
            - FL_COORD_POINT (Screen coordinate units in points, 1/72 inch),
            - FL_COORD_centiMM (Screen coordinate units in centi-millimeters
              1/100 of millimeters),
            - FL_COORD_centiPOINT (Screen coordinate units in centi-points,
              1/100 of a point)

    Examples
    --------
        >>> fl_set_coordunit(xfdata.FL_COORD_MM)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_coordunit = library.cfuncproto(
        library.load_so_libforms(), "fl_set_coordunit",\
        None, [cty.c_int],\
        """void fl_set_coordunit(int u)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(unit, \
            xfdata.COORDUNIT_list)
    i_unit = library.convert_to_intc(unit)
    library.keep_elem_refs(unit, i_unit)
    _fl_set_coordunit(i_unit)


def fl_set_border_width(borderwidth):
    """fl_set_border_width(borderwidth)

    Defines the width of the border.

    Parameters
    ----------
        borderwidth : int
            value of border width. If it is a negative number, all flobjects
            appear to have a softer appearance.

    Examples
    --------
        >>> fl_set_border_width(-3)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_set_border_width = library.cfuncproto(
        library.load_so_libforms(), "fl_set_border_width",\
        None, [cty.c_int],\
        """void fl_set_border_width(int bw)""")
    i_borderwidth = library.convert_to_intc(borderwidth)
    library.keep_elem_refs(borderwidth, i_borderwidth)
    _fl_set_border_width(i_borderwidth)


def fl_set_scrollbar_type(sbtype):
    """fl_set_scrollbar_type(sbtype)

    Defines the type of a scrollbar.

    Parameters
    ----------
        sbtype : int
            type of scrollbar. Values (from xfdata.py) FL_VERT_SCROLLBAR,
            FL_HOR_SCROLLBAR, FL_VERT_THIN_SCROLLBAR, FL_HOR_THIN_SCROLLBAR,
            FL_VERT_NICE_SCROLLBAR, FL_HOR_NICE_SCROLLBAR,
            FL_VERT_PLAIN_SCROLLBAR, FL_HOR_PLAIN_SCROLLBAR,
            FL_HOR_BASIC_SCROLLBAR, FL_VERT_BASIC_SCROLLBAR,
            FL_NORMAL_SCROLLBAR, FL_THIN_SCROLLBAR, FL_NICE_SCROLLBAR,
            FL_PLAIN_SCROLLBAR

    Examples
    --------
        >>> fl_set_scrollbar_type(xfdata.FL_VERT_BASIC_SCROLLBAR)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_scrollbar_type = library.cfuncproto(
        library.load_so_libforms(), "fl_set_scrollbar_type",\
        None, [cty.c_int],\
        """void fl_set_scrollbar_type(int t)""")
    library.checkfatal_allowed_value_in_list(sbtype, xfdata.SCROLLTYPE_list)
    i_sbtype = library.convert_to_intc(sbtype)
    library.keep_elem_refs(sbtype, i_sbtype)
    _fl_set_scrollbar_type(i_sbtype)


def fl_set_thinscrollbar(yesno):
    """fl_set_thinscrollbar(yesno)

    Defines if type of scrollbar is thin or normal.

    Parameters
    ----------
        yesno : int
            flag if thin scrollbar or not. Values 1 (for thin)
            or 0 (for normal)

    Examples
    --------
        >>> fl_set_thinscrollbar(1)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    if yesno:
        sbtype = xfdata.FL_THIN_SCROLLBAR
    else:
        sbtype = xfdata.FL_NORMAL_SCROLLBAR
    fl_set_scrollbar_type(sbtype)


def fl_flip_yorigin():
    """fl_flip_yorigin()

    Defines the origin of XForms coordinates at the lower-left corner
    of the form (instead of default upper-left corner).

    Examples
    --------
        >>> fl_flip_yorigin()

    Notes
    -----
        Status: NN-UTest + Doc + Demo = OK
        Precondition: to be called before fl_initialize()

    """
    _fl_flip_yorigin = library.cfuncproto(
        library.load_so_libforms(), "fl_flip_yorigin",\
        None, [],\
        """void fl_flip_yorigin()""")
    _fl_flip_yorigin()


def fl_get_coordunit():
    """fl_get_coordunit() -> coordunit

    Finds out the unit used for screen coordinates.

    Returns
    -------
        coordunit : int
            current coordinates unit (e.g. from xfdata.py FL_COORD_MM,
            FL_COORD_centiPOINT, etc..)

    Examples
    --------
        >>> cunit = fl_get_coordunit()

    Notes
    -----
        Status: NN-UTest + Doc + Demo = OK

    """
    _fl_get_coordunit = library.cfuncproto(
            library.load_so_libforms(), "fl_get_coordunit",\
            cty.c_int, [],\
            """int fl_get_coordunit()""")
    library.check_if_flinitialized()
    retval = _fl_get_coordunit()
    return retval


def fl_get_border_width():
    """fl_get_border_width() -> borderwidth

    Finds out the width of border.

    Returns
    -------
        borderwidth : int
            width of border

    Examples
    --------
        >>> bdw = fl_get_border_width()

    Notes
    -----
        Status: NN-UTest + Doc + Demo = OK

    """
    _fl_get_border_width = library.cfuncproto(
        library.load_so_libforms(), "fl_get_border_width",\
        cty.c_int, [],\
        """int fl_get_border_width()""")
    library.check_if_flinitialized()
    retval = _fl_get_border_width()
    return retval


# misc. routines

def fl_ringbell(percent):
    """fl_ringbell(percent)

    Sounds the keyboard ringbell (if capable). Note that not all
    keyboards support volume variations.

    Parameters
    ----------
        percent : int
            volume value for the bell. Values from -100 (minimum,
            off), to 100 (max), 0 is default.

    Examples
    --------
        >>> fl_ringbell(50)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_ringbell = library.cfuncproto(
        library.load_so_libforms(), "fl_ringbell",\
        None, [cty.c_int],\
        """void fl_ringbell(int percent)""")
    library.check_if_flinitialized()
    i_percent = library.convert_to_intc(percent)
    library.keep_elem_refs(percent, i_percent)
    _fl_ringbell(i_percent)


def fl_gettime():
    """fl_gettime() -> secs, usecs

    Finds out the current time, expressed in seconds and microseconds
    since 1st January 1970, 00:00 GMT. It is most useful for computing
    time differences.

    Returns
    -------
        secs : long
            seconds
        usecs : long
            microseconds

    Examples
    --------
        >>> secs, usecs = fl_gettime()

    API_diversion
    ----------
        API changed from XForms, upstream is fl_gettime(sec, usec)

    Notes
    -----
        Status: NN-UTest + Doc + Demo = OK

    """
    _fl_gettime = library.cfuncproto(
        library.load_so_libforms(), "fl_gettime",\
        None, [cty.POINTER(cty.c_long), cty.POINTER(cty.c_long)],\
        """void fl_gettime(long int * sec, long int * usec)""")
    library.check_if_flinitialized()
    l_secs, ptr_secs = library.make_longc_and_pointer()
    l_usecs, ptr_usecs = library.make_longc_and_pointer()
    library.keep_elem_refs(l_secs, l_usecs, ptr_secs, ptr_usecs)
    _fl_gettime(ptr_secs, ptr_usecs)
    return l_secs.value, l_usecs.value


def fl_now():
    """fl_now() -> datetimetxt

    Finds out a string form of the current date and time. The format
    of the string is in the form "Wed Jun 30 21:49:08 1993"

    Returns
    -------
        datetimetxt : str
            current text of date and time

    Examples
    --------
        >>> curdattim = fl_now()

    Notes
    -----
        Status: NN-UTest + Doc + NoDemo = Maybe

    """
    _fl_now = library.cfuncproto(
        library.load_so_libforms(), "fl_now", \
        xfdata.STRING, [], \
        """const char * fl_now()""")
    library.check_if_flinitialized()
    retval = _fl_now()
    return retval


def fl_whoami():
    """fl_whoami() -> username

    Finds out the user name who is running the application.

    Returns
    -------
        username : str
            text of username

    Examples
    --------
        >>> usertxt = fl_whoami()

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_whoami = library.cfuncproto(
        library.load_so_libforms(), "fl_whoami", \
        xfdata.STRING, [],\
        """const char * fl_whoami()""")
    library.check_if_flinitialized()
    retval = _fl_whoami()
    return retval


def fl_mouse_button():
    """fl_mouse_button() -> mousebtn

    Finds out which mouse button was pushed or released. Sometimes an
    application program might need to find out more information about
    the event that triggered a callback, e.g., to implement mouse button
    number sensitive functionalities. This function, if needed, should
    be called from within a callback. If the callback is triggered by a
    shortcut, the function returns the keysym (ascii value if ASCII) of
    the key plus FL_SHORTCUT. For example, if a button has a shortcut
    <Ctrl>C (ASCII value is 3), the button number returned upon activation
    of the shortcut would be xfdata.FL_SHORTCUT + 3. You can use
    xfdata.FL_SHORTCUT to determine if the callback is triggered by a
    shortcut or not.

    Returns
    -------
        mousebtn : long
            which mouse button was pushed or released. Values (from xfdata.py)
            - FL_MBUTTON1 or FL_LEFT_MOUSE (Left mouse button was pressed),
            - FL_MBUTTON2 or FL_MIDDLE_MOUSE (Middle mouse button was pressed),
            - FL_MBUTTON3 or FL_RIGHT_MOUSE (Right mouse button was pressed),
            - FL_MBUTTON4 or FL_SCROLLUP_MOUSE (Mouse scroll wheel was rotated
              in up direction),
            - FL_MBUTTON5 or FL_SCROLLDOWN_MOUSE (Mouse scroll wheel was
              rotated in down direction.

    Examples
    --------
        >>> mousebtn = fl_mouse_button()

    Notes
    -----
        Status: NN-UTest + Doc + Demo = OK

    """
    _fl_mouse_button = library.cfuncproto(
        library.load_so_libforms(), "fl_mouse_button", \
        cty.c_long, [], \
        """long int fl_mouse_button()""")
    library.check_if_flinitialized()
    retval = _fl_mouse_button()
    return retval


fl_mousebutton = fl_mouse_button


# fl_strdup(strng) function placeholder (low-level)


def fl_set_err_logfp(ptr_file):
    """fl_set_err_logfp(ptr_file)

    Makes the default message handler to log the error to a
    file instead of printing to stderr.

    Parameters
    ----------
        ptr_file : pointer to FILE
            file opened in "w" mode by fl_popen()

    Examples
    --------
        >>> pfile1 = fl_popen("myerrlog", "w")
        >>> fl_set_err_logfp(pfile1)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_err_logfp = library.cfuncproto(
        library.load_so_libforms(), "fl_set_err_logfp",\
        None, [cty.POINTER(xfdata.FILE)],\
        """void fl_set_err_logfp(FILE * fp)""")
    library.check_if_flinitialized()
    library.keep_elem_refs(ptr_file)
    _fl_set_err_logfp(ptr_file)


# fl_set_error_logfp placeholder (backwards)


def fl_set_error_handler(pyfn_ErrorFunc):
    """fl_set_error_handler(pyfn_ErrorFunc)

    Normally the XForms Library reports errors to stderr. This can be
    avoided or modified by registering an error handling function. The
    library will call the user handler function with a string indicating
    in which function an error occured and a formatting string (other
    additional arguments are not supported in xforms-python). To restore
    the default handler, call the function again with user handler set to
    None. You can call this function anytime and as many times as you wish.

    Parameters
    ----------
        pyfn_ErrorFunc : python function, no return
            name referring to function([str]name, [str]msg)
            function for handling error

    Examples
    --------
        >>> def errhandler(funcnam, errmsg):
        >>> ... print("Error caught in %s: %s.") % (funcnam, errmsg)
        >>> fl_set_error_handler(errhandler)

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    #FL_ERROR_FUNC = cty.CFUNCTYPE(None, xfdata.STRING, xfdata.STRING)
    _fl_set_error_handler = library.cfuncproto(
        library.load_so_libforms(), "fl_set_error_handler",\
        None, [xfdata.FL_ERROR_FUNC],\
        """void fl_set_error_handler(FL_ERROR_FUNC user_func)""")
    library.check_if_flinitialized()
    library.verify_function_type(pyfn_ErrorFunc)
    if not pyfn_ErrorFunc:      # if it is None
        cfn_ErrorFunc = cty.cast(pyfn_ErrorFunc, cty.c_void_p)
    else:                       # real function
        cfn_ErrorFunc = xfdata.FL_ERROR_FUNC(pyfn_ErrorFunc)
    library.keep_cfunc_refs(cfn_ErrorFunc, pyfn_ErrorFunc)
    _fl_set_error_handler(cfn_ErrorFunc)


# commented as it gives a SegFault.
# You can use len(sys.argv) and sys.argv, instead
#def fl_get_cmdline_args(argnum):
#    """fl_get_cmdline_args(argnum)
#
#    Finds out command line arguments.
#
#    Parameters
#    ----------
#        argnum : int
#            argument number
#
#    Returns
#    -------
#        argum : pointer to str
#            argument
#
#    Examples
#    --------
#        >>> fl_get_cmdline_args(1)
#
#    Notes
#    -----
#        Status: NA-UTest + Doc + NoDemo = KO (Segfault)
#
#    """
#    _fl_get_cmdline_args = library.cfuncproto(
#        library.load_so_libforms(), "fl_get_cmdline_args",\
#        cty.POINTER(xfdata.STRING), [cty.POINTER(cty.c_int)],\
#        """char * * fl_get_cmdline_args(int * p1)""")
#    library.check_if_flinitialized()
#    #ptr_argnum = cty.cast(argnum, cty.POINTER(cty.c_int))
#    ptr_argnum = library.convert_to_ptr_intc(argnum)
#    library.keep_elem_refs(argnum, ptr_argnum)
#    retval = _fl_get_cmdline_args(ptr_argnum)
#    return retval


# fl_free function placeholder (low-level)
# fl_malloc function placeholder (low-level)
# fl_calloc function placeholder (low-level)
# fl_realloc function placeholder (low-level)


def fl_msleep(msec):
    """fl_msleep(msec) -> result

    Waits for a number of milliseconds (with the best
    resolution possible on your system).

    Parameters
    ----------
        msec : long_pos
            milliseconds to sleep

    Returns
    -------
        result : int
            0 (on success)

    Examples
    --------
        >>> fl_msleep(200)

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_msleep = library.cfuncproto(
        library.load_so_libforms(), "fl_msleep",\
        cty.c_int, [cty.c_ulong],\
        """int fl_msleep(long unsigned int msec)""")
    library.check_if_flinitialized()
    ul_msec = library.convert_to_ulongc(msec)
    library.keep_elem_refs(msec, ul_msec)
    retval = _fl_msleep(ul_msec)
    return retval


def fl_is_same_object(ptr_flobject1, ptr_flobject2):
    """fl_is_same_object(ptr_flobject1, ptr_flobject2) -> yesno

    Does a comparison between two flobjects, if they are the
    same, or not.

    Parameters
    ----------
        ptr_flobject1 : pointer to xfdata.FL_OBJECT
            1st flobject to compare
        ptr_flobject2 : pointer to xfdata.FL_OBJECT
            2nd flobject to compare

    Returns
    -------
        yesno : int
            flag of comparison. Values 0 (if they are
            different) or non-zero (if they are the same)

    Examples
    --------
        >>> if fl_is_same_object(pobj, pexitobj):
        >>> ... <something>

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_is_same_object = library.cfuncproto(
        library.load_so_libforms(), "fl_is_same_object", \
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT),
        cty.POINTER(xfdata.FL_OBJECT)], \
        """int fl_is_same_object(FL_OBJECT * obj1, FL_OBJECT * obj2)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject1)
    library.verify_flobjectptr_type(ptr_flobject2)
    library.keep_elem_refs(ptr_flobject1, ptr_flobject2)
    retval = _fl_is_same_object(ptr_flobject1, ptr_flobject2)
    return retval

