#!/usr/bin/env python
# -*- coding: iso8859-1 -*-

""" xforms-python's functions to manage basic generic objects.

    Copyright (C) 2009, 2010  Luca Lazzaroni "LukenShiro"
    e-mail: <lukenshiro@ngi.it>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, version 2.1 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU LGPL along with this
    program. If not, see <http://www.gnu.org/licenses/>.

    See CREDITS file to read acknowledgements and thanks to XForms,
    ctypes and other developers.
"""


# originally generated by 'h2xml+gccxml' and 'xml2py'
# then heavily reordered and reworked

# ############################################# #
# Interface to XForms shared object libraries   #
# ############################################# #

import ctypes as cty
from xformslib import library as libr
from xformslib import xfdata


# exported variable
FL_EVENT = (cty.POINTER(xfdata.FL_OBJECT)).in_dll(libr.load_so_libforms(), \
    'FL_EVENT')


########################################
# forms.h (Basic.h)
#  Basic definitions and limits.
#  Window system independent prototypes
#  Modify with care
########################################


def FL_IS_UPBOX(boxtype):
    if (boxtype == xfdata.FL_UP_BOX) or \
        (boxtype == xfdata.FL_OVAL3D_UPBOX) or \
        (boxtype == xfdata.FL_ROUNDED3D_UPBOX):
        return True
    else:
        return False


def FL_IS_DOWNBOX(boxtype):
    if (boxtype == xfdata.FL_DOWN_BOX) or \
        (boxtype == xfdata.FL_OVAL3D_DOWNBOX) or \
        (boxtype == xfdata.FL_ROUNDED3D_DOWNBOX):
        return True
    else:
        return False


def FL_TO_DOWNBOX(boxtype):
    if boxtype == xfdata.FL_UP_BOX:
        t1 = xfdata.FL_DOWN_BOX
    elif boxtype == xfdata.FL_ROUNDED3D_UPBOX:
        t1 = xfdata.FL_ROUNDED3D_DOWNBOX
    elif boxtype == xfdata.FL_OVAL3D_UPBOX:
        t1 = xfdata.FL_OVAL3D_DOWNBOX
    else:
        t1 = boxtype
    return t1


def special_style(style):
    if (style >= xfdata.FL_SHADOW_STYLE) and \
     (style <= (xfdata.FL_EMBOSSED_STYLE + xfdata.FL_MAXFONTS)):
        return True
    else:
        return False


# IO other than XEvent Q

def fl_add_io_callback(fd, mask, py_IoCallback, vdata):
    """Registers an input callback function when input is available from fd.

    --

    :Parameters:
      `fd` : int
        a valid file descriptor in a unix system from an opened file
      `mask` : int
        under what circumstance the input callback should be invoked. Values
        (from xfdata.py) FL_READ, FL_WRITE, FL_EXCEPT
      `py_IoCallback` : python function to be invoked, no return
        name referring to function(num, ptr_void)
      `vdata` : one of those 'None'|long|str|pointer to xfdata.FL_OBJECT
        user data argument to be passed to function

    :note: e.g. def iocb(num, vdata): > ...
    :note: fdesc = os.open(myfile, os.RD_ONLY)
    :note: fl_add_io_callback(fdesc, xfdata.FL_READ, iocb, None)

    :status: Tested + Doc + NoDemo = OK

    """
    #FL_IO_CALLBACK = cty.CFUNCTYPE(None, cty.c_int, cty.c_void_p)
    _fl_add_io_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_add_io_callback", \
        None, [cty.c_int, cty.c_uint, xfdata.FL_IO_CALLBACK, cty.c_void_p],
        """void fl_add_io_callback(int fd, unsigned int mask,
           FL_IO_CALLBACK callback, void * data) """)
    libr.check_if_initialized()
    ifd = libr.convert_to_int(fd)
    libr.check_admitted_value_in_list(mask, xfdata.ASYNCIO_list)
    uimask = libr.convert_to_uint(mask)
    libr.verify_function_type(py_IoCallback)
    c_IoCallback = xfdata.FL_IO_CALLBACK(py_IoCallback)
    if vdata is None:
        pvdata = cty.cast(vdata, cty.c_void_p)
    elif isinstance(vdata, long):
        ldata = libr.convert_to_long(vdata)
        pvdata = cty.cast(ldata, cty.POINTER(cty.c_long))
    elif isinstance(vdata, str):
        ldata = libr.convert_to_string(vdata)
        pvdata = cty.cast(ldata, cty.POINTER(xfdata.STRING))
    else:
        pvdata = vdata          # it is pFlObject
    libr.keep_cfunc_refs(c_IoCallback, py_IoCallback)
    libr.keep_elem_refs(fd, ifd, mask, uimask, vdata, pvdata)
    _fl_add_io_callback(ifd, uimask, c_IoCallback, pvdata)


def fl_remove_io_callback(fd, mask, py_IoCallback):
    """Removes the registered callback function when input is available from
    fd.

    --

    :Parameters:
      `fd` : int
        a valid file descriptor in a unix system
      `mask` : int
        under what circumstance the input callback should be removed. Values
        (from xfdata.py) FL_READ, FL_WRITE, FL_EXCEPT
      `py_IoCallback` : python function to be removed, no return
        name referring to function(num, ptr_void)

    :note: def iocb(num, vdata): > ...
    :note: fdesc = os.open(myfile, os.RD_ONLY)
    :note: fl_remove_io_callback(fdesc, xfdata.FL_READ, iocb)

    :status: Tested + Doc + NoDemo = OK

    """
    #FL_IO_CALLBACK = cty.CFUNCTYPE(None, cty.c_int, cty.c_void_p)
    _fl_remove_io_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_remove_io_callback", \
        None, [cty.c_int, cty.c_uint, xfdata.FL_IO_CALLBACK], \
        """void fl_remove_io_callback(int fd, unsigned int mask,
           FL_IO_CALLBACK cb) """)
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(mask, xfdata.ASYNCIO_list)
    ifd = libr.convert_to_int(fd)
    uimask = libr.convert_to_uint(mask)
    libr.verify_function_type(py_IoCallback)
    c_IoCallback = xfdata.FL_IO_CALLBACK(py_IoCallback)
    libr.keep_cfunc_refs(c_IoCallback, py_IoCallback)
    libr.keep_elem_refs(fd, ifd, mask, uimask)
    _fl_remove_io_callback(ifd, uimask, c_IoCallback)


# signals

def fl_add_signal_callback(sglnum, py_SignalHandler, vdata):
    """Handles the receipt of a signal by registering a callback function that
    gets called when a signal is caught (only one function per signal).

    --

    :Parameters:
      `sglnum` : int
        signal number. Values (from signal module) SIGALRM, SIGINT, ...
      `py_SignalHandler` : callback invoked after catching signal, no return
        name referring to function(num, ptr_void)
      `vdata` : None or long or pointer to xfdata.FL_OBJECT
        argument to be passed to function

    :note: def sglhandl(numsgl, vdata): > ...
    :note: fl_add_signal_callback(signal.SIGALRM, sglhandl, None)

    :status: Tested + Doc + NoDemo = OK

    """
    #FL_SIGNAL_HANDLER = cty.CFUNCTYPE(None, cty.c_int, cty.c_void_p)
    _fl_add_signal_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_add_signal_callback", \
        None, [cty.c_int, xfdata.FL_SIGNAL_HANDLER, cty.c_void_p], \
        """void fl_add_signal_callback(int s, FL_SIGNAL_HANDLER cb,
           void * data) """)
    libr.check_if_initialized()
    isglnum = libr.convert_to_int(sglnum)
    c_SignalHandler = xfdata.FL_SIGNAL_HANDLER(py_SignalHandler)
    if vdata is None:
        pvdata = cty.cast(vdata, cty.c_void_p)
    elif isinstance(vdata, long):
        ldata = libr.convert_to_long(vdata)
        pvdata = cty.cast(ldata, cty.POINTER(cty.c_long))
    else:
        pvdata = vdata          # it is pFlObject
    libr.keep_cfunc_refs(c_SignalHandler, py_SignalHandler)
    libr.keep_elem_refs(sglnum, isglnum, vdata, pvdata)
    _fl_add_signal_callback(isglnum, c_SignalHandler, pvdata)


def fl_remove_signal_callback(sglnum):
    """Removes a previously registered callback function related to a signal.

    --

    :Parameters:
     `sglnum` : int
       signal number. Values (from signal module) SIGALRM, SIGINT, ...

    :note: e.g. fl_remove_signal_callback(signal.SIGALRM)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_remove_signal_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_remove_signal_callback", \
        None, [cty.c_int], \
        """void fl_remove_signal_callback(int s) """)
    libr.check_if_initialized()
    isglnum = libr.convert_to_int(sglnum)
    libr.keep_elem_refs(sglnum, isglnum)
    _fl_remove_signal_callback(isglnum)


def fl_signal_caught(sglnum):
    """Informs the main loop of the delivery of the particular signal. The
    signal is received by the application program.

    --

    :Parameters:
      `sglnum` : int
        signal number. Values (from signal module) SIGALRM, SIGINT, ...

    :note: e.g. fl_signal_caught(signal.SIGALRM)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_signal_caught = libr.cfuncproto(
        libr.load_so_libforms(), "fl_signal_caught", \
        None, [cty.c_int], \
        """void fl_signal_caught(int s) """)
    libr.check_if_initialized()
    isglnum = libr.convert_to_int(sglnum)
    libr.keep_elem_refs(sglnum, isglnum)
    _fl_signal_caught(isglnum)


def fl_app_signal_direct(flag):
    """Changes the default behavior of the built-in signal facilities (to
    be called with a true value for flag prior to any use of
    fl_add_signal_callback)

    --

    :Parameters:
      `flag` : int
        flag to disable/enable signal. Values 0 (disabled) or 1 (enabled)

    :note: e.g. fl_app_signal_direct(1)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_app_signal_direct = libr.cfuncproto(
        libr.load_so_libforms(), "fl_app_signal_direct", \
        None, [cty.c_int], \
        """void fl_app_signal_direct(int y) """)
    libr.check_if_initialized()
    iflag = libr.convert_to_int(flag)
    libr.keep_elem_refs(flag, iflag)
    _fl_app_signal_direct(iflag)


# timeouts

def fl_add_timeout(msec, py_TimeoutCallback, vdata):
    """Adds a timeout callback after a specified elapsed time.

    --

    :Parameters:
      `msec` : long
        time elapsed in milliseconds
      `py_TimeoutCallback` : python function to be invoked, no return
        name referring to function(num, ptr_void)
      `vdata` : None or long or pointer to xfdata.FL_OBJECT
        user data to be passed to function

    :return: timer number id
    :rtype: int

    :note: e.g. def timeoutcb(num, vdata): > ...
    :note: e.g. timnum = fl_add_timeout(100, timeoutcb, None)

    :status: Tested + Doc + Demo = OK

    """
    #FL_TIMEOUT_CALLBACK = cty.CFUNCTYPE(None, cty.c_int, cty.c_void_p)
    _fl_add_timeout = libr.cfuncproto(
        libr.load_so_libforms(), "fl_add_timeout", \
        cty.c_int, [cty.c_long, xfdata.FL_TIMEOUT_CALLBACK, cty.c_void_p],
        """int fl_add_timeout(long int msec,
           FL_TIMEOUT_CALLBACK callback, void * data) """)
    libr.check_if_initialized()
    lmsec = libr.convert_to_long(msec)
    if vdata is None:
        pvdata = cty.cast(vdata, cty.c_void_p)
    elif isinstance(vdata, long):
        ldata = libr.convert_to_long(vdata)
        pvdata = cty.cast(ldata, cty.POINTER(cty.c_long))
    else:
        pvdata = vdata          # it is pFlObject
    c_TimeoutCallback = xfdata.FL_TIMEOUT_CALLBACK(py_TimeoutCallback)
    libr.keep_cfunc_refs(c_TimeoutCallback, py_TimeoutCallback)
    libr.keep_elem_refs(msec, lmsec, vdata, pvdata)
    retval = _fl_add_timeout(lmsec, c_TimeoutCallback, pvdata)
    return retval


def fl_remove_timeout(idnum):
    """Removes a timeout callback function (created with fl_add_timeout).

    --

    :Parameters:
      `idnum` : int
        timeout number id

    :note: e.g. fl_remove_timeout(timnum)

    :status: Tested + Doc + Demo = OK

    """
    _fl_remove_timeout = libr.cfuncproto(
        libr.load_so_libforms(), "fl_remove_timeout", \
        None, [cty.c_int], \
        """void fl_remove_timeout(int id) """)
    libr.check_if_initialized()
    iidnum = libr.convert_to_int(idnum)
    libr.keep_elem_refs(idnum, iidnum)
    _fl_remove_timeout(iidnum)


# Basic public routine prototypes

def fl_library_version():
    """Returns consolidated, major and minor version informations.

    --

    :return: version_rev (computed as 1000 * version + revision), version
        (e.g. 1 in 1.x.yy), revision (e.g. 0 in x.0.yy)
    :rtype: int, int, int

    :note: e.g. compver, ver, rev = fl_library_version()

    :attention: API change from XForms - upstream was fl_library_version(ver,
        rev)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_library_version = libr.cfuncproto(
        libr.load_so_libforms(), "fl_library_version", \
        cty.c_int, [cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)], \
        """int fl_library_version(int * ver, int * rev) """)
    libr.check_if_initialized()
    ver, pver = libr.make_int_and_pointer()
    rev, prev = libr.make_int_and_pointer()
    libr.keep_elem_refs(ver, rev, pver, prev)
    retval = _fl_library_version(pver, prev)
    return retval, ver.value, rev.value


# Generic routines that deal with FORMS

def fl_bgn_form(formtype, w, h):
    """Starts the definition of a form call.

    --

    :Parameters:
      `formtype` : int
        type of box used as a background. Values (from xfdata.py) FL_NO_BOX,
        FL_UP_BOX, FL_DOWN_BOX, FL_BORDER_BOX, FL_SHADOW_BOX, FL_FRAME_BOX,
        FL_ROUNDED_BOX, FL_EMBOSSED_BOX, FL_FLAT_BOX, FL_RFLAT_BOX,
        FL_RSHADOW_BOX, FL_OVAL_BOX, FL_ROUNDED3D_UPBOX, FL_ROUNDED3D_DOWNBOX,
        FL_OVAL3D_UPBOX, FL_OVAL3D_DOWNBOX, FL_OVAL3D_FRAMEBOX,
        FL_OVAL3D_EMBOSSEDBOX
      `w` : int
        width of the new form in coord units
      `h` : int
        height of the new form in coord units

    :return: form to define (pFlForm)
    :rtype: pointer to xfdata.FL_FORM

    :note: e.g. pform = fl_bgn_form(xfdata.FL_UP_BOX, 400, 500)

    :status: Tested + Doc + Demo = OK

    """
    _fl_bgn_form = libr.cfuncproto(
        libr.load_so_libforms(), "fl_bgn_form", \
        cty.POINTER(xfdata.FL_FORM), [cty.c_int, xfdata.FL_Coord,
        xfdata.FL_Coord],
        """FL_FORM * fl_bgn_form(int type, FL_Coord w, FL_Coord h) """)
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(formtype, xfdata.BOXTYPE_list)
    iformtype = libr.convert_to_int(formtype)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    libr.keep_elem_refs(formtype, iformtype, w, iw, h, ih)
    retval = _fl_bgn_form(iformtype, iw, ih)
    return retval


def fl_end_form():
    """Ends the definition for a form call, after all required objects have
    been added to a form call.

    --

    :note: e.g. fl_end_form()

    :status: Tested + Doc + Demo = OK

    """
    _fl_end_form = libr.cfuncproto(
        libr.load_so_libforms(), "fl_end_form", \
        None, [], \
        """void fl_end_form() """)
    libr.check_if_initialized()
    _fl_end_form()


def fl_do_forms():
    """Starts the main loop of the program and returns only when the state of
    a FL_OBJECT (that has no callback bound to it) changes.

    --

    :return: object changed (pFlObject)
    :rtype: pointer to xfdata.FL_OBJECT

    :note: e.g. while fl_do_forms(): pass

    :status: Tested + Doc + Demo = OK

    """
    _fl_do_forms = libr.cfuncproto(
        libr.load_so_libforms(), "fl_do_forms", \
        cty.POINTER(xfdata.FL_OBJECT), [], \
        """FL_OBJECT * fl_do_forms() """)
    libr.check_if_initialized()
    retval = _fl_do_forms()
    return retval


def fl_check_forms():
    """Returns None immediately unless the state of one of xfdata.FL_OBJECT
    (without a callback bound to it) changed.

    --

    :return: object changed (pFlObject)
    :rtype: pointer to xfdata.FL_OBJECT

    :note: e.g. pobj = fl_check_forms()

    :status: Tested + Doc + Demo = OK

    """
    _fl_check_forms = libr.cfuncproto(
        libr.load_so_libforms(), "fl_check_forms", \
        cty.POINTER(xfdata.FL_OBJECT), [], \
        """FL_OBJECT * fl_check_forms() """)
    libr.check_if_initialized()
    retval = _fl_check_forms()
    return retval


def fl_do_only_forms():
    """Starts the main loop of the program and returns only when the state of
    an object changes that has no callback bound to it. It does not handle
    user events generated by application windows opened via fl_winopen() or
    similar routines.

    --

    :return: object changed (pFlObject)
    :rtype: pointer to xfdata.FL_OBJECT

    :note: e.g. pobj = fl_do_only_forms()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_do_only_forms = libr.cfuncproto(
        libr.load_so_libforms(), "fl_do_only_forms", \
        cty.POINTER(xfdata.FL_OBJECT), [], \
        """FL_OBJECT * fl_do_only_forms() """)
    libr.check_if_initialized()
    retval = _fl_do_only_forms()
    return retval


def fl_check_only_forms():
    """Returns None immediately unless the state of one of the object (without
    a callback bound to it) changed. It does not handle user events generated
    by application windows opened via fl_winopen() or similar routines.

    --

    :return: object changed (pFlObject)
    :rtype: pointer to xfdata.FL_OBJECT

    :note: e.g. pobj = fl_check_only_forms()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_check_only_forms = libr.cfuncproto(
        libr.load_so_libforms(), "fl_check_only_forms", \
        cty.POINTER(xfdata.FL_OBJECT), [], \
        """FL_OBJECT * fl_check_only_forms() """)
    libr.check_if_initialized()
    retval = _fl_check_only_forms()
    return retval


def fl_freeze_form(pFlForm):
    """Redraw of a form is temporarily suspended, while changes are being
    made, so all changes made are instead buffered internally.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form not to be re-drawn temporarily

    :note: e.g. fl_freeze_form(pform1)

    :status: Tested + Doc + Demo = OK

    """
    _fl_freeze_form = libr.cfuncproto(
        libr.load_so_libforms(), "fl_freeze_form", \
        None, [cty.POINTER(xfdata.FL_FORM)], \
        """void fl_freeze_form(FL_FORM * form) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    _fl_freeze_form(pFlForm)


def fl_set_focus_object(pFlForm, pFlObject):
    """Sets the input focus in form to object pFlObject.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form whose object has to be focused
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to be focused

    :note: e.g. fl_set_focus_object(pform, pobj)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_focus_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_focus_object", \
        None, [cty.POINTER(xfdata.FL_FORM), cty.POINTER(xfdata.FL_OBJECT)], \
        """void fl_set_focus_object(FL_FORM * form, FL_OBJECT * obj) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlForm, pFlObject)
    _fl_set_focus_object(pFlForm, pFlObject)


fl_set_object_focus = fl_set_focus_object


def fl_get_focus_object(pFlForm):
    """Obtains the object that has the focus on a form.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form that has a focused object in

    :return: focused object (pFlObject)
    :rtype: pointer to xfdata.FL_OBJECT

    :note: e.g. pobj2 = fl_get_focus_object(pform1)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_focus_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_focus_object", \
        cty.POINTER(xfdata.FL_OBJECT), [cty.POINTER(xfdata.FL_FORM)], \
        """FL_OBJECT * fl_get_focus_object(FL_FORM * form) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    retval = _fl_get_focus_object(pFlForm)
    return retval


def fl_reset_focus_object(pFlObject):
    """Resets focus on current object, overriding the xfdata.FL_UNFOCUS
    event.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object towards applying event

    :note: e.g. fl_reset_focus_object(pobj2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_reset_focus_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_reset_focus_object", \
        None, [cty.POINTER(xfdata.FL_OBJECT)], \
        """void fl_reset_focus_object(FL_OBJECT * ob) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    _fl_reset_focus_object(pFlObject)


def fl_set_form_atclose(pFlForm, py_FormAtclose, vdata):
    """Calls a callback function before closing the form.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form that receives the message
      `py_FormAtclose` : python callback to be called, with returning value
        name referring to function(pFlForm, ptr_void) -> num
      `vdata` : None or long or pointer to xfdata.FL_OBJECT
        user data to be passed to function

    :return: old FL_FORM_ATCLOSE function

    :note: e.g. def atcolsecb(pform, vdata): > ... ; return 0
    :note: e.g. oldatclosecb = fl_set_form_atclose(pform1, None)

    :status: Tested + Doc + NoDemo = OK

    """
    # FL_FORM_ATCLOSE = cty.CFUNCTYPE(cty.c_int, cty.POINTER(xfdata.FL_FORM), \
    #                                 cty.c_void_p)
    _fl_set_form_atclose = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_form_atclose", \
        xfdata.FL_FORM_ATCLOSE, [cty.POINTER(xfdata.FL_FORM), \
        xfdata.FL_FORM_ATCLOSE, cty.c_void_p], \
        """FL_FORM_ATCLOSE fl_set_form_atclose(FL_FORM * form,
           FL_FORM_ATCLOSE fmclose, void * data) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    c_FormAtclose = xfdata.FL_FORM_ATCLOSE(py_FormAtclose)
    if vdata is None:
        pvdata = cty.cast(vdata, cty.c_void_p)
    elif isinstance(vdata, long):
        ldata = libr.convert_to_long(vdata)
        pvdata = cty.cast(ldata, cty.POINTER(cty.c_long))
    else:
        pvdata = vdata          # it is pFlObject
    libr.keep_cfunc_refs(c_FormAtclose, py_FormAtclose)
    libr.keep_elem_refs(pFlForm, vdata, pvdata)
    retval = _fl_set_form_atclose(pFlForm, c_FormAtclose, pvdata)
    return retval


def fl_set_atclose(py_FormAtclose, vdata):
    """Calls a callback function before terminating the application.

    --

    :Parameters:
      `py_FormAtclose` : python callback to be called, with returning value
        name referring to function(pFlForm, ptr_void) -> num
      `vdata` : None or long or pointer to xfdata.FL_OBJECT
        user data to be passed to function

    :return: old FL_FORM_ATCLOSE function

    :note: e.g. def atclose(pform, vdata): > ... ; return 0
    :note: e.g. oldatclosefunc = fl_set_atclose(atclose, None)

    :status: Tested + Doc + NoDemo = OK

    """
    # FL_FORM_ATCLOSE = cty.CFUNCTYPE(cty.c_int, cty.POINTER(xfdata.FL_FORM), \
    #                                 cty.c_void_p)
    _fl_set_atclose = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_atclose", \
        xfdata.FL_FORM_ATCLOSE, [xfdata.FL_FORM_ATCLOSE, cty.c_void_p], \
        """FL_FORM_ATCLOSE fl_set_atclose(FL_FORM_ATCLOSE fmclose,
           void * data) """)
    libr.check_if_initialized()
    c_FormAtclose = xfdata.FL_FORM_ATCLOSE(py_FormAtclose)
    if vdata is None:
        pvdata = cty.cast(vdata, cty.c_void_p)
    elif isinstance(vdata, long):
        ldata = libr.convert_to_long(vdata)
        pvdata = cty.cast(ldata, cty.POINTER(cty.c_long))
    else:
        pvdata = vdata          # it is pFlObject
    libr.keep_cfunc_refs(c_FormAtclose, py_FormAtclose)
    libr.keep_elem_refs(vdata, pvdata)
    retval = _fl_set_atclose(c_FormAtclose, pvdata)
    return retval


def fl_set_form_atactivate(pFlForm, py_FormAtactivate, vdata):
    """Register a callback that is called when activation status of a forms
    is enabled.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        activated form
      `py_FormAtactivate` : python callback function called, no return
        name referring to function(pFlForm, ptr_void)
      `vdata` : None or long or pointer to xfdata.FL_OBJECT
        user data to be passed to function

    :return: old FL_FORM_ATACTIVATE function

    :note: e.g. def atactcb(pform, vdata): > ...
    :note: e.g. oldactfunc = fl_set_form_atdeactivate(pform, atactcb, None)

    :status: Tested + Doc + NoDemo = OK

    """
    #FL_FORM_ATACTIVATE = cty.CFUNCTYPE(None, cty.POINTER(xfdata.FL_FORM), \
    #                                   cty.c_void_p)
    _fl_set_form_atactivate = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_form_atactivate", \
        xfdata.FL_FORM_ATACTIVATE, [cty.POINTER(xfdata.FL_FORM),
        xfdata.FL_FORM_ATACTIVATE, cty.c_void_p], \
        """FL_FORM_ATACTIVATE fl_set_form_atactivate(FL_FORM * form,
           FL_FORM_ATACTIVATE cb, void * data) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    c_FormAtactivate = xfdata.FL_FORM_ATACTIVATE(py_FormAtactivate)
    if vdata is None:
        pvdata = cty.cast(vdata, cty.c_void_p)
    elif isinstance(vdata, long):
        ldata = libr.convert_to_long(vdata)
        pvdata = cty.cast(ldata, cty.POINTER(cty.c_long))
    else:
        pvdata = vdata          # it is pFlObject
    libr.keep_cfunc_refs(c_FormAtactivate, py_FormAtactivate)
    libr.keep_elem_refs(pFlForm, vdata, pvdata)
    retval = _fl_set_form_atactivate(pFlForm, c_FormAtactivate, pvdata)
    return retval


def fl_set_form_atdeactivate(pFlForm, py_FormAtdeactivate, vdata):
    """Register a callback that is called when activation status of a forms
    is disabled.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        de-activated form
      `py_FormAtdeactivate` : python callback function called, no return
        name referring to function(pFlForm, ptr_void)
      `vdata` : None or long or pointer to xfdata.FL_OBJECT
        user data to be passed to function

    :return: old FL_FORM_ATDEACTIVATE function

    :note: e.g. def atdeactcb(pform, vdata): > ...
    :note: e.g. oldatdeactfunc = xf.fl_set_form_atdeactivate(pform,
        atdeactcb, None)

    :status: Tested + Doc + NoDemo = OK

    """
    #FL_FORM_ATDEACTIVATE = cty.CFUNCTYPE(None, cty.POINTER(xfdata.FL_FORM), \
    #                                     cty.c_void_p)
    _fl_set_form_atdeactivate = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_form_atdeactivate", \
        xfdata.FL_FORM_ATDEACTIVATE, [cty.POINTER(xfdata.FL_FORM),
        xfdata.FL_FORM_ATDEACTIVATE, cty.c_void_p], \
        """FL_FORM_ATDEACTIVATE fl_set_form_atdeactivate(FL_FORM * form,
           FL_FORM_ATDEACTIVATE cb, void * data) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    c_FormAtdeactivate = xfdata.FL_FORM_ATDEACTIVATE(py_FormAtdeactivate)
    if vdata is None:
        pvdata = cty.cast(vdata, cty.c_void_p)
    elif isinstance(vdata, long):
        ldata = libr.convert_to_long(vdata)
        pvdata = cty.cast(ldata, cty.POINTER(cty.c_long))
    else:
        pvdata = vdata          # it is pFlObject
    libr.keep_cfunc_refs(c_FormAtdeactivate, py_FormAtdeactivate)
    libr.keep_elem_refs(pFlForm, vdata, pvdata)
    retval = _fl_set_form_atdeactivate(pFlForm, c_FormAtdeactivate, pvdata)
    return retval


def fl_unfreeze_form(pFlForm):
    """Reverts previous freeze (set with fl_freeze_form function), all
    changes made in the meantime in a form are drawn at once.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form to be re-drawn after freezing

    :note: e.g. fl_unfreeze_form(pform)

    :status: Tested + Doc + Demo = OK

    """
    _fl_unfreeze_form = libr.cfuncproto(
        libr.load_so_libforms(), "fl_unfreeze_form", \
        None, [cty.POINTER(xfdata.FL_FORM)], \
        """void fl_unfreeze_form(FL_FORM * form) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    _fl_unfreeze_form(pFlForm)


def fl_deactivate_form(pFlForm):
    """Deactivates form temporarily, without hiding it, but not allowing a
    user to interact with elements contained in form (buttons, etc.).

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form to be de-activated

    :note: e.g. fl_deactivate_form(pform)

    :status: Tested + Doc + Demo = OK

    """
    _fl_deactivate_form = libr.cfuncproto(
        libr.load_so_libforms(), "fl_deactivate_form", \
        None, [cty.POINTER(xfdata.FL_FORM)], \
        """void fl_deactivate_form(FL_FORM * form) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    _fl_deactivate_form(pFlForm)


def fl_activate_form(pFlForm):
    """(Re)activates form (deactivated with fl_deactivate_form), allowing the
    user to interact again with elements contained in form (buttons, etc.).

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form to be re-activated

    :note: e.g. fl_activate_form(pform)

    :status: Tested + Doc + Demo = OK

    """
    _fl_activate_form = libr.cfuncproto(
        libr.load_so_libforms(), "fl_activate_form", \
        None, [cty.POINTER(xfdata.FL_FORM)], \
        """void fl_activate_form(FL_FORM * form) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    _fl_activate_form(pFlForm)


def fl_deactivate_all_forms():
    """De-activates all current forms, forbidding any event/user interaction.

    --

    :note: e.g. fl_deactivate_all_forms()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_deactivate_all_forms = libr.cfuncproto(
        libr.load_so_libforms(), "fl_deactivate_all_forms", \
        None, [], \
        """void fl_deactivate_all_forms() """)
    libr.check_if_initialized()
    _fl_deactivate_all_forms()


def fl_activate_all_forms():
    """(Re)activates all current forms, allowing event/user interaction.

    --

    :note: e.g. fl_activate_all_forms()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_activate_all_forms = libr.cfuncproto(
        libr.load_so_libforms(), "fl_activate_all_forms", \
        None, [], \
        """void fl_activate_all_forms() """)
    libr.check_if_initialized()
    _fl_activate_all_forms()


def fl_freeze_all_forms():
    """All current forms are not temporarily redrawn, while changes are being
    made and are instead buffered internally.

    --

    :note: e.g. fl_freeze_all_forms()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_freeze_all_forms = libr.cfuncproto(
        libr.load_so_libforms(), "fl_freeze_all_forms", \
        None, [], \
        """void fl_freeze_all_forms() """)
    libr.check_if_initialized()
    _fl_freeze_all_forms()


def fl_unfreeze_all_forms():
    """All changes made in the meantime in all current forms are drawn at
    once, reverting previous freeze.

    --

    :note: e.g. fl_unfreeze_all_forms()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_unfreeze_all_forms = libr.cfuncproto(
        libr.load_so_libforms(), "fl_unfreeze_all_forms", \
        None, [], \
        """void fl_unfreeze_all_forms() """)
    libr.check_if_initialized()
    _fl_unfreeze_all_forms()


def fl_scale_form(pFlForm, xsc, ysc):
    """Scales a form and the objects on it in size and position, indicating
    a scaling factor in x- and y-direction (1.1 = 110 percent, 0.5 = 50,
    etc.) with respect to the current size, and reshapes the window.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form to be scaled
      `xsc` : float
        scaling factor in horizontal direction
      `ysc` : float
        scaling factor in vertical direction

    :note: e.g. fl_scale_form(pform, 0.8, 1.2)

    :status: Tested + Doc + Demo = OK

    """
    _fl_scale_form = libr.cfuncproto(
        libr.load_so_libforms(), "fl_scale_form", \
        None, [cty.POINTER(xfdata.FL_FORM), cty.c_double, cty.c_double], \
        """void fl_scale_form(FL_FORM * form, double xsc, double ysc) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    fxsc = libr.convert_to_double(xsc)
    fysc = libr.convert_to_double(ysc)
    libr.keep_elem_refs(pFlForm, xsc, fxsc, ysc, fysc)
    _fl_scale_form(pFlForm, fxsc, fysc)


def fl_set_form_position(pFlForm, x, y):
    """Sets position of form, when placing a form on the screen with
    xfdata.FL_PLACE_GEOMETRY as place argument.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form whose position is to be set
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)

    :note: e.g. fl_set_form_position(pform, 125, 250)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_form_position = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_form_position", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.FL_Coord, xfdata.FL_Coord],
        """void fl_set_form_position(FL_FORM * form, FL_Coord x,
           FL_Coord y) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    libr.keep_elem_refs(pFlForm, x, ix, y, iy)
    _fl_set_form_position(pFlForm, ix, iy)


def fl_set_form_title(pFlForm, title):
    """Changes the form title (and the icon name) after it is shown.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form whose title has to be changed
      `title` : str
        new title text for the form

    :note: e.g. fl_set_form_title(pform, "My great form")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_form_title = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_form_title", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.STRING], \
        """void fl_set_form_title(FL_FORM * form, const char * name) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    stitle = libr.convert_to_string(title)
    libr.keep_elem_refs(pFlForm, title, stitle)
    _fl_set_form_title(pFlForm, stitle)


def fl_set_app_mainform(pFlForm):
    """Designates the main form. By default, the main form is set
    automatically by the library to the first full-bordered form shown.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form to be set as main one

    :note: e.g. fl_set_app_mainform(pform2)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_app_mainform = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_app_mainform",
        None, [cty.POINTER(xfdata.FL_FORM)], \
        """void fl_set_app_mainform(FL_FORM * form) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    _fl_set_app_mainform(pFlForm)


def fl_get_app_mainform():
    """Returns the current mainform.

    --

    :return: main form (pFlForm)
    :rtype: pointer to xfdata.FL_FORM

    :note: e.g. fl_get_app_mainform()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_app_mainform = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_app_mainform",
        cty.POINTER(xfdata.FL_FORM), [], \
        """FL_FORM * fl_get_app_mainform() """)
    libr.check_if_initialized()
    retval = _fl_get_app_mainform()
    return retval


def fl_set_app_nomainform(yesno):
    """In some situations, either because the concept of an application
    main form does not apply (for example, an application might have
    multiple full-bordered windows), or under some (buggy) window managers,
    the designation of a main form may cause stacking order problems. To
    workaround these, it can disable the designation of a main form (must
    be called before any full-bordered form is shown).

    --

    :Parameters:
      `yesno` : int
        flag to disable/enable mainform designation. Values 1 (to disable) or
        0 (to enable)

    :note: e.g. fl_set_app_nomainform(1)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_app_nomainform = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_app_nomainform",
        None, [cty.c_int], \
        """void fl_set_app_nomainform(int flag) """)
    libr.check_if_initialized()
    iyesno = libr.convert_to_int(yesno)
    libr.keep_elem_refs(yesno, iyesno)
    _fl_set_app_nomainform(iyesno)


def fl_set_form_callback(pFlForm, py_FormCallbackPtr, vdata):
    """Sets the callback function bound to an entire form. Whenever
    fl_do_forms() or fl_check_forms() would return an object in form they
    call the routine callback instead, with the object as an argument. So
    with each form you can associate its own callback routine. For objects
    that have their own callbacks, the object callbacks have priority over
    the form callback.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form whose callback has to be set
      `py_FormCallbackPtr` : python callback to be set, no return
        name referring to function(pFlObject, ptr_void)
      `vdata` : None or long or pointer to xfdata.FL_OBJECT
        user data to be passed to function

    :note: e.g. def formcb(pobj, vdata): > ...

    :note: e.g. fl_set_form_callback(pform, formcb, None)

    :status: Tested + Doc + Demo = OK

    """
    #FL_FORMCALLBACKPTR = cty.CFUNCTYPE(None, cty.POINTER(xfdata.FL_OBJECT), \
    #                                   cty.c_void_p)
    _fl_set_form_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_form_callback", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.FL_FORMCALLBACKPTR, \
        cty.c_void_p], \
        """void fl_set_form_callback(FL_FORM * form,
           FL_FORMCALLBACKPTR callback, void * d) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    c_FormCallbackPtr = xfdata.FL_FORMCALLBACKPTR(py_FormCallbackPtr)
    if vdata is None:
        pvdata = cty.cast(vdata, cty.c_void_p)
    elif isinstance(vdata, long):
        ldata = libr.convert_to_long(vdata)
        pvdata = cty.cast(ldata, cty.POINTER(cty.c_long))
    else:
        pvdata = vdata          # it is pFlObject
    libr.keep_cfunc_refs(c_FormCallbackPtr, py_FormCallbackPtr)
    libr.keep_elem_refs(pFlForm, vdata, pvdata)
    _fl_set_form_callback(pFlForm, c_FormCallbackPtr, pvdata)


fl_set_form_call_back = fl_set_form_callback


def fl_set_form_size(pFlForm, w, h):
    """Sets the size of form.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form whose size has to be set
      `w` : int
        width of form in coord units
      `h` : int
        height of form in coord units

    :note: e.g. fl_set_form_size(pform, 200, 200)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_form_size = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_form_size", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.FL_Coord,
        xfdata.FL_Coord], \
        """void fl_set_form_size(FL_FORM * form, FL_Coord w, FL_Coord h)""")
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    libr.keep_elem_refs(pFlForm, w, iw, h, ih)
    _fl_set_form_size(pFlForm, iw, ih)


def fl_set_form_hotspot(pFlForm, x, y):
    """Sets the position of the hotspot, for showing a form so that a
    particular point is under the mouse. You have to use
    xfdata.FL_PLACE_HOTSPOT as place argument in fl_show_form().

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form to be set
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)

    :note: e.g. fl_set_form_hotspot(pform, 300, 50)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_form_hotspot = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_form_hotspot", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.FL_Coord,
        xfdata.FL_Coord], \
        """void fl_set_form_hotspot(FL_FORM * form, FL_Coord x,
           FL_Coord y) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    libr.keep_elem_refs(pFlForm, x, ix, y, iy)
    _fl_set_form_hotspot(pFlForm, ix, iy)


def fl_set_form_hotobject(pFlForm, pFlObject):
    """Sets the hotspot for showing a form so that a particular object is
    under the mouse. You have to use xfdata.FL_PLACE_HOTSPOT as place
    argument in fl_show_form().

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form whose object has to be set
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object

    :note: e.g. fl_set_form_hotobject(pform, pobj)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_form_hotobject = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_form_hotobject", \
        None, [cty.POINTER(xfdata.FL_FORM), cty.POINTER(xfdata.FL_OBJECT)], \
        """void fl_set_form_hotobject(FL_FORM * form, FL_OBJECT * ob) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlForm, pFlObject)
    _fl_set_form_hotobject(pFlForm, pFlObject)


def fl_set_form_minsize(pFlForm, w, h):
    """Sets the minimum size a form can have, if interactive resizing is
    allowed (e.g., by showing the form with xfdata.FL_PLACE_POSITION).

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form
      `w` : int
        width of form in coord units
      `h` : int
        height of form in coord units

    :note: e.g. fl_set_form_minsize(pform, 200, 300)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_form_minsize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_form_minsize", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.FL_Coord,
        xfdata.FL_Coord],
        """void fl_set_form_minsize(FL_FORM * form, FL_Coord w,
           FL_Coord h) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    libr.keep_elem_refs(pFlForm, w, iw, h, ih)
    _fl_set_form_minsize(pFlForm, iw, ih)


def fl_set_form_maxsize(pFlForm, w, h):
    """Sets the maximum size a form can have, if interactive resizing is
    allowed (e.g. by showing the form with xfdata.FL_PLACE_POSITION).

    --

    :Parameters:
      `pFlForm` : pointer to xdata.FL_FORM
        form whose size has to be set
      `w` : int
        width of form in coord units
      `h` : int
        height of form in coord units

    :note: e.g. fl_set_form_maxsize(pform, 400, 450)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_form_maxsize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_form_maxsize", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.FL_Coord,
        xfdata.FL_Coord], \
        """void fl_set_form_maxsize(FL_FORM * form, FL_Coord w,
           FL_Coord h) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    libr.keep_elem_refs(pFlForm, w, iw, h, ih)
    _fl_set_form_maxsize(pFlForm, iw, ih)


# TODO: find if key mask have to be included
def fl_set_form_event_cmask(pFlForm, cmask):
    """Sets the event compress mask a form can react to.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form
      `cmask` : long_pos
        event compress mask for form. Values (from xfdata.py) one or more
        OR-ed between NoEventMask, KeyPressMask, KeyReleaseMask,
        ButtonPressMask, ButtonReleaseMask, EnterWindowMask, LeaveWindowMask,
        PointerMotionMask, PointerMotionHintMask, Button1MotionMask,
        Button2MotionMask, Button3MotionMask, Button4MotionMask,
        Button5MotionMask, ButtonMotionMask, KeymapStateMask, ExposureMask,
        VisibilityChangeMask, StructureNotifyMask, ResizeRedirectMask,
        SubstructureNotifyMask, SubstructureRedirectMask, FocusChangeMask,
        ColormapChangeMask, OwnerGrabButtonMask, FL_ALL_EVENT, ... ?

    :note: e.g. fl_set_form_event_cmask(pform, xfdata.FL_ALL_EVENT)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_form_event_cmask = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_form_event_cmask", \
        None, [cty.POINTER(xfdata.FL_FORM), cty.c_ulong], \
        """void fl_set_form_event_cmask(FL_FORM * form,
           long unsigned int cmask) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    ulcmask = libr.convert_to_ulong(cmask)
    libr.keep_elem_refs(pFlForm, cmask, ulcmask)
    _fl_set_form_event_cmask(pFlForm, ulcmask)


def fl_get_form_event_cmask(pFlForm):
    """Returns event compress mask a form can react to.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form

    :return: event compress mask id (cmask)
    :rtype: long_pos

    :note: e.g. cmaskid = fl_get_form_event_cmask(pform)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_form_event_cmask = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_form_event_cmask", \
        cty.c_ulong, [cty.POINTER(xfdata.FL_FORM)], \
        """long unsigned int fl_get_form_event_cmask(FL_FORM * form)""")
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    retval = _fl_get_form_event_cmask(pFlForm)
    return retval


def fl_set_form_geometry(pFlForm, x, y, w, h):
    """Sets the geometry (position and size) of a form.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        pointer to form to be set
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width of form in coord units
      `h` : int
        height of form in coord units

    :note: e.g. fl_set_form_geometry(pform, 300, 400, 150, 150)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_form_geometry = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_form_geometry", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord], \
        """void fl_set_form_geometry(FL_FORM * form, FL_Coord x,
           FL_Coord y, FL_Coord w, FL_Coord h) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    libr.keep_elem_refs(pFlForm, x, ix, y, iy, w, iw, h, ih)
    _fl_set_form_geometry(pFlForm, ix, iy, iw, ih)


fl_set_initial_placement = fl_set_form_geometry


def fl_show_form(pFlForm, place, border, title):
    """Shows the form.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form to be shown
      `place` : int
        where form has to be placed. Values (from xfdata.py) FL_PLACE_FREE,
        FL_PLACE_MOUSE, FL_PLACE_CENTER, FL_PLACE_POSITION, FL_PLACE_SIZE,
        FL_PLACE_GEOMETRY, FL_PLACE_ASPECT, FL_PLACE_FULLSCREEN,
        FL_PLACE_HOTSPOT, FL_PLACE_ICONIC, FL_FREE_SIZE, FL_PLACE_FREE_CENTER,
        FL_PLACE_CENTERFREE, FL_PLACE_MOUSE|FL_FREE_SIZE,
        FL_PLACE_FULLSCREEN|FL_FREE_SIZE, FL_PLACE_HOTSPOT|FL_FREE_SIZE

      `border` : int
        window manager decoration. Values (from xfdata.py) FL_FULLBORDER,
        FL_TRANSIENT, FL_NOBORDER
      `title` : str
        title of form

    :return:  window id (win)
    :rtype: long_pos

    :note: e.g. wind = fl_show_form(pform0, FL_PLACE_FREE, FL_FULLBORDER,
        "MyForm")

    :status: Tested + Doc + Demo = OK

    """
    _fl_show_form = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_form",
        xfdata.Window, [cty.POINTER(xfdata.FL_FORM), cty.c_int, cty.c_int,
        xfdata.STRING], \
        """Window fl_show_form(FL_FORM * form, int place, int border,
           const char * name) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.check_admitted_value_in_list(place, xfdata.PLACE_list)
    libr.check_admitted_value_in_list(border, xfdata.DECORATION_list)
    iplace = libr.convert_to_int(place)
    iborder = libr.convert_to_int(border)
    stitle = libr.convert_to_string(title)
    libr.keep_elem_refs(pFlForm, place, iplace, border, iborder, title,
                           stitle)
    retval = _fl_show_form(pFlForm, iplace, iborder, stitle)
    return retval


def fl_hide_form(pFlForm):
    """Hides the form.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form to be hidden

    :note: e.g. fl_hide_form(pform0)

    :status: Tested + Doc + Demo = OK

    """
    _fl_hide_form = libr.cfuncproto(
        libr.load_so_libforms(), "fl_hide_form",
        None, [cty.POINTER(xfdata.FL_FORM)], \
        """void fl_hide_form(FL_FORM * form) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    _fl_hide_form(pFlForm)


def fl_free_form(pFlForm):
    """Frees the memory used by a form, hiding and deleting it together
    with all its objects.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form to be freed

    :note: e.g. fl_free_form(pform0)

    :status: Tested + Doc + Demo = OK

    """
    _fl_free_form = libr.cfuncproto(
        libr.load_so_libforms(), "fl_free_form",
        None, [cty.POINTER(xfdata.FL_FORM)], \
        """void fl_free_form(FL_FORM * form) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    _fl_free_form(pFlForm)


def fl_redraw_form(pFlForm):
    """(Re)draws an entire form.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form to redraw

    :note: e.g. fl_redraw_form(pform0)

    :status: Tested + Doc + Demo = OK

    """
    _fl_redraw_form = libr.cfuncproto(
        libr.load_so_libforms(), "fl_redraw_form",
        None, [cty.POINTER(xfdata.FL_FORM)], \
        """void fl_redraw_form(FL_FORM * form) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    _fl_redraw_form(pFlForm)


def fl_set_form_dblbuffer(pFlForm, yesno):
    """Uses double buffering on a per-form basis. Since Xlib doesn't support
    double buffering, XForms library simulates this functionality with pixmap
    bit-bliting. In practice, the effect is hardly distinguishable from double
    buffering and performance is on par with multi-buffering extensions (it is
    slower than drawing into a window directly on most workstations however).
    Bear in mind that a pixmap can be resource hungry, so use this option with
    discretion.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form to set
      `yesno` : int
        flag to disable/enable doublebuffer. Values 0 (disabled) or 1 (enabled)

    :note: e.g. fl_set_form_dblbuffer(1)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_form_dblbuffer = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_form_dblbuffer", \
        None, [cty.POINTER(xfdata.FL_FORM), cty.c_int], \
        """void fl_set_form_dblbuffer(FL_FORM * form, int y) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    iyesno = libr.convert_to_int(yesno)
    libr.keep_elem_refs(pFlForm, yesno, iyesno)
    _fl_set_form_dblbuffer(pFlForm, iyesno)


def fl_prepare_form_window(pFlForm, place, border, title):
    """Creates a window that obeys any and all constraints just as
    fl_show_form() does but remains unmapped (not shown), returning its
    window handle. You need fl_show_form_window() after to show it.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form to display
      `place` : int
        where has to be placed. Values (from xfdata.py) FL_PLACE_FREE,
        FL_PLACE_MOUSE, FL_PLACE_CENTER, FL_PLACE_POSITION, FL_PLACE_SIZE,
        FL_PLACE_GEOMETRY, FL_PLACE_ASPECT, FL_PLACE_FULLSCREEN,
        FL_PLACE_HOTSPOT, FL_PLACE_ICONIC, FL_FREE_SIZE, FL_PLACE_FREE_CENTER,
        FL_PLACE_CENTERFREE, FL_PLACE_MOUSE|FL_FREE_SIZE,
        FL_PLACE_FULLSCREEN|FL_FREE_SIZE, FL_PLACE_HOTSPOT|FL_FREE_SIZE
      `border` : int
        window manager decoration. Values (from xfdata.py) FL_FULLBORDER,
        FL_TRANSIENT, FL_NOBORDER
      `title` : str
       text title of form

    :return: window id (win)
    :rtype: long_pos

    :note: e.g. wind = fl_prepare_form_window(pform2, FL_PLACE_FREE,
        FL_FULLBORDER, "MyForm")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_prepare_form_window = libr.cfuncproto(
        libr.load_so_libforms(), "fl_prepare_form_window", \
        xfdata.Window, [cty.POINTER(xfdata.FL_FORM), cty.c_int, cty.c_int,
        xfdata.STRING], \
        """Window fl_prepare_form_window(FL_FORM * form, int place,
           int border, const char * name) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.check_admitted_value_in_list(place, xfdata.PLACE_list)
    libr.check_admitted_value_in_list(border, xfdata.DECORATION_list)
    iplace = libr.convert_to_int(place)
    iborder = libr.convert_to_int(border)
    stitle = libr.convert_to_string(title)
    libr.keep_elem_refs(pFlForm, place, iplace, border, iborder, title, stitle)
    retval = _fl_prepare_form_window(pFlForm, iplace, iborder, stitle)
    return retval


def fl_show_form_window(pFlForm):
    """Maps (shows) a window of form that has been created before with
    fl_prepare_form_window().

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form whose window has to be shown

    :return: window id (win)
    :rtype: long_pos

    :note: e.g. win1 = fl_show_form_window(pform2)

    :status: Tested + Doc + Demo = OK

    """
    _fl_show_form_window = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_form_window", \
        xfdata.Window, [cty.POINTER(xfdata.FL_FORM)], \
        """Window fl_show_form_window(FL_FORM * form) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    retval = _fl_show_form_window(pFlForm)
    return retval


def fl_adjust_form_size(pFlForm):
    """Similar to fl_fit_object_label, but will do it for all objects and
    has a smaller threshold. Mainly intended for compensation for font size
    variations.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form whose size has to be adjusted

    :return: max factor id
    :rtype: float

    :note: e.g. mfactor = fl_adjust_form_size(pform)

    :status: Tested + Doc + Demo = OK

    """
    _fl_adjust_form_size = libr.cfuncproto(
        libr.load_so_libforms(), "fl_adjust_form_size", \
        cty.c_double, [cty.POINTER(xfdata.FL_FORM)], \
        """double fl_adjust_form_size(FL_FORM * form) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    retval = _fl_adjust_form_size(pFlForm)
    return retval


def fl_form_is_visible(pFlForm):
    """Returns if form is visible or not.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form to evaluate

    :return: visibility state (0 invisible, non-zero visible)
    :rtype: int

    :note: e.g. visib = fl_form_is_visible(pform)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_form_is_visible = libr.cfuncproto(
        libr.load_so_libforms(), "fl_form_is_visible", \
        cty.c_int, [cty.POINTER(xfdata.FL_FORM)], \
        """int fl_form_is_visible(FL_FORM * form) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    retval = _fl_form_is_visible(pFlForm)
    return retval


def fl_form_is_iconified(pFlForm):
    """Returns if a form's window is in iconified state or not.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form to evaluate

    :return: iconic state (0 not iconified, non-zero iconified)
    :rtype: int

    :note: e.g. iconif = fl_form_is_iconified(pform)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_form_is_iconified = libr.cfuncproto(
        libr.load_so_libforms(), "fl_form_is_iconified", \
        cty.c_int, [cty.POINTER(xfdata.FL_FORM)], \
        """int fl_form_is_iconified(FL_FORM * form) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    retval = _fl_form_is_iconified(pFlForm)
    return retval


def fl_register_raw_callback(pFlForm, mask, py_RawCallback):
    """Registers preemptive event handlers. Only one handler is allowed
    for each event pair.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form
      `mask` : long_pos
        key/button/window event mask (press, release, motion, enter, leave
        etc..). Values (from xfdata.py) i.e. KeyPressMask and KeyReleaseMask,
        ButtonPressMask and ButtonReleaseMask, EnterWindowMask and
        LeaveWindowMask, ButtonMotionMask and PointerMotionMask, FL_ALL_EVENT
      `py_RawCallback` : python callback function, with return value
        name referring to function(pFlForm, pXEvent) -> num

    :return: old xfdata.FL_RAW_CALLBACK function

    :note: e.g. def rawcb(pform, xev): > ... ; return 0
    :note: e.g. oldrawcb = fl_register_callback(pform3, xfdata.KeyPressMask,
        rawcb)

    :status: Tested + Doc + Demo = OK

    """
    #FL_RAW_CALLBACK = cty.CFUNCTYPE(cty.c_int, cty.POINTER(xfdata.FL_FORM), \
    #                                 cty.POINTER(xfdata.XEvent))
    _fl_register_raw_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_register_raw_callback", \
        xfdata.FL_RAW_CALLBACK, [cty.POINTER(xfdata.FL_FORM), cty.c_ulong,
        xfdata.FL_RAW_CALLBACK], \
        """FL_RAW_CALLBACK fl_register_raw_callback(FL_FORM * form,
           long unsigned int mask, FL_RAW_CALLBACK rcb) """)
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    ulmask = libr.convert_to_ulong(mask)
    c_RawCallback = xfdata.FL_RAW_CALLBACK(py_RawCallback)
    libr.keep_cfunc_refs(c_RawCallback, py_RawCallback)
    libr.keep_elem_refs(pFlForm, mask, ulmask)
    retval = _fl_register_raw_callback(pFlForm, ulmask, c_RawCallback)
    return retval


fl_register_call_back = fl_register_raw_callback


def fl_bgn_group():
    """Starts a group of objects definition. It purpose can be e.g. to define
    a series of objects to be hidden or deactivated or to define a series of
    radio buttons.

    --

    :return: group started (pFlObject)
    :rtype: pointer to xfdata.FL_OBJECT

    :note: e.g. group0 = fl_bgn_group()

    :status: Tested + Doc + Demo = OK

    """
    _fl_bgn_group = libr.cfuncproto(
        libr.load_so_libforms(), "fl_bgn_group", \
        cty.POINTER(xfdata.FL_OBJECT), [], \
        """FL_OBJECT * fl_bgn_group() """)
    libr.check_if_initialized()
    retval = _fl_bgn_group()
    return retval


def fl_end_group():
    """Ends a group definition.

    --

    :note: e.g. fl_end_group()

    :status: Tested + Doc + Demo = OK

    """
    _fl_end_group = libr.cfuncproto(
        libr.load_so_libforms(), "fl_end_group", \
        None, [], \
        """void fl_end_group() """)
    libr.check_if_initialized()
    _fl_end_group()


def fl_addto_group(pFlObject):
    """Reopens a group (after fl_end_group) to allow addition of further
    objects.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        group object to reopen

    :return: form (pFlForm) or None (on failure)
    :rtype: pointer to xfdata.FL_FORM

    :note: e.g. group1 = fl_addto_group(closedgroup)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_addto_group = libr.cfuncproto(
        libr.load_so_libforms(), "fl_addto_group", \
        cty.POINTER(xfdata.FL_OBJECT), [cty.POINTER(xfdata.FL_OBJECT)], \
        """FL_OBJECT * fl_addto_group(FL_OBJECT * group) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_addto_group(pFlObject)
    return retval


# Routines that deal with FL_OBJECTS

def fl_get_object_objclass(pFlObject):
    """Return the object class of an object. (e.g. button, lightbutton, box,
    nmenu, counter, etc.)

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to evaluate

    :return: objclass id, or -1 (on failure)
    :rtype: int

    :note: e.g. obcls = fl_get_object_objclass(pobj)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_object_objclass = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_objclass", \
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)], \
        """int fl_get_object_objclass(FL_OBJECT * obj) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_object_objclass(pFlObject)
    return retval


def fl_get_object_type(pFlObject):
    """Return the type of an object (e.g. radio button, multiline input,
    normal browser, etc..).

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to evaluate

    :return: type id, or -1 (on failure)
    :rtype: int

    :note: e.g. obtype = fl_get_object_type(pobj)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_object_type = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_type", \
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)], \
        """int fl_get_object_type(FL_OBJECT * obj) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_object_type(pFlObject)
    return retval


def fl_set_object_boxtype(pFlObject, boxtype):
    """Sets the shape of box of an object. Not all possible boxtypes are
    suitable for all types of objects.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object whose boxtype has to be set
      `boxtype` : int
        type of the box to be set. Values (from xfdata.py) FL_NO_BOX,
        FL_UP_BOX, FL_DOWN_BOX, FL_BORDER_BOX, FL_SHADOW_BOX, FL_FRAME_BOX,
        FL_ROUNDED_BOX, FL_EMBOSSED_BOX, FL_FLAT_BOX, FL_RFLAT_BOX,
        FL_RSHADOW_BOX, FL_OVAL_BOX, FL_ROUNDED3D_UPBOX, FL_ROUNDED3D_DOWNBOX,
        FL_OVAL3D_UPBOX, FL_OVAL3D_DOWNBOX, FL_OVAL3D_FRAMEBOX,
        FL_OVAL3D_EMBOSSEDBOX

    :note: e.g. fl_set_object_boxtype(ptextobj, xfdata.FL_BORDER_BOX)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_object_boxtype = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_boxtype", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int], \
        """void fl_set_object_boxtype(FL_OBJECT * ob, int boxtype) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.check_admitted_value_in_list(boxtype, xfdata.BOXTYPE_list)
    iboxtype = libr.convert_to_int(boxtype)
    libr.keep_elem_refs(pFlObject, boxtype, iboxtype)
    _fl_set_object_boxtype(pFlObject, iboxtype)


def fl_get_object_boxtype(pFlObject):
    """Returns the current boxtype of an object (e.g. no box, up box,
    shadow box, etc..).

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to evaluate

    :return:  boxtype id or -1 (on failure)
    :rtype: int

    :note: e.g. boxtp = fl_get_object_boxtype(ptextobj)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_object_boxtype = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_boxtype", \
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)], \
        """int fl_get_object_boxtype(FL_OBJECT * obj) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_object_boxtype(pFlObject)
    return retval


def fl_set_object_bw(pFlObject, bw):
    """Sets the borderwidth of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object
      `bw` : int
        borderwidth of object to be set. If it's 0, -1 is used, if it's a
        negative number, all objects appear to have a softer appearance.

    :note: e.g. fl_set_object_bw(pobj, 2)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_object_bw = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_bw", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int], \
        """void fl_set_object_bw(FL_OBJECT * ob, int bw) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ibw = libr.convert_to_int(bw)
    libr.keep_elem_refs(pFlObject, bw, ibw)
    _fl_set_object_bw(pFlObject, ibw)


def fl_get_object_bw(pFlObject):
    """Returns the borderwidth of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to evaluate

    :return: borderwidth (bw)
    :rtype: int

    :note: e.g. currbw = fl_get_object_bw(pobj)

    :attention: API change from XForms - upstream was
        fl_get_object_bw(pFlObject, bw)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_object_bw = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_bw", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(cty.c_int)], \
        """void fl_get_object_bw(FL_OBJECT * ob, int * bw) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    bw, pbw = libr.make_int_and_pointer()
    libr.keep_elem_refs(pFlObject, bw, pbw)
    _fl_get_object_bw(pFlObject, pbw)
    return bw.value


def fl_set_object_resize(pFlObject, what):
    """Sets the resize property of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to set
      `what` : int_pos
        resize property. Values (from xfdata.py) FL_RESIZE_NONE,
        FL_RESIZE_X, FL_RESIZE_Y, FL_RESIZE_ALL

    :note: e.g. fl_set_object_resize(pobj, xfdata.FL_RESIZE_ALL)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_object_resize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_resize", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_uint], \
        """void fl_set_object_resize(FL_OBJECT * ob, unsigned int what) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.check_admitted_value_in_list(what, xfdata.RESIZE_list)
    uiwhat = libr.convert_to_uint(what)
    libr.keep_elem_refs(pFlObject, what, uiwhat)
    _fl_set_object_resize(pFlObject, uiwhat)


def fl_get_object_resize(pFlObject):
    """Returns the resize property of an object (e.g. resize all, resize
    none, etc..).

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to evaluate

    :return: resize property
    :rtype: int_pos

    :attention: API change from XForms - upstream was
        fl_get_object_resize(pFlObject, what)

    :note: e.g. reszprop = fl_get_object_resize(pobj)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_object_resize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_resize", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(cty.c_uint)], \
        """void fl_get_object_resize(FL_OBJECT * ob,
           unsigned int * what) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    what, pwhat = libr.make_uint_and_pointer()
    libr.keep_elem_refs(pFlObject, what, pwhat)
    _fl_get_object_resize(pFlObject, pwhat)
    return what.value


def fl_set_object_gravity(pFlObject, nw, se):
    """Sets the gravity properties of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to be set
      `nw` : int_pos
        gravity property for NorthWest. Values (from xfdata.py)
        FL_North, FL_NorthEast, FL_NorthWest, FL_South, FL_SouthEast,
        FL_SouthWest, FL_East, FL_West, FL_NoGravity, FL_ForgetGravity
      `se` : int_pos
        gravity property for SouthEast. Values (from xfdata.py)
        FL_North, FL_NorthEast, FL_NorthWest, FL_South, FL_SouthEast,
        FL_SouthWest, FL_East, FL_West, FL_NoGravity, FL_ForgetGravity

    :note: e.g. fl_set_object_gravity(pobj, xfdata.FL_North, xfdata.FL_East)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_object_gravity = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_gravity", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_uint, cty.c_uint], \
        """void fl_set_object_gravity(FL_OBJECT * ob, unsigned int nw,
           unsigned int se) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.check_admitted_value_in_list(nw, xfdata.GRAVITY_list)
    libr.check_admitted_value_in_list(se, xfdata.GRAVITY_list)
    uinw = libr.convert_to_uint(nw)
    uise = libr.convert_to_uint(se)
    libr.keep_elem_refs(pFlObject, nw, uinw, se, uise)
    _fl_set_object_gravity(pFlObject, uinw, uise)


def fl_get_object_gravity(pFlObject):
    """Returns the NorthWest and SouthEast gravity properties of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to set

    :return: NorthWest gravity, SouthEast gravity
    :rtype: int_pos, int_pos

    :note: e.g. nowe, soea = fl_get_object_gravity(pobj)

    :attention: API change from XForms - upstream was
        fl_get_object_gravity(pFlObject, nw, se)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_object_gravity = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_gravity", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(cty.c_uint),
        cty.POINTER(cty.c_uint)], \
        """void fl_get_object_gravity(FL_OBJECT * ob,
           unsigned int * nw, unsigned int * se) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    nw, pnw = libr.make_uint_and_pointer()
    se, pse = libr.make_uint_and_pointer()
    libr.keep_elem_refs(pFlObject, nw, se, pnw, pse)
    _fl_get_object_gravity(pFlObject, pnw, pse)
    return nw.value, se.value


def fl_set_object_lsize(pFlObject, size):
    """Sets the label size of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to be set
      `size` : int
        label size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE

    :note: e.g. fl_set_object_lsize(pobj, xfdata.FL_MEDIUM_SIZE)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_object_lsize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_lsize", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int], \
        """void fl_set_object_lsize(FL_OBJECT * ob, int lsize) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    isize = libr.convert_to_int(size)
    libr.keep_elem_refs(pFlObject, size, isize)
    _fl_set_object_lsize(pFlObject, isize)


def fl_get_object_lsize(pFlObject):
    """Returns the label size of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to evaluate

    :return: label size
    :rtype: int

    :note: e.g. lsize = fl_get_object_lsize(pobj)

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_object_lsize = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_lsize", \
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)], \
        """int fl_get_object_lsize(FL_OBJECT * obj) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_object_lsize(pFlObject)
    return retval


def fl_set_object_lstyle(pFlObject, style):
    """Sets the label style of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to be set
      `style` : int
        label style. Values (from xfdata.py) FL_NORMAL_STYLE,
        FL_BOLD_STYLE, FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE

    :note: e.g. fl_set_object_lstyle(pobj, xfdata.FL_TIMESITALIC_STYLE)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_object_lstyle = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_lstyle", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int], \
        """void fl_set_object_lstyle(FL_OBJECT * ob, int lstyle) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    istyle = libr.convert_to_int(style)
    libr.keep_elem_refs(pFlObject, style, istyle)
    _fl_set_object_lstyle(pFlObject, istyle)


def fl_get_object_lstyle(pFlObject):
    """Returns the label style of an object (e.g. xfdata.FL_BOLD_STYLE,
    xfdata.FL_NORMAL_STYLE, etc..).

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to evaluate

    :return: label style
    :rtype: int

    :note: e.g. lstyle = fl_get_object_lstyle(pobj)

    :status: Tested + NoDoc + Demo = OK

    """
    _fl_get_object_lstyle = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_lstyle", \
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)], \
        """int fl_get_object_lstyle(FL_OBJECT * obj) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_object_lstyle(pFlObject)
    return retval


def fl_set_object_lcol(pFlObject, colr):
    """Sets the label color of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to be set
      `colr` : long_pos
        label color. Values (from xfdata.py) one of defined colors
        FL_BLACK, ... FL_BLUE, ... FL_GREEN, ... FL_RED, ... etc..

    :note: e.g. fl_set_object_lcol(pobj, xfdata.FL_BLUE)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_object_lcol = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_lcol", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_COLOR], \
        """void fl_set_object_lcol(FL_OBJECT * ob, FL_COLOR lcol) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(pFlObject, colr, ulcolr)
    _fl_set_object_lcol(pFlObject, ulcolr)


fl_set_object_lcolor = fl_set_object_lcol


def fl_get_object_lcol(pFlObject):
    """Returns the label color of an object (from xfdata, e.g. FL_WHITE,
    FL_LIME, etc..).

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to evaluate

    :return:  color value
    :rtype: long_pos

    :note: e.g. obcolor = fl_get_object_lcol(pobj)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_object_lcol = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_lcol", \
        xfdata.FL_COLOR, [cty.POINTER(xfdata.FL_OBJECT)], \
        """FL_COLOR fl_set_object_lcol(FL_OBJECT * obj) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_object_lcol(pFlObject)
    return retval


def fl_set_object_return(pFlObject, when):
    """Sets the conditions under which an object gets returned (or its callback
    invoked). If the object has to do additional work on setting te condition
    (e.g. it has child objects that also need to be set) it has to set up it's
    own function that then will called in the end. This should only be called
    once an object has been created completely! Not all return types make
    sense for all objects.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object
      `when` : int_pos
        return type (when it returns). Values (from xfdata.py)
        FL_RETURN_NONE, FL_RETURN_CHANGED, FL_RETURN_END,
        FL_RETURN_END_CHANGED, FL_RETURN_SELECTION, FL_RETURN_DESELECTION,
        FL_RETURN_TRIGGERED, FL_RETURN_ALWAYS

    :return: old return type id
    :rtype: int

    :note: e.g. fl_set_object_return(pobj, xfdata.FL_RETURN_CHANGED)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_object_return = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_return", \
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT), cty.c_uint], \
        """int fl_set_object_return(FL_OBJECT * ob, unsigned int when) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.check_admitted_value_in_list(when, xfdata.RETURN_list)
    uiwhen = libr.convert_to_uint(when)
    libr.keep_elem_refs(pFlObject, when, uiwhen)
    retval = _fl_set_object_return(pFlObject, uiwhen)
    return retval


# TODO: verify what its purpose is.
def fl_notify_object(pFlObject, cause):
    """*todo*

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object
      `cause` : int
        cause for notification. Values (from xfdata.py) FL_ATTRIB,
        FL_RESIZED, FL_MOVEORIGIN

    :note: e.g. fl_notify_object(pobj5, xfdata.FL_RESIZED)

    :status: Tested + NoDoc + NoDemo = NOT OK (not clear purpose)

    """
    _fl_notify_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_notify_object", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int], \
        """void fl_notify_object(FL_OBJECT * obj, int cause) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.check_admitted_value_in_list(cause, xfdata.EVENTS_list)
    icause = libr.convert_to_int(cause)
    libr.keep_elem_refs(pFlObject, cause, icause)
    _fl_notify_object(pFlObject, icause)


def fl_set_object_lalign(pFlObject, align):
    """Sets alignment of an object's label.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to be set
      `align` : int
        alignment of label. Values (from xfdata.py) FL_ALIGN_CENTER,
        FL_ALIGN_TOP, FL_ALIGN_BOTTOM, FL_ALIGN_LEFT, FL_ALIGN_RIGHT,
        FL_ALIGN_LEFT_TOP, FL_ALIGN_RIGHT_TOP, FL_ALIGN_LEFT_BOTTOM,
        FL_ALIGN_RIGHT_BOTTOM, FL_ALIGN_INSIDE, FL_ALIGN_VERT.
        Bitwise OR with FL_ALIGN_INSIDE is allowed.

    :note: e.g. fl_set_object_lalign(pobj8, xfdata.FL_ALIGN_RIGHT)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_object_lalign = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_lalign", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int], \
        """void fl_set_object_lalign(FL_OBJECT * ob, int align) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.check_admitted_value_in_list(align, xfdata.ALIGN_list)
    ialign = libr.convert_to_int(align)
    libr.keep_elem_refs(pFlObject, align, ialign)
    _fl_set_object_lalign(pFlObject, ialign)


def fl_get_object_lalign(pFlObject):
    """Returns alignment of an object's label (from xfdata, e.g.
    FL_ALIGN_LEFT, FL_ALIGN_RIGHT_TOP, etc..).

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to be set

    :return: align num.
    :rtype: int

    :note: e.g. obalign = fl_get_object_lalign(pobj8)

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_object_lalign = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_lalign", \
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)], \
        """int fl_set_object_lalign(FL_OBJECT * ob) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_object_lalign(pFlObject)
    return retval


fl_set_object_align = fl_set_object_lalign


def fl_set_object_shortcut(pFlObject, shctxt, showit):
    """Sets a shortcut, binding a key or a series of keys to an object. It
    resets any previous defined shortcuts for the object. Using e.g. "acE#d^h"
    the keys 'a', 'c', 'E', <Alt>d and <Ctrl>h are associated with the object.
    The precise format is as follows: any character in the string is considered
    as a shortcut, except '^' and '#', which stand for combinations with the
    <Ctrl> and <Alt> keys; the case of the key following '#' or '^' is not
    important, i.e. no distinction is made between e.g. "^C" and "^c", both
    encode the key combination <Ctrl>C as well as <Ctrl>C.) The key '^' itself
    can be set as a shortcut key by using "^^" in the string defining the
    shortcut. The key '#' can be obtained as a shortcut by using the string
    "^#". So, e.g. "#^#" encodes <ALT>#. The <Esc> key can be given as "^[".
    Another special character not mentioned yet is '&', which indicates
    function and arrow keys. Use a sequence starting with '&' and directly
    followed by a number between 1 and 35 to represent one of the function
    keys. For example, "&2" stands for the <F2> function key. The four cursors
    keys (up, down, right, and left) can be given as "&A", "&B", "&C" and "&D",
    respectively. The key '&' itself can be obtained as a shortcut by
    prefixing it with '^'.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object
      `shctxt` : str
        shortcut text to be set
      `showit` : int
        flag if shortcut letter has to be underlined or not if a match exists
        (only the 1st alphanumeric character is used). Values 0 (underline not
        shown) or 1 (shown)

    :note: e.g. fl_set_object_shortcut(pobj6, "aA#A^A", 1)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_object_shortcut = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_shortcut", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.STRING, cty.c_int], \
        """void fl_set_object_shortcut(FL_OBJECT * obj,
           const char * sstr, int showit) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    sshctxt = libr.convert_to_string(shctxt)
    ishowit = libr.convert_to_int(showit)
    libr.keep_elem_refs(pFlObject, shctxt, sshctxt, showit, ishowit)
    _fl_set_object_shortcut(pFlObject, sshctxt, ishowit)


def fl_set_object_shortcutkey(pFlObject, keysym):
    """Uses a special key as a shortcut. It always appends the specified key
    to the current shortcuts. Special keys can't be underlined.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object
      `keysym` : int_pos
        X key symbolic num. See xfdata.py for a (maybe) incomplete list

    :note: e.g. fl_set_object_shortcutkey(pobj, xfdata.XK_Home)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_object_shortcutkey = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_shortcutkey",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_uint], \
        """void fl_set_object_shortcutkey(FL_OBJECT * obj,
           unsigned int keysym) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    uikeysym = libr.convert_to_uint(keysym)
    libr.keep_elem_refs(pFlObject, keysym, uikeysym)
    _fl_set_object_shortcutkey(pFlObject, uikeysym)


def fl_set_object_dblbuffer(pFlObject, yesno):
    """ Uses double buffering on a per-object basis. Currently double buffering
    for objects having a non-rectangular box might not work well. A
    nonrectangular box means that there are regions within the bounding box
    that should not be painted, which is not easily done without complex and
    expensive clipping and unacceptable inefficiency. Since Xlib doesn't
    support double buffering, XForms library simulates this functionality with
    pixmap bit-bliting. In practice, the effect is hardly distinguishable from
    double buffering and performance is on par with multi-buffering extensions
    (it is slower than drawing into a window directly on most workstations
    however). Bear in mind that a pixmap can be resource hungry, so use this
    option with discretion.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object
      `yesno` : int
        flag to disable/enable double buffer. Values 0 (disabled) or 1
        (enabled)

    :note: e.g. fl_set_object_dblbuffer(pobj7, 1)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_object_dblbuffer = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_dblbuffer", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int], \
        """void fl_set_object_dblbuffer(FL_OBJECT * ob, int y) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    iyesno = libr.convert_to_int(yesno)
    libr.keep_elem_refs(pFlObject, yesno, iyesno)
    _fl_set_object_dblbuffer(pFlObject, iyesno)


def fl_set_object_color(pFlObject, fgcolr, bgcolr):
    """Sets the color of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object
      `fgcolr` : long_pos
        foreground color value
      `bgcolr` : long_pos
        background color value

    :note: e.g. fl_set_object_color(pbutob7, xfdata.FL_AQUA, xfdata.FL_WHEAT)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_object_color = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_color", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_COLOR,
        xfdata.FL_COLOR],
        """void fl_set_object_color(FL_OBJECT * ob, FL_COLOR col1,
           FL_COLOR col2) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.check_admitted_value_in_list(fgcolr, xfdata.COLOR_list)
    libr.check_admitted_value_in_list(bgcolr, xfdata.COLOR_list)
    ulfgcolr = libr.convert_to_FL_COLOR(fgcolr)
    ulbgcolr = libr.convert_to_FL_COLOR(bgcolr)
    libr.keep_elem_refs(pFlObject, fgcolr, ulfgcolr, bgcolr, ulbgcolr)
    _fl_set_object_color(pFlObject, ulfgcolr, ulbgcolr)


def fl_get_object_color(pFlObject):
    """Returns the foreground and background colors of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object

    :return: foreground color value (colr), background color value (colr)
    :rtype: long_pos, long_pos

    :note: e.g. primcol, secncol = fl_get_object_color(pobj)

    :attention: API change from XForms - upstream was
        fl_set_object_color(pFlObject, fgcolr, bgcolr)

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_object_color = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_color", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(xfdata.FL_COLOR), \
        cty.POINTER(xfdata.FL_COLOR)], \
        """void fl_get_object_color(FL_OBJECT * ob, FL_COLOR * col1,
           FL_COLOR * col2)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    fgcolr, pfgcolr = libr.make_FL_COLOR_and_pointer()
    bgcolr, pbgcolr = libr.make_FL_COLOR_and_pointer()
    libr.keep_elem_refs(pFlObject, fgcolr, pfgcolr, bgcolr, pbgcolr)
    _fl_get_object_color(pFlObject, pfgcolr, pbgcolr)
    return fgcolr.value, bgcolr.value


def fl_set_object_label(pFlObject, label):
    """Sets the label of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object
      `label` : str
        text label of object

    :note: e.g. fl_set_object_label(pobj, "My New Label")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_object_label = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_label", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.STRING], \
        """void fl_set_object_label(FL_OBJECT * ob, const char * label) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    slabel = libr.convert_to_string(label)
    libr.keep_elem_refs(pFlObject, label, slabel)
    _fl_set_object_label(pFlObject, slabel)


def fl_get_object_label(pFlObject):
    """Returns the label of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object

    :return: text of label
    :rtype: str

    :note: e.g. currlbl = fl_get_object_label(pobj)

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_object_label = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_label", \
        xfdata.STRING, [cty.POINTER(xfdata.FL_OBJECT)], \
        """const char * fl_set_object_label(FL_OBJECT * obj) """)
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_object_label(pFlObject)
    return retval


def fl_set_object_helper(pFlObject, tip):
    """Sets the tooltip of an object (with possible embedded newlines in it)
    that will be shown when the mouse hovers over the object for more than
    about 600 msec.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object
      `tip` : str
        tooltip text for object

    :note: e.g. fl_set_object_helper(pobj, "Button to exit the procedure.")

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_object_helper = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_helper", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.STRING], \
        """void fl_set_object_helper(FL_OBJECT * ob, const char * tip)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    stip = libr.convert_to_string(tip)
    libr.keep_elem_refs(pFlObject, tip, stip)
    _fl_set_object_helper(pFlObject, stip)


def fl_set_object_position(pFlObject, x, y):
    """Sets position of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)

    :note: e.g. fl_set_object_position(pobj, 235, 123)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_object_position = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_position", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_Coord,
        xfdata.FL_Coord], \
        """void fl_set_object_position(FL_OBJECT * obj, FL_Coord x,
           FL_Coord y)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    libr.keep_elem_refs(pFlObject, x, ix, y, iy)
    _fl_set_object_position(pFlObject, ix, iy)


def fl_get_object_size(pFlObject):
    """Returns the size of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to evaluate

    :return: width (w) and height (h) in coord units
    :rtype: int, int

    :note: e.g. wid, hei = fl_get_object_size(pobj)

    :attention: API change from XForms - upstream was
        fl_get_object_size(pFlObject, w, h)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_object_size = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_size", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord)], \
        """void fl_get_object_size(FL_OBJECT * obj, FL_Coord * w,
           FL_Coord * h)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    w, pw = libr.make_FL_Coord_and_pointer()
    h, ph = libr.make_FL_Coord_and_pointer()
    libr.keep_elem_refs(pFlObject, w, h, pw, ph)
    _fl_get_object_size(pFlObject, pw, ph)
    return w.value, h.value


def fl_set_object_size(pFlObject, w, h):
    """Sets the size of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object
      `w` : int
        width of object in coord units
      `h` : int
        height of object in coord units

    :note: e.g. fl_set_object_size(pobj, 90, 35)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_object_size = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_size", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_Coord,
        xfdata.FL_Coord], \
        """void fl_set_object_size(FL_OBJECT * obj, FL_Coord w,
           FL_Coord h)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    libr.keep_elem_refs(pFlObject, w, iw, h, ih)
    _fl_set_object_size(pFlObject, iw, ih)


def fl_set_object_automatic(pFlObject, yesno):
    """Enables or disables an object to receive a xfdata.FL_STEP event. This
    should not be used with built-in objects. An object is automatic if it
    automatically (without user actions) has to change its contents. Automatic
    objects get a FL_STEP event about every 50 msec.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object
      `yesno` : int
        flag if automatic or not. Values 0 (not automatic) or 1 (automatic)

    :note: e.g. fl_set_object_automatic(pMyobj, 1)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_object_automatic = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_automatic",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int], \
        """void fl_set_object_automatic(FL_OBJECT * ob, int flag)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    iyesno = libr.convert_to_int(yesno)
    libr.keep_elem_refs(pFlObject, yesno, iyesno)
    _fl_set_object_automatic(pFlObject, iyesno)


def fl_object_is_automatic(pFlObject):
    """Returns if an object receives xfdata.FL_STEP events. An object is
    automatic if it automatically (without user actions) has to change its
    contents. Automatic objects get a xfdata.FL_STEP event about every 50 msec.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to evaluate

    :return: flag if it's automatic (1) or not (0)
    :rtype: int

    :note: e.g. if fl_object_is_automatic(pMyobj): > ...

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_object_is_automatic = libr.cfuncproto(
        libr.load_so_libforms(), "fl_object_is_automatic",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)], \
        """int fl_object_is_automatic(FL_OBJECT * obj)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_object_is_automatic(pFlObject)
    return retval


def fl_draw_object_label(pFlObject):
    """Draws the label according to the alignment, which could be inside
    or outside of the bounding box.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object

    :note: e.g. fl_draw_object_label(pobj3)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_draw_object_label = libr.cfuncproto(
        libr.load_so_libforms(), "fl_draw_object_label", \
        None, [cty.POINTER(xfdata.FL_OBJECT)], \
        """void fl_draw_object_label(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    _fl_draw_object_label(pFlObject)


def fl_draw_object_label_outside(pFlObject):
    """Draws the label outside of the bounding box.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object

    :note: e.g. fl_draw_object_label_outside(pobj3)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_draw_object_label_outside = libr.cfuncproto(
        libr.load_so_libforms(), "fl_draw_object_label_outside",
        None, [cty.POINTER(xfdata.FL_OBJECT)], \
        """void fl_draw_object_label_outside(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    _fl_draw_object_label_outside(pFlObject)


fl_draw_object_outside_label = fl_draw_object_label_outside


def fl_get_object_component(pFlObject, objclass, compontype, seqnum):
    """Returns the object that is a component of a composite object. E.g. the
    scrollbar object is made of a slider and two scroll buttons.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        composite object
      `objclass` : int
        component object's class id
      `compontype` : int
        component object's type id
      `seqnum` : int
        the sequence number of the desired object in case the composite has
        more than one object of the same class and type. -1 to indicate any
        type of specified class

    :return: component object (pFlObject) or None (no object found)
    :rtype: pointer to xfdata.FL_OBJECT

    :note: e.g. fl_get_object_component(browserobj, xfdata.FL_SCROLLBAR,
        xfdata.FL_HOR_THIN_SCROLLBAR, 0)

    :status: Untested + Doc + NoDemo = NOT OK

    """
    _fl_get_object_component = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_component",
        cty.POINTER(xfdata.FL_OBJECT), [cty.POINTER(xfdata.FL_OBJECT),
        cty.c_int, cty.c_int, cty.c_int], \
        """FL_OBJECT * fl_get_object_component(FL_OBJECT * composite,
           int objclass, int type, int numb)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    iobjclass = libr.convert_to_int(objclass)
    icompontype = libr.convert_to_int(compontype)
    iseqnum = libr.convert_to_int(seqnum)
    libr.keep_elem_refs(pFlObject, objclass, iobjclass, compontype, \
                        icompontype, seqnum, iseqnum)
    retval = _fl_get_object_component(pFlObject, iobjclass, icompontype,
                                      iseqnum)
    return retval


def fl_for_all_objects(pFlForm, py_operatecb, vdata):
    """Serves as an iterator to change an attribute for all objects on a
    particular form. Specified operating function is called for every object
    of the form form unless it returns nonzero, which terminates the iterator.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form
      `py_operatecb` : python callback function, returning value
        name referring to function(pFlObject, ptr_void) -> num
      `vdata` : None or long or pointer to xfdata.FL_OBJECT
        user data to be passed to function

    :note: e.g. def operatecb(pobj, vdata): > ... ; return 0
    :note: e.g. fl_for_all_objects(pform5, operatecb, None)

    :status: Untested + Doc + NoDemo = NOT OK

    """
    # cfunc_int_pobject_pvoid = cty.CFUNCTYPE(cty.c_int,
    #                  cty.POINTER(xfdata.FL_OBJECT), cty.c_void_p)
    _fl_for_all_objects = libr.cfuncproto(
        libr.load_so_libforms(), "fl_for_all_objects", \
        None, [cty.POINTER(xfdata.FL_FORM), xfdata.cfunc_int_pobject_pvoid, \
        cty.c_void_p], \
        """void fl_for_all_objects(FL_FORM * form, int ( * cb ) \
           ( FL_OBJECT *, void * ), void * v)""")
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    c_operatecb = xfdata.cfunc_int_pobject_pvoid(py_operatecb)
    if vdata is None:
        pvdata = cty.cast(vdata, cty.c_void_p)
    elif isinstance(vdata, long):
        ldata = libr.convert_to_long(vdata)
        pvdata = cty.cast(ldata, cty.POINTER(cty.c_long))
    else:
        pvdata = vdata          # it is pFlObject
    libr.keep_cfunc_refs(c_operatecb, py_operatecb)
    libr.keep_elem_refs(pFlForm, vdata, pvdata)
    _fl_for_all_objects(pFlForm, c_operatecb, pvdata)


def fl_set_object_dblclick(pFlObject, timeout):
    """Sets double click timeout value of an object, enabling or disabling it
    to receive the xfdata.FL_DBLCLICK event.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object
      `timeout` : long_pos
        maximum time interval (in msec) between two clicks for them to be
        considered a double-click. If it's 0 disables double-click detection.

    :note: e.g. fl_set_object_dblclick(pobj, 750)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_object_dblclick = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_dblclick", \
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_ulong], \
        """void fl_set_object_dblclick(FL_OBJECT *obj, unsigned \
           long timeout)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ultimeout = libr.convert_to_ulong(timeout)
    libr.keep_elem_refs(pFlObject, timeout, ultimeout)
    _fl_set_object_dblclick(pFlObject, ultimeout)


def fl_get_object_dblclick(pFlObject):
    """Return double click timeout value of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to evaluate

    :return: timeout value
    :rtype: long_pos

    :note: e.g. dctim = fl_get_object_dblclick(pobj0)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_object_dblclick = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_dblclick", \
        cty.c_ulong, [cty.POINTER(xfdata.FL_OBJECT)], \
        """unsigned long fl_get_object_dblclick(FL_OBJECT *obj)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_object_dblclick(pFlObject)
    return retval


def fl_set_object_geometry(pFlObject, x, y, w, h):
    """Sets the geometry (position and size) of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to modify
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units

    :note: e.g. fl_set_object_geometry(pobj, 200, 250, 120, 25)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_object_geometry = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_geometry", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord], \
        """void fl_set_object_geometry(FL_OBJECT * obj, FL_Coord x,
        FL_Coord y, FL_Coord w, FL_Coord h)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    libr.keep_elem_refs(pFlObject, x, ix, y, iy, w, iw, h, ih)
    _fl_set_object_geometry(pFlObject, ix, iy, iw, ih)


def fl_move_object(pFlObject, x, y):
    """Moves an object to a new position.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to be moved
      `x` : int
        new horizontal position (upper-left corner)
      `y` : int
        new vertical position (upper-left corner)

    :note: e.g. fl_move_object(pobj0, 120, 380)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_move_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_move_object", \
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_Coord,
        xfdata.FL_Coord], \
        """void fl_move_object(FL_OBJECT * obj, FL_Coord dx,
           FL_Coord dy)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ix = libr.convert_to_int(x)
    iy = libr.convert_to_int(y)
    libr.keep_elem_refs(pFlObject, x, ix, y, iy)
    _fl_move_object(pFlObject, ix, iy)


def fl_fit_object_label(pFlObject, xmargin, ymargin):
    """Checks if the label of an object fits into it (after x- and y-margin
    have been added). If not, all objects and the form are enlarged by the
    necessary factor (but never by more than a factor of 1.5).

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object
      `xmargin` : int
        horizontal margin of label in coord units
      `ymargin` : int
        vertical margin of label in coord units

    :note: e.g. fl_fit_object_label(pobj2, 10, 10)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_fit_object_label = libr.cfuncproto(
        libr.load_so_libforms(), "fl_fit_object_label",\
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_Coord,
        xfdata.FL_Coord],\
        """void fl_fit_object_label(FL_OBJECT * obj, FL_Coord xmargin,
           FL_Coord ymargin)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ixmargin = libr.convert_to_int(xmargin)
    iymargin = libr.convert_to_int(ymargin)
    libr.keep_elem_refs(pFlObject, xmargin, ixmargin, ymargin, iymargin)
    _fl_fit_object_label(pFlObject, ixmargin, iymargin)


def fl_get_object_geometry(pFlObject):
    """Returns the geometry (position and size) of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object

    :return: horizontal (x), vertical position (y), width (w), height (h)
    :rtype: int, int, int, int

    :note: e.g. xpos, ypos, wid, hei = fl_get_object_geometry(pobj1)

    :attention: API change from XForms - upstream was
        fl_get_object_geometry(pFlObject, x, y, w, h)

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_object_geometry = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_geometry",\
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(xfdata.FL_Coord),\
        cty.POINTER(xfdata.FL_Coord), cty.POINTER(xfdata.FL_Coord), \
        cty.POINTER(xfdata.FL_Coord)],
        """void fl_get_object_geometry(FL_OBJECT * ob, FL_Coord * x,
           FL_Coord * y, FL_Coord * w, FL_Coord * h)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    x, px = libr.make_FL_Coord_and_pointer()
    y, py = libr.make_FL_Coord_and_pointer()
    w, pw = libr.make_FL_Coord_and_pointer()
    h, ph = libr.make_FL_Coord_and_pointer()
    libr.keep_elem_refs(pFlObject, x, px, y, py, w, pw, h, ph)
    _fl_get_object_geometry(pFlObject, px, py, pw, ph)
    return x.value, y.value, w.value, h.value


def fl_get_object_position(pFlObject):
    """Returns the position of an object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to evaluate

    :return: horizontal (x) and vertical position (y)
    :rtype: int, int

    :note: e.g. xpos, ypos = fl_get_object_position(pobj2)

    :attention: API change from XForms - upstream was
        fl_get_object_position(pFlObject, x, y)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_object_position = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_position",\
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord)],\
        """void fl_get_object_position(FL_OBJECT * ob, FL_Coord * x,
           FL_Coord * y)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    x, px = libr.make_FL_Coord_and_pointer()
    y, py = libr.make_FL_Coord_and_pointer()
    libr.keep_elem_refs(pFlObject, x, px, y, py)
    _fl_get_object_position(pFlObject, px, py)
    return x.value, y.value


# this one takes into account the label

def fl_get_object_bbox(pFlObject):
    """Returns the bounding box size that has the label, which could be drawn
    outside of the object figured in.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to evaluate

    :return: horizontal (x), vertical position (y), width (w), height (h)
    :rtype: int, int, int, int

    :note: e.g. xpos, ypos, wid, hei = fl_get_object_bbox(pobj4)

    :attention: API change from XForms - upstream was
        fl_get_object_bbox(pFlObject, x, y, w, h)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_object_bbox = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_bbox",\
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(xfdata.FL_Coord),\
        cty.POINTER(xfdata.FL_Coord), cty.POINTER(xfdata.FL_Coord),
        cty.POINTER(xfdata.FL_Coord)],\
        """void fl_get_object_bbox(FL_OBJECT * obj, FL_Coord * x,
           FL_Coord * y, FL_Coord * w, FL_Coord * h)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    x, px = libr.make_FL_Coord_and_pointer()
    y, py = libr.make_FL_Coord_and_pointer()
    w, pw = libr.make_FL_Coord_and_pointer()
    h, ph = libr.make_FL_Coord_and_pointer()
    libr.keep_elem_refs(pFlObject, x, y, w, h, px, py, pw, ph)
    _fl_get_object_bbox(pFlObject, px, py, pw, ph)
    return x.value, y.value, w.value, h.value


fl_compute_object_geometry = fl_get_object_bbox


def fl_call_object_callback(pFlObject):
    """Invokes the callback manually (as opposed to invocation by the main
    loop). If the object does not have a callback associated with it, this
    call has not effect.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object

    :note: e.g. fl_call_object_callback(pobj_with_cb)

    :status: Tested + Doc + Demo = OK

    """
    _fl_call_object_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_call_object_callback",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_call_object_callback(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    _fl_call_object_callback(pFlObject)


def fl_set_object_prehandler(pFlObject, py_HandlerPtr):
    """By-passes the internal event processing for a particular object. The
    pre-handler will be called before the built-in object handler. By electing
    to handle some of the events, a pre-handler can, in effect, replace part
    of the built-in handler.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object
      `py_HandlerPtr` : python callback function, returning value
        name referring to function(pFlObject, num, coord, coord, num,
        ptr_void) -> num

    :return: old xfdata.FL_HANDLEPTR function

    :note: e.g. def prehandlecb(pobj, num, crd, crd, num2, vdata): > ...
    :note: e.g. > return 0
    :note: e.g. fl_set_object_prehandler(pobj2, prehandlecb)

    :status: Tested + Doc + Demo = OK

    """
    #FL_HANDLEPTR = cty.CFUNCTYPE(cty.c_int, cty.POINTER(xfdata.FL_OBJECT),
    #    cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, cty.c_int, cty.c_void_p)
    _fl_set_object_prehandler = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_prehandler",
        xfdata.FL_HANDLEPTR, [cty.POINTER(xfdata.FL_OBJECT),
        xfdata.FL_HANDLEPTR],\
        """FL_HANDLEPTR fl_set_object_prehandler(FL_OBJECT * ob,
           FL_HANDLEPTR phandler)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    c_HandlerPtr = xfdata.FL_HANDLEPTR(py_HandlerPtr)
    libr.keep_cfunc_refs(c_HandlerPtr, py_HandlerPtr)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_set_object_prehandler(pFlObject, c_HandlerPtr)
    return retval


def fl_set_object_posthandler(pFlObject, py_HandlerPtr):
    """By-passes the internal event processing for a particular object. The
    post-handler will be invoked after the built-in handler finishes. Whenever
    possible a post-handler should be used instead of a pre-handler.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object
      `py_HandlerPtr` : python callback function, returning value
        name referring function(pFlObject, num, coord, coord, num,
        ptr_void) -> num

    :return: old xfdata.FL_HANDLEPTR function

    :note: e.g. def posthandlecb(pobj, num, crd, crd, num2, vdata): > ...
    :note: e.g. > return 0
    :note: e.g. fl_set_object_posthandler(pobj2, posthandlecb)

    :status: Tested + Doc + Demo = OK

    """
    #FL_HANDLEPTR = cty.CFUNCTYPE(cty.c_int, cty.POINTER(xfdata.FL_OBJECT),
    #    cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, cty.c_int, cty.c_void_p)
    _fl_set_object_posthandler = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_posthandler",
        xfdata.FL_HANDLEPTR, [cty.POINTER(xfdata.FL_OBJECT),
        xfdata.FL_HANDLEPTR],\
        """FL_HANDLEPTR fl_set_object_posthandler(FL_OBJECT * ob,
           FL_HANDLEPTR post)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    c_HandlerPtr = xfdata.FL_HANDLEPTR(py_HandlerPtr)
    libr.keep_cfunc_refs(c_HandlerPtr, py_HandlerPtr)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_set_object_posthandler(pFlObject, c_HandlerPtr)
    return retval


def fl_set_object_callback(pFlObject, py_CallbackPtr, data):
    """Sets a callback function bound to an object and calls it if a condition
    is met.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object the callback is bound to
      `py_CallbackPtr` : python function to be used as callback, no return
        function with no () and no args referring to fn(pFlObject, longnum)
      `data` : long
        argument being passed to function

    :return: old xfdata.FL_CALLBACKPTR function

    :note: e.g. def myobcb(pobj, longdata): > ...
    :note: e.g. oldcb = fl_set_object_callback(pobj3, myobjcb, 0)

    :status: Tested + Doc + Demo = OK

    """
    #FL_CALLBACKPTR = cty.CFUNCTYPE(None, cty.POINTER(xfdata.FL_OBJECT),
    #                               cty.c_long)
    _fl_set_object_callback = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_object_callback",\
        xfdata.FL_CALLBACKPTR, [cty.POINTER(xfdata.FL_OBJECT),
        xfdata.FL_CALLBACKPTR, cty.c_long],
        """FL_CALLBACKPTR fl_set_object_callback(FL_OBJECT * obj,\
           FL_CALLBACKPTR callback, long int argument)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    ldata = libr.convert_to_long(data)
    c_CallbackPtr = xfdata.FL_CALLBACKPTR(py_CallbackPtr)
    libr.keep_cfunc_refs(c_CallbackPtr, py_CallbackPtr)
    libr.keep_elem_refs(pFlObject, data, ldata)
    retval = _fl_set_object_callback(pFlObject, c_CallbackPtr, ldata)
    return retval


fl_set_call_back = fl_set_object_callback


def fl_redraw_object(pFlObject):
    """Redraws the particular object. If it is a group it redraws the complete
    group. Normally you should never need this routine because all library
    routines take care of redrawing objects when necessary, but there might be
    situations in which an explicit redraw is required.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to redraw

    :note: e.g. fl_redraw_object(pobj)

    :status: Tested + Doc + Demo = OK

    """
    _fl_redraw_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_redraw_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_redraw_object(FL_OBJECT * obj)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    _fl_redraw_object(pFlObject)


def fl_scale_object(pFlObject, xs, ys):
    """Scales (shrinking or enlarging) an object, indicating a scaling factor
    in x- and y-direction (1.1 = 110 percent, 0.5 = 50, etc.)

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to be scaled
      `xs` : float
        new horizontal factor
      `ys` : float
        new vertical factor

    :note: e.g. fl_scale_object(pobj, 0.8, 1.1)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_scale_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_scale_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_double, cty.c_double],\
        """void fl_scale_object(FL_OBJECT * ob, double xs, double ys)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    fxs = libr.convert_to_double(xs)
    fys = libr.convert_to_double(ys)
    libr.keep_elem_refs(pFlObject, xs, fxs, ys, fys)
    _fl_scale_object(pFlObject, fxs, fys)


def fl_show_object(pFlObject):
    """Shows an (hidden) object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to be shown

    :note: e.g. fl_show_object(pobj8)

    :status: Tested + Doc + Demo = OK

    """
    _fl_show_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_show_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_show_object(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    _fl_show_object(pFlObject)


def fl_hide_object(pFlObject):
    """Hides a shown object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to be hidden

    :note: e.g. fl_hide_object(pobj8)

    :status: Tested + Doc + Demo = OK

    """
    _fl_hide_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_hide_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_hide_object(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    _fl_hide_object(pFlObject)


def fl_object_is_visible(pFlObject):
    """Returns if an object is visible or not.

    --

    :Parameters:
     `pFlObject` : pointer to xfdata.FL_OBJECT
       object to evaluate

    :return: flag 0 (invisible) or non-zero (visible)
    :rtype: int

    :note: e.g. if not fl_object_is_visible(pobj2): ...

    :status: Tested + Doc + Demo = OK

    """
    _fl_object_is_visible = libr.cfuncproto(
        libr.load_so_libforms(), "fl_object_is_visible",\
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],\
        """int fl_object_is_visible(FL_OBJECT * obj)""")
    libr.check_if_initialized()
    libr.keep_elem_refs(pFlObject)
    retval = _fl_object_is_visible(pFlObject)
    return retval


def fl_free_object(pFlObject):
    """Frees the object and finally destroys it (if necessary deletes the
    object first).

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to free

    :note: e.g. fl_free_object(pobj)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_free_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_free_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_free_object(FL_OBJECT * obj)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    _fl_free_object(pFlObject)


def fl_delete_object(pFlObject):
    """Deletes an object, breaking its connection to the form, but not
    destroying it.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to delete

    :note: e.g. fl_delete_object(pobj)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_delete_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_delete_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_delete_object(FL_OBJECT * obj)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    _fl_delete_object(pFlObject)


def fl_get_object_return_state(pFlObject):
    """Determines the reason an object was returned (or its callback invoked)
    you. The returned value is logical OR of the conditions that led to the
    object getting returned.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to evaluate

    :return: current return state
    :rtype: int

    :note: e.g. currstate = fl_get_object_return_state(pobj5)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_object_return_state = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_object_return_state",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],\
        """int fl_get_object_return_state(FL_OBJECT * obj)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_object_return_state(pFlObject)
    return retval


def fl_trigger_object(pFlObject):
    """Simulates the action of an object being triggered from within the
    program. Calling this routine on an object obj results in the object
    returned to the application program or its callback being called if it
    exists. Note however, there is no visual feedback, i.e.
    fl_trigger_object(button) will not make the button object named button
    appearing to be pushed.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to trigger

    :note: e.g. fl_trigger_object(pobj

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_trigger_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_trigger_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_trigger_object(FL_OBJECT * obj)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    _fl_trigger_object(pFlObject)


def fl_activate_object(pFlObject):
    """(Re)activates an object, (re)enabling user interaction.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to activate

    :note: e.g. fl_activate_object(pobj)

    :status: Tested + Doc + Demo = OK

    """
    _fl_activate_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_activate_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_activate_object(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    _fl_activate_object(pFlObject)


def fl_deactivate_object(pFlObject):
    """Makes a particular object to be temporarily inactive, disabling user
    interaction, e.g., you want to make it impossible for the user to press a
    particular button or to type input in a particular field. When object is a
    group, the whole group is deactivate.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to deactivate

    :note: e.g. fl_deactivate_object(pactobj)

    :status: Tested + Doc + Demo = OK

    """
    _fl_deactivate_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_deactivate_object",\
        None, [cty.POINTER(xfdata.FL_OBJECT)],\
        """void fl_deactivate_object(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    _fl_deactivate_object(pFlObject)


def fl_object_is_active(pFlObject):
    """Returns if object is active and reacting to events, or not.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to evaluate

    :return: flag 0 (not active) or non-zero (active)
    :rtype: int

    :note: e.g. if not fl_object_is_active(pobj): ...

    :status: Tested + Doc + Demo = OK

    """
    _fl_object_is_active = libr.cfuncproto(
        libr.load_so_libforms(), "fl_object_is_active",\
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],\
        """int fl_object_is_active(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_object_is_active(pFlObject)
    return retval


def fl_enumerate_fonts(py_output, shortform):
    """Lists built-in fonts.

    --

    :Parameters:
      `py_output` : python callback function, no return
        function referring to fn(string)
      `shortform` : int
        flag to use short form (non-zero) or not (0 for long form)

    :return: number of listed fonts
    :rtype: int

    :note: e.g. def pyoutput(strng): > print strng
    :note: e.g. numfonts = fl_enumerate(pyoutput, 0)

    :status: Tested + Doc + Demo = OK

    """
    # cfunc_none_string = cty.CFUNCTYPE(None, xfdata.STRING)
    _fl_enumerate_fonts = libr.cfuncproto(
        libr.load_so_libforms(), "fl_enumerate_fonts",\
        cty.c_int, [xfdata.cfunc_none_string, cty.c_int],\
        """int fl_enumerate_fonts(void ( * output )( const char *s ), \
           int shortform)""")
    libr.check_if_initialized()
    ishortform = libr.convert_to_int(shortform)
    c_output = xfdata.cfunc_none_string(py_output)
    libr.keep_cfunc_refs(c_output, py_output)
    libr.keep_elem_refs(shortform, ishortform)
    retval = _fl_enumerate_fonts(c_output, ishortform)
    return retval


# TODO: verify if name must conform to other (built-in) font names
def fl_set_font_name(fontnum, name):
    """Add a new font (indexed by number) or change an existing font.
    Preferably the font name contains a '?' in the size position so different
    sizes can be used. Redraw of all forms is required to actually see the
    change for visible form.

    --

    :Parameters:
      `fontnum` : int
        font number. Values between 0 and xfdata.FL_MAXFONTS-1
      `name` : str
        font name

    :return: 0 or 1, or -1 (on errors)
    :rtype: int

    :note: e.g. fl_set_font_name(40, "symbol-medium-whatever") ?

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_font_name = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_font_name",\
        cty.c_int, [cty.c_int, xfdata.STRING],\
        """int fl_set_font_name(int n, const char * name)""")
    libr.check_if_initialized()
    ifontnum = libr.convert_to_int(fontnum)
    sname = libr.convert_to_string(name)
    libr.keep_elem_refs(fontnum, ifontnum, name, sname)
    retval = _fl_set_font_name(ifontnum, sname)
    return retval


def fl_set_font(fontnum, size):
    """Makes the specified font as the current.

    --

    :Parameters:
      `fontnum` : int
        font number
      `size` : int
        font size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE

    :note: e.g. fl_set_font(5, xfdata.FL_SMALL_SIZE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_font = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_font",\
        None, [cty.c_int, cty.c_int],\
        """void fl_set_font(int numb, int size)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    ifontnum = libr.convert_to_int(fontnum)
    isize = libr.convert_to_int(size)
    libr.keep_elem_refs(fontnum, ifontnum, size, isize)
    _fl_set_font(ifontnum, isize)


# routines that facilitate free object

def fl_get_char_height(style, size):
    """Returns the maximum height of the used font and the height above and
    below the baseline of the font.

    --

    :Parameters:
      `style` : int
        font style. Values (from xfdata.py) FL_NORMAL_STYLE, FL_BOLD_STYLE,
        FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        font size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE

    :return: height (h), ascendent (asc), descendent (desc)
    :rtype: int, int, int

    :note: e.g. hei, asc, desc = fl_get_char_height(xfdata.FL_BOLD_STYLE,
        xfdata.FL_TINY_SIZE)

    :attention: API change from XForms - upstream was
        fl_get_char_height(style, size, asc, desc)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_char_height = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_char_height",\
        cty.c_int, [cty.c_int, cty.c_int, cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int)],\
        """int fl_get_char_height(int style, int size, int * asc,
           int * desc)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    istyle = libr.convert_to_int(style)
    isize = libr.convert_to_int(size)
    asc, pasc = libr.make_int_and_pointer()
    desc, pdesc = libr.make_int_and_pointer()
    libr.keep_elem_refs(style, istyle, size, isize, asc, desc, pasc, pdesc)
    retval = _fl_get_char_height(istyle, isize, pasc, pdesc)
    return retval, asc.value, desc.value


def fl_get_char_width(style, size):
    """Returns the maximum width of the used font.

    --

    :Parameters:
      `style` : int
        font style. Values (from xfdata.py) FL_NORMAL_STYLE, FL_BOLD_STYLE,
        FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        font size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE

    :return: width (w)
    :rtype: int

    :note: e.g. wid = fl_get_char_width(xfdata.FL_TIMES_STYLE,
        xfdata.FL_HUGE_SIZE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_char_width = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_char_width",\
        cty.c_int, [cty.c_int, cty.c_int],\
        """int fl_get_char_width(int style, int size)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    istyle = libr.convert_to_int(style)
    isize = libr.convert_to_int(size)
    libr.keep_elem_refs(style, istyle, size, isize)
    retval = _fl_get_char_width(istyle, isize)
    return retval


def fl_get_string_height(style, size, txtstr, strlng):
    """Obtains the height information of a specific string and the height
    above and below the font's baseline.

    --

    :Parameters:
      `style` : int
        font style. Values (from xfdata.py) FL_NORMAL_STYLE, FL_BOLD_STYLE,
        FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        font size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE
      `txtstr` : str
        text to evaluate
      `strlng` : int
        length of text

    :return: height (h), ascendent (asc), descendent (desc)
    :rtype: int, int, int

    :note: e.g. hei, asc, desc = fl_get_string_height(xfdata.FL_MISC_STYLE,
        xfdata.FL_MEDIUM_SIZE, "Mystring", 8)

    :attention: API change from XForms - upstream was
        fl_get_string_height(style, size, strng, strglen, asc, desc)

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_string_height = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_string_height",\
        cty.c_int, [cty.c_int, cty.c_int, xfdata.STRING, cty.c_int,
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],\
        """int fl_get_string_height(int style, int size, const char * s,
           int len, int * asc, int * desc)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    istyle = libr.convert_to_int(style)
    isize = libr.convert_to_int(size)
    stxtstr = libr.convert_to_string(txtstr)
    istrlng = libr.convert_to_int(strlng)
    asc, pasc = libr.make_int_and_pointer()
    desc, pdesc = libr.make_int_and_pointer()
    libr.keep_elem_refs(style, istyle, size, isize, txtstr, stxtstr, strlng, \
                   istrlng, asc, desc, pasc, pdesc)
    retval = _fl_get_string_height(istyle, isize, stxtstr, istrlng, pasc,
                                   pdesc)
    return retval, asc.value, desc.value


def fl_get_string_width(style, size, txtstr, strlng):
    """Obtains the width information for a specific string.

    --

    :Parameters:
      `style` : int
        font style. Values (from xfdata.py) FL_NORMAL_STYLE, FL_BOLD_STYLE,
        FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        font size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE
      `txtstr` : str
        text
      `strlng` : int
        length of text

    :return: width (w)
    :rtype: int

    :note: e.g. wid = fl_get_string_width(xfdata.FL_MISC_STYLE,
        xfdata.FL_MEDIUM_SIZE, "Mystring", 8)

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_string_width = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_string_width",\
        cty.c_int, [cty.c_int, cty.c_int, xfdata.STRING, cty.c_int],\
        """int fl_get_string_width(int style, int size, const char * s,
           int len)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    istyle = libr.convert_to_int(style)
    isize = libr.convert_to_int(size)
    stxtstr = libr.convert_to_string(txtstr)
    istrlng = libr.convert_to_int(strlng)
    libr.keep_elem_refs(style, istyle, size, isize, txtstr, stxtstr, strlng,
                   istrlng)
    retval = _fl_get_string_width(istyle, isize, stxtstr, istrlng)
    return retval


# TODO: what's its purpose?
def fl_get_string_widthTAB(style, size, txtstr, strlng):
    """*todo*

    --

    :Parameters:
      `style` : int
        font style. Values (from xfdata.py) FL_NORMAL_STYLE, FL_BOLD_STYLE,
        FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        font size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE
      `txtstr` : str
        text
      `strlng` : int
        length of text

    :return: width (w)
    :rtype: int

    :note: e.g. wid = fl_get_string_width(xfdata.FL_MISC_STYLE,
        xfdata.FL_MEDIUM_SIZE, "Mystring", 8)

    :status: Untested + NoDoc + NoDemo = NOT OK (not clear purpose)

    """
    _fl_get_string_widthTAB = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_string_widthTAB",\
        cty.c_int, [cty.c_int, cty.c_int, xfdata.STRING, cty.c_int],\
        """int fl_get_string_widthTAB(int style, int size, const char * s,
           int len)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    istyle = libr.convert_to_int(style)
    isize = libr.convert_to_int(size)
    stxtstr = libr.convert_to_string(txtstr)
    istrlng = libr.convert_to_int(strlng)
    libr.keep_elem_refs(style, istyle, size, isize, txtstr, stxtstr, strlng,
                   istrlng)
    retval = _fl_get_string_widthTAB(istyle, isize, stxtstr, istrlng)
    return retval


def fl_get_string_dimension(style, size, txtstr, strlng):
    """Returns the width and height of a string in one call. In addition, the
    string passed can contain embedded newline characters and the routine will
    make proper adjustment so the values returned are (just) large enough to
    contain the multiple lines of text.

    --

    :Parameters:
      `style` : int
        font style. Values (from xfdata.py) FL_NORMAL_STYLE, FL_BOLD_STYLE,
        FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        font size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE
      `txtstr` : str
        text
      `strlng` : int
        length of text

    :return: width (w), height (h)
    :rtype: int, int

    :note: e.g. fl_get_string_dimension(xfdata.FL_ENGRAVED_STYLE,
        xfdata.FL_DEFAULT_SIZE, "CustomString", 12)

    :attention: API change from upstream
        fl_get_string_dimension(fntstyle, fntsize, strng, strglen, w, h)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_string_dimension = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_string_dimension",\
        None, [cty.c_int, cty.c_int, xfdata.STRING, cty.c_int,
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],\
        """void fl_get_string_dimension(int fntstyle, int fntsize,
           const char * s, int len, int * width, int * height)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    istyle = libr.convert_to_int(style)
    isize = libr.convert_to_int(size)
    stxtstr = libr.convert_to_string(txtstr)
    istrlng = libr.convert_to_int(strlng)
    width, pwidth = libr.make_int_and_pointer()
    height, pheight = libr.make_int_and_pointer()
    libr.keep_elem_refs(style, istyle, size, isize, txtstr, stxtstr,
                   strlng, istrlng, width, height, pwidth, pheight)
    _fl_get_string_dimension(istyle, isize, stxtstr, istrlng, pwidth,
                             pheight)
    return width.value, height.value


fl_get_string_size = fl_get_string_dimension


def fl_get_align_xy(align, x, y, w, h, xsize, ysize, xmargin, ymargin):
    """Obtains the position of where to draw the object with a certain
    alignment and including padding. It works regardless if it is to be drawn
    inside or outside of the bounding box

    --

    :Parameters:
      `align` : int
        alignment. Values (from xfdata.py) FL_ALIGN_CENTER, FL_ALIGN_TOP,
        FL_ALIGN_BOTTOM, FL_ALIGN_LEFT, FL_ALIGN_RIGHT, FL_ALIGN_LEFT_TOP,
        FL_ALIGN_RIGHT_TOP, FL_ALIGN_LEFT_BOTTOM, FL_ALIGN_RIGHT_BOTTOM,
        FL_ALIGN_INSIDE, FL_ALIGN_VERT
        Bitwise OR with FL_ALIGN_INSIDE is allowed.
      `x` : int
        horizontal position of bounding box (upper-left corner)
      `y` : int
        vertical position of bounding box (upper-left corner)
      `w` : int
        width of bounding box in coord units
      `h` : int
        height of bounding box in coord units
      `xsize` : int
        width of the object to be drawn
      `ysize` : int
        height of the object to be drawn
      `xmargin` : int
        additional horizontal padding to use
      `ymargin` : int
        additional vertical padding to use

    :return: horizontal (x) and vertical position (y) used for drawing object
    :rtype: int, int

    :note: e.g. xpos, ypos = fl_get_align_xy(xfdata.FL_ALIGN_CENTER, 200, 300,
        110, 30, 120, 40, 15, 15)

    :attention: API change from XForms - upstream was
        fl_get_align_xy(align, x, y, w, h, xsize, ysize, xoff, yoff, xx, yy)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_align_xy = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_align_xy",\
        None, [cty.c_int, cty.c_int, cty.c_int, cty.c_int, cty.c_int,\
        cty.c_int, cty.c_int, cty.c_int, cty.c_int,
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],\
        """void fl_get_align_xy(int align, int x, int y, int w, int h,
           int xsize, int ysize, int xoff, int yoff, int * xx, int * yy)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(align, xfdata.ALIGN_list)
    ialign = libr.convert_to_int(align)
    ix = libr.convert_to_int(x)
    iy = libr.convert_to_int(y)
    iw = libr.convert_to_int(w)
    ih = libr.convert_to_int(h)
    ixsize = libr.convert_to_int(xsize)
    iysize = libr.convert_to_int(ysize)
    ixmargin = libr.convert_to_int(xmargin)
    iymargin = libr.convert_to_int(ymargin)
    xx, pxx = libr.make_int_and_pointer()
    yy, pyy = libr.make_int_and_pointer()
    libr.keep_elem_refs(align, ialign, x, ix, y, iy, w, iw, h, ih, xsize, \
        ixsize, ysize, iysize, xmargin, ixmargin, ymargin, iymargin, xx, yy, \
        pxx, pyy)
    _fl_get_align_xy(ialign, ix, iy, iw, ih, ixsize, iysize, ixmargin,
                     iymargin, pxx, pyy)
    return xx.value, yy.value


def fl_drw_text(align, x, y, w, h, colr, style, size, txtstr):
    """Draws the text inside the bounding box according to the alignment
    requested. It puts a padding of 5 pixels in vertical direction and 4 in
    horizontal around the text. Thus the bounding box should be 10 pixels wider
    and 8 pixels higher than required for the text to be drawn. It interprets
    a text string starting with the character @ differently in drawing some
    symbols instead.

    --

    :Parameters:
      `align` : int
        alignment of text. Values (from xfdata.py) FL_ALIGN_CENTER,
        FL_ALIGN_TOP, FL_ALIGN_BOTTOM, FL_ALIGN_LEFT, FL_ALIGN_RIGHT,
        FL_ALIGN_LEFT_TOP, FL_ALIGN_RIGHT_TOP, FL_ALIGN_LEFT_BOTTOM,
        FL_ALIGN_RIGHT_BOTTOM, FL_ALIGN_INSIDE, FL_ALIGN_VERT
        Bitwise OR with FL_ALIGN_INSIDE is allowed.
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value
      `style` : int
        font style. Values (from xfdata.py) FL_NORMAL_STYLE, FL_BOLD_STYLE,
        FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        font size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE
      `txtstr` : str
        text to draw

    :note: e.g. fl_drw_text(xfdata.FL_ALIGN_BOTTOM, 400, 175, 150, 45,
        xfdata.FL_GREEN, xfdata.FL_ITALIC_STYLE, xfdata.FL_SMALL_SIZE,
        "A Good Old String")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_drw_text = libr.cfuncproto(
        libr.load_so_libforms(), "fl_drw_text",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR, cty.c_int, cty.c_int, xfdata.STRING],
        """void fl_drw_text(int align, FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, FL_COLOR c, int style, int size, const char * istr)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(align, xfdata.ALIGN_list)
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    ialign = libr.convert_to_int(align)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    istyle = libr.convert_to_int(style)
    isize = libr.convert_to_int(size)
    stxtstr = libr.convert_to_string(txtstr)
    libr.keep_elem_refs(align, ialign, x, ix, y, iy, w, iw, h, ih, colr,
                   ulcolr, style, istyle, size, isize, txtstr, stxtstr)
    _fl_drw_text(ialign, ix, iy, iw, ih, ulcolr, istyle, isize,
                 stxtstr)


def fl_drw_text_beside(align, x, y, w, h, colr, style, size, txtstr):
    """Draws the text aligned outside of the box. It interprets a text string
    starting with the character @ differently in drawing some symbols instead.

    --

    :Parameters:
      `align` : int
        alignment of text. Values (from xfdata.py) FL_ALIGN_CENTER,
        FL_ALIGN_TOP, FL_ALIGN_BOTTOM, FL_ALIGN_LEFT, FL_ALIGN_RIGHT,
        FL_ALIGN_LEFT_TOP, FL_ALIGN_RIGHT_TOP, FL_ALIGN_LEFT_BOTTOM,
        FL_ALIGN_RIGHT_BOTTOM, FL_ALIGN_INSIDE, FL_ALIGN_VERT
        Bitwise OR with FL_ALIGN_INSIDE is allowed.
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value
      `style` : int
        font style. Values (from xfdata.py) FL_NORMAL_STYLE, FL_BOLD_STYLE,
        FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        font size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE
      `txtstr` : str
        text to draw

    :note: e.g. fl_drw_text_beside(xfdata.FL_ALIGN_BOTTOM, 400, 175, 150, 45,
        xfdata.FL_GREEN, xfdata.FL_ITALIC_STYLE, xfdata.FL_SMALL_SIZE,
        "A Good Old String")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_drw_text_beside = libr.cfuncproto(
        libr.load_so_libforms(), "fl_drw_text_beside",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR, cty.c_int, cty.c_int, xfdata.STRING],
        """void fl_drw_text_beside(int align, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR c, int style, int size,
           const char * str)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(align, xfdata.ALIGN_list)
    libr.check_admitted_value_in_list(align, xfdata.COLOR_list)
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    ialign = libr.convert_to_int(align)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    istyle = libr.convert_to_int(style)
    isize = libr.convert_to_int(size)
    stxtstr = libr.convert_to_string(txtstr)
    libr.keep_elem_refs(align, ialign, x, ix, y, iy, w, iw, h, ih, colr,
                   ulcolr, style, istyle, size, isize, txtstr, stxtstr)
    _fl_drw_text_beside(ialign, ix, iy, iw, ih, ulcolr, istyle,
                        isize, stxtstr)


def fl_drw_text_cursor(align, x, y, w, h, colr, style, size, txtstr, curscolr,
                       pos):
    """Draw text and, in addition, a cursor can optionally be drawn. It does
    no interpretation of the special character @ nor does it add padding
    around the text.

    --

    :Parameters:
      `align` : int
        alignment of text. Values (from xfdata.py) FL_ALIGN_CENTER,
        FL_ALIGN_TOP, FL_ALIGN_BOTTOM, FL_ALIGN_LEFT, FL_ALIGN_RIGHT,
        FL_ALIGN_LEFT_TOP, FL_ALIGN_RIGHT_TOP, FL_ALIGN_LEFT_BOTTOM,
        FL_ALIGN_RIGHT_BOTTOM, FL_ALIGN_INSIDE, FL_ALIGN_VERT
        Bitwise OR with FL_ALIGN_INSIDE is allowed.
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value
      `style` : int
        font style. Values (from xfdata.py) FL_NORMAL_STYLE, FL_BOLD_STYLE,
        FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        font size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE
      `txtstr` : str
        text to draw
      `curscolr` : int
        color of the cursor
      `pos` : int
        position which indicates the index of the character before which to
        draw the cursor (-1 for not showing it)

    :note: e.g. fl_drw_text_cursor(xfdata.FL_ALIGN_BOTTOM, 400, 175, 150, 45,
        xfdata.FL_GREEN, xfdata.FL_ITALIC_STYLE, xfdata.FL_SMALL_SIZE,
        "A Good Old String", xfdata.FL_YELLOW, 7)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_drw_text_cursor = libr.cfuncproto(
        libr.load_so_libforms(), "fl_drw_text_cursor",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR, cty.c_int, cty.c_int, xfdata.STRING,
        cty.c_int, cty.c_int],
        """void fl_drw_text_cursor(int align, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR c, int style, int size,
           const char * str, int cc, int pos)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(align, xfdata.ALIGN_list)
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    libr.check_admitted_value_in_list(style, xfdata.TEXTSTYLE_list)
    libr.check_admitted_value_in_list(size, xfdata.FONTSIZE_list)
    libr.check_admitted_value_in_list(curscolr, xfdata.COLOR_list)
    ialign = libr.convert_to_int(align)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    istyle = libr.convert_to_int(style)
    isize = libr.convert_to_int(size)
    stxtstr = libr.convert_to_string(txtstr)
    icurscolr = libr.convert_to_int(curscolr)
    ipos = libr.convert_to_int(pos)
    libr.keep_elem_refs(align, ialign, x, ix, y, iy, w, iw, h, ih, colr,
                   ulcolr, style, istyle, size, isize, txtstr, stxtstr,
                   curscolr, icurscolr, pos, ipos)
    _fl_drw_text_cursor(ialign, ix, iy, iw, ih, ulcolr, istyle,
                        isize, stxtstr, icurscolr, ipos)


def fl_drw_box(boxtype, x, y, w, h, colr, bw):
    """Draws the bounding box of an object.

    --

    :Parameters:
      `boxtype` : int
        type of box to draw. Values (from xfdata.py) FL_NO_BOX, FL_UP_BOX,
        FL_DOWN_BOX, FL_BORDER_BOX, FL_SHADOW_BOX, FL_FRAME_BOX,
        FL_ROUNDED_BOX, FL_EMBOSSED_BOX, FL_FLAT_BOX, FL_RFLAT_BOX,
        FL_RSHADOW_BOX, FL_OVAL_BOX, FL_ROUNDED3D_UPBOX, FL_ROUNDED3D_DOWNBOX,
        FL_OVAL3D_UPBOX, FL_OVAL3D_DOWNBOX, FL_OVAL3D_FRAMEBOX,
        FL_OVAL3D_EMBOSSEDBOX
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value
      `bw` : int
        width of the boundary

    :note: e.g. fl_drw_box(xfdata.FL_DOWN_BOX, 700, 800, 600, 450,
        xfdata.FL_INDIGO, 3)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_drw_box = libr.cfuncproto(
        libr.load_so_libforms(), "fl_drw_box",\
        None, [cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_COLOR, cty.c_int],\
        """void fl_drw_box(int style, FL_Coord x, FL_Coord y, FL_Coord w,
           FL_Coord h, FL_COLOR c, int bw_in)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(boxtype, xfdata.BOXTYPE_list)
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    iboxtype = libr.convert_to_int(boxtype)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    ibw = libr.convert_to_int(bw)
    libr.keep_elem_refs(boxtype, iboxtype, x, ix, y, iy, w, iw, h, ih, colr,
                   ulcolr, bw, ibw)
    _fl_drw_box(boxtype, x, y, w, h, ulcolr, ibw)


def fl_add_symbol(symbname, py_DrawPtr, scalable):
    """Adds a customly drawn symbol to the system which it can then use to
    display symbols on objects that are not provided by the libr.

    --

    :Parameters:
      `symbname` : str
        name under which the symbol should be known (at most 15 characters),
        without the leading @
      `py_DrawPtr` : python function to draw symbol, no return
        name referring to function(coord, coord, coord, coord,
        angle_degree_rotation, colr)
      `scalable` : int
        not used, a value of 0 will be fine

    :return: num.
    :rtype: int

    :note: e.g. def drawsymb(x, y, w, h, angle, col): > ...
    :note: e.g. fl_add_symbol("MySymbol", drawsymb, 0)

    :status: Tested + Doc + NoDemo = OK

    """
    #FL_DRAWPTR = cty.CFUNCTYPE(None, xfdata.FL_Coord, xfdata.FL_Coord,
    #        xfdata.FL_Coord, FL_Coord, cty.c_int, FL_COLOR)
    _fl_add_symbol = libr.cfuncproto(
        libr.load_so_libforms(), "fl_add_symbol",\
        cty.c_int, [xfdata.STRING, xfdata.FL_DRAWPTR, cty.c_int],\
        """int fl_add_symbol(const char * name, FL_DRAWPTR drawit,
           int scalable)""")
    libr.check_if_initialized()
    ssymbname = libr.convert_to_string(symbname)
    iscalable = libr.convert_to_int(scalable)
    c_DrawPtr = xfdata.FL_DRAWPTR(py_DrawPtr)
    libr.keep_cfunc_refs(c_DrawPtr, py_DrawPtr)
    libr.keep_elem_refs(symbname, ssymbname, scalable, iscalable)
    retval = _fl_add_symbol(ssymbname, c_DrawPtr, iscalable)
    return retval


def fl_draw_symbol(symbname, x, y, w, h, colr):
    """Draws directly a symbol on the screen.

    --

    :Parameters:
      `symbname` : str
        name given to the symbol
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `colr` : long_pos
        color value

    :return: 1 (on success) or 0 (on failure)
    :rtype: int

    :note: e.g. fl_draw_symbol("willsym", 120, 120, 15, 20,
        xfdata.FL_LIGHTGRAY)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_draw_symbol = libr.cfuncproto(
        libr.load_so_libforms(), "fl_draw_symbol",\
        cty.c_int, [xfdata.STRING, xfdata.FL_Coord, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_COLOR],\
        """int fl_draw_symbol(const char * label, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, FL_COLOR col)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ssymbname = libr.convert_to_string(symbname)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(symbname, ssymbname, x, ix, y, iy, w, iw, h, ih, colr,
                   ulcolr)
    retval = _fl_draw_symbol(ssymbname, ix, iy, iw, ih, ulcolr)
    return retval


def fl_mapcolor(colr, r, g, b):
    """Changes the colormap and make a color index active so that it can be
    used in various drawing routines after initialization. It maps a new color
    using specific values for red, green and blue. In case a request fails, we
    substitute the closest color. It is recommended that you use an index
    larger than xfdata.FL_FREE_COL1 for your remap request to avoid
    accidentally free the colors you have not explicitly allocated. Indices
    larger than 224 are reserved and should not be used.

    --

    :Parameters:
      `colr` : long_pos
        new color value to be mapped
      `r` : int
        value for red
      `g` : int
        value for green
      `b` : int
        value for blue

    :return: color value, or 0 (on failure)
    :rtype: long_pos

    :note: e.g. fl_mapcolor(xfdata.FL_FREE_COL1, 100, 200, 300)

    :status: Tested + Doc + Demo = OK

    """
    _fl_mapcolor = libr.cfuncproto(
        libr.load_so_libforms(), "fl_mapcolor",\
        cty.c_ulong, [xfdata.FL_COLOR, cty.c_int, cty.c_int, cty.c_int],
        """unsigned long fl_mapcolor(FL_COLOR col, int r, int g, int b)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    ir = libr.convert_to_int(r)
    ig = libr.convert_to_int(g)
    ib = libr.convert_to_int(b)
    libr.keep_elem_refs(colr, ulcolr, r, ir, g, ig, b, ib)
    retval = _fl_mapcolor(ulcolr, ir, ig, ib)
    return retval


def fl_mapcolorname(colr, rgbcolrname):
    """Sets the color in the colormap indexed by colr to the specified color
    name. It associates an index with a color name, which may have been
    obtained via resources.

    --

    :Parameters:
      `colr` : long_pos
        color value to be mapped
      `rgbcolrname` : str
        name of mapped color from the systems color database file "rgb.txt"
        (see that file for possible values)

    :return: color pixel value, or -1 (on failure)
    :rtype: long

    :note: e.g. fl_mapcolorname(xfdata.FL_FREE_COL3, "PowderBlue")

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_mapcolorname = libr.cfuncproto(
        libr.load_so_libforms(), "fl_mapcolorname",\
        cty.c_long, [xfdata.FL_COLOR, xfdata.STRING],\
        """long int fl_mapcolorname(FL_COLOR col, const char * name)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    srgbcolrname = libr.convert_to_string(rgbcolrname)
    libr.keep_elem_refs(colr, ulcolr, rgbcolrname, srgbcolrname)
    retval = _fl_mapcolorname(ulcolr, srgbcolrname)
    return retval


fl_mapcolor_name = fl_mapcolorname


# commented as it gives a SegFault
#def fl_free_colors(colr, numcolr):
#    """Frees allocated array of colors from the default colormap, if index of
#    colors are known. You shouldn't do that for the reserved colors (i.e.
#    colors with indices below xfdata.FL_FREE_COL1).
#
#    --
#
#    :Parameters:
#      `colr` : long_pos
#        color value
#      `numcolr` : int
#        number of colors stored in the array of colors
#
#    :note: e.g. *todo*
#
#    :status: Untested + Doc + NoDemo = NOT OK
#
#    """
#    _fl_free_colors = libr.cfuncproto(
#        libr.load_so_libforms(), "fl_free_colors",\
#        None, [cty.POINTER(xfdata.FL_COLOR), cty.c_int],\
#        """void fl_free_colors(FL_COLOR * c, int n)""")
#    libr.check_if_initialized()
#    pcolr = cty.cast(colr, cty.POINTER(xfdata.FL_COLOR))
#    inumcolr = libr.convert_to_int(numcolr)
#    libr.keep_elem_refs(colr, pcolr, numcolr, inumcolr)
#    _fl_free_colors(pcolr, inumcolr)


# commented as it gives a SegFault
#def fl_free_pixels(pix, numcolr):
#    """Frees allocated colors from the default colormap, if pixel values are
#    known. You shouldn't do that for the reserved colors (i.e. colors with
#    indices below xfdata.FL_FREE_COL1).
#
#    --
#
#    :Parameters:
#      `pix` : long_pos
#        pixel number
#      `numcolr` : int
#        number of colors stored
#
#    :note: e.g. *todo*
#
#    :status: Untested + Doc + NoDemo = NOT OK
#
#    """
#    _fl_free_pixels = libr.cfuncproto(
#        libr.load_so_libforms(), "fl_free_pixels",\
#        None, [cty.POINTER(cty.c_ulong), cty.c_int],\
#        """void fl_free_pixels(long unsigned int * pix, int n)""")
#    libr.check_if_initialized()
#    ppix = cty.cast(pix, cty.POINTER(cty.c_ulong))
#    inumcolr = libr.convert_to_int(numcolr)
#    libr.keep_elem_refs(pix, ppix, numcolr, inumcolr)
#    _fl_free_pixels(ppix, inumcolr)


# TODO: figure out what is its purpose.
def fl_set_color_leak(yesno):
    """Enables or disables the leakage of color. ?

    --

    :Parameters:
      `yesno` : int
        flag to enable/disable leakage of color. Values 0 (to disable) or 1
        (to enable)

    :note: e.g. fl_set_color_leak(1)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_color_leak = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_color_leak",\
        None, [cty.c_int],\
        """void fl_set_color_leak(int y)""")
    libr.check_if_initialized()
    iyesno = libr.convert_to_int(yesno)
    libr.keep_elem_refs(yesno, iyesno)
    _fl_set_color_leak(iyesno)


def fl_getmcolor(colr):
    """Obtains the RGB values of an index, returning the pixel value as known
    by the X server. If you are interested in the internal colormap of XForms
    fl_get_icm_color() is more efficient.

    --

    :Parameters:
      `colr` : long_pos
        color value

    :return: color pixel, red (r), green (r), blue (b)
    :rtype: long_pos, int, int, int

    :note: e.g. pixl, red, green, blue = fl_getmcolor(xfdata.FL_VIOLET)

    :attention: API change from XForms - upstream was
        fl_getmcolor(colr, r, g, b)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_getmcolor = libr.cfuncproto(
        libr.load_so_libforms(), "fl_getmcolor",\
        cty.c_ulong, [xfdata.FL_COLOR, cty.POINTER(cty.c_int),\
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],\
        """long unsigned int fl_getmcolor(FL_COLOR i, int * r, int * g,
           int * b)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    r, pr = libr.make_int_and_pointer()
    g, pg = libr.make_int_and_pointer()
    b, pb = libr.make_int_and_pointer()
    libr.keep_elem_refs(colr, ulcolr, r, g, b, pr, pg, pb)
    retval = _fl_getmcolor(ulcolr, pr, pg, pb)
    return retval, r.value, g.value, b.value


def fl_get_pixel(colr):
    """Obtains the actual pixel value the X server understands. XForms library
    keeps an internal colormap, initialized to predefined colors. The
    predefined colors do not correspond to pixel values the server understands
    but are indexes into the colormap. Therefore, they can't be used in any of
    the Graphics Context (GC) altering or Xlib routines.

    --

    :Parameters:
      `colr` : long_pos
        color value

    :return: color pixel
    :rtype: long_pos

    :note: e.g. pixl = fl_get_pixel(xfdata.FL_PEACHPUFF)

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_pixel = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_pixel",\
        cty.c_ulong, [xfdata.FL_COLOR],\
        """long unsigned int fl_get_pixel(FL_COLOR col)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(colr, ulcolr)
    retval = _fl_get_pixel(ulcolr)
    return retval


fl_get_flcolor = fl_get_pixel


def fl_get_icm_color(colr):
    """Queries the internal colormap handled by XForms, returning red, green
    and blue values corresponding to color index. Note that it does not
    communicate with the X server, it only return information about the
    internal colormap, which is made known to the X server by the
    initialization routine fl_initialize().

    --

    :Parameters:
      `colr` : long_pos
        color value

    :return: red (r), green (g), blue (b)
    :rtype: int, int, int

    :note: e.g. red, green, blue = fl_get_icm_color(xfdata.FL_OLIVE)

    :attention: API change from XForms - upstream was
        fl_get_icm_color(colr, r, g, b)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_icm_color = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_icm_color",\
        None, [xfdata.FL_COLOR, cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int), cty.POINTER(cty.c_int)],\
        """void fl_get_icm_color(FL_COLOR col, int * r, int * g, int * b)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    r, pr = libr.make_int_and_pointer()
    g, pg = libr.make_int_and_pointer()
    b, pb = libr.make_int_and_pointer()
    libr.keep_elem_refs(colr, ulcolr, r, g, b, pr, pg, pb)
    _fl_get_icm_color(ulcolr, pr, pg, pb)
    return r.value, g.value, b.value


def fl_set_icm_color(colr, r, g, b):
    """Changes the internal colormap handled by XForms, setting a color index
    using a red, green and blue values' combination. You have to call
    fl_set_icm_color() before fl_initialize() to change XForms's default
    colormap. Note that it does not communicate with the X server, it only
    populate the internal colormap, which is made known to the X server by
    the initialization routine fl_initialize().

    --

    :Parameters:
      `colr` : long_pos
        color value
      `r` : int
        value for red
      `g` : int
        value for green
      `b` : int
        value for blue

    :note: e.g. fl_set_icm_color(xfdata.FL_FREE_COL8, 75, 150, 225)

    :precondition: to be called before fl_initialize() ?

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_icm_color = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_icm_color",\
        None, [xfdata.FL_COLOR, cty.c_int, cty.c_int, cty.c_int],\
        """void fl_set_icm_color(FL_COLOR col, int r, int g, int b)""")
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    ir = libr.convert_to_int(r)
    ig = libr.convert_to_int(g)
    ib = libr.convert_to_int(b)
    libr.keep_elem_refs(colr, ulcolr, r, g, b, ir, ig, ib)
    _fl_set_icm_color(ulcolr, ir, ig, ib)


def fl_color(colr):
    """Sets the foreground color in the XForms library's default Graphics
    Context (gc[0]).

    --

    :Parameters:
      `colr` : long_pos
        color value

    :note: e.g. fl_color(xfdata.FL_ORANGE)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_color = libr.cfuncproto(
        libr.load_so_libforms(), "fl_color",\
        None, [xfdata.FL_COLOR],\
        """void fl_color(FL_COLOR col)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(colr, ulcolr)
    _fl_color(ulcolr)


def fl_bk_color(colr):
    """Sets the background color in the default Graphics Context (gc[0]).

    --

    :Parameters:
      `colr` : long_pos
        color value

    :note: e.g. fl_bk_color(xfdata.FL_MEDIUMORCHID)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_bk_color = libr.cfuncproto(
        libr.load_so_libforms(), "fl_bk_color",\
        None, [xfdata.FL_COLOR],\
        """void fl_bk_color(FL_COLOR col)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(colr, ulcolr)
    _fl_bk_color(ulcolr)


def fl_textcolor(colr):
    """Sets the foreground color for text in the default Graphics Context
    (gc[0]).

    --

    :Parameters:
      `colr` : long_pos
        color value

    :note: e.g. fl_textcolor(xfdata.FL_LIGHTCORAL)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_textcolor = libr.cfuncproto(
        libr.load_so_libforms(), "fl_textcolor",\
        None, [xfdata.FL_COLOR],\
        """void fl_textcolor(FL_COLOR col)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(colr, ulcolr)
    _fl_textcolor(ulcolr)


def fl_bk_textcolor(colr):
    """Sets the background color for text in the default Graphics Context
    (gc[0]).

    --

    :Parameters:
      `colr` : long_pos
        color value

    :note: e.g. fl_bk_textcolor(xfdata.FL_IVORY)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_bk_textcolor = libr.cfuncproto(
        libr.load_so_libforms(), "fl_bk_textcolor",\
        None, [xfdata.FL_COLOR],\
        """void fl_bk_textcolor(FL_COLOR col)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(colr, xfdata.COLOR_list)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(colr, ulcolr)
    _fl_bk_textcolor(ulcolr)


def fl_set_gamma(r, g, b):
    """Adjusts the brightness of the builtin colors. Larger the value,
    brighter the colors.

    --

    :Parameters:
      `r` : float
        gamma value for red. By default gamma is 1.0
      `g` : float
        gamma value for green. By default gamma is 1.0
      `b` : float
        gamma value for blue. By default gamma is 1.0

    :note: e.g. fl_set_gamma(2.0, 2.0, 2.0)

    :precondition: to be called before fl_initialize()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_gamma = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_gamma",\
        None, [cty.c_double, cty.c_double, cty.c_double],\
        """void fl_set_gamma(double r, double g, double b)""")
    fr = libr.convert_to_double(r)
    fg = libr.convert_to_double(g)
    fb = libr.convert_to_double(b)
    libr.keep_elem_refs(r, fr, g, fg, b, fb)
    _fl_set_gamma(fr, fg, fb)


# fl_show_errors(y) function placeholder (backwards)


# TODO: verify if they are necessary in python
# Some macros

def FL_max(a, b):
    if (a > b):
        return a
    else:
        return b


def FL_min(a, b):
    if (a < b):
        return a
    else:
        return b


def FL_abs(a):
    if (a > 0):
        return a
    else:
        return (-a)


def FL_nint(a):
    if int(a) > 0:
        return (a + 0.5)
    else:
        return (a - 0.5)


def FL_clamp(a, amin, amax):
    if (a < amin):
        return amin
    elif (a > amax):
        return amax
    else:
        return a


def FL_crnd(a):
    if a > 0:             # FL_Coord(a)
        return (a + 0.5)
    else:
        return (a - 0.5)


# utilities for new objects

def fl_add_object(pFlForm, pFlObject):
    """The object remains available (except if it's an object that marks the
    start or end of a group) and can be added again to the same or another form
    later. Normally, this function is used in object classes to add a newly
    created object to a form. It may not be used for objects representing the
    start or end of a group.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form which an object will be added to
      `pFlObject` : pointer to xfdata.FL_OBJECT
        object to be added

    :note: e.g. fl_add_object(pform2, pobjnew2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_add_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_add_object",\
        None, [cty.POINTER(xfdata.FL_FORM), cty.POINTER(xfdata.FL_OBJECT)],
        """void fl_add_object(FL_FORM * form, FL_OBJECT * obj)""")
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlForm, pFlObject)
    _fl_add_object(pFlForm, pFlObject)


def fl_addto_form(pFlForm):
    """Reopens a form (after fl_end_form) for adding further objects to it.

    --

    :Parameters:
      `pFlForm` : pointer to xfdata.FL_FORM
        form

    :return: form (pFlForm), or None (on failure)
    :rtype: pointer to xfdata.FL_FORM

    :note: e.g. form = fl_addto_form(closedform)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_addto_form = libr.cfuncproto(
        libr.load_so_libforms(), "fl_addto_form",
        cty.POINTER(xfdata.FL_FORM), [cty.POINTER(xfdata.FL_FORM)],\
        """FL_FORM * fl_addto_form(FL_FORM * form)""")
    libr.check_if_initialized()
    libr.verify_flformptr_type(pFlForm)
    libr.keep_elem_refs(pFlForm)
    retval = _fl_addto_form(pFlForm)
    return retval


def fl_make_object(objclass, objtype, x, y, w, h, label, py_HandlePtr):
    """Makes a custom object.

    --

    :Parameters:
      `objclass` : int
        class type of object to be made
      `objtype` : int
        type of the object to be made
      `x` : int
        horizontal position of object (upper-left corner)
      `y` : int
        vertical position of object (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height coord units
      `label` : str
        text label of object
      `py_HandlePtr` : python function for handling object, returning value
        referring to fn(pFlObject, num, coord, coord, num, ptr_void) -> num

    :return: object made (pFlObject)
    :rtype: pointer to xfdata.FL_OBJECT

    :note: e.g. def handlecb(pobj, num, w, h, num, vdata): > ... ; return 0
    :note: e.g. fl_make_object(...)

    :status: Untested + Doc + NoDemo = NOT OK

    """
    #FL_HANDLEPTR = cty.CFUNCTYPE(cty.c_int, cty.POINTER(xfdata.FL_OBJECT),
    #    cty.c_int, xfdata.FL_Coord, xfdata.FL_Coord, cty.c_int, cty.c_void_p)
    _fl_make_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_make_object",\
        cty.POINTER(xfdata.FL_OBJECT), [cty.c_int, cty.c_int, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.STRING,
        xfdata.FL_HANDLEPTR],
        """FL_OBJECT * fl_make_object(int objclass, int type, FL_Coord x,
           FL_Coord y, FL_Coord w, FL_Coord h, const char * label,
           FL_HANDLEPTR handle)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(objclass, xfdata.OBJCLASS_list)
    iobjclass = libr.convert_to_int(objclass)
    iobjtype = libr.convert_to_int(objtype)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    slabel = libr.convert_to_string(label)
    c_HandlePtr = xfdata.FL_HANDLEPTR(py_HandlePtr)
    libr.keep_cfunc_refs(c_HandlePtr, py_HandlePtr)
    libr.keep_elem_refs(objclass, objtype, x, y, w, h, label, iobjclass,
                   iobjtype, ix, iy, iw, ih, slabel)
    retval = _fl_make_object(iobjclass, iobjtype, ix, iy, iw,
                             ih, slabel, c_HandlePtr)
    return retval


def fl_add_child(pFlObject1, pFlObject2):
    """Makes an object a child of another object. An example is the scrollbar
    object. It has three child objects, a slider and two buttons, which all
    three are childs of the scrollbar object.

    --

    :Parameters:
      `pFlObject1` : pointer to xfdata.FL_OBJECT
        father object
      `pFlObject2` : pointer to xfdata.FL_OBJECT
        child object to add

    :note: e.g. fl_add_child(pobjf, pobjs)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_add_child = libr.cfuncproto(
        libr.load_so_libforms(), "fl_add_child",\
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(xfdata.FL_OBJECT)],
        """void fl_add_child(FL_OBJECT * p1, FL_OBJECT * p2)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject1)
    libr.verify_flobjectptr_type(pFlObject2)
    libr.keep_elem_refs(pFlObject1, pFlObject2)
    _fl_add_child(pFlObject1, pFlObject2)


def fl_set_coordunit(unit):
    """Sets the unit for screen coordinates, instead of default ones (pixels).

    --

    :Parameters:
      `unit` : int
        coord unit type to set. Values (from xfdata.py) FL_COORD_PIXEL,
        FL_COORD_MM, FL_COORD_POINT, FL_COORD_centiMM, FL_COORD_centiPOINT

    :note: e.g. fl_set_coordunit(xfdata.FL_COORD_MM)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_coordunit = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_coordunit",\
        None, [cty.c_int],\
        """void fl_set_coordunit(int u)""")
    libr.check_if_initialized()
    libr.check_admitted_value_in_list(unit, xfdata.COORDUNIT_list)
    iunit = libr.convert_to_int(unit)
    libr.keep_elem_refs(unit, iunit)
    _fl_set_coordunit(iunit)


def fl_set_border_width(bw):
    """Sets the width of the border.

    --

    :Parameters:
      `bw` : int
        value of border width. If it's a negative number, all objects appear
        to have a softer appearance.

    :note: e.g. fl_set_border_width(-3)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_border_width = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_border_width",\
        None, [cty.c_int],\
        """void fl_set_border_width(int bw)""")
    ibw = libr.convert_to_int(bw)
    libr.keep_elem_refs(bw, ibw)
    _fl_set_border_width(ibw)


def fl_set_scrollbar_type(sbtype):
    """Sets the type of a scrollbar.

    --

    :Parameters:
      `sbtype` : int
        type of scrollbar. Values (from xfdata.py) FL_VERT_SCROLLBAR,
        FL_HOR_SCROLLBAR, FL_VERT_THIN_SCROLLBAR, FL_HOR_THIN_SCROLLBAR,
        FL_VERT_NICE_SCROLLBAR, FL_HOR_NICE_SCROLLBAR, FL_VERT_PLAIN_SCROLLBAR,
        FL_HOR_PLAIN_SCROLLBAR, FL_HOR_BASIC_SCROLLBAR,
        FL_VERT_BASIC_SCROLLBAR, FL_NORMAL_SCROLLBAR, FL_THIN_SCROLLBAR,
        FL_NICE_SCROLLBAR, FL_PLAIN_SCROLLBAR

    :note: e.g. fl_set_scrollbar_type(xfdata.FL_VERT_BASIC_SCROLLBAR)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_scrollbar_type = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_scrollbar_type",\
        None, [cty.c_int],\
        """void fl_set_scrollbar_type(int t)""")
    libr.check_admitted_value_in_list(sbtype, xfdata.SCROLLTYPE_list)
    isbtype = libr.convert_to_int(sbtype)
    libr.keep_elem_refs(sbtype, isbtype)
    _fl_set_scrollbar_type(isbtype)


def fl_set_thinscrollbar(yesno):
    """Sets if scrollbar type is thin or normal.

    --

    :Parameters:
      `yesno` : int
        flag if thin scrollbar or not. Values 1 (for thin) or 0 (for normal)

    :note: e.g. fl_set_thinscrollbar(1)

    :status: Tested + Doc + NoDemo = OK

    """
    if yesno:
        sbtype = xfdata.FL_THIN_SCROLLBAR
    else:
        sbtype = xfdata.FL_NORMAL_SCROLLBAR
    fl_set_scrollbar_type(sbtype)


def fl_flip_yorigin():
    """Sets the origin of XForms coordinates at the lower-left corner of the
    form (instead of default upper-left corner).

    --

    :note: e.g. fl_flip_yorigin()

    :precondition: to be called before fl_initialize()

    :status: Tested + Doc + Demo = OK

    """
    _fl_flip_yorigin = libr.cfuncproto(
        libr.load_so_libforms(), "fl_flip_yorigin",\
        None, [],\
        """void fl_flip_yorigin()""")
    _fl_flip_yorigin()


def fl_get_coordunit():
    """Obtains the unit used for screen coordinates (e.g. xfdata.FL_COORD_MM,
    xfdata.FL_COORD_centiPOINT, etc..).

    --

    :return: current coordinates unit
    :rtype: int

    :note: e.g. cunit = fl_get_coordunit()

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_coordunit = libr.cfuncproto(
            libr.load_so_libforms(), "fl_get_coordunit",\
            cty.c_int, [],\
            """int fl_get_coordunit()""")
    libr.check_if_initialized()
    retval = _fl_get_coordunit()
    return retval


def fl_get_border_width():
    """Returns the width of border.

    --

    :return: borderwidth (bw)
    :rtype: int

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_border_width = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_border_width",\
        cty.c_int, [],\
        """int fl_get_border_width()""")
    libr.check_if_initialized()
    retval = _fl_get_border_width()
    return retval


# misc. routines

def fl_ringbell(percent):
    """Sounds the keyboard ringbell (if capable). Note that not all
    keyboards support volume variations.

    --

    :Parameters:
      `percent` : int
        volume value for the bell. Values from -100 (minimum, off), to 100
        (max), 0 is default.

    :note: e.g. fl_ringbell(50)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_ringbell = libr.cfuncproto(
        libr.load_so_libforms(), "fl_ringbell",\
        None, [cty.c_int],\
        """void fl_ringbell(int percent)""")
    libr.check_if_initialized()
    ipercent = libr.convert_to_int(percent)
    libr.keep_elem_refs(percent, ipercent)
    _fl_ringbell(ipercent)


def fl_gettime():
    """Returns the current time, expressed in seconds and microseconds since
    1st January 1970, 00:00 GMT. It is most useful for computing time
    differences.

    --

    :return: seconds (secs), microseconds (msecs)
    :rtype: long, long

    :note: e.g. secs, usecs = fl_gettime()

    :attention: API change from XForms - upstream was fl_gettime(sec, usec)

    :status: Tested + Doc + Demo = OK

    """
    _fl_gettime = libr.cfuncproto(
        libr.load_so_libforms(), "fl_gettime",\
        None, [cty.POINTER(cty.c_long), cty.POINTER(cty.c_long)],\
        """void fl_gettime(long int * sec, long int * usec)""")
    libr.check_if_initialized()
    sec, psec = libr.make_long_and_pointer()
    usec, pusec = libr.make_long_and_pointer()
    libr.keep_elem_refs(sec, usec, psec, pusec)
    _fl_gettime(psec, pusec)
    return sec.value, usec.value


def fl_now():
    """Returns a string form of the current date and time. The format of the
    string is of the form "Wed Jun 30 21:49:08 1993"

    --

    :return: current text of date and time
    :rtype: str

    :note: e.g. curdattim = fl_now()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_now = libr.cfuncproto(
        libr.load_so_libforms(), "fl_now",\
        xfdata.STRING, [],\
        """const char * fl_now()""")
    libr.check_if_initialized()
    retval = _fl_now()
    return retval


def fl_whoami():
    """Returns the user name who is running the application.

    --

    :return: text of username
    :rtype: str

    :note: e.g. usertxt = fl_whoami()

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_whoami = libr.cfuncproto(
        libr.load_so_libforms(), "fl_whoami",\
        xfdata.STRING, [],\
        """const char * fl_whoami()""")
    libr.check_if_initialized()
    retval = _fl_whoami()
    return retval


def fl_mouse_button():
    """Returns which mouse button was pushed or released (from xfdata, e.g.
    FL_RIGHT_MOUSE, FL_MIDDLE_MOUSE, etc..). Sometimes an application program
    might need to find out more information about the event that triggered a
    callback, e.g., to implement mouse button number sensitive functionalities.
    This function, if needed, should be called from within a callback. If the
    callback is triggered by a shortcut, the function returns the keysym
    (ascii value if ASCII) of the key plus FL_SHORTCUT. For example, if a
    button has a shortcut <Ctrl>C (ASCII value is 3), the button number
    returned upon activation of the shortcut would be xfdata.FL_SHORTCUT + 3.
    You can use xfdata.FL_SHORTCUT to determine if the callback is triggered
    by a shortcut or not.

    --

    :return: which mouse button was pushed or released
    :rtype: long

    :note: e.g. mousebtn = fl_mouse_button()

    :status: Tested + Doc + Demo = OK

    """
    _fl_mouse_button = libr.cfuncproto(
        libr.load_so_libforms(), "fl_mouse_button",\
        cty.c_long, [],\
        """long int fl_mouse_button()""")
    libr.check_if_initialized()
    retval = _fl_mouse_button()
    return retval


fl_mousebutton = fl_mouse_button


# fl_strdup(strng) function placeholder (low-level)


def fl_set_err_logfp(pFile):
    """Makes the default message handler to log the error to a file instead of
    printing to stderr.

    --

    :Parameters:
      `pFile` : pointer to FILE
        file opened in "w" mode by fl_popen()

    :note: e.g. pfile = fl_popen("myerrlog", "w")
    :note: e.g. fl_set_err_logfp(pfile)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_err_logfp = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_err_logfp",\
        None, [cty.POINTER(xfdata.FILE)],\
        """void fl_set_err_logfp(FILE * fp)""")
    libr.check_if_initialized()
    libr.keep_elem_refs(pFile)
    _fl_set_err_logfp(pFile)


# fl_set_error_logfp placeholder (backwards)


def fl_set_error_handler(py_ErrorFunc):
    """Normally the Forms Library reports errors to stderr. This can be avoided
    or modified by registering an error handling function. The library will
    call the user handler function with a string indicating in which function
    an error occured and a formatting string, followed by zero or more
    arguments. To restore the default handler, call the function again with
    user handler set to None. You can call this function anytime and as many
    times as you wish.

    --

    :Parameters:
      `py_ErrorFunc` : python function for handling error, no return
        function referring to fn(strng, strng)

    :note: e.g. def errhandler(funcnam, errmsg):
    :note: e.g. > print "Error caught in %s: %s." % (funcnam, errmsg)
    :note: e.g. fl_set_error_handler(errhandler)

    :status: Tested + Doc + NoDemo = OK

    """
    #FL_ERROR_FUNC = cty.CFUNCTYPE(None, xfdata.STRING, xfdata.STRING)
    _fl_set_error_handler = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_error_handler",\
        None, [xfdata.FL_ERROR_FUNC],\
        """void fl_set_error_handler(FL_ERROR_FUNC user_func)""")
    libr.check_if_initialized()
    c_ErrorFunc = xfdata.FL_ERROR_FUNC(py_ErrorFunc)
    libr.keep_cfunc_refs(c_ErrorFunc, py_ErrorFunc)
    retval = _fl_set_error_handler(c_ErrorFunc)
    return retval


# maybe pointless as command line args are not supported in python's
# fl_initialize()
# commented as it gives a SegFault
#def fl_get_cmdline_args(numargs):
#    """Returns command line arguments.
#
#    --
#
#    :Parameters:
#      `argnum` : int
#        argument number
#
#    :return: argument
#    :rtype: pointer to str
#
#    :note: e.g. fl_get_cmdline_args(1)
#
#    :status: Untested + Doc + NoDemo = NOT OK

#    """
#    _fl_get_cmdline_args = libr.cfuncproto(
#        libr.load_so_libforms(), "fl_get_cmdline_args",\
#        cty.POINTER(xfdata.STRING), [cty.POINTER(cty.c_int)],\
#        """char * * fl_get_cmdline_args(int * p1)""")
#    libr.check_if_initialized()
#    pnumargs = cty.cast(numargs, cty.POINTER(cty.c_int))
#    libr.keep_elem_refs(numargs, pnumargs)
#    retval = _fl_get_cmdline_args(pnumargs)
#    return retval


# fl_free function placeholder (low-level)
# fl_malloc function placeholder (low-level)
# fl_calloc function placeholder (low-level)
# fl_realloc function placeholder (low-level)


def fl_msleep(msec):
    """Waits for a number of milliseconds (with the best resolution possible
    on your system).

    --

    :Parameters:
     `msec` : long
       milliseconds to sleep

    :return: 0 (on success)
    :rtype: int

    :note: e.g. fl_msleep(200)

    :status: Tested + Doc + Demo = OK

    """
    _fl_msleep = libr.cfuncproto(
        libr.load_so_libforms(), "fl_msleep",\
        cty.c_int, [cty.c_ulong],\
        """int fl_msleep(long unsigned int msec)""")
    libr.check_if_initialized()
    ulmsec = libr.convert_to_ulong(msec)
    libr.keep_elem_refs(msec, ulmsec)
    retval = _fl_msleep(ulmsec)
    return retval


def fl_is_same_object(pFlObject1, pFlObject2):
    """Does a comparison between two objects, if they are the same, or not.

    --

    :Parameters:
      `pFlObject1` : pointer to xfdata.FL_OBJECT
        1st object to compare
      `pFlObject2` : pointer to xfdata.FL_OBJECT
        2nd object to compare

    :return: 0 (if they are different) or non-zero (if they are the same)
    :rtype: int

    :note: e.g. if fl_is_same_object(pobj, pexitobj): ...

    :status: Tested + Doc + Demo = OK

    """
    _fl_is_same_object = libr.cfuncproto(
        libr.load_so_libforms(), "fl_is_same_object", \
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT),
        cty.POINTER(xfdata.FL_OBJECT)], \
        """int fl_is_same_object(FL_OBJECT * obj1, FL_OBJECT * obj2)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject1)
    libr.verify_flobjectptr_type(pFlObject2)
    libr.keep_elem_refs(pFlObject1, pFlObject2)
    retval = _fl_is_same_object(pFlObject1, pFlObject2)
    return retval
