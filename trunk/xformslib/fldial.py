#!/usr/bin/env python
# -*- coding: iso8859-1 -*-

"""
    fldial.py - Functions to manage dial objects.

    Copyright (C) 2009, 2010  Luca Lazzaroni "LukenShiro"
    e-mail: <lukenshiro@ngi.it>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, version 2.1 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU LGPL along with this
    program. If not, see <http://www.gnu.org/licenses/>.

    See CREDITS file to read acknowledgements and thanks to XForms,
    ctypes and other developers.
"""


# originally generated by 'h2xml+gccxml' and 'xml2py'
# then heavily reordered and reworked

# ############################################# #
# Interface to XForms shared object libraries   #
# ############################################# #


import ctypes as cty
from xformslib import library as libr
from xformslib import xfdata



###################
# forms.h (dial.h)
###################

# Routines

# fl_create_dial function placeholder (internal)


def fl_add_dial(dialtype, x, y, w, h, label):
    """Adds a dial object to the form.

    --

    :Parameters:
      `dialtype` : int
        type of dial to be added. Values (from xfdata.py) FL_NORMAL_DIAL,
        FL_LINE_DIAL, FL_FILL_DIAL
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `label` : str
        text label of dial

    :return: dial object added (pFlObject)
    :rtype: pointer to xfdata.FL_OBJECT

    :note: e.g. fl_add_dial(xfdata.FL_LINE_DIAL, 140, 120, 123, 521, "MyDial")

    :status: Tested + Doc + Demo = OK

    """
    _fl_add_dial = libr.cfuncproto(
        libr.load_so_libforms(), "fl_add_dial",
        cty.POINTER(xfdata.FL_OBJECT), [cty.c_int, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.STRING],
        """FL_OBJECT * fl_add_dial(int type, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, const char * label)""")
    libr.check_if_initialized()
    libr.check_admitted_listvalues(dialtype, xfdata.DIALTYPE_list)
    idialtype = libr.convert_to_int(dialtype)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    slabel = libr.convert_to_string(label)
    libr.keep_elem_refs(dialtype, x, y, w, h, label, idialtype, ix, iy,
                   iw, ih, slabel)
    retval = _fl_add_dial(idialtype, ix, iy, iw, ih, slabel)
    return retval


def fl_set_dial_value(pFlObject, val):
    """Sets the value of a dial object. By default the value is 0.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        dial object
      `val` : float
        value of dial to be set

    :note: e.g. fl_set_dial_value(dialobj, 155.0)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_dial_value = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_dial_value",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_double],
        """void fl_set_dial_value(FL_OBJECT * ob, double val)""")
    libr.check_if_initialized()
    libr.check_if_FL_OBJECT_ptr(pFlObject)
    fval = libr.convert_to_double(val)
    libr.keep_elem_refs(pFlObject, val, fval)
    _fl_set_dial_value(pFlObject, fval)


def fl_get_dial_value(pFlObject):
    """Obtains the current value of a dial object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        dial object

    :return: current value of dial
    :rtype: float

    :note: e.g. currval = fl_get_dial_value(dialobj)

    :status: Tested + Doc + Demo = OK

    """
    _fl_get_dial_value = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_dial_value",
        cty.c_double, [cty.POINTER(xfdata.FL_OBJECT)],
        """double fl_get_dial_value(FL_OBJECT * ob)""")
    libr.check_if_initialized()
    libr.check_if_FL_OBJECT_ptr(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_dial_value(pFlObject)
    return retval


def fl_set_dial_bounds(pFlObject, minbound, maxbound):
    """Sets the minimum and the maximum values of a dial object. By default,
    the minimum value is 0.0, the maximum is 1.0.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        dial object
      `minbound` : float
        minimum value of dial
      `maxbound` : float
        maximum value of dial

    :note: e.g. fl_set_dial_bounds(dialobj, 0, 200)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_dial_bounds = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_dial_bounds",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_double, cty.c_double],
        """void fl_set_dial_bounds(FL_OBJECT * ob, double min,
           double max)""")
    libr.check_if_initialized()
    libr.check_if_FL_OBJECT_ptr(pFlObject)
    fminbound = libr.convert_to_double(minbound)
    fmaxbound = libr.convert_to_double(maxbound)
    libr.keep_elem_refs(pFlObject, minbound, maxbound, fminbound, fmaxbound)
    _fl_set_dial_bounds(pFlObject, fminbound, fmaxbound)


def fl_get_dial_bounds(pFlObject):
    """Obtains the minimum and maximum values of a dial object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        dial object

    :return: minimum value, maximum value of dial
    :rtype: float, float

    :note: e.g. minb, maxb = fl_get_dial_bounds(dialobj)

    :attention: API change from XForms - upstream was
        fl_get_dial_bounds(pFlObject, minbound, maxbound)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_get_dial_bounds = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_dial_bounds",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(cty.c_double),
        cty.POINTER(cty.c_double)],
        """void fl_get_dial_bounds(FL_OBJECT * ob, double * min,
           double * max)""")
    libr.check_if_initialized()
    libr.check_if_FL_OBJECT_ptr(pFlObject)
    minbound, pminbound = libr.make_double_and_pointer()
    maxbound, pmaxbound = libr.make_double_and_pointer()
    libr.keep_elem_refs(pFlObject, minbound, maxbound, pminbound, pmaxbound)
    _fl_get_dial_bounds(pFlObject, pminbound, pmaxbound)
    return minbound.value, maxbound.value


def fl_set_dial_step(pFlObject, step):
    """Sets the dial value to be rounded to a specified step or a
    multiple of it.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        dial object
      `step` : float
        rounding value to be set. Use 0.0 for step to switch off rounding

    :note: e.g. fl_set_dial_step(dialobj, 2)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_dial_step = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_dial_step",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_double],
        """void fl_set_dial_step(FL_OBJECT * ob, double value)""")
    libr.check_if_initialized()
    libr.check_if_FL_OBJECT_ptr(pFlObject)
    fstep = libr.convert_to_double(step)
    libr.keep_elem_refs(pFlObject, step, fstep)
    _fl_set_dial_step(pFlObject, fstep)


def fl_set_dial_return(pFlObject, when):
    """Sets the conditions under which a dial object gets returned (or
    its callback invoked).

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        dial object
      `when` : int_pos
        return type (when it returns). Values (from xfdata.py) FL_RETURN_NONE,
        FL_RETURN_CHANGED, FL_RETURN_END, FL_RETURN_END_CHANGED,
        FL_RETURN_SELECTION, FL_RETURN_DESELECTION, FL_RETURN_TRIGGERED,
        FL_RETURN_ALWAYS

    :note: e.g. fl_set_dial_return(dialobj, xfdata.FL_RETURN_END)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_dial_return = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_dial_return",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_uint],
        """void fl_set_dial_return(FL_OBJECT * ob, unsigned
           int value)""")
    libr.check_if_initialized()
    libr.check_if_FL_OBJECT_ptr(pFlObject)
    libr.check_admitted_listvalues(when, xfdata.RETURN_list)
    uiwhen = libr.convert_to_uint(when)
    libr.keep_elem_refs(pFlObject, when, uiwhen)
    _fl_set_dial_return(pFlObject, uiwhen)


def fl_set_dial_angles(pFlObject, angmin, angmax):
    """Limits the angular range a dial can take or choose an angle other
    than 0 to represent the minimum value. The angles are relative to the
    origin of the dial, which is by default at 6 o'clock and rotates
    clock-wise. By default, the minimum angle is 0 and the maximum angle
    is 360.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        dial object
      `angmin` : float
        minimum value of angle
      `angmax` : float
        maximum value of angle

    :note: e.g. fl_set_dial_angles(dialobj, 45, 180)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_dial_angles = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_dial_angles",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_double, cty.c_double],
        """void fl_set_dial_angles(FL_OBJECT * ob, double amin,
           double amax)""")
    libr.check_if_initialized()
    libr.check_if_FL_OBJECT_ptr(pFlObject)
    fangmin = libr.convert_to_double(angmin)
    fangmax = libr.convert_to_double(angmax)
    libr.keep_elem_refs(pFlObject, angmin, angmax, fangmin, fangmax)
    _fl_set_dial_angles(pFlObject, fangmin, fangmax)


def fl_set_dial_cross(pFlObject, yesno):
    """Allows crossing over of dial object. By default, crossing from
    359.9 to 0 or from 0 to 359.9 is not allowed.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        dial object
      `yesno` : int
        flag to enable/disable crossover. Values 1 (enabled) or 0 (disabled)

    :note: e.g. fl_set_dial_cross(dialobj, 1)

    :status: Tested + Doc + NoDemo = OK

    """
    _fl_set_dial_cross = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_dial_cross",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_set_dial_cross(FL_OBJECT * ob, int flag)""")
    libr.check_if_initialized()
    libr.check_if_FL_OBJECT_ptr(pFlObject)
    iyesno = libr.convert_to_int(yesno)
    libr.keep_elem_refs(pFlObject, yesno, iyesno)
    _fl_set_dial_cross(pFlObject, iyesno)


fl_set_dial_crossover = fl_set_dial_cross


def fl_set_dial_direction(pFlObject, directn):
    """Changes what rotation modifies dial value. By default, clock-wise
    rotation increases the dial value.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        dial object
      `directn` : int
        direction of dial rotation. Values (from xfdata.py) FL_DIAL_CCW
        (counter-clock-wise) or FL_DIAL_CW (clock-wise)

    :note: e.g. fl_set_dial_direction(dialobj, xfdata.FL_DIAL_CCW)

    :status: Tested + Doc + Demo = OK

    """
    _fl_set_dial_direction = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_dial_direction",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_set_dial_direction(FL_OBJECT * ob, int dir)""")
    libr.check_if_initialized()
    libr.check_if_FL_OBJECT_ptr(pFlObject)
    libr.check_admitted_listvalues(directn, xfdata.DIALROTN_list)
    idirectn = libr.convert_to_int(directn)
    libr.keep_elem_refs(pFlObject, directn, idirectn)
    _fl_set_dial_direction(pFlObject, idirectn)

