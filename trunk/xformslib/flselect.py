#!/usr/bin/env python
# -*- coding: iso8859-1 -*-

""" xforms-python's functions to manage select objects.

    Copyright (C) 2009, 2010  Luca Lazzaroni "LukenShiro"
    e-mail: <lukenshiro@ngi.it>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, version 2.1 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU LGPL along with this
    program. If not, see <http://www.gnu.org/licenses/>.

    See CREDITS file to read acknowledgements and thanks to XForms,
    ctypes and other developers.
"""


# originally generated by 'h2xml+gccxml' and 'xml2py'
# then heavily reordered and reworked

# ############################################# #
# Interface to XForms shared object libraries   #
# ############################################# #


import ctypes as cty
from xformslib import library as libr
from xformslib import xfdata


#####################
# forms.h (select.h)
#####################

# Select object types

# fl_create_select function placeholder (internal)


def fl_add_select(selecttype, x, y, w, h, label):
    """Adds a select (new generation choice) object to the form. It is a
    rather simple object that allows the user to pick alternatives from a
    linear list that pops up when he clicks on the object. It remembers the
    last selected item, which is also shown on top of the select object. It
    internally uses a popup.

    --

    :Parameters:
      `selecttype` : int
        type of select to be added. Values (from xfdata.py) FL_NORMAL_SELECT,
        FL_MENU_SELECT, FL_DROPLIST_SELECT
      `x` : int
        horizontal position (upper-left corner)
      `y` : int
        vertical position (upper-left corner)
      `w` : int
        width in coord units
      `h` : int
        height in coord units
      `label` : str
        text label of select

    :return: select object added (pFlObject)
    :rtype: pointer to xfdata.FL_OBJECT

    :note: e.g. *todo*

    :status: Tested + NoDoc + Demo = OK

    """
    _fl_add_select = libr.cfuncproto(
        libr.load_so_libforms(), "fl_add_select",
        cty.POINTER(xfdata.FL_OBJECT), [cty.c_int, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.STRING],
        """FL_OBJECT * fl_add_select(int p1, FL_Coord p2, FL_Coord p3,
           FL_Coord p4, FL_Coord p5, const char * p6)""")
    libr.check_if_initialized()
    libr.checkfatal_allowed_value_in_list(selecttype, xfdata.SELECTTYPE_list)
    iselecttype = libr.convert_to_int(selecttype)
    ix = libr.convert_to_FL_Coord(x)
    iy = libr.convert_to_FL_Coord(y)
    iw = libr.convert_to_FL_Coord(w)
    ih = libr.convert_to_FL_Coord(h)
    slabel = libr.convert_to_string(label)
    libr.keep_elem_refs(selecttype, x, y, w, h, label, iselecttype, ix, iy,
                   iw, ih, slabel)
    retval = _fl_add_select(iselecttype, ix, iy, iw, ih, slabel)
    return retval


def fl_clear_select(pFlObject):
    """Removes all items from a select object. If you used
    fl_set_select_popup() to set a popup for the select object then that
    popup gets deleted automatically on calling fl_clear_select(). The
    values automatically associated with items when calling
    fl_add_select_items() will start at 0 again.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_clear_select = libr.cfuncproto(
        libr.load_so_libforms(), "fl_clear_select",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],
        """int fl_clear_select(FL_OBJECT * p1)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    _fl_clear_select(pFlObject)


def fl_add_select_items(pFlObject, entryitems_txt):
    """Adds one or more items to a select object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object
      `entryitems_txt` : str
        text of the entry to be added and in-text special sequences with or
        without not separated additional arguments (if needed). Text may
        contain `|` to separate entries and newline characters which allows
        to create entries that span more than a single line. Only some special
        sequences are allowed: %x, %u, %f, %E, %L, %d, %h, %S, %s, %% (other
        combinations don't make sense here). *to be verified!*

    :return: popup entry (pPopupEntry)
    :rtype: pointer to xfdata.FL_POPUP_ENTRY

    :see: `Special sequences in entry text` documentation.

    :note: e.g. *todo*

    :status: HalfTested + NoDoc + Demo = NOT OK (sequence param.)

    """
    _fl_add_select_items = libr.cfuncproto(
        libr.load_so_libforms(), "fl_add_select_items",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
        xfdata.STRING],
        """FL_POPUP_ENTRY * fl_add_select_items(FL_OBJECT * p1,
           const char * p2, ...)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    sentryitems_txt = libr.convert_to_string(entryitems_txt)
    libr.keep_elem_refs(pFlObject, entryitems_txt, sentryitems_txt)
    retval = _fl_add_select_items(pFlObject, sentryitems_txt)
    return retval
#      `entryitems_txtlst` : list_of_str_and_any_type
#        list representing the text of the entry to be added and in-text
#        special sequences with or without separate or not separated additional
#        arguments (if needed). Text may contain `|` to separate entries and
#        newline characters which allows to create entries that span more than
#        a single line. Only some special sequences are allowed: %x, %u, %f,
#        %E, %L, %d, %h, %S, %s, %% (other combinations don't make sense here).
#        Up to 20 additional separated arguments are supported in xforms-python
#        currently, only.
#   _fl_add_select_items = libr.cfuncproto(
#        libr.load_so_libforms(), "fl_add_select_items",
#        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
#        xfdata.STRING, cty.c_void_p, cty.c_void_p, cty.c_void_p, cty.c_void_p,
#        cty.c_void_p, cty.c_void_p, cty.c_void_p, cty.c_void_p, cty.c_void_p,
#        cty.c_void_p, cty.c_void_p, cty.c_void_p, cty.c_void_p, cty.c_void_p,
#        cty.c_void_p, cty.c_void_p, cty.c_void_p, cty.c_void_p, cty.c_void_p,
#        cty.c_void_p],
#        """FL_POPUP_ENTRY * fl_add_select_items(FL_OBJECT * p1,
#           const char * p2, ...)""")
#    libr.check_if_initialized()
#    libr.verify_flobjectptr_type(pFlObject)
#    # first str + 20 additional args max
#    tmpentryitems_txtlst, finalentryitems_txtlst = \
#        libr.create_argslist_for_entrytxt(entryitems_txtlst, 21)
#    libr.keep_elem_refs(pFlObject, entryitems_txtlst, tmpentryitems_txtlst, \
#                        finalentryitems_txtlst)
#    retval = _fl_add_select_items(pFlObject, *finalentryitems_txtlst)
#    return retval


def fl_insert_select_items(pFlObject, pPopupEntry, entryitems_txt):
    """Inserts new items somewhere in the middle of a list of already
    existing items.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry. If it's 'None' new items are inserted at the very start.
      `entryitems_txt` : str
        text of the entry to be added and in-text special sequences with or
        without not separated additional arguments (if needed). Text may
        contain `|` to separate entries and newline characters which allows
        to create entries that span more than a single line. Only some special
        sequences are allowed: %x, %u, %f, %E, %L, %d, %h, %S, %s (other
        combinations don't make sense here).

    :return: popup entry
    :rtype: pointer to xfdata.FL_POPUP_ENTRY

    :see: `Special sequences in entry text` documentation.

    :note: e.g. *todo*

    :status: HalfTested + NoDoc + Demo = NOT OK (special sequence)

    """
    _fl_insert_select_items = libr.cfuncproto(
        libr.load_so_libforms(), "fl_insert_select_items",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
        cty.POINTER(xfdata.FL_POPUP_ENTRY), xfdata.STRING],
        """FL_POPUP_ENTRY * fl_insert_select_items(FL_OBJECT * p1,
           FL_POPUP_ENTRY * p2, const char * p3, ...)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.verify_flpopupentryptr_type(pPopupEntry)
    sentryitems_txt = libr.convert_to_string(entryitems_txt)
    libr.keep_elem_refs(pFlObject, pPopupEntry, entryitems_txt, \
                        sentryitems_txt)
    retval = _fl_insert_select_items(pFlObject, pPopupEntry, sentryitems_txt)
    return retval


def fl_replace_select_item(pFlObject, pPopupEntry, entryitems_txt):
    """Replaces an existing item of a select object with another.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry
      `entryitems_txt` : str
        text of the entry to be added and in-text special sequences with or 
        without not separated additional arguments (if needed). Text may
        contain `|` to separate entries and newline characters which allows
        to create entries that span more than a single line. Only some special
        sequences are allowed: %x, %u, %f, %E, %L, %d, %h, %S, %s (other
        combinations don't make sense here).

    :return: popup entry
    :rtype: pointer to xfdata.FL_POPUP_ENTRY

    :see: `Special sequences in entry text` documentation.

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_replace_select_item = libr.cfuncproto(
        libr.load_so_libforms(), "fl_replace_select_item",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
        cty.POINTER(xfdata.FL_POPUP_ENTRY), xfdata.STRING],
        """FL_POPUP_ENTRY * fl_replace_select_item(FL_OBJECT * p1,
            FL_POPUP_ENTRY * p2, const char * p3, ...)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.verify_flpopupentryptr_type(pPopupEntry)
    sentryitems_txt = libr.convert_to_string(entryitems_txt)
    libr.keep_elem_refs(pFlObject, pPopupEntry, entryitems_txt, \
                        sentryitems_txt)
    retval = _fl_replace_select_item(pFlObject, pPopupEntry, sentryitems_txt)
    return retval


def fl_delete_select_item(pFlObject, pPopupEntry):
    """Deletes an item of a select object. The values associated with items
    will not change due to removing an item.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_delete_select_item = libr.cfuncproto(
        libr.load_so_libforms(), "fl_delete_select_item",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT),
        cty.POINTER(xfdata.FL_POPUP_ENTRY)],
        """int fl_delete_select_item(FL_OBJECT * p1, FL_POPUP_ENTRY * p2)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject, pPopupEntry)
    retval = _fl_delete_select_item(pFlObject, pPopupEntry)
    return retval


def fl_set_select_items(pFlObject, pPopupItem):
    """(Re)populates a select object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object
      `pPopupItem` : pointer to xfdata.FL_POPUP_ITEM
        popup item class instance (array of it)

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_select_items = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_select_items",
        cty.c_long, [cty.POINTER(xfdata.FL_OBJECT),
        cty.POINTER(xfdata.FL_POPUP_ITEM)],
        """long int fl_set_select_items(FL_OBJECT * p1,
           FL_POPUP_ITEM * p2)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.verify_flpopupitemptr_type(pPopupItem)
    libr.keep_elem_refs(pFlObject, pPopupItem)
    retval = _fl_set_select_items(pFlObject, pPopupItem)
    return retval


def fl_get_select_popup(pFlObject):
    """Finds out which item of a select object is currently selected.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object

    :return: popup class instance
    :rtype: pointer to xfdata.FL_POPUP

    :note: e.g. *todo*

    :status: Tested + NoDoc + Demo = OK

    """
    _fl_get_select_popup = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_select_popup",
        cty.POINTER(xfdata.FL_POPUP), [cty.POINTER(xfdata.FL_OBJECT)],
        """FL_POPUP * fl_get_select_popup(FL_OBJECT * p1)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_select_popup(pFlObject)
    return retval


def fl_set_select_popup(pFlObject, pPopup):
    """Creates a popup directly and then associates it with the select object.
    Supplied popup may not contain any entries other than those of type
    xfdata.FL_POPUP_NORMAL (and, of course, the popup can't be a sub-popup
    of another popup)

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object
      `pPopup` : pointer to xfdata.FL_POPUP
        popup class instance

    :return: num.
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_select_popup = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_select_popup",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT),
        cty.POINTER(xfdata.FL_POPUP)],
        """int fl_set_select_popup(FL_OBJECT * p1, FL_POPUP * p2)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.verify_flpopupptr_type(pPopup)
    libr.keep_elem_refs(pFlObject, pPopup)
    retval = _fl_set_select_popup(pFlObject, pPopup)
    return retval


def fl_get_select_item(pFlObject):
    """Obtains currently selected item of a select object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object

    :return: popup return
    :rtype: pointer to xfdata.FL_POPUP_RETURN

    :note: e.g. *todo*

    :status: Tested + NoDoc + Demo = OK

    """
    _fl_get_select_item = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_select_item",
        cty.POINTER(xfdata.FL_POPUP_RETURN), [cty.POINTER(xfdata.FL_OBJECT)],
        """FL_POPUP_RETURN * fl_get_select_item(FL_OBJECT * p1)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_select_item(pFlObject)
    return retval


def fl_set_select_item(pFlObject, pPopupEntry):
    """Sets a new item of a select object as currently selected.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object
      `pPopupEntry` : pointer to xfdata.FL_POPUP_ENTRY
        popup entry class instance

    :return: popup return
    :rtype: pointer to xfdata.FL_POPUP_RETURN

    :note: e.g. *todo*

    :status: HalfTested + NoDoc + Demo = NOT OK (FL_POPUP_ENTRY not prepared)

    """
    _fl_set_select_item = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_select_item",
        cty.POINTER(xfdata.FL_POPUP_RETURN), [cty.POINTER(xfdata.FL_OBJECT),
        cty.POINTER(xfdata.FL_POPUP_ENTRY)],
        """FL_POPUP_RETURN * fl_set_select_item(FL_OBJECT * p1,
           FL_POPUP_ENTRY * p2)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.verify_flpopupentryptr_type(pPopupEntry)
    libr.keep_elem_refs(pFlObject, pPopupEntry)
    retval = _fl_set_select_item(pFlObject, pPopupEntry)
    return retval


def fl_get_select_item_by_value(pFlObject, value):
    """Finds the first item of select object with the value associated with
    the item.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object
      `value` : long
        value of the select item.

    :return: popup entry class instance, or None (on failure)
    :rtype: pointer to xfdata.FL_POPUP_ENTRY

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_get_select_item_by_value = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_select_item_by_value",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
        cty.c_long],
        """FL_POPUP_ENTRY * fl_get_select_item_by_value(FL_OBJECT * p1,
           long int p2)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    lvalue = libr.convert_to_long(value)
    libr.keep_elem_refs(pFlObject, value, lvalue)
    retval = _fl_get_select_item_by_value(pFlObject, lvalue)
    return retval


def fl_get_select_item_by_label(pFlObject, label):
    """Finds out an item of select object who has a certain label as
    displayed for the item in the popup.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object
      `label` : str
        label of the item.

    :return: popup entry class instance
    :rtype: pointer to xfdata.FL_POPUP_ENTRY

    :note: e.g. *todo*

    :status: Tested + NoDoc + Demo = OK

    """
    _fl_get_select_item_by_label = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_select_item_by_label",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
        xfdata.STRING],
        """FL_POPUP_ENTRY * fl_get_select_item_by_label(FL_OBJECT * p1,
           const char * p2)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    slabel = libr.convert_to_string(label)
    libr.keep_elem_refs(pFlObject, label, slabel)
    retval = _fl_get_select_item_by_label(pFlObject, slabel)
    return retval


def fl_get_select_item_by_text(pFlObject, txtstr):
    """Finds out an item of select object who has supplied text (that might
    be the same as the label text in simple cases).

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object
      `txtstr` : str
        text of the item.

    :return: popup entry class instance
    :rtype: pointer to xfdata.FL_POPUP_ENTRY

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_get_select_item_by_text = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_select_item_by_text",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
        xfdata.STRING],
        """FL_POPUP_ENTRY * fl_get_select_item_by_text(FL_OBJECT * p1,
           const char * p2)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    stxtstr = libr.convert_to_string(txtstr)
    libr.keep_elem_refs(pFlObject, txtstr, stxtstr)
    retval = _fl_get_select_item_by_text(pFlObject, stxtstr)
    return retval


def fl_get_select_text_color(pFlObject):
    """Obtains the color of the text of the currenty selected item on top of
    the object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object

    :return: color
    :rtype: long_pos

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_get_select_text_color = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_select_text_color",
        xfdata.FL_COLOR, [cty.POINTER(xfdata.FL_OBJECT)],
        """FL_COLOR fl_get_select_text_color(FL_OBJECT * p1)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_select_text_color(pFlObject)
    return retval


def fl_set_select_text_color(pFlObject, colr):
    """Sets the color of the text of the currenty selected item on top of
    the object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object
      `colr` : long_pos
        color value

    :return: previous color
    :rtype: long_pos

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_select_text_color = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_select_text_color",
        xfdata.FL_COLOR, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_COLOR],
        """FL_COLOR fl_set_select_text_color(FL_OBJECT * p1, FL_COLOR p2)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ulcolr = libr.convert_to_FL_COLOR(colr)
    libr.keep_elem_refs(pFlObject, colr, ulcolr)
    retval = _fl_set_select_text_color(pFlObject, ulcolr)
    return retval


def fl_get_select_text_font(pFlObject):
    """Obtains the font style and size used for the text of a select object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object

    :return: 0 or -1 (on failure), style, size
    :rtype: int, int, int

    :note: e.g. *todo*

    :attention: API change from XForms - upstream was
        fl_get_select_text_font(pFlObject, p2, p3)

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_get_select_text_font = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_select_text_font",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(cty.c_int),
        cty.POINTER(cty.c_int)],
        """int fl_get_select_text_font(FL_OBJECT * p1, int * p2, int * p3)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    style, pstyle = libr.make_int_and_pointer()
    size, psize = libr.make_int_and_pointer()
    libr.keep_elem_refs(pFlObject, style, pstyle, size, psize)
    retval = _fl_get_select_text_font(pFlObject, pstyle, psize)
    return retval, style.value, size.value


def fl_set_select_text_font(pFlObject, style, size):
    """Sets the font style and size used for the text of a select object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object
      `style` : int
        text style. Values (from xfdata.py) FL_NORMAL_STYLE,
        FL_BOLD_STYLE, FL_ITALIC_STYLE, FL_BOLDITALIC_STYLE, FL_FIXED_STYLE,
        FL_FIXEDBOLD_STYLE, FL_FIXEDITALIC_STYLE, FL_FIXEDBOLDITALIC_STYLE,
        FL_TIMES_STYLE, FL_TIMESBOLD_STYLE, FL_TIMESITALIC_STYLE,
        FL_TIMESBOLDITALIC_STYLE, FL_MISC_STYLE, FL_MISCBOLD_STYLE,
        FL_MISCITALIC_STYLE, FL_SYMBOL_STYLE, FL_SHADOW_STYLE,
        FL_ENGRAVED_STYLE, FL_EMBOSSED_STYLE
      `size` : int
        text size. Values (from xfdata.py) FL_TINY_SIZE, FL_SMALL_SIZE,
        FL_NORMAL_SIZE, FL_MEDIUM_SIZE, FL_LARGE_SIZE, FL_HUGE_SIZE,
        FL_DEFAULT_SIZE

    :return: 0, or -1 (on failure)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_select_text_font = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_select_text_font",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int, cty.c_int],
        """int fl_set_select_text_font(FL_OBJECT * p1, int p2, int p3)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.checkfatal_allowed_value_in_list(style, xfdata.TEXTSTYLE_list)
    libr.checknonfatal_allowed_value_in_list(size, xfdata.FONTSIZE_list)
    istyle = libr.convert_to_int(style)
    isize = libr.convert_to_int(size)
    libr.keep_elem_refs(pFlObject, style, size, istyle, isize)
    retval = _fl_set_select_text_font(pFlObject, istyle, isize)
    return retval


def fl_get_select_text_align(pFlObject):
    """Obtains the alignment of the text with the currently selected item
    on top of the select object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object

    :return: alignment
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_get_select_text_align = libr.cfuncproto(
        libr.load_so_libforms(), "fl_get_select_text_align",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],
        """int fl_get_select_text_align(FL_OBJECT * p1)""")
    libr.check_if_initialized()
    libr.verify_flobjectptr_type(pFlObject)
    libr.keep_elem_refs(pFlObject)
    retval = _fl_get_select_text_align(pFlObject)
    return retval


def fl_set_select_text_align(pFlObject, align):
    """Sets the alignment of the text with the currently selected item on
    top of the select object. The xfdata.FL_ALIGN_INSIDE flag should be set
    with align since the text always will be drawn withing the boundaries of
    the object.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object
      `align` : int
        alignment of text. Values (from xfdata.py) FL_ALIGN_CENTER,
        FL_ALIGN_TOP, FL_ALIGN_BOTTOM, FL_ALIGN_LEFT, FL_ALIGN_RIGHT,
        FL_ALIGN_LEFT_TOP, FL_ALIGN_RIGHT_TOP, FL_ALIGN_LEFT_BOTTOM,
        FL_ALIGN_RIGHT_BOTTOM, FL_ALIGN_INSIDE, FL_ALIGN_VERT.
        Bitwise OR with FL_ALIGN_INSIDE is allowed.

    :return: old setting of alignment, or -1 (on errors)
    :rtype: int

    :note: e.g. *todo*

    :status: Untested + NoDoc + NoDemo = NOT OK

    """
    _fl_set_select_text_align = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_select_text_align",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """int fl_set_select_text_align(FL_OBJECT * p1, int p2)""")
    libr.check_if_initialized()
    libr.checkfatal_allowed_value_in_list(align, xfdata.ALIGN_list)
    libr.verify_flobjectptr_type(pFlObject)
    ialign = libr.convert_to_int(align)
    libr.keep_elem_refs(pFlObject, align, ialign)
    retval = _fl_set_select_text_align(pFlObject, ialign)
    return retval


def fl_set_select_policy(pFlObject, policy):
    """Sets a policy of a select object. By default, the popup of a select
    objects remains shown when the user releases the mouse somewhere outside
    the popup window (or on its title area). The alternative is to close the
    popup immediately when the user releases the mouse, independent of where
    it is.

    --

    :Parameters:
      `pFlObject` : pointer to xfdata.FL_OBJECT
        select object
      `policy` : int
        popup policy to be set. Values (from xfdata.py) FL_POPUP_NORMAL_SELECT,
        FL_POPUP_DRAG_SELECT.

    :return: previous policy setting, or -1 (on error)
    :rtype: int

    :note: e.g. *todo*

    :status: Tested + NoDoc + Demo = OK

    """
    _fl_set_select_policy = libr.cfuncproto(
        libr.load_so_libforms(), "fl_set_select_policy",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """int fl_set_select_policy(FL_OBJECT * p1, int p2)""")
    libr.check_if_initialized()
    libr.checkfatal_allowed_value_in_list(policy, xfdata.POPUPPOLICY_list)
    libr.verify_flobjectptr_type(pFlObject)
    ipolicy = libr.convert_to_int(policy)
    libr.keep_elem_refs(pFlObject, policy, ipolicy)
    retval = _fl_set_select_policy(pFlObject, ipolicy)
    return retval
