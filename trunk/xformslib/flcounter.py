#!/usr/bin/env python
# -*- coding: iso8859-1 -*-

"""
    xforms-python - Python wrapper for XForms (X11) GUI C toolkit library
    using ctypes

    Copyright (C) 2009, 2010  Luca Lazzaroni "LukenShiro"
    e-mail: <lukenshiro@ngi.it>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation, version 2.1 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU LGPL along with this
    program. If not, see <http://www.gnu.org/licenses/>.

    See CREDITS file to read acknowledgements and thanks to XForms,
    ctypes and other developers.
"""


# originally generated by 'h2xml+gccxml' and 'xml2py'
# then heavily reordered and reworked

# ############################################# #
# Interface to XForms shared object libraries   #
# ############################################# #


import ctypes as cty
from xformslib import library
from xformslib import xfdata



######################
# forms.h (counter.h)
######################

# Routines

# fl_create_counter function placeholder (internal)


def fl_add_counter(countertype, x, y, w, h, label):
    """Adds a counter object.

    @param countertype: type of counter to be added. Values (from xfdata
        module) FL_NORMAL_COUNTER, FL_SIMPLE_COUNTER
    @type countertype: int
    @param x: horizontal position (upper-left corner)
    @type x: int
    @param y: vertical position (upper-left corner)
    @type y: int
    @param w: width in coord units
    @type w: int
    @param h: height in coord units
    @type h: int
    @param label: text label of counter
    @type label: str

    @returns: counter object added (pFlObject)
    @rtype: pointer to xfdata.FL_OBJECT

    @example: ctrobj = fl_add_counter(FL_NORMAL_COUNTER, 142, 230, 142, 
        100, "My Counter")

    @status: Tested + Doc + Demo = OK

    """
    _fl_add_counter = library.cfuncproto(
        library.load_so_libforms(), "fl_add_counter",
        cty.POINTER(xfdata.FL_OBJECT), [cty.c_int, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.STRING],
        """FL_OBJECT * fl_add_counter(int type, FL_Coord x, FL_Coord y,
           FL_Coord w, FL_Coord h, const char * label)""")
    library.check_if_initialized()
    library.check_admitted_listvalues(countertype, xfdata.COUNTERTYPE_list)
    icountertype = library.convert_to_int(countertype)
    ix = library.convert_to_FL_Coord(x)
    iy = library.convert_to_FL_Coord(y)
    iw = library.convert_to_FL_Coord(w)
    ih = library.convert_to_FL_Coord(h)
    slabel = library.convert_to_string(label)
    library.keep_elem_refs(countertype, x, y, w, h, label, icountertype, ix, iy,
                   iw, ih, slabel)
    retval = _fl_add_counter(icountertype, ix, iy, iw, ih, slabel)
    return retval


def fl_set_counter_value(pFlObject, val):
    """Sets the value of the counter (default is 0).

    @param pFlObject: counter object
    @type pFlObject: pointer to xfdata.FL_OBJECT

    @example: fl_set_counter_value(ctrobj, 42.0)

    @status: Tested + Doc + Demo = OK

    """
    _fl_set_counter_value = library.cfuncproto(
        library.load_so_libforms(), "fl_set_counter_value",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_double],
        """void fl_set_counter_value(FL_OBJECT * ob, double val)""")
    library.check_if_initialized()
    library.check_if_FL_OBJECT_ptr(pFlObject)
    fval = library.convert_to_double(val)
    library.keep_elem_refs(pFlObject, val, fval)
    _fl_set_counter_value(pFlObject, fval)


def fl_set_counter_bounds(pFlObject, minbound, maxbound):
    """Sets the minimum and maximum values that the counter will take (default
    are -1000000 and 1000000, respectively). For conficting settings bound
    take precedence over value.

    @param pFlObject: counter object
    @type pFlObject: pointer to xfdata.FL_OBJECT
    @param minbound: minimum value to be set
    @type minbound: float
    @param maxbound: maximum value to be set
    @type maxbound: float

    @example: fl_set_counter_bounds(ctrobj, -100.0, 100.0)

    @status: Tested + Doc + Demo = OK

    """
    _fl_set_counter_bounds = library.cfuncproto(
        library.load_so_libforms(), "fl_set_counter_bounds",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_double, cty.c_double],
        """void fl_set_counter_bounds(FL_OBJECT * ob, double min,
           double max)""")
    library.check_if_initialized()
    library.check_if_FL_OBJECT_ptr(pFlObject)
    fminbound = library.convert_to_double(minbound)
    fmaxbound = library.convert_to_double(maxbound)
    library.keep_elem_refs(pFlObject, minbound, maxbound, fminbound, fmaxbound)
    _fl_set_counter_bounds(pFlObject, fminbound, fmaxbound)


def fl_set_counter_step(pFlObject, small, large):
    """Sets the sizes of the small and large steps of a counter (defaults
    to 0.1 and 1). For simple counters only the small step is used.

    @param pFlObject: counter object
    @type pFlObject: pointer to xfdata.FL_OBJECT
    @param small: small step's size
    @type small: float
    @param large: large step's size
    @type large: float

    @example: fl_set_counter_step(ctrobj, 0.2, 2)

    @status: Tested + Doc + Demo = OK

    """
    _fl_set_counter_step = library.cfuncproto(
        library.load_so_libforms(), "fl_set_counter_step",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_double, cty.c_double],
        """void fl_set_counter_step(FL_OBJECT * ob, double s, double l)""")
    library.check_if_FL_OBJECT_ptr(pFlObject)
    fsmall = library.convert_to_double(small)
    flarge = library.convert_to_double(large)
    library.keep_elem_refs(pFlObject, small, large, fsmall, flarge)
    _fl_set_counter_step(pFlObject, fsmall, flarge)


def fl_set_counter_precision(pFlObject, prec):
    """Sets the precision (number of digits after the dot) with which
    the counter value is displayed.

    @param pFlObject: counter object
    @type pFlObject: pointer to xfdata.FL_OBJECT
    @param prec: precision to be set
    @type prec: int

    @example: fl_set_counter_precision(ctrobj, 2)

    @status: Tested + Doc + Demo = OK

    """
    _fl_set_counter_precision = library.cfuncproto(
        library.load_so_libforms(), "fl_set_counter_precision",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_set_counter_precision(FL_OBJECT * ob, int prec)""")
    library.check_if_initialized()
    library.check_if_FL_OBJECT_ptr(pFlObject)
    iprec = library.convert_to_int(prec)
    library.keep_elem_refs(pFlObject, prec, iprec)
    _fl_set_counter_precision(pFlObject, iprec)


def fl_get_counter_precision(pFlObject):
    """Determines the current value of the precision (number of digits
    after the dot) of the counter.

    @param pFlObject: counter object
    @type pFlObject: pointer to xfdata.FL_OBJECT

    @returns: number of digits after the dot
    @rtype: int

    @example: currprec = fl_get_counter_precision(ctrobj)

    @status: Tested + Doc + NoDemo = OK

    """
    _fl_get_counter_precision = library.cfuncproto(
        library.load_so_libforms(), "fl_get_counter_precision",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],
        """int fl_get_counter_precision(FL_OBJECT * ob)""")
    library.check_if_initialized()
    library.check_if_FL_OBJECT_ptr(pFlObject)
    library.keep_elem_refs(pFlObject)
    retval = _fl_get_counter_precision(pFlObject)
    return retval


# fl_set_counter_return function placeholder (deprecated)


def fl_get_counter_value(pFlObject):
    """Obtains the current value of the counter.

    @param pFlObject: counter object
    @type pFlObject: pointer to xfdata.FL_OBJECT

    @returns: current value
    @rtype: float

    @example: currvalue = fl_get_counter_value(ctrobj)

    @status: Tested + Doc + Demo = OK

    """
    _fl_get_counter_value = library.cfuncproto(
        library.load_so_libforms(), "fl_get_counter_value",
        cty.c_double, [cty.POINTER(xfdata.FL_OBJECT)],
        """double fl_get_counter_value(FL_OBJECT * ob)""")
    library.check_if_initialized()
    library.check_if_FL_OBJECT_ptr(pFlObject)
    library.keep_elem_refs(pFlObject)
    retval = _fl_get_counter_value(pFlObject)
    return retval


def fl_get_counter_bounds(pFlObject):
    """Obtains the current minimum and maximum bounds of the counter.

    @param pFlObject: counter object
    @type pFlObject: pointer to xfdata.FL_OBJECT

    @returns: minimum and maximum bounds
    @rtype: float, float

    @example: minb, maxb = fl_get_counter_bounds(ctrobj)

    @attention: API change from XForms - upstream was
        fl_get_counter_bounds(pFlObject, minbound, maxbound)

    @status: Tested + Doc + NoDemo = OK

    """
    _fl_get_counter_bounds = library.cfuncproto(
        library.load_so_libforms(), "fl_get_counter_bounds",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(cty.c_double),
        cty.POINTER(cty.c_double)],
        """void fl_get_counter_bounds(FL_OBJECT * ob, double * min,
           double * max)""")
    library.check_if_initialized()
    library.check_if_FL_OBJECT_ptr(pFlObject)
    minbound, pminbound = library.make_double_and_pointer()
    maxbound, pmaxbound = library.make_double_and_pointer()
    library.keep_elem_refs(pFlObject, minbound, maxbound, pminbound, pmaxbound)
    _fl_get_counter_bounds(pFlObject, pminbound, pmaxbound)
    return minbound.value, maxbound.value


def fl_get_counter_step(pFlObject):
    """Obtains the current small and large step's sizes of a counter.

    @param pFlObject: counter object
    @type pFlObject: pointer to xfdata.FL_OBJECT

    @returns: small and large step's sizes
    @rtype: float, float

    @example: minb, maxb = fl_get_counter_step(ctrobj)

    @attention: API change from XForms - upstream was
        fl_get_counter_step(pFlObject, sml, lrg)

    @status: Tested + Doc + NoDemo = OK

    """
    _fl_get_counter_step = library.cfuncproto(
        library.load_so_libforms(), "fl_get_counter_step",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.POINTER(cty.c_double),
        cty.POINTER(cty.c_double)],
        """void fl_get_counter_step(FL_OBJECT * ob, double * s,
           double * l)""")
    library.check_if_initialized()
    library.check_if_FL_OBJECT_ptr(pFlObject)
    small, psmall = library.make_double_and_pointer()
    large, plarge = library.make_double_and_pointer()
    library.keep_elem_refs(pFlObject, small, large, psmall, plarge)
    _fl_get_counter_step(pFlObject, psmall, plarge)
    return small.value, large.value


def fl_set_counter_filter(pFlObject, py_ValFilter):
    """Overrides the format and value shown by the counter. By default the
    value is shown in floating point format.

    @param pFlObject: counter object
    @type pFlObject: pointer to xfdata.FL_OBJECT
    @param py_ValFilter: python callback function, returning value
    @type py_ValFilter: __ funcname (pObject, valfloat, intprec) -> str __

    @example: def ctrvalfilt(pobj, fvalue, prec):
    @example: |->| ...
    @example: return string
    @example: fl_set_counter_filter(ctrobj, ctrvalfilt)

    @status: Tested + Doc + NoDemo = OK

    """
    #FL_VAL_FILTER = cty.CFUNCTYPE(xfdata.STRING, \
    #           cty.POINTER(xfdata.FL_OBJECT), cty.c_double, cty.c_int)
    _fl_set_counter_filter = library.cfuncproto(
        library.load_so_libforms(), "fl_set_counter_filter",
        None, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_VAL_FILTER],
        """void fl_set_counter_filter(FL_OBJECT * ob,
           FL_VAL_FILTER filter)""")
    library.check_if_initialized()
    library.check_if_FL_OBJECT_ptr(pFlObject)
    c_ValFilter = xfdata.FL_VAL_FILTER(py_ValFilter)
    library.keep_cfunc_refs(c_ValFilter, py_ValFilter)
    library.keep_elem_refs(pFlObject)
    _fl_set_counter_filter(pFlObject, c_ValFilter)


# Functions to set and get the timeout value used by the
# counter code to control modification of the counter value.

def fl_get_counter_repeat(pFlObject):
    """Returns the initial delay of the counter 

    @param pFlObject: counter object
    @type pFlObject: pointer to xfdata.FL_OBJECT

    @returns: initial delay in milliseconds
    @rtype: int

    @example: intdly = fl_get_counter_repeat(ctrobj)

    @status: Tested + Doc + NoDemo = OK

    """
    _fl_get_counter_repeat = library.cfuncproto(
        library.load_so_libforms(), "fl_get_counter_repeat",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],
        """int fl_get_counter_repeat(FL_OBJECT * ob)""")
    library.check_if_initialized()
    library.check_if_FL_OBJECT_ptr(pFlObject)
    library.keep_elem_refs(pFlObject)
    retval = _fl_get_counter_repeat(pFlObject)
    return retval


def fl_set_counter_repeat(pFlObject, msec):
    """Sets the initial delay of a counter. By default the counter value
    changes first slowly and the rate of change then accelerates until a
    final speed is reached. The default delay between the value changing
    is 600 ms at the start.

    @param pFlObject: counter object
    @type pFlObject: pointer to xfdata.FL_OBJECT
    @param msec: initial delay in milliseconds
    @type msec: int

    @example: fl_set_counter_repeat(ctrobj, 200)

    @status: Tested + Doc + NoDemo = OK

    """
    _fl_set_counter_repeat = library.cfuncproto(
        library.load_so_libforms(), "fl_set_counter_repeat",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_set_counter_repeat(FL_OBJECT * ob, int millisec)""")
    library.check_if_initialized()
    library.check_if_FL_OBJECT_ptr(pFlObject)
    imsec = library.convert_to_int(msec)
    library.keep_elem_refs(pFlObject, msec, imsec)
    _fl_set_counter_repeat(pFlObject, imsec)


def fl_get_counter_min_repeat(pFlObject):
    """Returns the final delay of a counter object.

    @param pFlObject: counter object
    @type pFlObject: pointer to xfdata.FL_OBJECT

    @returns: final delay in milliseconds
    @rtype: int

    @example: fnldly = fl_get_counter_min_repeat(ctrobj)

    @status: Tested + Doc + NoDemo = OK

    """
    _fl_get_counter_min_repeat = library.cfuncproto(
        library.load_so_libforms(), "fl_get_counter_min_repeat",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],
        """int fl_get_counter_min_repeat(FL_OBJECT * ob)""")
    library.check_if_FL_OBJECT_ptr(pFlObject)
    library.keep_elem_refs(pFlObject)
    retval = _fl_get_counter_min_repeat(pFlObject)
    return retval


def fl_set_counter_min_repeat(pFlObject, msec):
    """Sets the final delay of a counter. By default the counter value
    changes first slowly and the rate of change then accelerates until
    a final speed is reached. The default the final delay is 50 ms.

    @param pFlObject: counter object
    @type pFlObject: pointer to xfdata.FL_OBJECT
    @param msec: final delay in milliseconds
    @type msec: int

    @example: fl_set_counter_min_repeat(ctrobj, 100)

    @status: Tested + Doc + NoDemo = OK

    """
    _fl_set_counter_min_repeat = library.cfuncproto(
        library.load_so_libforms(), "fl_set_counter_min_repeat",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_set_counter_min_repeat(FL_OBJECT * ob, int millisec)""")
    library.check_if_initialized()
    library.check_if_FL_OBJECT_ptr(pFlObject)
    imsec = library.convert_to_int(msec)
    library.keep_elem_refs(pFlObject, msec, imsec)
    _fl_set_counter_min_repeat(pFlObject, imsec)


def fl_get_counter_speedjump(pFlObject):
    """Determines the setting for speedjumping (e.g. 1 if set, or 0 if unset).

    @param pFlObject: pointer to object
    @type pFlObject: pointer to xfdata.FL_OBJECT

    @returns: setting flag of speedjump
    @rtype: int

    @example: isspdjmp = fl_get_counter_speedjump(ctrobj)

    @status: Tested + Doc + NoDemo = OK

    """
    _fl_get_counter_speedjump = library.cfuncproto(
        library.load_so_libforms(), "fl_get_counter_speedjump",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],
        """int fl_get_counter_speedjump(FL_OBJECT * ob)""")
    library.check_if_initialized()
    library.check_if_FL_OBJECT_ptr(pFlObject)
    library.keep_elem_refs(pFlObject)
    retval = _fl_get_counter_speedjump(pFlObject)
    return retval


def fl_set_counter_speedjump(pFlObject, yn):
    """Makes only the first change of the counter has a different delay
    from all the following ones. The delay for the first change of the
    counter value will then be the one set by fl_set_counter_repeat()
    and the following delays last as long as set by
    fl_set_counter_min_repeat().

    @param pFlObject: counter object
    @type pFlObject: pointer to xfdata.FL_OBJECT
    @param yn: flag. Values 1 (to set speedjump) or 0 (to unset speedjump)
    @type yn: int

    @example: fl_set_counter_speedjump(ctrobj, 1)

    @status: Tested + Doc + NoDemo = OK

    """
    _fl_set_counter_speedjump = library.cfuncproto(
        library.load_so_libforms(), "fl_set_counter_speedjump",
        None, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """void fl_set_counter_speedjump(FL_OBJECT * ob, int yes_no)""")
    library.check_if_initialized()
    library.check_if_FL_OBJECT_ptr(pFlObject)
    iyesno = library.convert_to_int(yesno)
    library.keep_elem_refs(pFlObject, yesno, iyesno)
    _fl_set_counter_speedjump(pFlObject, iyesno)



