#!/usr/bin/env python
# -*- coding: iso8859-1 -*-

""" xforms-python's functions to manage nmenu flobjects.
"""

#    Copyright (C) 2009, 2010, 2011  Luca Lazzaroni "LukenShiro"
#    e-mail: <lukenshiro@ngi.it>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU Lesser General Public License as
#    published by the Free Software Foundation, version 2.1 of the License.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#    GNU Lesser General Public License for more details.
#
#    You should have received a copy of the GNU LGPL along with this
#    program. If not, see <http://www.gnu.org/licenses/>.
#
#    See CREDITS file to read acknowledgements and thanks to XForms,
#    ctypes and other developers.

# originally generated by 'h2xml+gccxml' and 'xml2py'
# then heavily reordered and reworked

# ############################################# #
# Interface to XForms shared flobject libraries   #
# ############################################# #


import ctypes as cty
from xformslib import library
from xformslib import xfdata


#####################
# forms.h (nmenu.h)
#####################

# Nmenu flobject types

# fl_create_nmenu function placeholder (internal)


def fl_add_nmenu(nmenutype, xpos, ypos, width, height, label):
    """fl_add_nmenu(nmenutype, xpos, ypos, width, height, label)
    -> ptr_flobject

    Adds a new generation menu (nmenu) object. It heavily depends on popups.

    Parameters
    ----------
        nmenutype : type of nmenu to be. Values (from xfdata.py)
            FL_NORMAL_NMENU (Probably the most often used type: shown as text
            on a borderless background, popup gets opened when clicked on),
            FL_NORMAL_TOUCH_NMENU (Also shown as text on a borderless
            background, but popup gets opened when the mouse is moved on top
            of it without any further user action required), FL_BUTTON_NMENU
            (When not active shown as text on borderless background, when
            clicked on popup is shown and the flobject itself being displayed
            as a button), FL_BUTTON_TOUCH_NMENU (When not active shown as text
            on borderless background, when mouse is moved onto it the popup is
            shown and the flobject itself is displayed as a button)
        xpos : int
            horizontal position (upper-left corner)
        ypos : int
            vertical position (upper-left corner)
        width : int
            width in coord units
        height : int
            height in coord units
        label : str
            text label of nmenu flobject

    Returns
    -------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject added

    Examples
    --------
        >>> nmnobj = fl_add_nmenu(xfdata.FL_NORMAL_NMENU, 50, 100,
                300, 90, "MyNmenu")

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_add_nmenu = library.cfuncproto(
        library.load_so_libforms(), "fl_add_nmenu",
        cty.POINTER(xfdata.FL_OBJECT), [cty.c_int, xfdata.FL_Coord,
        xfdata.FL_Coord, xfdata.FL_Coord, xfdata.FL_Coord, xfdata.STRING],
        """FL_OBJECT * fl_add_nmenu(int p1, FL_Coord p2, FL_Coord p3,
           FL_Coord p4, FL_Coord p5, const char * p6)""")
    library.check_if_flinitialized()
    library.checkfatal_allowed_value_in_list(nmenutype, \
            xfdata.NMENUTYPE_list)
    i_nmenutype = library.convert_to_intc(nmenutype)
    i_xpos = library.convert_to_FL_Coord(xpos)
    i_ypos = library.convert_to_FL_Coord(ypos)
    i_width = library.convert_to_FL_Coord(width)
    i_height = library.convert_to_FL_Coord(height)
    s_label = library.convert_to_stringc(label)
    library.keep_elem_refs(nmenutype, xpos, ypos, width, height, label, \
            i_nmenutype, i_xpos, i_ypos, i_width, i_height, s_label)
    retval = _fl_add_nmenu(i_nmenutype, i_xpos, i_ypos, i_width, \
            i_height, s_label)
    return retval


def fl_clear_nmenu(ptr_flobject):
    """fl_clear_nmenu(ptr_flobject) -> result

    Removes all items from a nmenu flobject at once.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject

    Returns
    -------
        result : int
            0 (on success), or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_clear_nmenu = library.cfuncproto(
        library.load_so_libforms(), "fl_clear_nmenu",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT)],
        """int fl_clear_nmenu(FL_OBJECT * p1)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_clear_nmenu(ptr_flobject)
    return retval


def fl_add_nmenu_items(ptr_flobject, entryitemstxt, x=None, u=None, \
                       f=None, E=None, L=None, m=None, Rr=None, s=None):
    """fl_add_nmenu_items(ptr_flobject, entryitemstxtx=None, u=None, \
    f=None, E=None, L=None, m=None, Rr=None, s=None) -> ptr_flpopupentry

    Adds an item to an existing nmenu flobject (it can be used several times).
    If additional separated arguments are required by in-text special
    sequences, user must respect the same sequences' order.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject
        entryitemstxt : str
            text of the entry to be added and in-text special sequences with
            or without not separated additional arguments (if required). Text
            may contain "|" for more than one entry and newline character which
            allows to create entries that span more than a single line. Special
            sequences who are allowed are: %x, %u, %f, %E, %L, %m or %T or %t,
            %R or %r or %l, %d, %h, %S, %s, %%. Special sequences of same type
            cannot be repeated in xforms-python.
        x : long
            numeric data to be passed to callbacks for entry (separated
            additional argument corresponding to %x in-text special sequence)
        u : pointer to any type
            user data to be passed to function; invoked callback has to take
            care of type check and re-cast from ptr_void to chosen type using
            appropriate xfstruct.convert_ptrvoid_to_*() function (separated
            additional argument corresponding to %u in-text special sequence)
        f : python callback function, returned value
            name referring to function(ptr_flpopupreturn) -> [int]num
            function to be invoked on set (separated additional argument
            corresponding to %f in-text special sequence)
        E : python callback function, returned unused value
            name referring to function(ptr_flpopupreturn) -> [int]num
            function to be invoked on enter (separated additional argument
            corresponding to %E in-text special sequence)
        L : python callback function, returned unused value
            name referring to function(ptr_flpopupreturn) -> [int]num
            function to be invoked on leave (separated additional argument
            corresponding to %L in-text special sequence)
        m : pointer to xfdata.FL_POPUP
            popup class to be used as sub-popup (separated additional argument
            corresponding to %m in-text special sequence)
        Rr : int
            group number of a radio entry type (separated additional argument
            corresponding to %R or %r in-text special sequence)
        s : str
            shortcut text for the entry (separated additional argument
            corresponding to %s in-text special sequence)

    Returns
    -------
        ptr_flpopupentry : pointer to xfdata.FL_POPUP_ENTRY
            popup entry

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: HalfTested + Doc + Demo = OK
        See: Special sequences in entry text documentation in xfdata.py.

    """
    # managing additional separate parameters
    l_x = ptr_u = cfn_f = cfn_E = cfn_L = i_Rr = s_s = None
    cparam_argstypelist = []
    specseqargslist = []
    if x:       # long x additional arg
        l_x = library.convert_to_longc(x)
        cparam_argstypelist.append(cty.c_long)
        specseqargslist.append(l_x)
    if u:       # pointer to void u additional arg
        ptr_u = library.convert_userdata_to_ptrvoid(u)
        cparam_argstypelist.append(cty.c_void_p)
        specseqargslist.append(ptr_u)
    if f:       # xfdata.FL_POPUP_CB f additional arg
        library.verify_function_type(f)
        cfn_f = xfdata.FL_POPUP_CB(f)
        cparam_argstypelist.append(xfdata.FL_POPUP_CB)
        specseqargslist.append(cfn_f)
    if E:       # xfdata.FL_POPUP_CB E additional arg
        library.verify_function_type(E)
        cfn_E = xfdata.FL_POPUP_CB(E)
        cparam_argstypelist.append(xfdata.FL_POPUP_CB)
        specseqargslist.append(cfn_E)
    if L:       # xfdata.FL_POPUP_CB L additional arg
        library.verify_function_type(L)
        cfn_L = xfdata.FL_POPUP_CB(L)
        cparam_argstypelist.append(xfdata.FL_POPUP_CB)
        specseqargslist.append(cfn_L)
    if m:       # pointer to xfdata.FL_POPUP m additional arg
        library.verify_flpopupptr_type(m)
        # passed as is
        cparam_argstypelist.append(cty.POINTER(xfdata.FL_POPUP))
        specseqargslist.append(m)
    if Rr:      # int R or r additional arg
        i_Rr = library.convert_to_intc(Rr)
        cparam_argstypelist.append(cty.c_int)
        specseqargslist.append(i_Rr)
    if s:      # str s additional arg
        s_s = library.convert_to_stringc(s)
        cparam_argstypelist.append(cty.c_char_p)
        specseqargslist.append(s_s)

    if not cparam_argstypelist:     # no additional separate params
        cparam_argstypelist = [cty.c_char_p, cty.c_char_p]
        specseqargslist = ["", ""]
    elif len(cparam_argstypelist) < 2:  # just 1 param, add another
        cparam_argstypelist.append(cty.c_char_p)
        specseqargslist.append("")

    _fl_add_nmenu_items = library.cfuncproto(
        library.load_so_libforms(), "fl_add_nmenu_items",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
        xfdata.STRING, cparam_argstypelist],
        """FL_POPUP_ENTRY * fl_add_nmenu_items(FL_OBJECT * p1,
           const char * p2, ...)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    s_entryitemstxt = library.convert_to_stringc(entryitemstxt)
    library.keep_elem_refs(ptr_flobject, entryitemstxt, s_entryitemstxt, \
            specseqargslist, cparam_argstypelist, x, u, f, E, L, m, Rr, s, \
            l_x, ptr_u, cfn_f, cfn_E, cfn_L, i_Rr, s_s)
    retval = _fl_add_nmenu_items(ptr_flobject, s_entryitemstxt, \
            *specseqargslist)
    return retval


def fl_insert_nmenu_items(ptr_flobject, ptr_flpopupentry, entryitemstxt, \
        x=None, u=None, f=None, E=None, L=None, m=None, Rr=None, s=None):
    """fl_insert_nmenu_items(ptr_flobject, ptr_flpopupentry, entryitemstxt,
    x=None, u=None, f=None, E=None, L=None, m=None, Rr=None, s=None)
    -> ptr_flpopupentry

    Inserts an additional item in nmenu flobject (it can be used several
    times). If additional separated arguments are required by in-text special
    sequences, user must respect the same sequences' order.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject
        ptr_flpopupentry : pointer to xfdata.FL_POPUP_ENTRY
            existing popup entry, after which the new items are to be
            inserted. If it is None, it inserts items at the very start.
        entryitemstxt : str
            text of the entry to be inserted and in-text special sequences
            with or without not separated additional arguments (if required).
            Text may contain "|" for more than one entry newline characters
            which allows to create entries that span more than a single line.
            Special sequences who are allowed are: %x, %u, %f, %E, %L, %m or
            %T or %t, %R or %r or %l, %d, %h, %S, %s, %%. Special sequences of
            same type cannot be repeated in xforms-python.
        x : long
            numeric data to be passed to callbacks for entry (separated
            additional argument corresponding to %x in-text special sequence)
        u : pointer to any type
            user data to be passed to callbacks for entry; invoked callback
            has to take care of type check and re-cast ptr_void to chosen type
            using appropriate xfstruct.convert_ptrvoid_to_* function (separated
            additional argument corresponding to %u in-text special sequence)
        f : python callback function, returned value
            name referring to function(ptr_flpopupreturn) -> int
            function to be invoked on set (separated additional argument
            corresponding to %f in-text special sequence)
        E : python callback function, returned unused value
            name referring to function(ptr_flpopupreturn) -> int
            function to be invoked on enter (separated additional argument
            corresponding to %E in-text special sequence)
        L : python callback function, returned unused value
            name referring to function(ptr_flpopupreturn) -> int
            function to be invoked on leave (separated additional argument
            corresponding to %L in-text special sequence)
        m : pointer to xfdata.FL_POPUP
            popup class to be used as sub-popup (separated additional argument
            corresponding to %m in-text special sequence)
        Rr : int
            group number of a radio entry type (separated additional argument
            corresponding to %R or %r in-text special sequence)
        s : str
            shortcut text for the entry (separated additional argument
            corresponding to %s in-text special sequence)

    Returns
    -------
        ptr_flpopupentry : pointer to xfdata.FL_POPUP_ENTRY
            popup entry

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK
        See: Special sequences in entry text documentation in xfdata.py.

    """
    # managing additional separate parameters
    l_x = ptr_u = cfn_f = cfn_E = cfn_L = i_Rr = s_s = None
    cparam_argstypelist = []
    specseqargslist = []
    if x:       # long x additional arg
        l_x = library.convert_to_longc(x)
        cparam_argstypelist.append(cty.c_long)
        specseqargslist.append(l_x)
    if u:       # pointer to void u additional arg
        ptr_u = library.convert_userdata_to_ptrvoid(u)
        cparam_argstypelist.append(cty.c_void_p)
        specseqargslist.append(ptr_u)
    if f:       # xfdata.FL_POPUP_CB f additional arg
        library.verify_function_type(f)
        cfn_f = xfdata.FL_POPUP_CB(f)
        cparam_argstypelist.append(xfdata.FL_POPUP_CB)
        specseqargslist.append(cfn_f)
    if E:       # xfdata.FL_POPUP_CB E additional arg
        library.verify_function_type(E)
        cfn_E = xfdata.FL_POPUP_CB(E)
        cparam_argstypelist.append(xfdata.FL_POPUP_CB)
        specseqargslist.append(cfn_E)
    if L:       # xfdata.FL_POPUP_CB L additional arg
        library.verify_function_type(L)
        cfn_L = xfdata.FL_POPUP_CB(L)
        cparam_argstypelist.append(xfdata.FL_POPUP_CB)
        specseqargslist.append(cfn_L)
    if m:       # pointer to xfdata.FL_POPUP m additional arg
        library.verify_flpopupptr_type(m)
        # passed as is
        cparam_argstypelist.append(cty.POINTER(xfdata.FL_POPUP))
        specseqargslist.append(m)
    if Rr:      # int R or r additional arg
        i_Rr = library.convert_to_intc(Rr)
        cparam_argstypelist.append(cty.c_int)
        specseqargslist.append(i_Rr)
    if s:      # str s additional arg
        s_s = library.convert_to_stringc(s)
        cparam_argstypelist.append(cty.c_char_p)
        specseqargslist.append(s_s)

    if not cparam_argstypelist:     # no additional separate params
        cparam_argstypelist = [cty.c_char_p, cty.c_char_p]
        specseqargslist = ["", ""]
    elif len(cparam_argstypelist) < 2:  # just 1 param, add another
        cparam_argstypelist.append(cty.c_char_p)
        specseqargslist.append("")

    _fl_insert_nmenu_items = library.cfuncproto(
        library.load_so_libforms(), "fl_insert_nmenu_items",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
        cty.POINTER(xfdata.FL_POPUP_ENTRY), xfdata.STRING, \
        cparam_argstypelist],
        """FL_POPUP_ENTRY * fl_insert_nmenu_items(FL_OBJECT * p1,
           FL_POPUP_ENTRY * p2, const char * p3, ...)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.verify_flpopupentryptr_type(ptr_flpopupentry)
    s_entryitemstxt = library.convert_to_stringc(entryitemstxt)
    library.keep_elem_refs(ptr_flobject, ptr_flpopupentry, entryitemstxt, \
            s_entryitemstxt, specseqargslist, cparam_argstypelist, x, u, f, \
            E, L, m, Rr, s, l_x, ptr_u, cfn_f, cfn_E, cfn_L, i_Rr, s_s)
    retval = _fl_insert_nmenu_items(ptr_flobject, ptr_flpopupentry, \
            s_entryitemstxt, *specseqargslist)
    return retval


def fl_replace_nmenu_item(ptr_flobject, ptr_flpopupentry, entryitemstxt,
            x=None, u=None, f=None, E=None, L=None, m=None, Rr=None, s=None):
    """fl_replace_nmenu_item(ptr_flobject, ptr_flpopupentry, entryitemstxt,
    x=None, u=None, f=None, E=None, L=None, m=None, Rr=None, s=None)
    -> ptr_flpopupentry

    Replaces an existing item of a nmenu flobject with another. If additional
    separated arguments are required by in-text special sequences, user must
    respect the same sequences' order.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject
        ptr_flpopupentry : pointer to xfdata.FL_POPUP_ENTRY
            old popup entry to be replaced
        entryitemstxt : str
            text of the entry to be replaced and in-text special sequences
            with or without not separated additional arguments (if required).
            Text may contain "|" for more than one entry newline character
            which allows to create entries that span more than a single line.
            Special sequences who are allowed are: %x, %u, %f, %E, %L, %m or
            %T or %t, %R or %r or %l, %d, %h, %S, %s, %%. Special sequences of
            same type cannot be repeated in xforms-python.
        x : long
            numeric data to be passed to callbacks for entry (separated
            additional argument corresponding to %x in-text special sequence)
        u : pointer to any type
            user data to be passed to callbacks for entry; invoked callback
            has to take care of type check and re-cast ptr_void to chosen type
            using appropriate xfstruct.convert_ptrvoid_to_* function (separated
            additional argument corresponding to %u in-text special sequence)
        f : python callback function, returned value
            name referring to function(ptr_flpopupreturn) -> int
            function to be invoked on set (separated additional argument
            corresponding to %f in-text special sequence)
        E : python callback function, returned unused value
            name referring to function(ptr_flpopupreturn) -> int
            function to be invoked on enter (separated additional argument
            corresponding to %E in-text special sequence)
        L : python callback function, returned unused value
            name referring to function(ptr_flpopupreturn) -> int
            function to be invoked on leave (separated additional argument
            corresponding to %L in-text special sequence)
        m : pointer to xfdata.FL_POPUP
            popup class to be used as sub-popup (separated additional argument
            corresponding to %m in-text special sequence)
        Rr : int
            group number of a radio entry type (separated additional argument
            corresponding to %R or %r in-text special sequence)
        s : str
            shortcut text for the entry (separated additional argument
            corresponding to %s in-text special sequence)

    Returns
    -------
        ptr_flpopupentry : pointer to xfdata.FL_POPUP_ENTRY
            popup entry

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK
        See: Special sequences in entry text documentation in xfdata.py.

    """
    # managing additional separate parameters
    l_x = ptr_u = cfn_f = cfn_E = cfn_L = i_Rr = s_s = None
    cparam_argstypelist = []
    specseqargslist = []
    if x:       # long x additional arg
        l_x = library.convert_to_longc(x)
        cparam_argstypelist.append(cty.c_long)
        specseqargslist.append(l_x)
    if u:       # pointer to void u additional arg
        ptr_u = library.convert_userdata_to_ptrvoid(u)
        cparam_argstypelist.append(cty.c_void_p)
        specseqargslist.append(ptr_u)
    if f:       # xfdata.FL_POPUP_CB f additional arg
        library.verify_function_type(f)
        cfn_f = xfdata.FL_POPUP_CB(f)
        cparam_argstypelist.append(xfdata.FL_POPUP_CB)
        specseqargslist.append(cfn_f)
    if E:       # xfdata.FL_POPUP_CB E additional arg
        library.verify_function_type(E)
        cfn_E = xfdata.FL_POPUP_CB(E)
        cparam_argstypelist.append(xfdata.FL_POPUP_CB)
        specseqargslist.append(cfn_E)
    if L:       # xfdata.FL_POPUP_CB L additional arg
        library.verify_function_type(L)
        cfn_L = xfdata.FL_POPUP_CB(L)
        cparam_argstypelist.append(xfdata.FL_POPUP_CB)
        specseqargslist.append(cfn_L)
    if m:       # pointer to xfdata.FL_POPUP m additional arg
        library.verify_flpopupptr_type(m)
        # passed as is
        cparam_argstypelist.append(cty.POINTER(xfdata.FL_POPUP))
        specseqargslist.append(m)
    if Rr:      # int R or r additional arg
        i_Rr = library.convert_to_intc(Rr)
        cparam_argstypelist.append(cty.c_int)
        specseqargslist.append(i_Rr)
    if s:      # str s additional arg
        s_s = library.convert_to_stringc(s)
        cparam_argstypelist.append(cty.c_char_p)
        specseqargslist.append(s_s)

    if not cparam_argstypelist:     # no additional separate params
        cparam_argstypelist = [cty.c_char_p, cty.c_char_p]
        specseqargslist = ["", ""]
    elif len(cparam_argstypelist) < 2:  # just 1 param, add another
        cparam_argstypelist.append(cty.c_char_p)
        specseqargslist.append("")

    _fl_replace_nmenu_item = library.cfuncproto(
        library.load_so_libforms(), "fl_replace_nmenu_item",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
        cty.POINTER(xfdata.FL_POPUP_ENTRY), xfdata.STRING, \
        cparam_argstypelist],
        """FL_POPUP_ENTRY * fl_replace_nmenu_item(FL_OBJECT * p1,
           FL_POPUP_ENTRY * p2, const char * p3, ...)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.verify_flpopupentryptr_type(ptr_flpopupentry)
    s_entryitemstxt = library.convert_to_stringc(entryitemstxt)
    library.keep_elem_refs(ptr_flobject, ptr_flpopupentry, entryitemstxt, \
            s_entryitemstxt, specseqargslist, cparam_argstypelist, x, u, f, \
            E, L, m, Rr, s, l_x, ptr_u, cfn_f, cfn_E, cfn_L, i_Rr, s_s)
    retval = _fl_replace_nmenu_item(ptr_flobject, ptr_flpopupentry, \
            s_entryitemstxt, *specseqargslist)
    return retval


def fl_delete_nmenu_item(ptr_flobject, ptr_flpopupentry):
    """fl_delete_nmenu_item(ptr_flobject, ptr_flpopupentry) -> result

    Deletes an item from a nmenu flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject
        ptr_flpopupentry : pointer to xfdata.FL_POPUP_ENTRY
            existing popup entry to delete

    Returns
    -------
        result : int
            0 (on success), or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_delete_nmenu_item = library.cfuncproto(
        library.load_so_libforms(), "fl_delete_nmenu_item",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT),
        cty.POINTER(xfdata.FL_POPUP_ENTRY)],
        """int fl_delete_nmenu_item(FL_OBJECT * p1, FL_POPUP_ENTRY * p2)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.verify_flpopupentryptr_type(ptr_flpopupentry)
    library.keep_elem_refs(ptr_flobject, ptr_flpopupentry)
    retval = _fl_delete_nmenu_item(ptr_flobject, ptr_flpopupentry)
    return retval


def fl_set_nmenu_items(ptr_flobject, ptr_flpopupitem):
    """fl_set_nmenu_items(ptr_flobject, ptr_flpopupitem) -> ptr_flpopupentry

    Defines a popup nmenu item.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject
        ptr_flpopupitem : pointer to xfdata.FL_POPUP_ITEM
            popup item to be set. It can be prepared passing a dict (whose
            keys are corresponding to xfdata.FL_POPUP_ITEM's members) to
            xfstruct.make_ptr_flpopupitem function.

    Returns
    -------
        ptr_flpopupentry : pointer to xfdata.FL_POPUP_ENTRY
            first nmenu item, or None (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_nmenu_items = library.cfuncproto(
        library.load_so_libforms(), "fl_set_nmenu_items",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
        cty.POINTER(xfdata.FL_POPUP_ITEM)],
        """FL_POPUP_ENTRY * fl_set_nmenu_items(FL_OBJECT * p1,
           FL_POPUP_ITEM * p2)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.verify_flpopupitemptr_type(ptr_flpopupitem)
    library.keep_elem_refs(ptr_flobject, ptr_flpopupitem)
    retval = _fl_set_nmenu_items(ptr_flobject, ptr_flpopupitem)
    return retval


def fl_add_nmenu_items2(ptr_flobject, ptr_flpopupitem):
    """fl_add_nmenu_items2(ptr_flobject, ptr_flpopupitem) -> ptr_flpopupentry

    Adds items to a nmenu flobject (alternative).

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject
        ptr_flpopupitem : pointer to xfdata.FL_POPUP_ITEM
            popup item to be set. It can be prepared passing a dict (whose
            keys are corresponding to xfdata.FL_POPUP_ITEM's members) to
            xfstruct.make_ptr_flpopupitem function.

    Returns
    -------
        ptr_flpopupentry : pointer to xfdata.FL_POPUP_ENTRY
            first nmenu item, or None (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_add_nmenu_items2 = library.cfuncproto(
        library.load_so_libforms(), "fl_add_nmenu_items2",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
        cty.POINTER(xfdata.FL_POPUP_ITEM)],
        """FL_POPUP_ENTRY * fl_add_nmenu_items2(FL_OBJECT * obj,
           FL_POPUP_ITEM * p2)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.verify_flpopupitemptr_type(ptr_flpopupitem)
    library.keep_elem_refs(ptr_flobject, ptr_flpopupitem)
    retval = _fl_add_nmenu_items2(ptr_flobject, ptr_flpopupitem)
    return retval


def fl_insert_nmenu_items2(ptr_flobject, ptr_flpopupentry, ptr_flpopupitem):
    """fl_insert_nmenu_items2(ptr_flobject, ptr_flpopupentry, ptr_flpopupitem)
    -> ptr_flpopupentry

    Inserts items in a nmenu flobject (alternative).

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject
        ptr_flpopupentry : pointer to xfdata.FL_POPUP_ENTRY
            existing popup entry, after which the new items are to be
            inserted. If it is None, it inserts items at the real start.
        ptr_flpopupitem : pointer to xfdata.FL_POPUP_ITEM
            popup item to be set. It can be prepared passing a dict (whose
            keys are corresponding to xfdata.FL_POPUP_ITEM's members) to
            xfstruct.make_ptr_flpopupitem function.

    Returns
    -------
        ptr_flpopupentry : pointer to xfdata.FL_POPUP_ENTRY
             first nmenu item, or None (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_insert_nmenu_items2 = library.cfuncproto(
        library.load_so_libforms(), "fl_insert_nmenu_items2",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
        cty.c_void_p, cty.POINTER(xfdata.FL_POPUP_ITEM)],
        """FL_POPUP_ENTRY * fl_insert_nmenu_items2(FL_OBJECT * obj,
           FL_POPUP_ITEM * p2, FL_POPUP_ITEM * p3)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    if not ptr_flpopupentry:        # it is None
        ptr_flpopupentry_alt = cty.cast(ptr_flpopupentry, \
                cty.POINTER(cty.c_void_p))
    else:                           # real FL_POPUP_ENTRY pointer
        ptr_flpopupentry_alt = ptr_flpopupentry
        library.verify_flpopupentryptr_type(ptr_flpopupentry_alt)
    library.verify_flpopupitemptr_type(ptr_flpopupitem)
    library.keep_elem_refs(ptr_flobject, ptr_flpopupentry, \
            ptr_flpopupentry_alt, ptr_flpopupitem)
    retval = _fl_insert_nmenu_items2(ptr_flobject, ptr_flpopupentry_alt, \
            ptr_flpopupitem)
    return retval


def fl_replace_nmenu_items2(ptr_flobject, ptr_flpopupentry, ptr_flpopupitem):
    """fl_replace_nmenu_items2(ptr_flobject, ptr_flpopupentry, ptr_flpopupitem)
    -> ptr_flpopupentry

    Replaces an item of a nmenu flobject (alternative).

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject
        ptr_flpopupentry : pointer to xfdata.FL_POPUP_ENTRY
            old popup entry to be replaced
        ptr_flpopupitem : pointer to xfdata.FL_POPUP_ITEM
            new popup item. It can be prepared passing a dict (whose keys
            are corresponding to xfdata.FL_POPUP_ITEM's members) to
            xfstruct.make_ptr_flpopupitem function.

    Returns
    -------
        ptr_flpopupentry : pointer to xfdata.FL_POPUP_ENTRY
            first nmenu item, or None (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_replace_nmenu_items2 = library.cfuncproto(
        library.load_so_libforms(), "fl_replace_nmenu_items2",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
        cty.POINTER(xfdata.FL_POPUP_ENTRY), cty.POINTER(xfdata.FL_POPUP_ITEM)],
        """FL_POPUP_ENTRY * fl_replace_nmenu_items2(FL_OBJECT * obj,
           FL_POPUP_ENTRY * p2, FL_POPUP_ITEM * p3)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.verify_flpopupentryptr_type(ptr_flpopupentry)
    library.verify_flpopupitemptr_type(ptr_flpopupitem)
    library.keep_elem_refs(ptr_flobject, ptr_flpopupentry, ptr_flpopupitem)
    retval = _fl_replace_nmenu_items2(ptr_flobject, ptr_flpopupentry, \
            ptr_flpopupitem)
    return retval


def fl_get_nmenu_popup(ptr_flobject):
    """fl_get_nmenu_popup(ptr_flobject) -> ptr_flpopup

    Finds out which popup is associated with the nmenu flobject.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject

    Returns
    -------
        ptr_flpopup : pointer to xfdata.FL_POPUP
            popup class instance

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_nmenu_popup = library.cfuncproto(
        library.load_so_libforms(), "fl_get_nmenu_popup",
        cty.POINTER(xfdata.FL_POPUP), [cty.POINTER(xfdata.FL_OBJECT)],
        """FL_POPUP * fl_get_nmenu_popup(FL_OBJECT * p1)""")
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_get_nmenu_popup(ptr_flobject)
    return retval


def fl_set_nmenu_popup(ptr_flobject, ptr_flpopup):
    """fl_set_nmenu_popup(ptr_flobject, ptr_flpopup) -> ptr_flpopup

    Defines an existing popup as the nmenu's popup. The popup you associate
    with the nmenu flobject in this way cannot be a sub-popup.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject
        ptr_flpopup : pointer to xfdata.FL_POPUP
            popup class instance

    Returns
    -------
        ptr_flpopup : pointer to xfdata.FL_POPUP
            popup class instance

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_nmenu_popup = library.cfuncproto(
        library.load_so_libforms(), "fl_set_nmenu_popup",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT),
        cty.POINTER(xfdata.FL_POPUP)],
        """int fl_set_nmenu_popup(FL_OBJECT * p1, FL_POPUP * p2)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.verify_flpopupptr_type(ptr_flpopup)
    library.keep_elem_refs(ptr_flobject, ptr_flpopup)
    retval = _fl_set_nmenu_popup(ptr_flobject, ptr_flpopup)
    return retval


def fl_get_nmenu_item(ptr_flobject):
    """fl_get_nmenu_item(ptr_flobject) -> ptr_flpopupreturn

    Finds out which item of a nmenu flobject was selected.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject

    Returns
    -------
        ptr_flpopupreturn : pointer to xfdata.FL_POPUP_RETURN
            popup return class instance, or None (if no selection was made the
            last time the nmenu flobject was used)

    Examples
    --------
        >>> pPpRtn = fl_get_nmenu(pnmenuobj)
        >>> print "order number" % pPpRtn.contents.val
        >>> print "extry text" % pPpRtn.contents.text
        >>> print "order number" % pPpRtn.contents.val

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_get_nmenu_item = library.cfuncproto(
        library.load_so_libforms(), "fl_get_nmenu_item",
        cty.POINTER(xfdata.FL_POPUP_RETURN), [cty.POINTER(xfdata.FL_OBJECT)],
        """FL_POPUP_RETURN * fl_get_nmenu_item(FL_OBJECT * p1)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.keep_elem_refs(ptr_flobject)
    retval = _fl_get_nmenu_item(ptr_flobject)
    return retval


def fl_get_nmenu_item_by_value(ptr_flobject, itemval):
    """fl_get_nmenu_item_by_value(ptr_flobject, itemval) -> ptr_flpopupentry

    Searches through the list of all items (including items in sub-popups) and
    returns the first one with the val associated with the item.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject
        itemval : long
            value corresponding to an item to be searched.

    Returns
    -------
        ptr_flpopupentry : pointer to xfdata.FL_POPUP_ENTRY
            first item associated, or None (if is not found)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + Demo = OK

    """
    _fl_get_nmenu_item_by_value = library.cfuncproto(
        library.load_so_libforms(), "fl_get_nmenu_item_by_value",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
        cty.c_long],
        """FL_POPUP_ENTRY * fl_get_nmenu_item_by_value(FL_OBJECT * p1,
           long int p2)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    l_itemval = library.convert_to_longc(itemval)
    library.keep_elem_refs(ptr_flobject, itemval, l_itemval)
    retval = _fl_get_nmenu_item_by_value(ptr_flobject, l_itemval)
    return retval


def fl_get_nmenu_item_by_label(ptr_flobject, label):
    """fl_get_nmenu_item_by_label(ptr_flobject, label) -> ptr_flpopupentry

    Searches for a certain label as displayed for the item in the nmenu's
    popup.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject
        label : str
            text associated with an item.

    Returns
    -------
        ptr_flpopupentry : pointer to xfdata.FL_POPUP_ENTRY
            first item associated, or None (if is not found)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_nmenu_item_by_label = library.cfuncproto(
        library.load_so_libforms(), "fl_get_nmenu_item_by_label",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
        xfdata.STRING],
        """FL_POPUP_ENTRY * fl_get_nmenu_item_by_label(FL_OBJECT * p1,
           const char * p2)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    s_label = library.convert_to_stringc(label)
    library.keep_elem_refs(ptr_flobject, label, s_label)
    retval = _fl_get_nmenu_item_by_label(ptr_flobject, s_label)
    return retval


def fl_get_nmenu_item_by_text(ptr_flobject, text):
    """fl_get_nmenu_item_by_text(ptr_flobject, text) -> ptr_flpopupentry

    Searches for the text the item in nmenu flobject was created by (that
    might be the same as the label text in simple cases).

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject
        text : str
            text associated with an item.

    Returns
    -------
        ptr_flpopupentry : pointer to xfdata.FL_POPUP_ENTRY
            first item associated, or None (if is not found)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_get_nmenu_item_by_text = library.cfuncproto(
        library.load_so_libforms(), "fl_get_nmenu_item_by_text",
        cty.POINTER(xfdata.FL_POPUP_ENTRY), [cty.POINTER(xfdata.FL_OBJECT),
        xfdata.STRING],
        """FL_POPUP_ENTRY * fl_get_nmenu_item_by_text(FL_OBJECT * p1,
           const char * p2)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    s_text = library.convert_to_stringc(text)
    library.keep_elem_refs(ptr_flobject, text, s_text)
    retval = _fl_get_nmenu_item_by_text(ptr_flobject, s_text)
    return retval


def fl_set_nmenu_policy(ptr_flobject, policy):
    """fl_set_nmenu_policy(ptr_flobject, policy) -> oldpol

    Changes nmenu policy about closing, so that the popup also gets closed
    (without a selection) when the mouse button is clicked or released on a
    non-selectable item (giving the impression of a "pull-down" menu). By
    default, the popup is closed when an item is selected or (without a
    selection) when the user clicks somehwere outside of the popups area.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject
        policy : int
            under which conditions the nmenu's popup gets closed. Values (from
            xfdata.py) FL_POPUP_NORMAL_SELECT (default, keeps the popup opened
            when the mouse is not released on one of the selectable items),
            FL_POPUP_DRAG_SELECT (Closes the popup immediately when the mouse
            button is released)

    Returns
    -------
        oldpol : int
            old policy settings, or -1 (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_nmenu_policy = library.cfuncproto(
        library.load_so_libforms(), "fl_set_nmenu_policy",
        cty.c_int, [cty.POINTER(xfdata.FL_OBJECT), cty.c_int],
        """int fl_set_nmenu_policy(FL_OBJECT * p1, int p2)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    library.checkfatal_allowed_value_in_list(policy, xfdata.POPUPPOLICY_list)
    i_policy = library.convert_to_intc(policy)
    library.keep_elem_refs(ptr_flobject, policy, i_policy)
    retval = _fl_set_nmenu_policy(ptr_flobject, i_policy)
    return retval


def fl_set_nmenu_hl_text_color(ptr_flobject, colr):
    """fl_set_nmenu_hl_text_color(ptr_flobject, colr) -> oldcolr

    Defines the color of label when it is in "active" state (i.e. while the
    popup is shown). In "inactive" state this is set by fl_set_object_lcol().
    By default, this color is xfdata.FL_BLACK for nmenus that are shown as a
    button while being "active", while for normal nmenus it is the same color
    that is used items in the popup when the mouse is hovering over them.

    Parameters
    ----------
        ptr_flobject : pointer to xfdata.FL_OBJECT
            nmenu flobject
        colr : long_pos
            color to be set

    Returns
    -------
        oldcolr : long_pos
            old color, or xfdata.FL_MAX_COLORS (on failure)

    Examples
    --------
        >>> *todo*

    Notes
    -----
        Status: NA-UTest + Doc + NoDemo = Maybe

    """
    _fl_set_nmenu_hl_text_color = library.cfuncproto(
        library.load_so_libforms(), "fl_set_nmenu_hl_text_color",
        xfdata.FL_COLOR, [cty.POINTER(xfdata.FL_OBJECT), xfdata.FL_COLOR],
        """FL_COLOR fl_set_nmenu_hl_text_color(FL_OBJECT * p1,
           FL_COLOR p2)""")
    library.check_if_flinitialized()
    library.verify_flobjectptr_type(ptr_flobject)
    #library.checknonfatal_allowed_value_in_list(colr, xfdata.COLOR_list)
    ul_colr = library.convert_to_FL_COLOR(colr)
    library.keep_elem_refs(ptr_flobject, colr, ul_colr)
    retval = _fl_set_nmenu_hl_text_color(ptr_flobject, ul_colr)
    return retval

